// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: k8s.io/api/storage/v1/generated.proto
// Protobuf Java Version: 4.26.1

package io.kubernetes.client.proto;

public final class V1Storage {
  private V1Storage() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 26,
      /* patch= */ 1,
      /* suffix= */ "",
      V1Storage.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface CSIDriverOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.CSIDriver)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata.
     * metadata.Name indicates the name of the CSI driver that this object
     * refers to; it MUST be the same name returned by the CSI GetPluginName()
     * call for that driver.
     * The driver name must be 63 characters or less, beginning and ending with
     * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata.
     * metadata.Name indicates the name of the CSI driver that this object
     * refers to; it MUST be the same name returned by the CSI GetPluginName()
     * call for that driver.
     * The driver name must be 63 characters or less, beginning and ending with
     * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata.
     * metadata.Name indicates the name of the CSI driver that this object
     * refers to; it MUST be the same name returned by the CSI GetPluginName()
     * call for that driver.
     * The driver name must be 63 characters or less, beginning and ending with
     * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * spec represents the specification of the CSI Driver.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    boolean hasSpec();
    /**
     * <pre>
     * spec represents the specification of the CSI Driver.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
     * @return The spec.
     */
    io.kubernetes.client.proto.V1Storage.CSIDriverSpec getSpec();
    /**
     * <pre>
     * spec represents the specification of the CSI Driver.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSIDriverSpecOrBuilder getSpecOrBuilder();
  }
  /**
   * <pre>
   * CSIDriver captures information about a Container Storage Interface (CSI)
   * volume driver deployed on the cluster.
   * Kubernetes attach detach controller uses this object to determine whether attach is required.
   * Kubelet uses this object to determine whether pod information needs to be passed on mount.
   * CSIDriver objects are non-namespaced.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.CSIDriver}
   */
  public static final class CSIDriver extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.CSIDriver)
      CSIDriverOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CSIDriver.class.getName());
    }
    // Use CSIDriver.newBuilder() to construct.
    private CSIDriver(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CSIDriver() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriver_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriver_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.CSIDriver.class, io.kubernetes.client.proto.V1Storage.CSIDriver.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata.
     * metadata.Name indicates the name of the CSI driver that this object
     * refers to; it MUST be the same name returned by the CSI GetPluginName()
     * call for that driver.
     * The driver name must be 63 characters or less, beginning and ending with
     * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object metadata.
     * metadata.Name indicates the name of the CSI driver that this object
     * refers to; it MUST be the same name returned by the CSI GetPluginName()
     * call for that driver.
     * The driver name must be 63 characters or less, beginning and ending with
     * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata.
     * metadata.Name indicates the name of the CSI driver that this object
     * refers to; it MUST be the same name returned by the CSI GetPluginName()
     * call for that driver.
     * The driver name must be 63 characters or less, beginning and ending with
     * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Storage.CSIDriverSpec spec_;
    /**
     * <pre>
     * spec represents the specification of the CSI Driver.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    @java.lang.Override
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * spec represents the specification of the CSI Driver.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
     * @return The spec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIDriverSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Storage.CSIDriverSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * spec represents the specification of the CSI Driver.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIDriverSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Storage.CSIDriverSpec.getDefaultInstance() : spec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSpec());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.CSIDriver)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.CSIDriver other = (io.kubernetes.client.proto.V1Storage.CSIDriver) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasSpec() != other.hasSpec()) return false;
      if (hasSpec()) {
        if (!getSpec()
            .equals(other.getSpec())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriver parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.CSIDriver prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CSIDriver captures information about a Container Storage Interface (CSI)
     * volume driver deployed on the cluster.
     * Kubernetes attach detach controller uses this object to determine whether attach is required.
     * Kubelet uses this object to determine whether pod information needs to be passed on mount.
     * CSIDriver objects are non-namespaced.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.CSIDriver}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.CSIDriver)
        io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriver_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriver_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.CSIDriver.class, io.kubernetes.client.proto.V1Storage.CSIDriver.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.CSIDriver.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriver_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIDriver getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.CSIDriver.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIDriver build() {
        io.kubernetes.client.proto.V1Storage.CSIDriver result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIDriver buildPartial() {
        io.kubernetes.client.proto.V1Storage.CSIDriver result = new io.kubernetes.client.proto.V1Storage.CSIDriver(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.CSIDriver result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.spec_ = specBuilder_ == null
              ? spec_
              : specBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.CSIDriver) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.CSIDriver)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.CSIDriver other) {
        if (other == io.kubernetes.client.proto.V1Storage.CSIDriver.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata.
       * metadata.Name indicates the name of the CSI driver that this object
       * refers to; it MUST be the same name returned by the CSI GetPluginName()
       * call for that driver.
       * The driver name must be 63 characters or less, beginning and ending with
       * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object metadata.
       * metadata.Name indicates the name of the CSI driver that this object
       * refers to; it MUST be the same name returned by the CSI GetPluginName()
       * call for that driver.
       * The driver name must be 63 characters or less, beginning and ending with
       * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata.
       * metadata.Name indicates the name of the CSI driver that this object
       * refers to; it MUST be the same name returned by the CSI GetPluginName()
       * call for that driver.
       * The driver name must be 63 characters or less, beginning and ending with
       * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata.
       * metadata.Name indicates the name of the CSI driver that this object
       * refers to; it MUST be the same name returned by the CSI GetPluginName()
       * call for that driver.
       * The driver name must be 63 characters or less, beginning and ending with
       * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata.
       * metadata.Name indicates the name of the CSI driver that this object
       * refers to; it MUST be the same name returned by the CSI GetPluginName()
       * call for that driver.
       * The driver name must be 63 characters or less, beginning and ending with
       * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object metadata.
       * metadata.Name indicates the name of the CSI driver that this object
       * refers to; it MUST be the same name returned by the CSI GetPluginName()
       * call for that driver.
       * The driver name must be 63 characters or less, beginning and ending with
       * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata.
       * metadata.Name indicates the name of the CSI driver that this object
       * refers to; it MUST be the same name returned by the CSI GetPluginName()
       * call for that driver.
       * The driver name must be 63 characters or less, beginning and ending with
       * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata.
       * metadata.Name indicates the name of the CSI driver that this object
       * refers to; it MUST be the same name returned by the CSI GetPluginName()
       * call for that driver.
       * The driver name must be 63 characters or less, beginning and ending with
       * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata.
       * metadata.Name indicates the name of the CSI driver that this object
       * refers to; it MUST be the same name returned by the CSI GetPluginName()
       * call for that driver.
       * The driver name must be 63 characters or less, beginning and ending with
       * an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Storage.CSIDriverSpec spec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSIDriverSpec, io.kubernetes.client.proto.V1Storage.CSIDriverSpec.Builder, io.kubernetes.client.proto.V1Storage.CSIDriverSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * spec represents the specification of the CSI Driver.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
       * @return Whether the spec field is set.
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * spec represents the specification of the CSI Driver.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
       * @return The spec.
       */
      public io.kubernetes.client.proto.V1Storage.CSIDriverSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Storage.CSIDriverSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * spec represents the specification of the CSI Driver.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Storage.CSIDriverSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * spec represents the specification of the CSI Driver.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Storage.CSIDriverSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * spec represents the specification of the CSI Driver.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Storage.CSIDriverSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            spec_ != null &&
            spec_ != io.kubernetes.client.proto.V1Storage.CSIDriverSpec.getDefaultInstance()) {
            getSpecBuilder().mergeFrom(value);
          } else {
            spec_ = value;
          }
        } else {
          specBuilder_.mergeFrom(value);
        }
        if (spec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * spec represents the specification of the CSI Driver.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * spec represents the specification of the CSI Driver.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIDriverSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * spec represents the specification of the CSI Driver.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIDriverSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Storage.CSIDriverSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * spec represents the specification of the CSI Driver.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSIDriverSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSIDriverSpec, io.kubernetes.client.proto.V1Storage.CSIDriverSpec.Builder, io.kubernetes.client.proto.V1Storage.CSIDriverSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Storage.CSIDriverSpec, io.kubernetes.client.proto.V1Storage.CSIDriverSpec.Builder, io.kubernetes.client.proto.V1Storage.CSIDriverSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.CSIDriver)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.CSIDriver)
    private static final io.kubernetes.client.proto.V1Storage.CSIDriver DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.CSIDriver();
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriver getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CSIDriver>
        PARSER = new com.google.protobuf.AbstractParser<CSIDriver>() {
      @java.lang.Override
      public CSIDriver parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CSIDriver> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CSIDriver> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIDriver getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CSIDriverListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.CSIDriverList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Storage.CSIDriver> 
        getItemsList();
    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSIDriver getItems(int index);
    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * CSIDriverList is a collection of CSIDriver objects.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.CSIDriverList}
   */
  public static final class CSIDriverList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.CSIDriverList)
      CSIDriverListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CSIDriverList.class.getName());
    }
    // Use CSIDriverList.newBuilder() to construct.
    private CSIDriverList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CSIDriverList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.CSIDriverList.class, io.kubernetes.client.proto.V1Storage.CSIDriverList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Storage.CSIDriver> items_;
    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Storage.CSIDriver> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIDriver getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * items is the list of CSIDriver
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.CSIDriverList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.CSIDriverList other = (io.kubernetes.client.proto.V1Storage.CSIDriverList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.CSIDriverList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CSIDriverList is a collection of CSIDriver objects.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.CSIDriverList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.CSIDriverList)
        io.kubernetes.client.proto.V1Storage.CSIDriverListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.CSIDriverList.class, io.kubernetes.client.proto.V1Storage.CSIDriverList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.CSIDriverList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIDriverList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.CSIDriverList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIDriverList build() {
        io.kubernetes.client.proto.V1Storage.CSIDriverList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIDriverList buildPartial() {
        io.kubernetes.client.proto.V1Storage.CSIDriverList result = new io.kubernetes.client.proto.V1Storage.CSIDriverList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Storage.CSIDriverList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.CSIDriverList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.CSIDriverList) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.CSIDriverList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.CSIDriverList other) {
        if (other == io.kubernetes.client.proto.V1Storage.CSIDriverList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Storage.CSIDriver m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Storage.CSIDriver.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Storage.CSIDriver> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Storage.CSIDriver>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSIDriver, io.kubernetes.client.proto.V1Storage.CSIDriver.Builder, io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.CSIDriver> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIDriver getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.CSIDriver value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.CSIDriver.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Storage.CSIDriver value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.CSIDriver value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Storage.CSIDriver.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.CSIDriver.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Storage.CSIDriver> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIDriver.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIDriver.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Storage.CSIDriver.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIDriver.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Storage.CSIDriver.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of CSIDriver
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIDriver items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.CSIDriver.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSIDriver, io.kubernetes.client.proto.V1Storage.CSIDriver.Builder, io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Storage.CSIDriver, io.kubernetes.client.proto.V1Storage.CSIDriver.Builder, io.kubernetes.client.proto.V1Storage.CSIDriverOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.CSIDriverList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.CSIDriverList)
    private static final io.kubernetes.client.proto.V1Storage.CSIDriverList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.CSIDriverList();
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriverList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CSIDriverList>
        PARSER = new com.google.protobuf.AbstractParser<CSIDriverList>() {
      @java.lang.Override
      public CSIDriverList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CSIDriverList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CSIDriverList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIDriverList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CSIDriverSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.CSIDriverSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * attachRequired indicates this CSI volume driver requires an attach
     * operation (because it implements the CSI ControllerPublishVolume()
     * method), and that the Kubernetes attach detach controller should call
     * the attach volume interface which checks the volumeattachment status
     * and waits until the volume is attached before proceeding to mounting.
     * The CSI external-attacher coordinates with CSI volume driver and updates
     * the volumeattachment status when the attach operation is complete.
     * If the CSIDriverRegistry feature gate is enabled and the value is
     * specified to false, the attach operation will be skipped.
     * Otherwise the attach operation will be called.
     *
     * This field is immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool attachRequired = 1;</code>
     * @return Whether the attachRequired field is set.
     */
    boolean hasAttachRequired();
    /**
     * <pre>
     * attachRequired indicates this CSI volume driver requires an attach
     * operation (because it implements the CSI ControllerPublishVolume()
     * method), and that the Kubernetes attach detach controller should call
     * the attach volume interface which checks the volumeattachment status
     * and waits until the volume is attached before proceeding to mounting.
     * The CSI external-attacher coordinates with CSI volume driver and updates
     * the volumeattachment status when the attach operation is complete.
     * If the CSIDriverRegistry feature gate is enabled and the value is
     * specified to false, the attach operation will be skipped.
     * Otherwise the attach operation will be called.
     *
     * This field is immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool attachRequired = 1;</code>
     * @return The attachRequired.
     */
    boolean getAttachRequired();

    /**
     * <pre>
     * podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.)
     * during mount operations, if set to true.
     * If set to false, pod information will not be passed on mount.
     * Default is false.
     *
     * The CSI driver specifies podInfoOnMount as part of driver deployment.
     * If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls.
     * The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.
     *
     * The following VolumeContext will be passed if podInfoOnMount is set to true.
     * This list might grow, but the prefix will be used.
     * "csi.storage.k8s.io/pod.name": pod.Name
     * "csi.storage.k8s.io/pod.namespace": pod.Namespace
     * "csi.storage.k8s.io/pod.uid": string(pod.UID)
     * "csi.storage.k8s.io/ephemeral": "true" if the volume is an ephemeral inline volume
     * defined by a CSIVolumeSource, otherwise "false"
     *
     * "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only
     * required for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
     * Other drivers can leave pod info disabled and/or ignore this field.
     * As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when
     * deployed on such a cluster and the deployment determines which mode that is, for example
     * via a command line parameter of the driver.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool podInfoOnMount = 2;</code>
     * @return Whether the podInfoOnMount field is set.
     */
    boolean hasPodInfoOnMount();
    /**
     * <pre>
     * podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.)
     * during mount operations, if set to true.
     * If set to false, pod information will not be passed on mount.
     * Default is false.
     *
     * The CSI driver specifies podInfoOnMount as part of driver deployment.
     * If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls.
     * The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.
     *
     * The following VolumeContext will be passed if podInfoOnMount is set to true.
     * This list might grow, but the prefix will be used.
     * "csi.storage.k8s.io/pod.name": pod.Name
     * "csi.storage.k8s.io/pod.namespace": pod.Namespace
     * "csi.storage.k8s.io/pod.uid": string(pod.UID)
     * "csi.storage.k8s.io/ephemeral": "true" if the volume is an ephemeral inline volume
     * defined by a CSIVolumeSource, otherwise "false"
     *
     * "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only
     * required for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
     * Other drivers can leave pod info disabled and/or ignore this field.
     * As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when
     * deployed on such a cluster and the deployment determines which mode that is, for example
     * via a command line parameter of the driver.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool podInfoOnMount = 2;</code>
     * @return The podInfoOnMount.
     */
    boolean getPodInfoOnMount();

    /**
     * <pre>
     * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
     * The default if the list is empty is "Persistent", which is the usage defined by the
     * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
     *
     * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
     * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
     * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
     *
     * For more information about implementing this mode, see
     * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
     * A driver can support one or more of these modes and more modes may be added in the future.
     *
     * This field is beta.
     * This field is immutable.
     *
     * +optional
     * +listType=set
     * </pre>
     *
     * <code>repeated string volumeLifecycleModes = 3;</code>
     * @return A list containing the volumeLifecycleModes.
     */
    java.util.List<java.lang.String>
        getVolumeLifecycleModesList();
    /**
     * <pre>
     * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
     * The default if the list is empty is "Persistent", which is the usage defined by the
     * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
     *
     * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
     * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
     * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
     *
     * For more information about implementing this mode, see
     * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
     * A driver can support one or more of these modes and more modes may be added in the future.
     *
     * This field is beta.
     * This field is immutable.
     *
     * +optional
     * +listType=set
     * </pre>
     *
     * <code>repeated string volumeLifecycleModes = 3;</code>
     * @return The count of volumeLifecycleModes.
     */
    int getVolumeLifecycleModesCount();
    /**
     * <pre>
     * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
     * The default if the list is empty is "Persistent", which is the usage defined by the
     * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
     *
     * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
     * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
     * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
     *
     * For more information about implementing this mode, see
     * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
     * A driver can support one or more of these modes and more modes may be added in the future.
     *
     * This field is beta.
     * This field is immutable.
     *
     * +optional
     * +listType=set
     * </pre>
     *
     * <code>repeated string volumeLifecycleModes = 3;</code>
     * @param index The index of the element to return.
     * @return The volumeLifecycleModes at the given index.
     */
    java.lang.String getVolumeLifecycleModes(int index);
    /**
     * <pre>
     * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
     * The default if the list is empty is "Persistent", which is the usage defined by the
     * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
     *
     * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
     * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
     * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
     *
     * For more information about implementing this mode, see
     * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
     * A driver can support one or more of these modes and more modes may be added in the future.
     *
     * This field is beta.
     * This field is immutable.
     *
     * +optional
     * +listType=set
     * </pre>
     *
     * <code>repeated string volumeLifecycleModes = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the volumeLifecycleModes at the given index.
     */
    com.google.protobuf.ByteString
        getVolumeLifecycleModesBytes(int index);

    /**
     * <pre>
     * storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage
     * capacity that the driver deployment will report by creating
     * CSIStorageCapacity objects with capacity information, if set to true.
     *
     * The check can be enabled immediately when deploying a driver.
     * In that case, provisioning new volumes with late binding
     * will pause until the driver deployment has published
     * some suitable CSIStorageCapacity object.
     *
     * Alternatively, the driver can be deployed with the field
     * unset or false and it can be flipped later when storage
     * capacity information has been published.
     *
     * This field was immutable in Kubernetes &lt;= 1.22 and now is mutable.
     *
     * +optional
     * +featureGate=CSIStorageCapacity
     * </pre>
     *
     * <code>optional bool storageCapacity = 4;</code>
     * @return Whether the storageCapacity field is set.
     */
    boolean hasStorageCapacity();
    /**
     * <pre>
     * storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage
     * capacity that the driver deployment will report by creating
     * CSIStorageCapacity objects with capacity information, if set to true.
     *
     * The check can be enabled immediately when deploying a driver.
     * In that case, provisioning new volumes with late binding
     * will pause until the driver deployment has published
     * some suitable CSIStorageCapacity object.
     *
     * Alternatively, the driver can be deployed with the field
     * unset or false and it can be flipped later when storage
     * capacity information has been published.
     *
     * This field was immutable in Kubernetes &lt;= 1.22 and now is mutable.
     *
     * +optional
     * +featureGate=CSIStorageCapacity
     * </pre>
     *
     * <code>optional bool storageCapacity = 4;</code>
     * @return The storageCapacity.
     */
    boolean getStorageCapacity();

    /**
     * <pre>
     * fsGroupPolicy defines if the underlying volume supports changing ownership and
     * permission of the volume before being mounted.
     * Refer to the specific FSGroupPolicy values for additional details.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * Defaults to ReadWriteOnceWithFSType, which will examine each volume
     * to determine if Kubernetes should modify ownership and permissions of the volume.
     * With the default policy the defined fsGroup will only be applied
     * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
     *
     * +optional
     * </pre>
     *
     * <code>optional string fsGroupPolicy = 5;</code>
     * @return Whether the fsGroupPolicy field is set.
     */
    boolean hasFsGroupPolicy();
    /**
     * <pre>
     * fsGroupPolicy defines if the underlying volume supports changing ownership and
     * permission of the volume before being mounted.
     * Refer to the specific FSGroupPolicy values for additional details.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * Defaults to ReadWriteOnceWithFSType, which will examine each volume
     * to determine if Kubernetes should modify ownership and permissions of the volume.
     * With the default policy the defined fsGroup will only be applied
     * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
     *
     * +optional
     * </pre>
     *
     * <code>optional string fsGroupPolicy = 5;</code>
     * @return The fsGroupPolicy.
     */
    java.lang.String getFsGroupPolicy();
    /**
     * <pre>
     * fsGroupPolicy defines if the underlying volume supports changing ownership and
     * permission of the volume before being mounted.
     * Refer to the specific FSGroupPolicy values for additional details.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * Defaults to ReadWriteOnceWithFSType, which will examine each volume
     * to determine if Kubernetes should modify ownership and permissions of the volume.
     * With the default policy the defined fsGroup will only be applied
     * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
     *
     * +optional
     * </pre>
     *
     * <code>optional string fsGroupPolicy = 5;</code>
     * @return The bytes for fsGroupPolicy.
     */
    com.google.protobuf.ByteString
        getFsGroupPolicyBytes();

    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Storage.TokenRequest> 
        getTokenRequestsList();
    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    io.kubernetes.client.proto.V1Storage.TokenRequest getTokenRequests(int index);
    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    int getTokenRequestsCount();
    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder> 
        getTokenRequestsOrBuilderList();
    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder getTokenRequestsOrBuilder(
        int index);

    /**
     * <pre>
     * requiresRepublish indicates the CSI driver wants `NodePublishVolume`
     * being periodically called to reflect any possible change in the mounted
     * volume. This field defaults to false.
     *
     * Note: After a successful initial NodePublishVolume call, subsequent calls
     * to NodePublishVolume should only update the contents of the volume. New
     * mount points will not be seen by a running container.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool requiresRepublish = 7;</code>
     * @return Whether the requiresRepublish field is set.
     */
    boolean hasRequiresRepublish();
    /**
     * <pre>
     * requiresRepublish indicates the CSI driver wants `NodePublishVolume`
     * being periodically called to reflect any possible change in the mounted
     * volume. This field defaults to false.
     *
     * Note: After a successful initial NodePublishVolume call, subsequent calls
     * to NodePublishVolume should only update the contents of the volume. New
     * mount points will not be seen by a running container.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool requiresRepublish = 7;</code>
     * @return The requiresRepublish.
     */
    boolean getRequiresRepublish();

    /**
     * <pre>
     * seLinuxMount specifies if the CSI driver supports "-o context"
     * mount option.
     *
     * When "true", the CSI driver must ensure that all volumes provided by this CSI
     * driver can be mounted separately with different `-o context` options. This is
     * typical for storage backends that provide volumes as filesystems on block
     * devices or as independent shared volumes.
     * Kubernetes will call NodeStage / NodePublish with "-o context=xyz" mount
     * option when mounting a ReadWriteOncePod volume used in Pod that has
     * explicitly set SELinux context. In the future, it may be expanded to other
     * volume AccessModes. In any case, Kubernetes will ensure that the volume is
     * mounted only with a single SELinux context.
     *
     * When "false", Kubernetes won't pass any special SELinux mount options to the driver.
     * This is typical for volumes that represent subdirectories of a bigger shared filesystem.
     *
     * Default is "false".
     *
     * +featureGate=SELinuxMountReadWriteOncePod
     * +optional
     * </pre>
     *
     * <code>optional bool seLinuxMount = 8;</code>
     * @return Whether the seLinuxMount field is set.
     */
    boolean hasSeLinuxMount();
    /**
     * <pre>
     * seLinuxMount specifies if the CSI driver supports "-o context"
     * mount option.
     *
     * When "true", the CSI driver must ensure that all volumes provided by this CSI
     * driver can be mounted separately with different `-o context` options. This is
     * typical for storage backends that provide volumes as filesystems on block
     * devices or as independent shared volumes.
     * Kubernetes will call NodeStage / NodePublish with "-o context=xyz" mount
     * option when mounting a ReadWriteOncePod volume used in Pod that has
     * explicitly set SELinux context. In the future, it may be expanded to other
     * volume AccessModes. In any case, Kubernetes will ensure that the volume is
     * mounted only with a single SELinux context.
     *
     * When "false", Kubernetes won't pass any special SELinux mount options to the driver.
     * This is typical for volumes that represent subdirectories of a bigger shared filesystem.
     *
     * Default is "false".
     *
     * +featureGate=SELinuxMountReadWriteOncePod
     * +optional
     * </pre>
     *
     * <code>optional bool seLinuxMount = 8;</code>
     * @return The seLinuxMount.
     */
    boolean getSeLinuxMount();
  }
  /**
   * <pre>
   * CSIDriverSpec is the specification of a CSIDriver.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.CSIDriverSpec}
   */
  public static final class CSIDriverSpec extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.CSIDriverSpec)
      CSIDriverSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CSIDriverSpec.class.getName());
    }
    // Use CSIDriverSpec.newBuilder() to construct.
    private CSIDriverSpec(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CSIDriverSpec() {
      volumeLifecycleModes_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      fsGroupPolicy_ = "";
      tokenRequests_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.CSIDriverSpec.class, io.kubernetes.client.proto.V1Storage.CSIDriverSpec.Builder.class);
    }

    private int bitField0_;
    public static final int ATTACHREQUIRED_FIELD_NUMBER = 1;
    private boolean attachRequired_ = false;
    /**
     * <pre>
     * attachRequired indicates this CSI volume driver requires an attach
     * operation (because it implements the CSI ControllerPublishVolume()
     * method), and that the Kubernetes attach detach controller should call
     * the attach volume interface which checks the volumeattachment status
     * and waits until the volume is attached before proceeding to mounting.
     * The CSI external-attacher coordinates with CSI volume driver and updates
     * the volumeattachment status when the attach operation is complete.
     * If the CSIDriverRegistry feature gate is enabled and the value is
     * specified to false, the attach operation will be skipped.
     * Otherwise the attach operation will be called.
     *
     * This field is immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool attachRequired = 1;</code>
     * @return Whether the attachRequired field is set.
     */
    @java.lang.Override
    public boolean hasAttachRequired() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * attachRequired indicates this CSI volume driver requires an attach
     * operation (because it implements the CSI ControllerPublishVolume()
     * method), and that the Kubernetes attach detach controller should call
     * the attach volume interface which checks the volumeattachment status
     * and waits until the volume is attached before proceeding to mounting.
     * The CSI external-attacher coordinates with CSI volume driver and updates
     * the volumeattachment status when the attach operation is complete.
     * If the CSIDriverRegistry feature gate is enabled and the value is
     * specified to false, the attach operation will be skipped.
     * Otherwise the attach operation will be called.
     *
     * This field is immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool attachRequired = 1;</code>
     * @return The attachRequired.
     */
    @java.lang.Override
    public boolean getAttachRequired() {
      return attachRequired_;
    }

    public static final int PODINFOONMOUNT_FIELD_NUMBER = 2;
    private boolean podInfoOnMount_ = false;
    /**
     * <pre>
     * podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.)
     * during mount operations, if set to true.
     * If set to false, pod information will not be passed on mount.
     * Default is false.
     *
     * The CSI driver specifies podInfoOnMount as part of driver deployment.
     * If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls.
     * The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.
     *
     * The following VolumeContext will be passed if podInfoOnMount is set to true.
     * This list might grow, but the prefix will be used.
     * "csi.storage.k8s.io/pod.name": pod.Name
     * "csi.storage.k8s.io/pod.namespace": pod.Namespace
     * "csi.storage.k8s.io/pod.uid": string(pod.UID)
     * "csi.storage.k8s.io/ephemeral": "true" if the volume is an ephemeral inline volume
     * defined by a CSIVolumeSource, otherwise "false"
     *
     * "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only
     * required for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
     * Other drivers can leave pod info disabled and/or ignore this field.
     * As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when
     * deployed on such a cluster and the deployment determines which mode that is, for example
     * via a command line parameter of the driver.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool podInfoOnMount = 2;</code>
     * @return Whether the podInfoOnMount field is set.
     */
    @java.lang.Override
    public boolean hasPodInfoOnMount() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.)
     * during mount operations, if set to true.
     * If set to false, pod information will not be passed on mount.
     * Default is false.
     *
     * The CSI driver specifies podInfoOnMount as part of driver deployment.
     * If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls.
     * The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.
     *
     * The following VolumeContext will be passed if podInfoOnMount is set to true.
     * This list might grow, but the prefix will be used.
     * "csi.storage.k8s.io/pod.name": pod.Name
     * "csi.storage.k8s.io/pod.namespace": pod.Namespace
     * "csi.storage.k8s.io/pod.uid": string(pod.UID)
     * "csi.storage.k8s.io/ephemeral": "true" if the volume is an ephemeral inline volume
     * defined by a CSIVolumeSource, otherwise "false"
     *
     * "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only
     * required for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
     * Other drivers can leave pod info disabled and/or ignore this field.
     * As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when
     * deployed on such a cluster and the deployment determines which mode that is, for example
     * via a command line parameter of the driver.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool podInfoOnMount = 2;</code>
     * @return The podInfoOnMount.
     */
    @java.lang.Override
    public boolean getPodInfoOnMount() {
      return podInfoOnMount_;
    }

    public static final int VOLUMELIFECYCLEMODES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList volumeLifecycleModes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
     * The default if the list is empty is "Persistent", which is the usage defined by the
     * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
     *
     * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
     * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
     * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
     *
     * For more information about implementing this mode, see
     * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
     * A driver can support one or more of these modes and more modes may be added in the future.
     *
     * This field is beta.
     * This field is immutable.
     *
     * +optional
     * +listType=set
     * </pre>
     *
     * <code>repeated string volumeLifecycleModes = 3;</code>
     * @return A list containing the volumeLifecycleModes.
     */
    public com.google.protobuf.ProtocolStringList
        getVolumeLifecycleModesList() {
      return volumeLifecycleModes_;
    }
    /**
     * <pre>
     * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
     * The default if the list is empty is "Persistent", which is the usage defined by the
     * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
     *
     * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
     * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
     * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
     *
     * For more information about implementing this mode, see
     * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
     * A driver can support one or more of these modes and more modes may be added in the future.
     *
     * This field is beta.
     * This field is immutable.
     *
     * +optional
     * +listType=set
     * </pre>
     *
     * <code>repeated string volumeLifecycleModes = 3;</code>
     * @return The count of volumeLifecycleModes.
     */
    public int getVolumeLifecycleModesCount() {
      return volumeLifecycleModes_.size();
    }
    /**
     * <pre>
     * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
     * The default if the list is empty is "Persistent", which is the usage defined by the
     * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
     *
     * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
     * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
     * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
     *
     * For more information about implementing this mode, see
     * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
     * A driver can support one or more of these modes and more modes may be added in the future.
     *
     * This field is beta.
     * This field is immutable.
     *
     * +optional
     * +listType=set
     * </pre>
     *
     * <code>repeated string volumeLifecycleModes = 3;</code>
     * @param index The index of the element to return.
     * @return The volumeLifecycleModes at the given index.
     */
    public java.lang.String getVolumeLifecycleModes(int index) {
      return volumeLifecycleModes_.get(index);
    }
    /**
     * <pre>
     * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
     * The default if the list is empty is "Persistent", which is the usage defined by the
     * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
     *
     * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
     * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
     * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
     *
     * For more information about implementing this mode, see
     * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
     * A driver can support one or more of these modes and more modes may be added in the future.
     *
     * This field is beta.
     * This field is immutable.
     *
     * +optional
     * +listType=set
     * </pre>
     *
     * <code>repeated string volumeLifecycleModes = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the volumeLifecycleModes at the given index.
     */
    public com.google.protobuf.ByteString
        getVolumeLifecycleModesBytes(int index) {
      return volumeLifecycleModes_.getByteString(index);
    }

    public static final int STORAGECAPACITY_FIELD_NUMBER = 4;
    private boolean storageCapacity_ = false;
    /**
     * <pre>
     * storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage
     * capacity that the driver deployment will report by creating
     * CSIStorageCapacity objects with capacity information, if set to true.
     *
     * The check can be enabled immediately when deploying a driver.
     * In that case, provisioning new volumes with late binding
     * will pause until the driver deployment has published
     * some suitable CSIStorageCapacity object.
     *
     * Alternatively, the driver can be deployed with the field
     * unset or false and it can be flipped later when storage
     * capacity information has been published.
     *
     * This field was immutable in Kubernetes &lt;= 1.22 and now is mutable.
     *
     * +optional
     * +featureGate=CSIStorageCapacity
     * </pre>
     *
     * <code>optional bool storageCapacity = 4;</code>
     * @return Whether the storageCapacity field is set.
     */
    @java.lang.Override
    public boolean hasStorageCapacity() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage
     * capacity that the driver deployment will report by creating
     * CSIStorageCapacity objects with capacity information, if set to true.
     *
     * The check can be enabled immediately when deploying a driver.
     * In that case, provisioning new volumes with late binding
     * will pause until the driver deployment has published
     * some suitable CSIStorageCapacity object.
     *
     * Alternatively, the driver can be deployed with the field
     * unset or false and it can be flipped later when storage
     * capacity information has been published.
     *
     * This field was immutable in Kubernetes &lt;= 1.22 and now is mutable.
     *
     * +optional
     * +featureGate=CSIStorageCapacity
     * </pre>
     *
     * <code>optional bool storageCapacity = 4;</code>
     * @return The storageCapacity.
     */
    @java.lang.Override
    public boolean getStorageCapacity() {
      return storageCapacity_;
    }

    public static final int FSGROUPPOLICY_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fsGroupPolicy_ = "";
    /**
     * <pre>
     * fsGroupPolicy defines if the underlying volume supports changing ownership and
     * permission of the volume before being mounted.
     * Refer to the specific FSGroupPolicy values for additional details.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * Defaults to ReadWriteOnceWithFSType, which will examine each volume
     * to determine if Kubernetes should modify ownership and permissions of the volume.
     * With the default policy the defined fsGroup will only be applied
     * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
     *
     * +optional
     * </pre>
     *
     * <code>optional string fsGroupPolicy = 5;</code>
     * @return Whether the fsGroupPolicy field is set.
     */
    @java.lang.Override
    public boolean hasFsGroupPolicy() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * fsGroupPolicy defines if the underlying volume supports changing ownership and
     * permission of the volume before being mounted.
     * Refer to the specific FSGroupPolicy values for additional details.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * Defaults to ReadWriteOnceWithFSType, which will examine each volume
     * to determine if Kubernetes should modify ownership and permissions of the volume.
     * With the default policy the defined fsGroup will only be applied
     * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
     *
     * +optional
     * </pre>
     *
     * <code>optional string fsGroupPolicy = 5;</code>
     * @return The fsGroupPolicy.
     */
    @java.lang.Override
    public java.lang.String getFsGroupPolicy() {
      java.lang.Object ref = fsGroupPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fsGroupPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * fsGroupPolicy defines if the underlying volume supports changing ownership and
     * permission of the volume before being mounted.
     * Refer to the specific FSGroupPolicy values for additional details.
     *
     * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
     *
     * Defaults to ReadWriteOnceWithFSType, which will examine each volume
     * to determine if Kubernetes should modify ownership and permissions of the volume.
     * With the default policy the defined fsGroup will only be applied
     * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
     *
     * +optional
     * </pre>
     *
     * <code>optional string fsGroupPolicy = 5;</code>
     * @return The bytes for fsGroupPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFsGroupPolicyBytes() {
      java.lang.Object ref = fsGroupPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fsGroupPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TOKENREQUESTS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Storage.TokenRequest> tokenRequests_;
    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Storage.TokenRequest> getTokenRequestsList() {
      return tokenRequests_;
    }
    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder> 
        getTokenRequestsOrBuilderList() {
      return tokenRequests_;
    }
    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    @java.lang.Override
    public int getTokenRequestsCount() {
      return tokenRequests_.size();
    }
    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.TokenRequest getTokenRequests(int index) {
      return tokenRequests_.get(index);
    }
    /**
     * <pre>
     * tokenRequests indicates the CSI driver needs pods' service account
     * tokens it is mounting volume for to do necessary authentication. Kubelet
     * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
     * The CSI driver should parse and validate the following VolumeContext:
     * "csi.storage.k8s.io/serviceAccount.tokens": {
     * "&lt;audience&gt;": {
     * "token": &lt;token&gt;,
     * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
     * },
     * ...
     * }
     *
     * Note: Audience in each TokenRequest should be different and at
     * most one token is empty string. To receive a new token after expiry,
     * RequiresRepublish can be used to trigger NodePublishVolume periodically.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder getTokenRequestsOrBuilder(
        int index) {
      return tokenRequests_.get(index);
    }

    public static final int REQUIRESREPUBLISH_FIELD_NUMBER = 7;
    private boolean requiresRepublish_ = false;
    /**
     * <pre>
     * requiresRepublish indicates the CSI driver wants `NodePublishVolume`
     * being periodically called to reflect any possible change in the mounted
     * volume. This field defaults to false.
     *
     * Note: After a successful initial NodePublishVolume call, subsequent calls
     * to NodePublishVolume should only update the contents of the volume. New
     * mount points will not be seen by a running container.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool requiresRepublish = 7;</code>
     * @return Whether the requiresRepublish field is set.
     */
    @java.lang.Override
    public boolean hasRequiresRepublish() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * requiresRepublish indicates the CSI driver wants `NodePublishVolume`
     * being periodically called to reflect any possible change in the mounted
     * volume. This field defaults to false.
     *
     * Note: After a successful initial NodePublishVolume call, subsequent calls
     * to NodePublishVolume should only update the contents of the volume. New
     * mount points will not be seen by a running container.
     *
     * +optional
     * </pre>
     *
     * <code>optional bool requiresRepublish = 7;</code>
     * @return The requiresRepublish.
     */
    @java.lang.Override
    public boolean getRequiresRepublish() {
      return requiresRepublish_;
    }

    public static final int SELINUXMOUNT_FIELD_NUMBER = 8;
    private boolean seLinuxMount_ = false;
    /**
     * <pre>
     * seLinuxMount specifies if the CSI driver supports "-o context"
     * mount option.
     *
     * When "true", the CSI driver must ensure that all volumes provided by this CSI
     * driver can be mounted separately with different `-o context` options. This is
     * typical for storage backends that provide volumes as filesystems on block
     * devices or as independent shared volumes.
     * Kubernetes will call NodeStage / NodePublish with "-o context=xyz" mount
     * option when mounting a ReadWriteOncePod volume used in Pod that has
     * explicitly set SELinux context. In the future, it may be expanded to other
     * volume AccessModes. In any case, Kubernetes will ensure that the volume is
     * mounted only with a single SELinux context.
     *
     * When "false", Kubernetes won't pass any special SELinux mount options to the driver.
     * This is typical for volumes that represent subdirectories of a bigger shared filesystem.
     *
     * Default is "false".
     *
     * +featureGate=SELinuxMountReadWriteOncePod
     * +optional
     * </pre>
     *
     * <code>optional bool seLinuxMount = 8;</code>
     * @return Whether the seLinuxMount field is set.
     */
    @java.lang.Override
    public boolean hasSeLinuxMount() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * seLinuxMount specifies if the CSI driver supports "-o context"
     * mount option.
     *
     * When "true", the CSI driver must ensure that all volumes provided by this CSI
     * driver can be mounted separately with different `-o context` options. This is
     * typical for storage backends that provide volumes as filesystems on block
     * devices or as independent shared volumes.
     * Kubernetes will call NodeStage / NodePublish with "-o context=xyz" mount
     * option when mounting a ReadWriteOncePod volume used in Pod that has
     * explicitly set SELinux context. In the future, it may be expanded to other
     * volume AccessModes. In any case, Kubernetes will ensure that the volume is
     * mounted only with a single SELinux context.
     *
     * When "false", Kubernetes won't pass any special SELinux mount options to the driver.
     * This is typical for volumes that represent subdirectories of a bigger shared filesystem.
     *
     * Default is "false".
     *
     * +featureGate=SELinuxMountReadWriteOncePod
     * +optional
     * </pre>
     *
     * <code>optional bool seLinuxMount = 8;</code>
     * @return The seLinuxMount.
     */
    @java.lang.Override
    public boolean getSeLinuxMount() {
      return seLinuxMount_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(1, attachRequired_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(2, podInfoOnMount_);
      }
      for (int i = 0; i < volumeLifecycleModes_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, volumeLifecycleModes_.getRaw(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(4, storageCapacity_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, fsGroupPolicy_);
      }
      for (int i = 0; i < tokenRequests_.size(); i++) {
        output.writeMessage(6, tokenRequests_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(7, requiresRepublish_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(8, seLinuxMount_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, attachRequired_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, podInfoOnMount_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < volumeLifecycleModes_.size(); i++) {
          dataSize += computeStringSizeNoTag(volumeLifecycleModes_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getVolumeLifecycleModesList().size();
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, storageCapacity_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, fsGroupPolicy_);
      }
      for (int i = 0; i < tokenRequests_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, tokenRequests_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, requiresRepublish_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(8, seLinuxMount_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.CSIDriverSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.CSIDriverSpec other = (io.kubernetes.client.proto.V1Storage.CSIDriverSpec) obj;

      if (hasAttachRequired() != other.hasAttachRequired()) return false;
      if (hasAttachRequired()) {
        if (getAttachRequired()
            != other.getAttachRequired()) return false;
      }
      if (hasPodInfoOnMount() != other.hasPodInfoOnMount()) return false;
      if (hasPodInfoOnMount()) {
        if (getPodInfoOnMount()
            != other.getPodInfoOnMount()) return false;
      }
      if (!getVolumeLifecycleModesList()
          .equals(other.getVolumeLifecycleModesList())) return false;
      if (hasStorageCapacity() != other.hasStorageCapacity()) return false;
      if (hasStorageCapacity()) {
        if (getStorageCapacity()
            != other.getStorageCapacity()) return false;
      }
      if (hasFsGroupPolicy() != other.hasFsGroupPolicy()) return false;
      if (hasFsGroupPolicy()) {
        if (!getFsGroupPolicy()
            .equals(other.getFsGroupPolicy())) return false;
      }
      if (!getTokenRequestsList()
          .equals(other.getTokenRequestsList())) return false;
      if (hasRequiresRepublish() != other.hasRequiresRepublish()) return false;
      if (hasRequiresRepublish()) {
        if (getRequiresRepublish()
            != other.getRequiresRepublish()) return false;
      }
      if (hasSeLinuxMount() != other.hasSeLinuxMount()) return false;
      if (hasSeLinuxMount()) {
        if (getSeLinuxMount()
            != other.getSeLinuxMount()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAttachRequired()) {
        hash = (37 * hash) + ATTACHREQUIRED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAttachRequired());
      }
      if (hasPodInfoOnMount()) {
        hash = (37 * hash) + PODINFOONMOUNT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPodInfoOnMount());
      }
      if (getVolumeLifecycleModesCount() > 0) {
        hash = (37 * hash) + VOLUMELIFECYCLEMODES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeLifecycleModesList().hashCode();
      }
      if (hasStorageCapacity()) {
        hash = (37 * hash) + STORAGECAPACITY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getStorageCapacity());
      }
      if (hasFsGroupPolicy()) {
        hash = (37 * hash) + FSGROUPPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFsGroupPolicy().hashCode();
      }
      if (getTokenRequestsCount() > 0) {
        hash = (37 * hash) + TOKENREQUESTS_FIELD_NUMBER;
        hash = (53 * hash) + getTokenRequestsList().hashCode();
      }
      if (hasRequiresRepublish()) {
        hash = (37 * hash) + REQUIRESREPUBLISH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRequiresRepublish());
      }
      if (hasSeLinuxMount()) {
        hash = (37 * hash) + SELINUXMOUNT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSeLinuxMount());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.CSIDriverSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CSIDriverSpec is the specification of a CSIDriver.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.CSIDriverSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.CSIDriverSpec)
        io.kubernetes.client.proto.V1Storage.CSIDriverSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.CSIDriverSpec.class, io.kubernetes.client.proto.V1Storage.CSIDriverSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.CSIDriverSpec.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        attachRequired_ = false;
        podInfoOnMount_ = false;
        volumeLifecycleModes_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        storageCapacity_ = false;
        fsGroupPolicy_ = "";
        if (tokenRequestsBuilder_ == null) {
          tokenRequests_ = java.util.Collections.emptyList();
        } else {
          tokenRequests_ = null;
          tokenRequestsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        requiresRepublish_ = false;
        seLinuxMount_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIDriverSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIDriverSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.CSIDriverSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIDriverSpec build() {
        io.kubernetes.client.proto.V1Storage.CSIDriverSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIDriverSpec buildPartial() {
        io.kubernetes.client.proto.V1Storage.CSIDriverSpec result = new io.kubernetes.client.proto.V1Storage.CSIDriverSpec(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Storage.CSIDriverSpec result) {
        if (tokenRequestsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            tokenRequests_ = java.util.Collections.unmodifiableList(tokenRequests_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.tokenRequests_ = tokenRequests_;
        } else {
          result.tokenRequests_ = tokenRequestsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.CSIDriverSpec result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.attachRequired_ = attachRequired_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.podInfoOnMount_ = podInfoOnMount_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          volumeLifecycleModes_.makeImmutable();
          result.volumeLifecycleModes_ = volumeLifecycleModes_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.storageCapacity_ = storageCapacity_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.fsGroupPolicy_ = fsGroupPolicy_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.requiresRepublish_ = requiresRepublish_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.seLinuxMount_ = seLinuxMount_;
          to_bitField0_ |= 0x00000020;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.CSIDriverSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.CSIDriverSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.CSIDriverSpec other) {
        if (other == io.kubernetes.client.proto.V1Storage.CSIDriverSpec.getDefaultInstance()) return this;
        if (other.hasAttachRequired()) {
          setAttachRequired(other.getAttachRequired());
        }
        if (other.hasPodInfoOnMount()) {
          setPodInfoOnMount(other.getPodInfoOnMount());
        }
        if (!other.volumeLifecycleModes_.isEmpty()) {
          if (volumeLifecycleModes_.isEmpty()) {
            volumeLifecycleModes_ = other.volumeLifecycleModes_;
            bitField0_ |= 0x00000004;
          } else {
            ensureVolumeLifecycleModesIsMutable();
            volumeLifecycleModes_.addAll(other.volumeLifecycleModes_);
          }
          onChanged();
        }
        if (other.hasStorageCapacity()) {
          setStorageCapacity(other.getStorageCapacity());
        }
        if (other.hasFsGroupPolicy()) {
          fsGroupPolicy_ = other.fsGroupPolicy_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (tokenRequestsBuilder_ == null) {
          if (!other.tokenRequests_.isEmpty()) {
            if (tokenRequests_.isEmpty()) {
              tokenRequests_ = other.tokenRequests_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureTokenRequestsIsMutable();
              tokenRequests_.addAll(other.tokenRequests_);
            }
            onChanged();
          }
        } else {
          if (!other.tokenRequests_.isEmpty()) {
            if (tokenRequestsBuilder_.isEmpty()) {
              tokenRequestsBuilder_.dispose();
              tokenRequestsBuilder_ = null;
              tokenRequests_ = other.tokenRequests_;
              bitField0_ = (bitField0_ & ~0x00000020);
              tokenRequestsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getTokenRequestsFieldBuilder() : null;
            } else {
              tokenRequestsBuilder_.addAllMessages(other.tokenRequests_);
            }
          }
        }
        if (other.hasRequiresRepublish()) {
          setRequiresRepublish(other.getRequiresRepublish());
        }
        if (other.hasSeLinuxMount()) {
          setSeLinuxMount(other.getSeLinuxMount());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                attachRequired_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                podInfoOnMount_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureVolumeLifecycleModesIsMutable();
                volumeLifecycleModes_.add(bs);
                break;
              } // case 26
              case 32: {
                storageCapacity_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 42: {
                fsGroupPolicy_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                io.kubernetes.client.proto.V1Storage.TokenRequest m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Storage.TokenRequest.parser(),
                        extensionRegistry);
                if (tokenRequestsBuilder_ == null) {
                  ensureTokenRequestsIsMutable();
                  tokenRequests_.add(m);
                } else {
                  tokenRequestsBuilder_.addMessage(m);
                }
                break;
              } // case 50
              case 56: {
                requiresRepublish_ = input.readBool();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 64: {
                seLinuxMount_ = input.readBool();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean attachRequired_ ;
      /**
       * <pre>
       * attachRequired indicates this CSI volume driver requires an attach
       * operation (because it implements the CSI ControllerPublishVolume()
       * method), and that the Kubernetes attach detach controller should call
       * the attach volume interface which checks the volumeattachment status
       * and waits until the volume is attached before proceeding to mounting.
       * The CSI external-attacher coordinates with CSI volume driver and updates
       * the volumeattachment status when the attach operation is complete.
       * If the CSIDriverRegistry feature gate is enabled and the value is
       * specified to false, the attach operation will be skipped.
       * Otherwise the attach operation will be called.
       *
       * This field is immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool attachRequired = 1;</code>
       * @return Whether the attachRequired field is set.
       */
      @java.lang.Override
      public boolean hasAttachRequired() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * attachRequired indicates this CSI volume driver requires an attach
       * operation (because it implements the CSI ControllerPublishVolume()
       * method), and that the Kubernetes attach detach controller should call
       * the attach volume interface which checks the volumeattachment status
       * and waits until the volume is attached before proceeding to mounting.
       * The CSI external-attacher coordinates with CSI volume driver and updates
       * the volumeattachment status when the attach operation is complete.
       * If the CSIDriverRegistry feature gate is enabled and the value is
       * specified to false, the attach operation will be skipped.
       * Otherwise the attach operation will be called.
       *
       * This field is immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool attachRequired = 1;</code>
       * @return The attachRequired.
       */
      @java.lang.Override
      public boolean getAttachRequired() {
        return attachRequired_;
      }
      /**
       * <pre>
       * attachRequired indicates this CSI volume driver requires an attach
       * operation (because it implements the CSI ControllerPublishVolume()
       * method), and that the Kubernetes attach detach controller should call
       * the attach volume interface which checks the volumeattachment status
       * and waits until the volume is attached before proceeding to mounting.
       * The CSI external-attacher coordinates with CSI volume driver and updates
       * the volumeattachment status when the attach operation is complete.
       * If the CSIDriverRegistry feature gate is enabled and the value is
       * specified to false, the attach operation will be skipped.
       * Otherwise the attach operation will be called.
       *
       * This field is immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool attachRequired = 1;</code>
       * @param value The attachRequired to set.
       * @return This builder for chaining.
       */
      public Builder setAttachRequired(boolean value) {

        attachRequired_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * attachRequired indicates this CSI volume driver requires an attach
       * operation (because it implements the CSI ControllerPublishVolume()
       * method), and that the Kubernetes attach detach controller should call
       * the attach volume interface which checks the volumeattachment status
       * and waits until the volume is attached before proceeding to mounting.
       * The CSI external-attacher coordinates with CSI volume driver and updates
       * the volumeattachment status when the attach operation is complete.
       * If the CSIDriverRegistry feature gate is enabled and the value is
       * specified to false, the attach operation will be skipped.
       * Otherwise the attach operation will be called.
       *
       * This field is immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool attachRequired = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAttachRequired() {
        bitField0_ = (bitField0_ & ~0x00000001);
        attachRequired_ = false;
        onChanged();
        return this;
      }

      private boolean podInfoOnMount_ ;
      /**
       * <pre>
       * podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.)
       * during mount operations, if set to true.
       * If set to false, pod information will not be passed on mount.
       * Default is false.
       *
       * The CSI driver specifies podInfoOnMount as part of driver deployment.
       * If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls.
       * The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.
       *
       * The following VolumeContext will be passed if podInfoOnMount is set to true.
       * This list might grow, but the prefix will be used.
       * "csi.storage.k8s.io/pod.name": pod.Name
       * "csi.storage.k8s.io/pod.namespace": pod.Namespace
       * "csi.storage.k8s.io/pod.uid": string(pod.UID)
       * "csi.storage.k8s.io/ephemeral": "true" if the volume is an ephemeral inline volume
       * defined by a CSIVolumeSource, otherwise "false"
       *
       * "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only
       * required for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
       * Other drivers can leave pod info disabled and/or ignore this field.
       * As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when
       * deployed on such a cluster and the deployment determines which mode that is, for example
       * via a command line parameter of the driver.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool podInfoOnMount = 2;</code>
       * @return Whether the podInfoOnMount field is set.
       */
      @java.lang.Override
      public boolean hasPodInfoOnMount() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.)
       * during mount operations, if set to true.
       * If set to false, pod information will not be passed on mount.
       * Default is false.
       *
       * The CSI driver specifies podInfoOnMount as part of driver deployment.
       * If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls.
       * The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.
       *
       * The following VolumeContext will be passed if podInfoOnMount is set to true.
       * This list might grow, but the prefix will be used.
       * "csi.storage.k8s.io/pod.name": pod.Name
       * "csi.storage.k8s.io/pod.namespace": pod.Namespace
       * "csi.storage.k8s.io/pod.uid": string(pod.UID)
       * "csi.storage.k8s.io/ephemeral": "true" if the volume is an ephemeral inline volume
       * defined by a CSIVolumeSource, otherwise "false"
       *
       * "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only
       * required for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
       * Other drivers can leave pod info disabled and/or ignore this field.
       * As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when
       * deployed on such a cluster and the deployment determines which mode that is, for example
       * via a command line parameter of the driver.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool podInfoOnMount = 2;</code>
       * @return The podInfoOnMount.
       */
      @java.lang.Override
      public boolean getPodInfoOnMount() {
        return podInfoOnMount_;
      }
      /**
       * <pre>
       * podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.)
       * during mount operations, if set to true.
       * If set to false, pod information will not be passed on mount.
       * Default is false.
       *
       * The CSI driver specifies podInfoOnMount as part of driver deployment.
       * If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls.
       * The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.
       *
       * The following VolumeContext will be passed if podInfoOnMount is set to true.
       * This list might grow, but the prefix will be used.
       * "csi.storage.k8s.io/pod.name": pod.Name
       * "csi.storage.k8s.io/pod.namespace": pod.Namespace
       * "csi.storage.k8s.io/pod.uid": string(pod.UID)
       * "csi.storage.k8s.io/ephemeral": "true" if the volume is an ephemeral inline volume
       * defined by a CSIVolumeSource, otherwise "false"
       *
       * "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only
       * required for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
       * Other drivers can leave pod info disabled and/or ignore this field.
       * As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when
       * deployed on such a cluster and the deployment determines which mode that is, for example
       * via a command line parameter of the driver.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool podInfoOnMount = 2;</code>
       * @param value The podInfoOnMount to set.
       * @return This builder for chaining.
       */
      public Builder setPodInfoOnMount(boolean value) {

        podInfoOnMount_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.)
       * during mount operations, if set to true.
       * If set to false, pod information will not be passed on mount.
       * Default is false.
       *
       * The CSI driver specifies podInfoOnMount as part of driver deployment.
       * If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls.
       * The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.
       *
       * The following VolumeContext will be passed if podInfoOnMount is set to true.
       * This list might grow, but the prefix will be used.
       * "csi.storage.k8s.io/pod.name": pod.Name
       * "csi.storage.k8s.io/pod.namespace": pod.Namespace
       * "csi.storage.k8s.io/pod.uid": string(pod.UID)
       * "csi.storage.k8s.io/ephemeral": "true" if the volume is an ephemeral inline volume
       * defined by a CSIVolumeSource, otherwise "false"
       *
       * "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only
       * required for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
       * Other drivers can leave pod info disabled and/or ignore this field.
       * As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when
       * deployed on such a cluster and the deployment determines which mode that is, for example
       * via a command line parameter of the driver.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool podInfoOnMount = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPodInfoOnMount() {
        bitField0_ = (bitField0_ & ~0x00000002);
        podInfoOnMount_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList volumeLifecycleModes_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureVolumeLifecycleModesIsMutable() {
        if (!volumeLifecycleModes_.isModifiable()) {
          volumeLifecycleModes_ = new com.google.protobuf.LazyStringArrayList(volumeLifecycleModes_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <pre>
       * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
       * The default if the list is empty is "Persistent", which is the usage defined by the
       * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
       *
       * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
       * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
       * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
       *
       * For more information about implementing this mode, see
       * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
       * A driver can support one or more of these modes and more modes may be added in the future.
       *
       * This field is beta.
       * This field is immutable.
       *
       * +optional
       * +listType=set
       * </pre>
       *
       * <code>repeated string volumeLifecycleModes = 3;</code>
       * @return A list containing the volumeLifecycleModes.
       */
      public com.google.protobuf.ProtocolStringList
          getVolumeLifecycleModesList() {
        volumeLifecycleModes_.makeImmutable();
        return volumeLifecycleModes_;
      }
      /**
       * <pre>
       * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
       * The default if the list is empty is "Persistent", which is the usage defined by the
       * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
       *
       * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
       * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
       * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
       *
       * For more information about implementing this mode, see
       * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
       * A driver can support one or more of these modes and more modes may be added in the future.
       *
       * This field is beta.
       * This field is immutable.
       *
       * +optional
       * +listType=set
       * </pre>
       *
       * <code>repeated string volumeLifecycleModes = 3;</code>
       * @return The count of volumeLifecycleModes.
       */
      public int getVolumeLifecycleModesCount() {
        return volumeLifecycleModes_.size();
      }
      /**
       * <pre>
       * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
       * The default if the list is empty is "Persistent", which is the usage defined by the
       * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
       *
       * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
       * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
       * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
       *
       * For more information about implementing this mode, see
       * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
       * A driver can support one or more of these modes and more modes may be added in the future.
       *
       * This field is beta.
       * This field is immutable.
       *
       * +optional
       * +listType=set
       * </pre>
       *
       * <code>repeated string volumeLifecycleModes = 3;</code>
       * @param index The index of the element to return.
       * @return The volumeLifecycleModes at the given index.
       */
      public java.lang.String getVolumeLifecycleModes(int index) {
        return volumeLifecycleModes_.get(index);
      }
      /**
       * <pre>
       * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
       * The default if the list is empty is "Persistent", which is the usage defined by the
       * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
       *
       * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
       * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
       * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
       *
       * For more information about implementing this mode, see
       * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
       * A driver can support one or more of these modes and more modes may be added in the future.
       *
       * This field is beta.
       * This field is immutable.
       *
       * +optional
       * +listType=set
       * </pre>
       *
       * <code>repeated string volumeLifecycleModes = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the volumeLifecycleModes at the given index.
       */
      public com.google.protobuf.ByteString
          getVolumeLifecycleModesBytes(int index) {
        return volumeLifecycleModes_.getByteString(index);
      }
      /**
       * <pre>
       * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
       * The default if the list is empty is "Persistent", which is the usage defined by the
       * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
       *
       * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
       * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
       * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
       *
       * For more information about implementing this mode, see
       * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
       * A driver can support one or more of these modes and more modes may be added in the future.
       *
       * This field is beta.
       * This field is immutable.
       *
       * +optional
       * +listType=set
       * </pre>
       *
       * <code>repeated string volumeLifecycleModes = 3;</code>
       * @param index The index to set the value at.
       * @param value The volumeLifecycleModes to set.
       * @return This builder for chaining.
       */
      public Builder setVolumeLifecycleModes(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureVolumeLifecycleModesIsMutable();
        volumeLifecycleModes_.set(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
       * The default if the list is empty is "Persistent", which is the usage defined by the
       * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
       *
       * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
       * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
       * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
       *
       * For more information about implementing this mode, see
       * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
       * A driver can support one or more of these modes and more modes may be added in the future.
       *
       * This field is beta.
       * This field is immutable.
       *
       * +optional
       * +listType=set
       * </pre>
       *
       * <code>repeated string volumeLifecycleModes = 3;</code>
       * @param value The volumeLifecycleModes to add.
       * @return This builder for chaining.
       */
      public Builder addVolumeLifecycleModes(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureVolumeLifecycleModesIsMutable();
        volumeLifecycleModes_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
       * The default if the list is empty is "Persistent", which is the usage defined by the
       * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
       *
       * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
       * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
       * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
       *
       * For more information about implementing this mode, see
       * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
       * A driver can support one or more of these modes and more modes may be added in the future.
       *
       * This field is beta.
       * This field is immutable.
       *
       * +optional
       * +listType=set
       * </pre>
       *
       * <code>repeated string volumeLifecycleModes = 3;</code>
       * @param values The volumeLifecycleModes to add.
       * @return This builder for chaining.
       */
      public Builder addAllVolumeLifecycleModes(
          java.lang.Iterable<java.lang.String> values) {
        ensureVolumeLifecycleModesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, volumeLifecycleModes_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
       * The default if the list is empty is "Persistent", which is the usage defined by the
       * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
       *
       * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
       * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
       * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
       *
       * For more information about implementing this mode, see
       * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
       * A driver can support one or more of these modes and more modes may be added in the future.
       *
       * This field is beta.
       * This field is immutable.
       *
       * +optional
       * +listType=set
       * </pre>
       *
       * <code>repeated string volumeLifecycleModes = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearVolumeLifecycleModes() {
        volumeLifecycleModes_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
       * The default if the list is empty is "Persistent", which is the usage defined by the
       * CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
       *
       * The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
       * with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
       * A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
       *
       * For more information about implementing this mode, see
       * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
       * A driver can support one or more of these modes and more modes may be added in the future.
       *
       * This field is beta.
       * This field is immutable.
       *
       * +optional
       * +listType=set
       * </pre>
       *
       * <code>repeated string volumeLifecycleModes = 3;</code>
       * @param value The bytes of the volumeLifecycleModes to add.
       * @return This builder for chaining.
       */
      public Builder addVolumeLifecycleModesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureVolumeLifecycleModesIsMutable();
        volumeLifecycleModes_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private boolean storageCapacity_ ;
      /**
       * <pre>
       * storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage
       * capacity that the driver deployment will report by creating
       * CSIStorageCapacity objects with capacity information, if set to true.
       *
       * The check can be enabled immediately when deploying a driver.
       * In that case, provisioning new volumes with late binding
       * will pause until the driver deployment has published
       * some suitable CSIStorageCapacity object.
       *
       * Alternatively, the driver can be deployed with the field
       * unset or false and it can be flipped later when storage
       * capacity information has been published.
       *
       * This field was immutable in Kubernetes &lt;= 1.22 and now is mutable.
       *
       * +optional
       * +featureGate=CSIStorageCapacity
       * </pre>
       *
       * <code>optional bool storageCapacity = 4;</code>
       * @return Whether the storageCapacity field is set.
       */
      @java.lang.Override
      public boolean hasStorageCapacity() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage
       * capacity that the driver deployment will report by creating
       * CSIStorageCapacity objects with capacity information, if set to true.
       *
       * The check can be enabled immediately when deploying a driver.
       * In that case, provisioning new volumes with late binding
       * will pause until the driver deployment has published
       * some suitable CSIStorageCapacity object.
       *
       * Alternatively, the driver can be deployed with the field
       * unset or false and it can be flipped later when storage
       * capacity information has been published.
       *
       * This field was immutable in Kubernetes &lt;= 1.22 and now is mutable.
       *
       * +optional
       * +featureGate=CSIStorageCapacity
       * </pre>
       *
       * <code>optional bool storageCapacity = 4;</code>
       * @return The storageCapacity.
       */
      @java.lang.Override
      public boolean getStorageCapacity() {
        return storageCapacity_;
      }
      /**
       * <pre>
       * storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage
       * capacity that the driver deployment will report by creating
       * CSIStorageCapacity objects with capacity information, if set to true.
       *
       * The check can be enabled immediately when deploying a driver.
       * In that case, provisioning new volumes with late binding
       * will pause until the driver deployment has published
       * some suitable CSIStorageCapacity object.
       *
       * Alternatively, the driver can be deployed with the field
       * unset or false and it can be flipped later when storage
       * capacity information has been published.
       *
       * This field was immutable in Kubernetes &lt;= 1.22 and now is mutable.
       *
       * +optional
       * +featureGate=CSIStorageCapacity
       * </pre>
       *
       * <code>optional bool storageCapacity = 4;</code>
       * @param value The storageCapacity to set.
       * @return This builder for chaining.
       */
      public Builder setStorageCapacity(boolean value) {

        storageCapacity_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage
       * capacity that the driver deployment will report by creating
       * CSIStorageCapacity objects with capacity information, if set to true.
       *
       * The check can be enabled immediately when deploying a driver.
       * In that case, provisioning new volumes with late binding
       * will pause until the driver deployment has published
       * some suitable CSIStorageCapacity object.
       *
       * Alternatively, the driver can be deployed with the field
       * unset or false and it can be flipped later when storage
       * capacity information has been published.
       *
       * This field was immutable in Kubernetes &lt;= 1.22 and now is mutable.
       *
       * +optional
       * +featureGate=CSIStorageCapacity
       * </pre>
       *
       * <code>optional bool storageCapacity = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearStorageCapacity() {
        bitField0_ = (bitField0_ & ~0x00000008);
        storageCapacity_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object fsGroupPolicy_ = "";
      /**
       * <pre>
       * fsGroupPolicy defines if the underlying volume supports changing ownership and
       * permission of the volume before being mounted.
       * Refer to the specific FSGroupPolicy values for additional details.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * Defaults to ReadWriteOnceWithFSType, which will examine each volume
       * to determine if Kubernetes should modify ownership and permissions of the volume.
       * With the default policy the defined fsGroup will only be applied
       * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
       *
       * +optional
       * </pre>
       *
       * <code>optional string fsGroupPolicy = 5;</code>
       * @return Whether the fsGroupPolicy field is set.
       */
      public boolean hasFsGroupPolicy() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * fsGroupPolicy defines if the underlying volume supports changing ownership and
       * permission of the volume before being mounted.
       * Refer to the specific FSGroupPolicy values for additional details.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * Defaults to ReadWriteOnceWithFSType, which will examine each volume
       * to determine if Kubernetes should modify ownership and permissions of the volume.
       * With the default policy the defined fsGroup will only be applied
       * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
       *
       * +optional
       * </pre>
       *
       * <code>optional string fsGroupPolicy = 5;</code>
       * @return The fsGroupPolicy.
       */
      public java.lang.String getFsGroupPolicy() {
        java.lang.Object ref = fsGroupPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fsGroupPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * fsGroupPolicy defines if the underlying volume supports changing ownership and
       * permission of the volume before being mounted.
       * Refer to the specific FSGroupPolicy values for additional details.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * Defaults to ReadWriteOnceWithFSType, which will examine each volume
       * to determine if Kubernetes should modify ownership and permissions of the volume.
       * With the default policy the defined fsGroup will only be applied
       * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
       *
       * +optional
       * </pre>
       *
       * <code>optional string fsGroupPolicy = 5;</code>
       * @return The bytes for fsGroupPolicy.
       */
      public com.google.protobuf.ByteString
          getFsGroupPolicyBytes() {
        java.lang.Object ref = fsGroupPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fsGroupPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * fsGroupPolicy defines if the underlying volume supports changing ownership and
       * permission of the volume before being mounted.
       * Refer to the specific FSGroupPolicy values for additional details.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * Defaults to ReadWriteOnceWithFSType, which will examine each volume
       * to determine if Kubernetes should modify ownership and permissions of the volume.
       * With the default policy the defined fsGroup will only be applied
       * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
       *
       * +optional
       * </pre>
       *
       * <code>optional string fsGroupPolicy = 5;</code>
       * @param value The fsGroupPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFsGroupPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fsGroupPolicy_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fsGroupPolicy defines if the underlying volume supports changing ownership and
       * permission of the volume before being mounted.
       * Refer to the specific FSGroupPolicy values for additional details.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * Defaults to ReadWriteOnceWithFSType, which will examine each volume
       * to determine if Kubernetes should modify ownership and permissions of the volume.
       * With the default policy the defined fsGroup will only be applied
       * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
       *
       * +optional
       * </pre>
       *
       * <code>optional string fsGroupPolicy = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearFsGroupPolicy() {
        fsGroupPolicy_ = getDefaultInstance().getFsGroupPolicy();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fsGroupPolicy defines if the underlying volume supports changing ownership and
       * permission of the volume before being mounted.
       * Refer to the specific FSGroupPolicy values for additional details.
       *
       * This field was immutable in Kubernetes &lt; 1.29 and now is mutable.
       *
       * Defaults to ReadWriteOnceWithFSType, which will examine each volume
       * to determine if Kubernetes should modify ownership and permissions of the volume.
       * With the default policy the defined fsGroup will only be applied
       * if a fstype is defined and the volume's access mode contains ReadWriteOnce.
       *
       * +optional
       * </pre>
       *
       * <code>optional string fsGroupPolicy = 5;</code>
       * @param value The bytes for fsGroupPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFsGroupPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fsGroupPolicy_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1Storage.TokenRequest> tokenRequests_ =
        java.util.Collections.emptyList();
      private void ensureTokenRequestsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          tokenRequests_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Storage.TokenRequest>(tokenRequests_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.TokenRequest, io.kubernetes.client.proto.V1Storage.TokenRequest.Builder, io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder> tokenRequestsBuilder_;

      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.TokenRequest> getTokenRequestsList() {
        if (tokenRequestsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(tokenRequests_);
        } else {
          return tokenRequestsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public int getTokenRequestsCount() {
        if (tokenRequestsBuilder_ == null) {
          return tokenRequests_.size();
        } else {
          return tokenRequestsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public io.kubernetes.client.proto.V1Storage.TokenRequest getTokenRequests(int index) {
        if (tokenRequestsBuilder_ == null) {
          return tokenRequests_.get(index);
        } else {
          return tokenRequestsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public Builder setTokenRequests(
          int index, io.kubernetes.client.proto.V1Storage.TokenRequest value) {
        if (tokenRequestsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTokenRequestsIsMutable();
          tokenRequests_.set(index, value);
          onChanged();
        } else {
          tokenRequestsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public Builder setTokenRequests(
          int index, io.kubernetes.client.proto.V1Storage.TokenRequest.Builder builderForValue) {
        if (tokenRequestsBuilder_ == null) {
          ensureTokenRequestsIsMutable();
          tokenRequests_.set(index, builderForValue.build());
          onChanged();
        } else {
          tokenRequestsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public Builder addTokenRequests(io.kubernetes.client.proto.V1Storage.TokenRequest value) {
        if (tokenRequestsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTokenRequestsIsMutable();
          tokenRequests_.add(value);
          onChanged();
        } else {
          tokenRequestsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public Builder addTokenRequests(
          int index, io.kubernetes.client.proto.V1Storage.TokenRequest value) {
        if (tokenRequestsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTokenRequestsIsMutable();
          tokenRequests_.add(index, value);
          onChanged();
        } else {
          tokenRequestsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public Builder addTokenRequests(
          io.kubernetes.client.proto.V1Storage.TokenRequest.Builder builderForValue) {
        if (tokenRequestsBuilder_ == null) {
          ensureTokenRequestsIsMutable();
          tokenRequests_.add(builderForValue.build());
          onChanged();
        } else {
          tokenRequestsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public Builder addTokenRequests(
          int index, io.kubernetes.client.proto.V1Storage.TokenRequest.Builder builderForValue) {
        if (tokenRequestsBuilder_ == null) {
          ensureTokenRequestsIsMutable();
          tokenRequests_.add(index, builderForValue.build());
          onChanged();
        } else {
          tokenRequestsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public Builder addAllTokenRequests(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Storage.TokenRequest> values) {
        if (tokenRequestsBuilder_ == null) {
          ensureTokenRequestsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, tokenRequests_);
          onChanged();
        } else {
          tokenRequestsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public Builder clearTokenRequests() {
        if (tokenRequestsBuilder_ == null) {
          tokenRequests_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          tokenRequestsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public Builder removeTokenRequests(int index) {
        if (tokenRequestsBuilder_ == null) {
          ensureTokenRequestsIsMutable();
          tokenRequests_.remove(index);
          onChanged();
        } else {
          tokenRequestsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public io.kubernetes.client.proto.V1Storage.TokenRequest.Builder getTokenRequestsBuilder(
          int index) {
        return getTokenRequestsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder getTokenRequestsOrBuilder(
          int index) {
        if (tokenRequestsBuilder_ == null) {
          return tokenRequests_.get(index);  } else {
          return tokenRequestsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder> 
           getTokenRequestsOrBuilderList() {
        if (tokenRequestsBuilder_ != null) {
          return tokenRequestsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(tokenRequests_);
        }
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public io.kubernetes.client.proto.V1Storage.TokenRequest.Builder addTokenRequestsBuilder() {
        return getTokenRequestsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Storage.TokenRequest.getDefaultInstance());
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public io.kubernetes.client.proto.V1Storage.TokenRequest.Builder addTokenRequestsBuilder(
          int index) {
        return getTokenRequestsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Storage.TokenRequest.getDefaultInstance());
      }
      /**
       * <pre>
       * tokenRequests indicates the CSI driver needs pods' service account
       * tokens it is mounting volume for to do necessary authentication. Kubelet
       * will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
       * The CSI driver should parse and validate the following VolumeContext:
       * "csi.storage.k8s.io/serviceAccount.tokens": {
       * "&lt;audience&gt;": {
       * "token": &lt;token&gt;,
       * "expirationTimestamp": &lt;expiration timestamp in RFC3339&gt;,
       * },
       * ...
       * }
       *
       * Note: Audience in each TokenRequest should be different and at
       * most one token is empty string. To receive a new token after expiry,
       * RequiresRepublish can be used to trigger NodePublishVolume periodically.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.TokenRequest tokenRequests = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.TokenRequest.Builder> 
           getTokenRequestsBuilderList() {
        return getTokenRequestsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.TokenRequest, io.kubernetes.client.proto.V1Storage.TokenRequest.Builder, io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder> 
          getTokenRequestsFieldBuilder() {
        if (tokenRequestsBuilder_ == null) {
          tokenRequestsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Storage.TokenRequest, io.kubernetes.client.proto.V1Storage.TokenRequest.Builder, io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder>(
                  tokenRequests_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          tokenRequests_ = null;
        }
        return tokenRequestsBuilder_;
      }

      private boolean requiresRepublish_ ;
      /**
       * <pre>
       * requiresRepublish indicates the CSI driver wants `NodePublishVolume`
       * being periodically called to reflect any possible change in the mounted
       * volume. This field defaults to false.
       *
       * Note: After a successful initial NodePublishVolume call, subsequent calls
       * to NodePublishVolume should only update the contents of the volume. New
       * mount points will not be seen by a running container.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool requiresRepublish = 7;</code>
       * @return Whether the requiresRepublish field is set.
       */
      @java.lang.Override
      public boolean hasRequiresRepublish() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * requiresRepublish indicates the CSI driver wants `NodePublishVolume`
       * being periodically called to reflect any possible change in the mounted
       * volume. This field defaults to false.
       *
       * Note: After a successful initial NodePublishVolume call, subsequent calls
       * to NodePublishVolume should only update the contents of the volume. New
       * mount points will not be seen by a running container.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool requiresRepublish = 7;</code>
       * @return The requiresRepublish.
       */
      @java.lang.Override
      public boolean getRequiresRepublish() {
        return requiresRepublish_;
      }
      /**
       * <pre>
       * requiresRepublish indicates the CSI driver wants `NodePublishVolume`
       * being periodically called to reflect any possible change in the mounted
       * volume. This field defaults to false.
       *
       * Note: After a successful initial NodePublishVolume call, subsequent calls
       * to NodePublishVolume should only update the contents of the volume. New
       * mount points will not be seen by a running container.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool requiresRepublish = 7;</code>
       * @param value The requiresRepublish to set.
       * @return This builder for chaining.
       */
      public Builder setRequiresRepublish(boolean value) {

        requiresRepublish_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * requiresRepublish indicates the CSI driver wants `NodePublishVolume`
       * being periodically called to reflect any possible change in the mounted
       * volume. This field defaults to false.
       *
       * Note: After a successful initial NodePublishVolume call, subsequent calls
       * to NodePublishVolume should only update the contents of the volume. New
       * mount points will not be seen by a running container.
       *
       * +optional
       * </pre>
       *
       * <code>optional bool requiresRepublish = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearRequiresRepublish() {
        bitField0_ = (bitField0_ & ~0x00000040);
        requiresRepublish_ = false;
        onChanged();
        return this;
      }

      private boolean seLinuxMount_ ;
      /**
       * <pre>
       * seLinuxMount specifies if the CSI driver supports "-o context"
       * mount option.
       *
       * When "true", the CSI driver must ensure that all volumes provided by this CSI
       * driver can be mounted separately with different `-o context` options. This is
       * typical for storage backends that provide volumes as filesystems on block
       * devices or as independent shared volumes.
       * Kubernetes will call NodeStage / NodePublish with "-o context=xyz" mount
       * option when mounting a ReadWriteOncePod volume used in Pod that has
       * explicitly set SELinux context. In the future, it may be expanded to other
       * volume AccessModes. In any case, Kubernetes will ensure that the volume is
       * mounted only with a single SELinux context.
       *
       * When "false", Kubernetes won't pass any special SELinux mount options to the driver.
       * This is typical for volumes that represent subdirectories of a bigger shared filesystem.
       *
       * Default is "false".
       *
       * +featureGate=SELinuxMountReadWriteOncePod
       * +optional
       * </pre>
       *
       * <code>optional bool seLinuxMount = 8;</code>
       * @return Whether the seLinuxMount field is set.
       */
      @java.lang.Override
      public boolean hasSeLinuxMount() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * seLinuxMount specifies if the CSI driver supports "-o context"
       * mount option.
       *
       * When "true", the CSI driver must ensure that all volumes provided by this CSI
       * driver can be mounted separately with different `-o context` options. This is
       * typical for storage backends that provide volumes as filesystems on block
       * devices or as independent shared volumes.
       * Kubernetes will call NodeStage / NodePublish with "-o context=xyz" mount
       * option when mounting a ReadWriteOncePod volume used in Pod that has
       * explicitly set SELinux context. In the future, it may be expanded to other
       * volume AccessModes. In any case, Kubernetes will ensure that the volume is
       * mounted only with a single SELinux context.
       *
       * When "false", Kubernetes won't pass any special SELinux mount options to the driver.
       * This is typical for volumes that represent subdirectories of a bigger shared filesystem.
       *
       * Default is "false".
       *
       * +featureGate=SELinuxMountReadWriteOncePod
       * +optional
       * </pre>
       *
       * <code>optional bool seLinuxMount = 8;</code>
       * @return The seLinuxMount.
       */
      @java.lang.Override
      public boolean getSeLinuxMount() {
        return seLinuxMount_;
      }
      /**
       * <pre>
       * seLinuxMount specifies if the CSI driver supports "-o context"
       * mount option.
       *
       * When "true", the CSI driver must ensure that all volumes provided by this CSI
       * driver can be mounted separately with different `-o context` options. This is
       * typical for storage backends that provide volumes as filesystems on block
       * devices or as independent shared volumes.
       * Kubernetes will call NodeStage / NodePublish with "-o context=xyz" mount
       * option when mounting a ReadWriteOncePod volume used in Pod that has
       * explicitly set SELinux context. In the future, it may be expanded to other
       * volume AccessModes. In any case, Kubernetes will ensure that the volume is
       * mounted only with a single SELinux context.
       *
       * When "false", Kubernetes won't pass any special SELinux mount options to the driver.
       * This is typical for volumes that represent subdirectories of a bigger shared filesystem.
       *
       * Default is "false".
       *
       * +featureGate=SELinuxMountReadWriteOncePod
       * +optional
       * </pre>
       *
       * <code>optional bool seLinuxMount = 8;</code>
       * @param value The seLinuxMount to set.
       * @return This builder for chaining.
       */
      public Builder setSeLinuxMount(boolean value) {

        seLinuxMount_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * seLinuxMount specifies if the CSI driver supports "-o context"
       * mount option.
       *
       * When "true", the CSI driver must ensure that all volumes provided by this CSI
       * driver can be mounted separately with different `-o context` options. This is
       * typical for storage backends that provide volumes as filesystems on block
       * devices or as independent shared volumes.
       * Kubernetes will call NodeStage / NodePublish with "-o context=xyz" mount
       * option when mounting a ReadWriteOncePod volume used in Pod that has
       * explicitly set SELinux context. In the future, it may be expanded to other
       * volume AccessModes. In any case, Kubernetes will ensure that the volume is
       * mounted only with a single SELinux context.
       *
       * When "false", Kubernetes won't pass any special SELinux mount options to the driver.
       * This is typical for volumes that represent subdirectories of a bigger shared filesystem.
       *
       * Default is "false".
       *
       * +featureGate=SELinuxMountReadWriteOncePod
       * +optional
       * </pre>
       *
       * <code>optional bool seLinuxMount = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSeLinuxMount() {
        bitField0_ = (bitField0_ & ~0x00000080);
        seLinuxMount_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.CSIDriverSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.CSIDriverSpec)
    private static final io.kubernetes.client.proto.V1Storage.CSIDriverSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.CSIDriverSpec();
    }

    public static io.kubernetes.client.proto.V1Storage.CSIDriverSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CSIDriverSpec>
        PARSER = new com.google.protobuf.AbstractParser<CSIDriverSpec>() {
      @java.lang.Override
      public CSIDriverSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CSIDriverSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CSIDriverSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIDriverSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CSINodeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.CSINode)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * metadata.name must be the Kubernetes node name.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * metadata.name must be the Kubernetes node name.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * metadata.name must be the Kubernetes node name.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * spec is the specification of CSINode
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    boolean hasSpec();
    /**
     * <pre>
     * spec is the specification of CSINode
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
     * @return The spec.
     */
    io.kubernetes.client.proto.V1Storage.CSINodeSpec getSpec();
    /**
     * <pre>
     * spec is the specification of CSINode
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSINodeSpecOrBuilder getSpecOrBuilder();
  }
  /**
   * <pre>
   * CSINode holds information about all CSI drivers installed on a node.
   * CSI drivers do not need to create the CSINode object directly. As long as
   * they use the node-driver-registrar sidecar container, the kubelet will
   * automatically populate the CSINode object for the CSI driver as part of
   * kubelet plugin registration.
   * CSINode has the same name as a node. If the object is missing, it means either
   * there are no CSI Drivers available on the node, or the Kubelet version is low
   * enough that it doesn't create this object.
   * CSINode has an OwnerReference that points to the corresponding node object.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.CSINode}
   */
  public static final class CSINode extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.CSINode)
      CSINodeOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CSINode.class.getName());
    }
    // Use CSINode.newBuilder() to construct.
    private CSINode(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CSINode() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINode_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINode_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.CSINode.class, io.kubernetes.client.proto.V1Storage.CSINode.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * metadata.name must be the Kubernetes node name.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * metadata.name must be the Kubernetes node name.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * metadata.name must be the Kubernetes node name.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Storage.CSINodeSpec spec_;
    /**
     * <pre>
     * spec is the specification of CSINode
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    @java.lang.Override
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * spec is the specification of CSINode
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
     * @return The spec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINodeSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Storage.CSINodeSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * spec is the specification of CSINode
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINodeSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Storage.CSINodeSpec.getDefaultInstance() : spec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSpec());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.CSINode)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.CSINode other = (io.kubernetes.client.proto.V1Storage.CSINode) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasSpec() != other.hasSpec()) return false;
      if (hasSpec()) {
        if (!getSpec()
            .equals(other.getSpec())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.CSINode parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.CSINode parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINode parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.CSINode prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CSINode holds information about all CSI drivers installed on a node.
     * CSI drivers do not need to create the CSINode object directly. As long as
     * they use the node-driver-registrar sidecar container, the kubelet will
     * automatically populate the CSINode object for the CSI driver as part of
     * kubelet plugin registration.
     * CSINode has the same name as a node. If the object is missing, it means either
     * there are no CSI Drivers available on the node, or the Kubelet version is low
     * enough that it doesn't create this object.
     * CSINode has an OwnerReference that points to the corresponding node object.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.CSINode}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.CSINode)
        io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINode_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINode_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.CSINode.class, io.kubernetes.client.proto.V1Storage.CSINode.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.CSINode.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINode_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINode getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.CSINode.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINode build() {
        io.kubernetes.client.proto.V1Storage.CSINode result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINode buildPartial() {
        io.kubernetes.client.proto.V1Storage.CSINode result = new io.kubernetes.client.proto.V1Storage.CSINode(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.CSINode result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.spec_ = specBuilder_ == null
              ? spec_
              : specBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.CSINode) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.CSINode)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.CSINode other) {
        if (other == io.kubernetes.client.proto.V1Storage.CSINode.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * metadata.name must be the Kubernetes node name.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * metadata.name must be the Kubernetes node name.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * metadata.name must be the Kubernetes node name.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * metadata.name must be the Kubernetes node name.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * metadata.name must be the Kubernetes node name.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * metadata.name must be the Kubernetes node name.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * metadata.name must be the Kubernetes node name.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * metadata.name must be the Kubernetes node name.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * metadata.name must be the Kubernetes node name.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Storage.CSINodeSpec spec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSINodeSpec, io.kubernetes.client.proto.V1Storage.CSINodeSpec.Builder, io.kubernetes.client.proto.V1Storage.CSINodeSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * spec is the specification of CSINode
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
       * @return Whether the spec field is set.
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * spec is the specification of CSINode
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
       * @return The spec.
       */
      public io.kubernetes.client.proto.V1Storage.CSINodeSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Storage.CSINodeSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * spec is the specification of CSINode
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Storage.CSINodeSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * spec is the specification of CSINode
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Storage.CSINodeSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * spec is the specification of CSINode
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Storage.CSINodeSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            spec_ != null &&
            spec_ != io.kubernetes.client.proto.V1Storage.CSINodeSpec.getDefaultInstance()) {
            getSpecBuilder().mergeFrom(value);
          } else {
            spec_ = value;
          }
        } else {
          specBuilder_.mergeFrom(value);
        }
        if (spec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * spec is the specification of CSINode
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * spec is the specification of CSINode
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINodeSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * spec is the specification of CSINode
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINodeSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Storage.CSINodeSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * spec is the specification of CSINode
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.CSINodeSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSINodeSpec, io.kubernetes.client.proto.V1Storage.CSINodeSpec.Builder, io.kubernetes.client.proto.V1Storage.CSINodeSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Storage.CSINodeSpec, io.kubernetes.client.proto.V1Storage.CSINodeSpec.Builder, io.kubernetes.client.proto.V1Storage.CSINodeSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.CSINode)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.CSINode)
    private static final io.kubernetes.client.proto.V1Storage.CSINode DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.CSINode();
    }

    public static io.kubernetes.client.proto.V1Storage.CSINode getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CSINode>
        PARSER = new com.google.protobuf.AbstractParser<CSINode>() {
      @java.lang.Override
      public CSINode parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CSINode> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CSINode> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINode getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CSINodeDriverOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.CSINodeDriver)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * name represents the name of the CSI driver that this object refers to.
     * This MUST be the same name returned by the CSI GetPluginName() call for
     * that driver.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * name represents the name of the CSI driver that this object refers to.
     * This MUST be the same name returned by the CSI GetPluginName() call for
     * that driver.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * name represents the name of the CSI driver that this object refers to.
     * This MUST be the same name returned by the CSI GetPluginName() call for
     * that driver.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * nodeID of the node from the driver point of view.
     * This field enables Kubernetes to communicate with storage systems that do
     * not share the same nomenclature for nodes. For example, Kubernetes may
     * refer to a given node as "node1", but the storage system may refer to
     * the same node as "nodeA". When Kubernetes issues a command to the storage
     * system to attach a volume to a specific node, it can use this field to
     * refer to the node name using the ID that the storage system will
     * understand, e.g. "nodeA" instead of "node1". This field is required.
     * </pre>
     *
     * <code>optional string nodeID = 2;</code>
     * @return Whether the nodeID field is set.
     */
    boolean hasNodeID();
    /**
     * <pre>
     * nodeID of the node from the driver point of view.
     * This field enables Kubernetes to communicate with storage systems that do
     * not share the same nomenclature for nodes. For example, Kubernetes may
     * refer to a given node as "node1", but the storage system may refer to
     * the same node as "nodeA". When Kubernetes issues a command to the storage
     * system to attach a volume to a specific node, it can use this field to
     * refer to the node name using the ID that the storage system will
     * understand, e.g. "nodeA" instead of "node1". This field is required.
     * </pre>
     *
     * <code>optional string nodeID = 2;</code>
     * @return The nodeID.
     */
    java.lang.String getNodeID();
    /**
     * <pre>
     * nodeID of the node from the driver point of view.
     * This field enables Kubernetes to communicate with storage systems that do
     * not share the same nomenclature for nodes. For example, Kubernetes may
     * refer to a given node as "node1", but the storage system may refer to
     * the same node as "nodeA". When Kubernetes issues a command to the storage
     * system to attach a volume to a specific node, it can use this field to
     * refer to the node name using the ID that the storage system will
     * understand, e.g. "nodeA" instead of "node1". This field is required.
     * </pre>
     *
     * <code>optional string nodeID = 2;</code>
     * @return The bytes for nodeID.
     */
    com.google.protobuf.ByteString
        getNodeIDBytes();

    /**
     * <pre>
     * topologyKeys is the list of keys supported by the driver.
     * When a driver is initialized on a cluster, it provides a set of topology
     * keys that it understands (e.g. "company.com/zone", "company.com/region").
     * When a driver is initialized on a node, it provides the same topology keys
     * along with values. Kubelet will expose these topology keys as labels
     * on its own node object.
     * When Kubernetes does topology aware provisioning, it can use this list to
     * determine which labels it should retrieve from the node object and pass
     * back to the driver.
     * It is possible for different nodes to use different topology keys.
     * This can be empty if driver does not support topology.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string topologyKeys = 3;</code>
     * @return A list containing the topologyKeys.
     */
    java.util.List<java.lang.String>
        getTopologyKeysList();
    /**
     * <pre>
     * topologyKeys is the list of keys supported by the driver.
     * When a driver is initialized on a cluster, it provides a set of topology
     * keys that it understands (e.g. "company.com/zone", "company.com/region").
     * When a driver is initialized on a node, it provides the same topology keys
     * along with values. Kubelet will expose these topology keys as labels
     * on its own node object.
     * When Kubernetes does topology aware provisioning, it can use this list to
     * determine which labels it should retrieve from the node object and pass
     * back to the driver.
     * It is possible for different nodes to use different topology keys.
     * This can be empty if driver does not support topology.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string topologyKeys = 3;</code>
     * @return The count of topologyKeys.
     */
    int getTopologyKeysCount();
    /**
     * <pre>
     * topologyKeys is the list of keys supported by the driver.
     * When a driver is initialized on a cluster, it provides a set of topology
     * keys that it understands (e.g. "company.com/zone", "company.com/region").
     * When a driver is initialized on a node, it provides the same topology keys
     * along with values. Kubelet will expose these topology keys as labels
     * on its own node object.
     * When Kubernetes does topology aware provisioning, it can use this list to
     * determine which labels it should retrieve from the node object and pass
     * back to the driver.
     * It is possible for different nodes to use different topology keys.
     * This can be empty if driver does not support topology.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string topologyKeys = 3;</code>
     * @param index The index of the element to return.
     * @return The topologyKeys at the given index.
     */
    java.lang.String getTopologyKeys(int index);
    /**
     * <pre>
     * topologyKeys is the list of keys supported by the driver.
     * When a driver is initialized on a cluster, it provides a set of topology
     * keys that it understands (e.g. "company.com/zone", "company.com/region").
     * When a driver is initialized on a node, it provides the same topology keys
     * along with values. Kubelet will expose these topology keys as labels
     * on its own node object.
     * When Kubernetes does topology aware provisioning, it can use this list to
     * determine which labels it should retrieve from the node object and pass
     * back to the driver.
     * It is possible for different nodes to use different topology keys.
     * This can be empty if driver does not support topology.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string topologyKeys = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the topologyKeys at the given index.
     */
    com.google.protobuf.ByteString
        getTopologyKeysBytes(int index);

    /**
     * <pre>
     * allocatable represents the volume resources of a node that are available for scheduling.
     * This field is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
     * @return Whether the allocatable field is set.
     */
    boolean hasAllocatable();
    /**
     * <pre>
     * allocatable represents the volume resources of a node that are available for scheduling.
     * This field is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
     * @return The allocatable.
     */
    io.kubernetes.client.proto.V1Storage.VolumeNodeResources getAllocatable();
    /**
     * <pre>
     * allocatable represents the volume resources of a node that are available for scheduling.
     * This field is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
     */
    io.kubernetes.client.proto.V1Storage.VolumeNodeResourcesOrBuilder getAllocatableOrBuilder();
  }
  /**
   * <pre>
   * CSINodeDriver holds information about the specification of one CSI driver installed on a node
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.CSINodeDriver}
   */
  public static final class CSINodeDriver extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.CSINodeDriver)
      CSINodeDriverOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CSINodeDriver.class.getName());
    }
    // Use CSINodeDriver.newBuilder() to construct.
    private CSINodeDriver(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CSINodeDriver() {
      name_ = "";
      nodeID_ = "";
      topologyKeys_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeDriver_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeDriver_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.CSINodeDriver.class, io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * name represents the name of the CSI driver that this object refers to.
     * This MUST be the same name returned by the CSI GetPluginName() call for
     * that driver.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * name represents the name of the CSI driver that this object refers to.
     * This MUST be the same name returned by the CSI GetPluginName() call for
     * that driver.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * name represents the name of the CSI driver that this object refers to.
     * This MUST be the same name returned by the CSI GetPluginName() call for
     * that driver.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NODEID_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object nodeID_ = "";
    /**
     * <pre>
     * nodeID of the node from the driver point of view.
     * This field enables Kubernetes to communicate with storage systems that do
     * not share the same nomenclature for nodes. For example, Kubernetes may
     * refer to a given node as "node1", but the storage system may refer to
     * the same node as "nodeA". When Kubernetes issues a command to the storage
     * system to attach a volume to a specific node, it can use this field to
     * refer to the node name using the ID that the storage system will
     * understand, e.g. "nodeA" instead of "node1". This field is required.
     * </pre>
     *
     * <code>optional string nodeID = 2;</code>
     * @return Whether the nodeID field is set.
     */
    @java.lang.Override
    public boolean hasNodeID() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * nodeID of the node from the driver point of view.
     * This field enables Kubernetes to communicate with storage systems that do
     * not share the same nomenclature for nodes. For example, Kubernetes may
     * refer to a given node as "node1", but the storage system may refer to
     * the same node as "nodeA". When Kubernetes issues a command to the storage
     * system to attach a volume to a specific node, it can use this field to
     * refer to the node name using the ID that the storage system will
     * understand, e.g. "nodeA" instead of "node1". This field is required.
     * </pre>
     *
     * <code>optional string nodeID = 2;</code>
     * @return The nodeID.
     */
    @java.lang.Override
    public java.lang.String getNodeID() {
      java.lang.Object ref = nodeID_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          nodeID_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * nodeID of the node from the driver point of view.
     * This field enables Kubernetes to communicate with storage systems that do
     * not share the same nomenclature for nodes. For example, Kubernetes may
     * refer to a given node as "node1", but the storage system may refer to
     * the same node as "nodeA". When Kubernetes issues a command to the storage
     * system to attach a volume to a specific node, it can use this field to
     * refer to the node name using the ID that the storage system will
     * understand, e.g. "nodeA" instead of "node1". This field is required.
     * </pre>
     *
     * <code>optional string nodeID = 2;</code>
     * @return The bytes for nodeID.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNodeIDBytes() {
      java.lang.Object ref = nodeID_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeID_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TOPOLOGYKEYS_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList topologyKeys_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * topologyKeys is the list of keys supported by the driver.
     * When a driver is initialized on a cluster, it provides a set of topology
     * keys that it understands (e.g. "company.com/zone", "company.com/region").
     * When a driver is initialized on a node, it provides the same topology keys
     * along with values. Kubelet will expose these topology keys as labels
     * on its own node object.
     * When Kubernetes does topology aware provisioning, it can use this list to
     * determine which labels it should retrieve from the node object and pass
     * back to the driver.
     * It is possible for different nodes to use different topology keys.
     * This can be empty if driver does not support topology.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string topologyKeys = 3;</code>
     * @return A list containing the topologyKeys.
     */
    public com.google.protobuf.ProtocolStringList
        getTopologyKeysList() {
      return topologyKeys_;
    }
    /**
     * <pre>
     * topologyKeys is the list of keys supported by the driver.
     * When a driver is initialized on a cluster, it provides a set of topology
     * keys that it understands (e.g. "company.com/zone", "company.com/region").
     * When a driver is initialized on a node, it provides the same topology keys
     * along with values. Kubelet will expose these topology keys as labels
     * on its own node object.
     * When Kubernetes does topology aware provisioning, it can use this list to
     * determine which labels it should retrieve from the node object and pass
     * back to the driver.
     * It is possible for different nodes to use different topology keys.
     * This can be empty if driver does not support topology.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string topologyKeys = 3;</code>
     * @return The count of topologyKeys.
     */
    public int getTopologyKeysCount() {
      return topologyKeys_.size();
    }
    /**
     * <pre>
     * topologyKeys is the list of keys supported by the driver.
     * When a driver is initialized on a cluster, it provides a set of topology
     * keys that it understands (e.g. "company.com/zone", "company.com/region").
     * When a driver is initialized on a node, it provides the same topology keys
     * along with values. Kubelet will expose these topology keys as labels
     * on its own node object.
     * When Kubernetes does topology aware provisioning, it can use this list to
     * determine which labels it should retrieve from the node object and pass
     * back to the driver.
     * It is possible for different nodes to use different topology keys.
     * This can be empty if driver does not support topology.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string topologyKeys = 3;</code>
     * @param index The index of the element to return.
     * @return The topologyKeys at the given index.
     */
    public java.lang.String getTopologyKeys(int index) {
      return topologyKeys_.get(index);
    }
    /**
     * <pre>
     * topologyKeys is the list of keys supported by the driver.
     * When a driver is initialized on a cluster, it provides a set of topology
     * keys that it understands (e.g. "company.com/zone", "company.com/region").
     * When a driver is initialized on a node, it provides the same topology keys
     * along with values. Kubelet will expose these topology keys as labels
     * on its own node object.
     * When Kubernetes does topology aware provisioning, it can use this list to
     * determine which labels it should retrieve from the node object and pass
     * back to the driver.
     * It is possible for different nodes to use different topology keys.
     * This can be empty if driver does not support topology.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string topologyKeys = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the topologyKeys at the given index.
     */
    public com.google.protobuf.ByteString
        getTopologyKeysBytes(int index) {
      return topologyKeys_.getByteString(index);
    }

    public static final int ALLOCATABLE_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.V1Storage.VolumeNodeResources allocatable_;
    /**
     * <pre>
     * allocatable represents the volume resources of a node that are available for scheduling.
     * This field is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
     * @return Whether the allocatable field is set.
     */
    @java.lang.Override
    public boolean hasAllocatable() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * allocatable represents the volume resources of a node that are available for scheduling.
     * This field is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
     * @return The allocatable.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeNodeResources getAllocatable() {
      return allocatable_ == null ? io.kubernetes.client.proto.V1Storage.VolumeNodeResources.getDefaultInstance() : allocatable_;
    }
    /**
     * <pre>
     * allocatable represents the volume resources of a node that are available for scheduling.
     * This field is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeNodeResourcesOrBuilder getAllocatableOrBuilder() {
      return allocatable_ == null ? io.kubernetes.client.proto.V1Storage.VolumeNodeResources.getDefaultInstance() : allocatable_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, nodeID_);
      }
      for (int i = 0; i < topologyKeys_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, topologyKeys_.getRaw(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(4, getAllocatable());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, nodeID_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < topologyKeys_.size(); i++) {
          dataSize += computeStringSizeNoTag(topologyKeys_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getTopologyKeysList().size();
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getAllocatable());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.CSINodeDriver)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.CSINodeDriver other = (io.kubernetes.client.proto.V1Storage.CSINodeDriver) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasNodeID() != other.hasNodeID()) return false;
      if (hasNodeID()) {
        if (!getNodeID()
            .equals(other.getNodeID())) return false;
      }
      if (!getTopologyKeysList()
          .equals(other.getTopologyKeysList())) return false;
      if (hasAllocatable() != other.hasAllocatable()) return false;
      if (hasAllocatable()) {
        if (!getAllocatable()
            .equals(other.getAllocatable())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasNodeID()) {
        hash = (37 * hash) + NODEID_FIELD_NUMBER;
        hash = (53 * hash) + getNodeID().hashCode();
      }
      if (getTopologyKeysCount() > 0) {
        hash = (37 * hash) + TOPOLOGYKEYS_FIELD_NUMBER;
        hash = (53 * hash) + getTopologyKeysList().hashCode();
      }
      if (hasAllocatable()) {
        hash = (37 * hash) + ALLOCATABLE_FIELD_NUMBER;
        hash = (53 * hash) + getAllocatable().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.CSINodeDriver prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CSINodeDriver holds information about the specification of one CSI driver installed on a node
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.CSINodeDriver}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.CSINodeDriver)
        io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeDriver_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeDriver_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.CSINodeDriver.class, io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.CSINodeDriver.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getAllocatableFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        nodeID_ = "";
        topologyKeys_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        allocatable_ = null;
        if (allocatableBuilder_ != null) {
          allocatableBuilder_.dispose();
          allocatableBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeDriver_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINodeDriver getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.CSINodeDriver.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINodeDriver build() {
        io.kubernetes.client.proto.V1Storage.CSINodeDriver result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINodeDriver buildPartial() {
        io.kubernetes.client.proto.V1Storage.CSINodeDriver result = new io.kubernetes.client.proto.V1Storage.CSINodeDriver(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.CSINodeDriver result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.nodeID_ = nodeID_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          topologyKeys_.makeImmutable();
          result.topologyKeys_ = topologyKeys_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.allocatable_ = allocatableBuilder_ == null
              ? allocatable_
              : allocatableBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.CSINodeDriver) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.CSINodeDriver)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.CSINodeDriver other) {
        if (other == io.kubernetes.client.proto.V1Storage.CSINodeDriver.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasNodeID()) {
          nodeID_ = other.nodeID_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (!other.topologyKeys_.isEmpty()) {
          if (topologyKeys_.isEmpty()) {
            topologyKeys_ = other.topologyKeys_;
            bitField0_ |= 0x00000004;
          } else {
            ensureTopologyKeysIsMutable();
            topologyKeys_.addAll(other.topologyKeys_);
          }
          onChanged();
        }
        if (other.hasAllocatable()) {
          mergeAllocatable(other.getAllocatable());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                nodeID_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureTopologyKeysIsMutable();
                topologyKeys_.add(bs);
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getAllocatableFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * name represents the name of the CSI driver that this object refers to.
       * This MUST be the same name returned by the CSI GetPluginName() call for
       * that driver.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * name represents the name of the CSI driver that this object refers to.
       * This MUST be the same name returned by the CSI GetPluginName() call for
       * that driver.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * name represents the name of the CSI driver that this object refers to.
       * This MUST be the same name returned by the CSI GetPluginName() call for
       * that driver.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * name represents the name of the CSI driver that this object refers to.
       * This MUST be the same name returned by the CSI GetPluginName() call for
       * that driver.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name represents the name of the CSI driver that this object refers to.
       * This MUST be the same name returned by the CSI GetPluginName() call for
       * that driver.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name represents the name of the CSI driver that this object refers to.
       * This MUST be the same name returned by the CSI GetPluginName() call for
       * that driver.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object nodeID_ = "";
      /**
       * <pre>
       * nodeID of the node from the driver point of view.
       * This field enables Kubernetes to communicate with storage systems that do
       * not share the same nomenclature for nodes. For example, Kubernetes may
       * refer to a given node as "node1", but the storage system may refer to
       * the same node as "nodeA". When Kubernetes issues a command to the storage
       * system to attach a volume to a specific node, it can use this field to
       * refer to the node name using the ID that the storage system will
       * understand, e.g. "nodeA" instead of "node1". This field is required.
       * </pre>
       *
       * <code>optional string nodeID = 2;</code>
       * @return Whether the nodeID field is set.
       */
      public boolean hasNodeID() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * nodeID of the node from the driver point of view.
       * This field enables Kubernetes to communicate with storage systems that do
       * not share the same nomenclature for nodes. For example, Kubernetes may
       * refer to a given node as "node1", but the storage system may refer to
       * the same node as "nodeA". When Kubernetes issues a command to the storage
       * system to attach a volume to a specific node, it can use this field to
       * refer to the node name using the ID that the storage system will
       * understand, e.g. "nodeA" instead of "node1". This field is required.
       * </pre>
       *
       * <code>optional string nodeID = 2;</code>
       * @return The nodeID.
       */
      public java.lang.String getNodeID() {
        java.lang.Object ref = nodeID_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            nodeID_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * nodeID of the node from the driver point of view.
       * This field enables Kubernetes to communicate with storage systems that do
       * not share the same nomenclature for nodes. For example, Kubernetes may
       * refer to a given node as "node1", but the storage system may refer to
       * the same node as "nodeA". When Kubernetes issues a command to the storage
       * system to attach a volume to a specific node, it can use this field to
       * refer to the node name using the ID that the storage system will
       * understand, e.g. "nodeA" instead of "node1". This field is required.
       * </pre>
       *
       * <code>optional string nodeID = 2;</code>
       * @return The bytes for nodeID.
       */
      public com.google.protobuf.ByteString
          getNodeIDBytes() {
        java.lang.Object ref = nodeID_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeID_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * nodeID of the node from the driver point of view.
       * This field enables Kubernetes to communicate with storage systems that do
       * not share the same nomenclature for nodes. For example, Kubernetes may
       * refer to a given node as "node1", but the storage system may refer to
       * the same node as "nodeA". When Kubernetes issues a command to the storage
       * system to attach a volume to a specific node, it can use this field to
       * refer to the node name using the ID that the storage system will
       * understand, e.g. "nodeA" instead of "node1". This field is required.
       * </pre>
       *
       * <code>optional string nodeID = 2;</code>
       * @param value The nodeID to set.
       * @return This builder for chaining.
       */
      public Builder setNodeID(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        nodeID_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * nodeID of the node from the driver point of view.
       * This field enables Kubernetes to communicate with storage systems that do
       * not share the same nomenclature for nodes. For example, Kubernetes may
       * refer to a given node as "node1", but the storage system may refer to
       * the same node as "nodeA". When Kubernetes issues a command to the storage
       * system to attach a volume to a specific node, it can use this field to
       * refer to the node name using the ID that the storage system will
       * understand, e.g. "nodeA" instead of "node1". This field is required.
       * </pre>
       *
       * <code>optional string nodeID = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNodeID() {
        nodeID_ = getDefaultInstance().getNodeID();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * nodeID of the node from the driver point of view.
       * This field enables Kubernetes to communicate with storage systems that do
       * not share the same nomenclature for nodes. For example, Kubernetes may
       * refer to a given node as "node1", but the storage system may refer to
       * the same node as "nodeA". When Kubernetes issues a command to the storage
       * system to attach a volume to a specific node, it can use this field to
       * refer to the node name using the ID that the storage system will
       * understand, e.g. "nodeA" instead of "node1". This field is required.
       * </pre>
       *
       * <code>optional string nodeID = 2;</code>
       * @param value The bytes for nodeID to set.
       * @return This builder for chaining.
       */
      public Builder setNodeIDBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        nodeID_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList topologyKeys_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureTopologyKeysIsMutable() {
        if (!topologyKeys_.isModifiable()) {
          topologyKeys_ = new com.google.protobuf.LazyStringArrayList(topologyKeys_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <pre>
       * topologyKeys is the list of keys supported by the driver.
       * When a driver is initialized on a cluster, it provides a set of topology
       * keys that it understands (e.g. "company.com/zone", "company.com/region").
       * When a driver is initialized on a node, it provides the same topology keys
       * along with values. Kubelet will expose these topology keys as labels
       * on its own node object.
       * When Kubernetes does topology aware provisioning, it can use this list to
       * determine which labels it should retrieve from the node object and pass
       * back to the driver.
       * It is possible for different nodes to use different topology keys.
       * This can be empty if driver does not support topology.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string topologyKeys = 3;</code>
       * @return A list containing the topologyKeys.
       */
      public com.google.protobuf.ProtocolStringList
          getTopologyKeysList() {
        topologyKeys_.makeImmutable();
        return topologyKeys_;
      }
      /**
       * <pre>
       * topologyKeys is the list of keys supported by the driver.
       * When a driver is initialized on a cluster, it provides a set of topology
       * keys that it understands (e.g. "company.com/zone", "company.com/region").
       * When a driver is initialized on a node, it provides the same topology keys
       * along with values. Kubelet will expose these topology keys as labels
       * on its own node object.
       * When Kubernetes does topology aware provisioning, it can use this list to
       * determine which labels it should retrieve from the node object and pass
       * back to the driver.
       * It is possible for different nodes to use different topology keys.
       * This can be empty if driver does not support topology.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string topologyKeys = 3;</code>
       * @return The count of topologyKeys.
       */
      public int getTopologyKeysCount() {
        return topologyKeys_.size();
      }
      /**
       * <pre>
       * topologyKeys is the list of keys supported by the driver.
       * When a driver is initialized on a cluster, it provides a set of topology
       * keys that it understands (e.g. "company.com/zone", "company.com/region").
       * When a driver is initialized on a node, it provides the same topology keys
       * along with values. Kubelet will expose these topology keys as labels
       * on its own node object.
       * When Kubernetes does topology aware provisioning, it can use this list to
       * determine which labels it should retrieve from the node object and pass
       * back to the driver.
       * It is possible for different nodes to use different topology keys.
       * This can be empty if driver does not support topology.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string topologyKeys = 3;</code>
       * @param index The index of the element to return.
       * @return The topologyKeys at the given index.
       */
      public java.lang.String getTopologyKeys(int index) {
        return topologyKeys_.get(index);
      }
      /**
       * <pre>
       * topologyKeys is the list of keys supported by the driver.
       * When a driver is initialized on a cluster, it provides a set of topology
       * keys that it understands (e.g. "company.com/zone", "company.com/region").
       * When a driver is initialized on a node, it provides the same topology keys
       * along with values. Kubelet will expose these topology keys as labels
       * on its own node object.
       * When Kubernetes does topology aware provisioning, it can use this list to
       * determine which labels it should retrieve from the node object and pass
       * back to the driver.
       * It is possible for different nodes to use different topology keys.
       * This can be empty if driver does not support topology.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string topologyKeys = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the topologyKeys at the given index.
       */
      public com.google.protobuf.ByteString
          getTopologyKeysBytes(int index) {
        return topologyKeys_.getByteString(index);
      }
      /**
       * <pre>
       * topologyKeys is the list of keys supported by the driver.
       * When a driver is initialized on a cluster, it provides a set of topology
       * keys that it understands (e.g. "company.com/zone", "company.com/region").
       * When a driver is initialized on a node, it provides the same topology keys
       * along with values. Kubelet will expose these topology keys as labels
       * on its own node object.
       * When Kubernetes does topology aware provisioning, it can use this list to
       * determine which labels it should retrieve from the node object and pass
       * back to the driver.
       * It is possible for different nodes to use different topology keys.
       * This can be empty if driver does not support topology.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string topologyKeys = 3;</code>
       * @param index The index to set the value at.
       * @param value The topologyKeys to set.
       * @return This builder for chaining.
       */
      public Builder setTopologyKeys(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureTopologyKeysIsMutable();
        topologyKeys_.set(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * topologyKeys is the list of keys supported by the driver.
       * When a driver is initialized on a cluster, it provides a set of topology
       * keys that it understands (e.g. "company.com/zone", "company.com/region").
       * When a driver is initialized on a node, it provides the same topology keys
       * along with values. Kubelet will expose these topology keys as labels
       * on its own node object.
       * When Kubernetes does topology aware provisioning, it can use this list to
       * determine which labels it should retrieve from the node object and pass
       * back to the driver.
       * It is possible for different nodes to use different topology keys.
       * This can be empty if driver does not support topology.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string topologyKeys = 3;</code>
       * @param value The topologyKeys to add.
       * @return This builder for chaining.
       */
      public Builder addTopologyKeys(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureTopologyKeysIsMutable();
        topologyKeys_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * topologyKeys is the list of keys supported by the driver.
       * When a driver is initialized on a cluster, it provides a set of topology
       * keys that it understands (e.g. "company.com/zone", "company.com/region").
       * When a driver is initialized on a node, it provides the same topology keys
       * along with values. Kubelet will expose these topology keys as labels
       * on its own node object.
       * When Kubernetes does topology aware provisioning, it can use this list to
       * determine which labels it should retrieve from the node object and pass
       * back to the driver.
       * It is possible for different nodes to use different topology keys.
       * This can be empty if driver does not support topology.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string topologyKeys = 3;</code>
       * @param values The topologyKeys to add.
       * @return This builder for chaining.
       */
      public Builder addAllTopologyKeys(
          java.lang.Iterable<java.lang.String> values) {
        ensureTopologyKeysIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, topologyKeys_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * topologyKeys is the list of keys supported by the driver.
       * When a driver is initialized on a cluster, it provides a set of topology
       * keys that it understands (e.g. "company.com/zone", "company.com/region").
       * When a driver is initialized on a node, it provides the same topology keys
       * along with values. Kubelet will expose these topology keys as labels
       * on its own node object.
       * When Kubernetes does topology aware provisioning, it can use this list to
       * determine which labels it should retrieve from the node object and pass
       * back to the driver.
       * It is possible for different nodes to use different topology keys.
       * This can be empty if driver does not support topology.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string topologyKeys = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTopologyKeys() {
        topologyKeys_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * topologyKeys is the list of keys supported by the driver.
       * When a driver is initialized on a cluster, it provides a set of topology
       * keys that it understands (e.g. "company.com/zone", "company.com/region").
       * When a driver is initialized on a node, it provides the same topology keys
       * along with values. Kubelet will expose these topology keys as labels
       * on its own node object.
       * When Kubernetes does topology aware provisioning, it can use this list to
       * determine which labels it should retrieve from the node object and pass
       * back to the driver.
       * It is possible for different nodes to use different topology keys.
       * This can be empty if driver does not support topology.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string topologyKeys = 3;</code>
       * @param value The bytes of the topologyKeys to add.
       * @return This builder for chaining.
       */
      public Builder addTopologyKeysBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureTopologyKeysIsMutable();
        topologyKeys_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Storage.VolumeNodeResources allocatable_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeNodeResources, io.kubernetes.client.proto.V1Storage.VolumeNodeResources.Builder, io.kubernetes.client.proto.V1Storage.VolumeNodeResourcesOrBuilder> allocatableBuilder_;
      /**
       * <pre>
       * allocatable represents the volume resources of a node that are available for scheduling.
       * This field is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
       * @return Whether the allocatable field is set.
       */
      public boolean hasAllocatable() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * allocatable represents the volume resources of a node that are available for scheduling.
       * This field is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
       * @return The allocatable.
       */
      public io.kubernetes.client.proto.V1Storage.VolumeNodeResources getAllocatable() {
        if (allocatableBuilder_ == null) {
          return allocatable_ == null ? io.kubernetes.client.proto.V1Storage.VolumeNodeResources.getDefaultInstance() : allocatable_;
        } else {
          return allocatableBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * allocatable represents the volume resources of a node that are available for scheduling.
       * This field is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
       */
      public Builder setAllocatable(io.kubernetes.client.proto.V1Storage.VolumeNodeResources value) {
        if (allocatableBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          allocatable_ = value;
        } else {
          allocatableBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * allocatable represents the volume resources of a node that are available for scheduling.
       * This field is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
       */
      public Builder setAllocatable(
          io.kubernetes.client.proto.V1Storage.VolumeNodeResources.Builder builderForValue) {
        if (allocatableBuilder_ == null) {
          allocatable_ = builderForValue.build();
        } else {
          allocatableBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * allocatable represents the volume resources of a node that are available for scheduling.
       * This field is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
       */
      public Builder mergeAllocatable(io.kubernetes.client.proto.V1Storage.VolumeNodeResources value) {
        if (allocatableBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            allocatable_ != null &&
            allocatable_ != io.kubernetes.client.proto.V1Storage.VolumeNodeResources.getDefaultInstance()) {
            getAllocatableBuilder().mergeFrom(value);
          } else {
            allocatable_ = value;
          }
        } else {
          allocatableBuilder_.mergeFrom(value);
        }
        if (allocatable_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * allocatable represents the volume resources of a node that are available for scheduling.
       * This field is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
       */
      public Builder clearAllocatable() {
        bitField0_ = (bitField0_ & ~0x00000008);
        allocatable_ = null;
        if (allocatableBuilder_ != null) {
          allocatableBuilder_.dispose();
          allocatableBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * allocatable represents the volume resources of a node that are available for scheduling.
       * This field is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeNodeResources.Builder getAllocatableBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getAllocatableFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * allocatable represents the volume resources of a node that are available for scheduling.
       * This field is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeNodeResourcesOrBuilder getAllocatableOrBuilder() {
        if (allocatableBuilder_ != null) {
          return allocatableBuilder_.getMessageOrBuilder();
        } else {
          return allocatable_ == null ?
              io.kubernetes.client.proto.V1Storage.VolumeNodeResources.getDefaultInstance() : allocatable_;
        }
      }
      /**
       * <pre>
       * allocatable represents the volume resources of a node that are available for scheduling.
       * This field is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeNodeResources allocatable = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeNodeResources, io.kubernetes.client.proto.V1Storage.VolumeNodeResources.Builder, io.kubernetes.client.proto.V1Storage.VolumeNodeResourcesOrBuilder> 
          getAllocatableFieldBuilder() {
        if (allocatableBuilder_ == null) {
          allocatableBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Storage.VolumeNodeResources, io.kubernetes.client.proto.V1Storage.VolumeNodeResources.Builder, io.kubernetes.client.proto.V1Storage.VolumeNodeResourcesOrBuilder>(
                  getAllocatable(),
                  getParentForChildren(),
                  isClean());
          allocatable_ = null;
        }
        return allocatableBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.CSINodeDriver)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.CSINodeDriver)
    private static final io.kubernetes.client.proto.V1Storage.CSINodeDriver DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.CSINodeDriver();
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeDriver getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CSINodeDriver>
        PARSER = new com.google.protobuf.AbstractParser<CSINodeDriver>() {
      @java.lang.Override
      public CSINodeDriver parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CSINodeDriver> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CSINodeDriver> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINodeDriver getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CSINodeListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.CSINodeList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Storage.CSINode> 
        getItemsList();
    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSINode getItems(int index);
    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * CSINodeList is a collection of CSINode objects.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.CSINodeList}
   */
  public static final class CSINodeList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.CSINodeList)
      CSINodeListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CSINodeList.class.getName());
    }
    // Use CSINodeList.newBuilder() to construct.
    private CSINodeList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CSINodeList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.CSINodeList.class, io.kubernetes.client.proto.V1Storage.CSINodeList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Storage.CSINode> items_;
    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Storage.CSINode> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINode getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * items is the list of CSINode
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.CSINodeList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.CSINodeList other = (io.kubernetes.client.proto.V1Storage.CSINodeList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.CSINodeList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CSINodeList is a collection of CSINode objects.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.CSINodeList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.CSINodeList)
        io.kubernetes.client.proto.V1Storage.CSINodeListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.CSINodeList.class, io.kubernetes.client.proto.V1Storage.CSINodeList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.CSINodeList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINodeList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.CSINodeList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINodeList build() {
        io.kubernetes.client.proto.V1Storage.CSINodeList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINodeList buildPartial() {
        io.kubernetes.client.proto.V1Storage.CSINodeList result = new io.kubernetes.client.proto.V1Storage.CSINodeList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Storage.CSINodeList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.CSINodeList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.CSINodeList) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.CSINodeList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.CSINodeList other) {
        if (other == io.kubernetes.client.proto.V1Storage.CSINodeList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Storage.CSINode m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Storage.CSINode.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Storage.CSINode> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Storage.CSINode>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSINode, io.kubernetes.client.proto.V1Storage.CSINode.Builder, io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.CSINode> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINode getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.CSINode value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.CSINode.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Storage.CSINode value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.CSINode value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Storage.CSINode.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.CSINode.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Storage.CSINode> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINode.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINode.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Storage.CSINode.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINode.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Storage.CSINode.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of CSINode
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINode items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.CSINode.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSINode, io.kubernetes.client.proto.V1Storage.CSINode.Builder, io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Storage.CSINode, io.kubernetes.client.proto.V1Storage.CSINode.Builder, io.kubernetes.client.proto.V1Storage.CSINodeOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.CSINodeList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.CSINodeList)
    private static final io.kubernetes.client.proto.V1Storage.CSINodeList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.CSINodeList();
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CSINodeList>
        PARSER = new com.google.protobuf.AbstractParser<CSINodeList>() {
      @java.lang.Override
      public CSINodeList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CSINodeList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CSINodeList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINodeList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CSINodeSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.CSINodeSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Storage.CSINodeDriver> 
        getDriversList();
    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSINodeDriver getDrivers(int index);
    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    int getDriversCount();
    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder> 
        getDriversOrBuilderList();
    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder getDriversOrBuilder(
        int index);
  }
  /**
   * <pre>
   * CSINodeSpec holds information about the specification of all CSI drivers installed on a node
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.CSINodeSpec}
   */
  public static final class CSINodeSpec extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.CSINodeSpec)
      CSINodeSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CSINodeSpec.class.getName());
    }
    // Use CSINodeSpec.newBuilder() to construct.
    private CSINodeSpec(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CSINodeSpec() {
      drivers_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.CSINodeSpec.class, io.kubernetes.client.proto.V1Storage.CSINodeSpec.Builder.class);
    }

    public static final int DRIVERS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Storage.CSINodeDriver> drivers_;
    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Storage.CSINodeDriver> getDriversList() {
      return drivers_;
    }
    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder> 
        getDriversOrBuilderList() {
      return drivers_;
    }
    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    @java.lang.Override
    public int getDriversCount() {
      return drivers_.size();
    }
    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINodeDriver getDrivers(int index) {
      return drivers_.get(index);
    }
    /**
     * <pre>
     * drivers is a list of information of all CSI Drivers existing on a node.
     * If all drivers in the list are uninstalled, this can become empty.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder getDriversOrBuilder(
        int index) {
      return drivers_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < drivers_.size(); i++) {
        output.writeMessage(1, drivers_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < drivers_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, drivers_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.CSINodeSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.CSINodeSpec other = (io.kubernetes.client.proto.V1Storage.CSINodeSpec) obj;

      if (!getDriversList()
          .equals(other.getDriversList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getDriversCount() > 0) {
        hash = (37 * hash) + DRIVERS_FIELD_NUMBER;
        hash = (53 * hash) + getDriversList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.CSINodeSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CSINodeSpec holds information about the specification of all CSI drivers installed on a node
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.CSINodeSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.CSINodeSpec)
        io.kubernetes.client.proto.V1Storage.CSINodeSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.CSINodeSpec.class, io.kubernetes.client.proto.V1Storage.CSINodeSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.CSINodeSpec.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (driversBuilder_ == null) {
          drivers_ = java.util.Collections.emptyList();
        } else {
          drivers_ = null;
          driversBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSINodeSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINodeSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.CSINodeSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINodeSpec build() {
        io.kubernetes.client.proto.V1Storage.CSINodeSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSINodeSpec buildPartial() {
        io.kubernetes.client.proto.V1Storage.CSINodeSpec result = new io.kubernetes.client.proto.V1Storage.CSINodeSpec(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Storage.CSINodeSpec result) {
        if (driversBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            drivers_ = java.util.Collections.unmodifiableList(drivers_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.drivers_ = drivers_;
        } else {
          result.drivers_ = driversBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.CSINodeSpec result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.CSINodeSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.CSINodeSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.CSINodeSpec other) {
        if (other == io.kubernetes.client.proto.V1Storage.CSINodeSpec.getDefaultInstance()) return this;
        if (driversBuilder_ == null) {
          if (!other.drivers_.isEmpty()) {
            if (drivers_.isEmpty()) {
              drivers_ = other.drivers_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureDriversIsMutable();
              drivers_.addAll(other.drivers_);
            }
            onChanged();
          }
        } else {
          if (!other.drivers_.isEmpty()) {
            if (driversBuilder_.isEmpty()) {
              driversBuilder_.dispose();
              driversBuilder_ = null;
              drivers_ = other.drivers_;
              bitField0_ = (bitField0_ & ~0x00000001);
              driversBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getDriversFieldBuilder() : null;
            } else {
              driversBuilder_.addAllMessages(other.drivers_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                io.kubernetes.client.proto.V1Storage.CSINodeDriver m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Storage.CSINodeDriver.parser(),
                        extensionRegistry);
                if (driversBuilder_ == null) {
                  ensureDriversIsMutable();
                  drivers_.add(m);
                } else {
                  driversBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1Storage.CSINodeDriver> drivers_ =
        java.util.Collections.emptyList();
      private void ensureDriversIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          drivers_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Storage.CSINodeDriver>(drivers_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSINodeDriver, io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder, io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder> driversBuilder_;

      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.CSINodeDriver> getDriversList() {
        if (driversBuilder_ == null) {
          return java.util.Collections.unmodifiableList(drivers_);
        } else {
          return driversBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public int getDriversCount() {
        if (driversBuilder_ == null) {
          return drivers_.size();
        } else {
          return driversBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINodeDriver getDrivers(int index) {
        if (driversBuilder_ == null) {
          return drivers_.get(index);
        } else {
          return driversBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public Builder setDrivers(
          int index, io.kubernetes.client.proto.V1Storage.CSINodeDriver value) {
        if (driversBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDriversIsMutable();
          drivers_.set(index, value);
          onChanged();
        } else {
          driversBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public Builder setDrivers(
          int index, io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder builderForValue) {
        if (driversBuilder_ == null) {
          ensureDriversIsMutable();
          drivers_.set(index, builderForValue.build());
          onChanged();
        } else {
          driversBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public Builder addDrivers(io.kubernetes.client.proto.V1Storage.CSINodeDriver value) {
        if (driversBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDriversIsMutable();
          drivers_.add(value);
          onChanged();
        } else {
          driversBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public Builder addDrivers(
          int index, io.kubernetes.client.proto.V1Storage.CSINodeDriver value) {
        if (driversBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDriversIsMutable();
          drivers_.add(index, value);
          onChanged();
        } else {
          driversBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public Builder addDrivers(
          io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder builderForValue) {
        if (driversBuilder_ == null) {
          ensureDriversIsMutable();
          drivers_.add(builderForValue.build());
          onChanged();
        } else {
          driversBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public Builder addDrivers(
          int index, io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder builderForValue) {
        if (driversBuilder_ == null) {
          ensureDriversIsMutable();
          drivers_.add(index, builderForValue.build());
          onChanged();
        } else {
          driversBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public Builder addAllDrivers(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Storage.CSINodeDriver> values) {
        if (driversBuilder_ == null) {
          ensureDriversIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, drivers_);
          onChanged();
        } else {
          driversBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public Builder clearDrivers() {
        if (driversBuilder_ == null) {
          drivers_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          driversBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public Builder removeDrivers(int index) {
        if (driversBuilder_ == null) {
          ensureDriversIsMutable();
          drivers_.remove(index);
          onChanged();
        } else {
          driversBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder getDriversBuilder(
          int index) {
        return getDriversFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder getDriversOrBuilder(
          int index) {
        if (driversBuilder_ == null) {
          return drivers_.get(index);  } else {
          return driversBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder> 
           getDriversOrBuilderList() {
        if (driversBuilder_ != null) {
          return driversBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(drivers_);
        }
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder addDriversBuilder() {
        return getDriversFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Storage.CSINodeDriver.getDefaultInstance());
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder addDriversBuilder(
          int index) {
        return getDriversFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Storage.CSINodeDriver.getDefaultInstance());
      }
      /**
       * <pre>
       * drivers is a list of information of all CSI Drivers existing on a node.
       * If all drivers in the list are uninstalled, this can become empty.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSINodeDriver drivers = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder> 
           getDriversBuilderList() {
        return getDriversFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSINodeDriver, io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder, io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder> 
          getDriversFieldBuilder() {
        if (driversBuilder_ == null) {
          driversBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Storage.CSINodeDriver, io.kubernetes.client.proto.V1Storage.CSINodeDriver.Builder, io.kubernetes.client.proto.V1Storage.CSINodeDriverOrBuilder>(
                  drivers_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          drivers_ = null;
        }
        return driversBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.CSINodeSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.CSINodeSpec)
    private static final io.kubernetes.client.proto.V1Storage.CSINodeSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.CSINodeSpec();
    }

    public static io.kubernetes.client.proto.V1Storage.CSINodeSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CSINodeSpec>
        PARSER = new com.google.protobuf.AbstractParser<CSINodeSpec>() {
      @java.lang.Override
      public CSINodeSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CSINodeSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CSINodeSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSINodeSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CSIStorageCapacityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.CSIStorageCapacity)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
     * To ensure that there are no conflicts with other CSI drivers on the cluster,
     * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
     * which ends with the unique CSI driver name.
     *
     * Objects are namespaced.
     *
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
     * To ensure that there are no conflicts with other CSI drivers on the cluster,
     * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
     * which ends with the unique CSI driver name.
     *
     * Objects are namespaced.
     *
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
     * To ensure that there are no conflicts with other CSI drivers on the cluster,
     * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
     * which ends with the unique CSI driver name.
     *
     * Objects are namespaced.
     *
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * nodeTopology defines which nodes have access to the storage
     * for which capacity was reported. If not set, the storage is
     * not accessible from any node in the cluster. If empty, the
     * storage is accessible from all nodes. This field is
     * immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
     * @return Whether the nodeTopology field is set.
     */
    boolean hasNodeTopology();
    /**
     * <pre>
     * nodeTopology defines which nodes have access to the storage
     * for which capacity was reported. If not set, the storage is
     * not accessible from any node in the cluster. If empty, the
     * storage is accessible from all nodes. This field is
     * immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
     * @return The nodeTopology.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNodeTopology();
    /**
     * <pre>
     * nodeTopology defines which nodes have access to the storage
     * for which capacity was reported. If not set, the storage is
     * not accessible from any node in the cluster. If empty, the
     * storage is accessible from all nodes. This field is
     * immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNodeTopologyOrBuilder();

    /**
     * <pre>
     * storageClassName represents the name of the StorageClass that the reported capacity applies to.
     * It must meet the same requirements as the name of a StorageClass
     * object (non-empty, DNS subdomain). If that object no longer exists,
     * the CSIStorageCapacity object is obsolete and should be removed by its
     * creator.
     * This field is immutable.
     * </pre>
     *
     * <code>optional string storageClassName = 3;</code>
     * @return Whether the storageClassName field is set.
     */
    boolean hasStorageClassName();
    /**
     * <pre>
     * storageClassName represents the name of the StorageClass that the reported capacity applies to.
     * It must meet the same requirements as the name of a StorageClass
     * object (non-empty, DNS subdomain). If that object no longer exists,
     * the CSIStorageCapacity object is obsolete and should be removed by its
     * creator.
     * This field is immutable.
     * </pre>
     *
     * <code>optional string storageClassName = 3;</code>
     * @return The storageClassName.
     */
    java.lang.String getStorageClassName();
    /**
     * <pre>
     * storageClassName represents the name of the StorageClass that the reported capacity applies to.
     * It must meet the same requirements as the name of a StorageClass
     * object (non-empty, DNS subdomain). If that object no longer exists,
     * the CSIStorageCapacity object is obsolete and should be removed by its
     * creator.
     * This field is immutable.
     * </pre>
     *
     * <code>optional string storageClassName = 3;</code>
     * @return The bytes for storageClassName.
     */
    com.google.protobuf.ByteString
        getStorageClassNameBytes();

    /**
     * <pre>
     * capacity is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * The semantic is currently (CSI spec 1.2) defined as:
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If not set, that information is currently
     * unavailable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
     * @return Whether the capacity field is set.
     */
    boolean hasCapacity();
    /**
     * <pre>
     * capacity is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * The semantic is currently (CSI spec 1.2) defined as:
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If not set, that information is currently
     * unavailable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
     * @return The capacity.
     */
    io.kubernetes.client.proto.Resource.Quantity getCapacity();
    /**
     * <pre>
     * capacity is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * The semantic is currently (CSI spec 1.2) defined as:
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If not set, that information is currently
     * unavailable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
     */
    io.kubernetes.client.proto.Resource.QuantityOrBuilder getCapacityOrBuilder();

    /**
     * <pre>
     * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * This is defined since CSI spec 1.4.0 as the largest size
     * that may be used in a
     * CreateVolumeRequest.capacity_range.required_bytes field to
     * create a volume with the same parameters as those in
     * GetCapacityRequest. The corresponding value in the Kubernetes
     * API is ResourceRequirements.Requests in a volume claim.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
     * @return Whether the maximumVolumeSize field is set.
     */
    boolean hasMaximumVolumeSize();
    /**
     * <pre>
     * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * This is defined since CSI spec 1.4.0 as the largest size
     * that may be used in a
     * CreateVolumeRequest.capacity_range.required_bytes field to
     * create a volume with the same parameters as those in
     * GetCapacityRequest. The corresponding value in the Kubernetes
     * API is ResourceRequirements.Requests in a volume claim.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
     * @return The maximumVolumeSize.
     */
    io.kubernetes.client.proto.Resource.Quantity getMaximumVolumeSize();
    /**
     * <pre>
     * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * This is defined since CSI spec 1.4.0 as the largest size
     * that may be used in a
     * CreateVolumeRequest.capacity_range.required_bytes field to
     * create a volume with the same parameters as those in
     * GetCapacityRequest. The corresponding value in the Kubernetes
     * API is ResourceRequirements.Requests in a volume claim.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
     */
    io.kubernetes.client.proto.Resource.QuantityOrBuilder getMaximumVolumeSizeOrBuilder();
  }
  /**
   * <pre>
   * CSIStorageCapacity stores the result of one CSI GetCapacity call.
   * For a given StorageClass, this describes the available capacity in a
   * particular topology segment.  This can be used when considering where to
   * instantiate new PersistentVolumes.
   *
   * For example this can express things like:
   * - StorageClass "standard" has "1234 GiB" available in "topology.kubernetes.io/zone=us-east1"
   * - StorageClass "localssd" has "10 GiB" available in "kubernetes.io/hostname=knode-abc123"
   *
   * The following three cases all imply that no capacity is available for
   * a certain combination:
   * - no object exists with suitable topology and storage class name
   * - such an object exists, but the capacity is unset
   * - such an object exists, but the capacity is zero
   *
   * The producer of these objects can decide which approach is more suitable.
   *
   * They are consumed by the kube-scheduler when a CSI driver opts into
   * capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler
   * compares the MaximumVolumeSize against the requested size of pending volumes
   * to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back
   * to a comparison against the less precise Capacity. If that is also unset,
   * the scheduler assumes that capacity is insufficient and tries some other
   * node.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.CSIStorageCapacity}
   */
  public static final class CSIStorageCapacity extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.CSIStorageCapacity)
      CSIStorageCapacityOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CSIStorageCapacity.class.getName());
    }
    // Use CSIStorageCapacity.newBuilder() to construct.
    private CSIStorageCapacity(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CSIStorageCapacity() {
      storageClassName_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.class, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
     * To ensure that there are no conflicts with other CSI drivers on the cluster,
     * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
     * which ends with the unique CSI driver name.
     *
     * Objects are namespaced.
     *
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
     * To ensure that there are no conflicts with other CSI drivers on the cluster,
     * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
     * which ends with the unique CSI driver name.
     *
     * Objects are namespaced.
     *
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
     * To ensure that there are no conflicts with other CSI drivers on the cluster,
     * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
     * which ends with the unique CSI driver name.
     *
     * Objects are namespaced.
     *
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int NODETOPOLOGY_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector nodeTopology_;
    /**
     * <pre>
     * nodeTopology defines which nodes have access to the storage
     * for which capacity was reported. If not set, the storage is
     * not accessible from any node in the cluster. If empty, the
     * storage is accessible from all nodes. This field is
     * immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
     * @return Whether the nodeTopology field is set.
     */
    @java.lang.Override
    public boolean hasNodeTopology() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * nodeTopology defines which nodes have access to the storage
     * for which capacity was reported. If not set, the storage is
     * not accessible from any node in the cluster. If empty, the
     * storage is accessible from all nodes. This field is
     * immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
     * @return The nodeTopology.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getNodeTopology() {
      return nodeTopology_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : nodeTopology_;
    }
    /**
     * <pre>
     * nodeTopology defines which nodes have access to the storage
     * for which capacity was reported. If not set, the storage is
     * not accessible from any node in the cluster. If empty, the
     * storage is accessible from all nodes. This field is
     * immutable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNodeTopologyOrBuilder() {
      return nodeTopology_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : nodeTopology_;
    }

    public static final int STORAGECLASSNAME_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object storageClassName_ = "";
    /**
     * <pre>
     * storageClassName represents the name of the StorageClass that the reported capacity applies to.
     * It must meet the same requirements as the name of a StorageClass
     * object (non-empty, DNS subdomain). If that object no longer exists,
     * the CSIStorageCapacity object is obsolete and should be removed by its
     * creator.
     * This field is immutable.
     * </pre>
     *
     * <code>optional string storageClassName = 3;</code>
     * @return Whether the storageClassName field is set.
     */
    @java.lang.Override
    public boolean hasStorageClassName() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * storageClassName represents the name of the StorageClass that the reported capacity applies to.
     * It must meet the same requirements as the name of a StorageClass
     * object (non-empty, DNS subdomain). If that object no longer exists,
     * the CSIStorageCapacity object is obsolete and should be removed by its
     * creator.
     * This field is immutable.
     * </pre>
     *
     * <code>optional string storageClassName = 3;</code>
     * @return The storageClassName.
     */
    @java.lang.Override
    public java.lang.String getStorageClassName() {
      java.lang.Object ref = storageClassName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          storageClassName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * storageClassName represents the name of the StorageClass that the reported capacity applies to.
     * It must meet the same requirements as the name of a StorageClass
     * object (non-empty, DNS subdomain). If that object no longer exists,
     * the CSIStorageCapacity object is obsolete and should be removed by its
     * creator.
     * This field is immutable.
     * </pre>
     *
     * <code>optional string storageClassName = 3;</code>
     * @return The bytes for storageClassName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStorageClassNameBytes() {
      java.lang.Object ref = storageClassName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        storageClassName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CAPACITY_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.Resource.Quantity capacity_;
    /**
     * <pre>
     * capacity is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * The semantic is currently (CSI spec 1.2) defined as:
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If not set, that information is currently
     * unavailable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
     * @return Whether the capacity field is set.
     */
    @java.lang.Override
    public boolean hasCapacity() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * capacity is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * The semantic is currently (CSI spec 1.2) defined as:
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If not set, that information is currently
     * unavailable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
     * @return The capacity.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Resource.Quantity getCapacity() {
      return capacity_ == null ? io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance() : capacity_;
    }
    /**
     * <pre>
     * capacity is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * The semantic is currently (CSI spec 1.2) defined as:
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If not set, that information is currently
     * unavailable.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Resource.QuantityOrBuilder getCapacityOrBuilder() {
      return capacity_ == null ? io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance() : capacity_;
    }

    public static final int MAXIMUMVOLUMESIZE_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.Resource.Quantity maximumVolumeSize_;
    /**
     * <pre>
     * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * This is defined since CSI spec 1.4.0 as the largest size
     * that may be used in a
     * CreateVolumeRequest.capacity_range.required_bytes field to
     * create a volume with the same parameters as those in
     * GetCapacityRequest. The corresponding value in the Kubernetes
     * API is ResourceRequirements.Requests in a volume claim.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
     * @return Whether the maximumVolumeSize field is set.
     */
    @java.lang.Override
    public boolean hasMaximumVolumeSize() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * This is defined since CSI spec 1.4.0 as the largest size
     * that may be used in a
     * CreateVolumeRequest.capacity_range.required_bytes field to
     * create a volume with the same parameters as those in
     * GetCapacityRequest. The corresponding value in the Kubernetes
     * API is ResourceRequirements.Requests in a volume claim.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
     * @return The maximumVolumeSize.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Resource.Quantity getMaximumVolumeSize() {
      return maximumVolumeSize_ == null ? io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance() : maximumVolumeSize_;
    }
    /**
     * <pre>
     * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
     * for a GetCapacityRequest with topology and parameters that match the
     * previous fields.
     *
     * This is defined since CSI spec 1.4.0 as the largest size
     * that may be used in a
     * CreateVolumeRequest.capacity_range.required_bytes field to
     * create a volume with the same parameters as those in
     * GetCapacityRequest. The corresponding value in the Kubernetes
     * API is ResourceRequirements.Requests in a volume claim.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Resource.QuantityOrBuilder getMaximumVolumeSizeOrBuilder() {
      return maximumVolumeSize_ == null ? io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance() : maximumVolumeSize_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getNodeTopology());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, storageClassName_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getCapacity());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(5, getMaximumVolumeSize());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getNodeTopology());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, storageClassName_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getCapacity());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getMaximumVolumeSize());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.CSIStorageCapacity)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.CSIStorageCapacity other = (io.kubernetes.client.proto.V1Storage.CSIStorageCapacity) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasNodeTopology() != other.hasNodeTopology()) return false;
      if (hasNodeTopology()) {
        if (!getNodeTopology()
            .equals(other.getNodeTopology())) return false;
      }
      if (hasStorageClassName() != other.hasStorageClassName()) return false;
      if (hasStorageClassName()) {
        if (!getStorageClassName()
            .equals(other.getStorageClassName())) return false;
      }
      if (hasCapacity() != other.hasCapacity()) return false;
      if (hasCapacity()) {
        if (!getCapacity()
            .equals(other.getCapacity())) return false;
      }
      if (hasMaximumVolumeSize() != other.hasMaximumVolumeSize()) return false;
      if (hasMaximumVolumeSize()) {
        if (!getMaximumVolumeSize()
            .equals(other.getMaximumVolumeSize())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasNodeTopology()) {
        hash = (37 * hash) + NODETOPOLOGY_FIELD_NUMBER;
        hash = (53 * hash) + getNodeTopology().hashCode();
      }
      if (hasStorageClassName()) {
        hash = (37 * hash) + STORAGECLASSNAME_FIELD_NUMBER;
        hash = (53 * hash) + getStorageClassName().hashCode();
      }
      if (hasCapacity()) {
        hash = (37 * hash) + CAPACITY_FIELD_NUMBER;
        hash = (53 * hash) + getCapacity().hashCode();
      }
      if (hasMaximumVolumeSize()) {
        hash = (37 * hash) + MAXIMUMVOLUMESIZE_FIELD_NUMBER;
        hash = (53 * hash) + getMaximumVolumeSize().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.CSIStorageCapacity prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CSIStorageCapacity stores the result of one CSI GetCapacity call.
     * For a given StorageClass, this describes the available capacity in a
     * particular topology segment.  This can be used when considering where to
     * instantiate new PersistentVolumes.
     *
     * For example this can express things like:
     * - StorageClass "standard" has "1234 GiB" available in "topology.kubernetes.io/zone=us-east1"
     * - StorageClass "localssd" has "10 GiB" available in "kubernetes.io/hostname=knode-abc123"
     *
     * The following three cases all imply that no capacity is available for
     * a certain combination:
     * - no object exists with suitable topology and storage class name
     * - such an object exists, but the capacity is unset
     * - such an object exists, but the capacity is zero
     *
     * The producer of these objects can decide which approach is more suitable.
     *
     * They are consumed by the kube-scheduler when a CSI driver opts into
     * capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler
     * compares the MaximumVolumeSize against the requested size of pending volumes
     * to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back
     * to a comparison against the less precise Capacity. If that is also unset,
     * the scheduler assumes that capacity is insufficient and tries some other
     * node.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.CSIStorageCapacity}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.CSIStorageCapacity)
        io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.class, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getNodeTopologyFieldBuilder();
          getCapacityFieldBuilder();
          getMaximumVolumeSizeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        nodeTopology_ = null;
        if (nodeTopologyBuilder_ != null) {
          nodeTopologyBuilder_.dispose();
          nodeTopologyBuilder_ = null;
        }
        storageClassName_ = "";
        capacity_ = null;
        if (capacityBuilder_ != null) {
          capacityBuilder_.dispose();
          capacityBuilder_ = null;
        }
        maximumVolumeSize_ = null;
        if (maximumVolumeSizeBuilder_ != null) {
          maximumVolumeSizeBuilder_.dispose();
          maximumVolumeSizeBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacity getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacity build() {
        io.kubernetes.client.proto.V1Storage.CSIStorageCapacity result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacity buildPartial() {
        io.kubernetes.client.proto.V1Storage.CSIStorageCapacity result = new io.kubernetes.client.proto.V1Storage.CSIStorageCapacity(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.CSIStorageCapacity result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.nodeTopology_ = nodeTopologyBuilder_ == null
              ? nodeTopology_
              : nodeTopologyBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.storageClassName_ = storageClassName_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.capacity_ = capacityBuilder_ == null
              ? capacity_
              : capacityBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.maximumVolumeSize_ = maximumVolumeSizeBuilder_ == null
              ? maximumVolumeSize_
              : maximumVolumeSizeBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.CSIStorageCapacity) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.CSIStorageCapacity)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.CSIStorageCapacity other) {
        if (other == io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasNodeTopology()) {
          mergeNodeTopology(other.getNodeTopology());
        }
        if (other.hasStorageClassName()) {
          storageClassName_ = other.storageClassName_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasCapacity()) {
          mergeCapacity(other.getCapacity());
        }
        if (other.hasMaximumVolumeSize()) {
          mergeMaximumVolumeSize(other.getMaximumVolumeSize());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getNodeTopologyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                storageClassName_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getCapacityFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getMaximumVolumeSizeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
       * To ensure that there are no conflicts with other CSI drivers on the cluster,
       * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
       * which ends with the unique CSI driver name.
       *
       * Objects are namespaced.
       *
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
       * To ensure that there are no conflicts with other CSI drivers on the cluster,
       * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
       * which ends with the unique CSI driver name.
       *
       * Objects are namespaced.
       *
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
       * To ensure that there are no conflicts with other CSI drivers on the cluster,
       * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
       * which ends with the unique CSI driver name.
       *
       * Objects are namespaced.
       *
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
       * To ensure that there are no conflicts with other CSI drivers on the cluster,
       * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
       * which ends with the unique CSI driver name.
       *
       * Objects are namespaced.
       *
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
       * To ensure that there are no conflicts with other CSI drivers on the cluster,
       * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
       * which ends with the unique CSI driver name.
       *
       * Objects are namespaced.
       *
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
       * To ensure that there are no conflicts with other CSI drivers on the cluster,
       * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
       * which ends with the unique CSI driver name.
       *
       * Objects are namespaced.
       *
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
       * To ensure that there are no conflicts with other CSI drivers on the cluster,
       * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
       * which ends with the unique CSI driver name.
       *
       * Objects are namespaced.
       *
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
       * To ensure that there are no conflicts with other CSI drivers on the cluster,
       * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
       * which ends with the unique CSI driver name.
       *
       * Objects are namespaced.
       *
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * The name has no particular meaning. It must be a DNS subdomain (dots allowed, 253 characters).
       * To ensure that there are no conflicts with other CSI drivers on the cluster,
       * the recommendation is to use csisc-&lt;uuid&gt;, a generated name, or a reverse-domain name
       * which ends with the unique CSI driver name.
       *
       * Objects are namespaced.
       *
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector nodeTopology_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> nodeTopologyBuilder_;
      /**
       * <pre>
       * nodeTopology defines which nodes have access to the storage
       * for which capacity was reported. If not set, the storage is
       * not accessible from any node in the cluster. If empty, the
       * storage is accessible from all nodes. This field is
       * immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
       * @return Whether the nodeTopology field is set.
       */
      public boolean hasNodeTopology() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * nodeTopology defines which nodes have access to the storage
       * for which capacity was reported. If not set, the storage is
       * not accessible from any node in the cluster. If empty, the
       * storage is accessible from all nodes. This field is
       * immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
       * @return The nodeTopology.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNodeTopology() {
        if (nodeTopologyBuilder_ == null) {
          return nodeTopology_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : nodeTopology_;
        } else {
          return nodeTopologyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * nodeTopology defines which nodes have access to the storage
       * for which capacity was reported. If not set, the storage is
       * not accessible from any node in the cluster. If empty, the
       * storage is accessible from all nodes. This field is
       * immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
       */
      public Builder setNodeTopology(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (nodeTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          nodeTopology_ = value;
        } else {
          nodeTopologyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * nodeTopology defines which nodes have access to the storage
       * for which capacity was reported. If not set, the storage is
       * not accessible from any node in the cluster. If empty, the
       * storage is accessible from all nodes. This field is
       * immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
       */
      public Builder setNodeTopology(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (nodeTopologyBuilder_ == null) {
          nodeTopology_ = builderForValue.build();
        } else {
          nodeTopologyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * nodeTopology defines which nodes have access to the storage
       * for which capacity was reported. If not set, the storage is
       * not accessible from any node in the cluster. If empty, the
       * storage is accessible from all nodes. This field is
       * immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
       */
      public Builder mergeNodeTopology(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (nodeTopologyBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            nodeTopology_ != null &&
            nodeTopology_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getNodeTopologyBuilder().mergeFrom(value);
          } else {
            nodeTopology_ = value;
          }
        } else {
          nodeTopologyBuilder_.mergeFrom(value);
        }
        if (nodeTopology_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * nodeTopology defines which nodes have access to the storage
       * for which capacity was reported. If not set, the storage is
       * not accessible from any node in the cluster. If empty, the
       * storage is accessible from all nodes. This field is
       * immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
       */
      public Builder clearNodeTopology() {
        bitField0_ = (bitField0_ & ~0x00000002);
        nodeTopology_ = null;
        if (nodeTopologyBuilder_ != null) {
          nodeTopologyBuilder_.dispose();
          nodeTopologyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * nodeTopology defines which nodes have access to the storage
       * for which capacity was reported. If not set, the storage is
       * not accessible from any node in the cluster. If empty, the
       * storage is accessible from all nodes. This field is
       * immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNodeTopologyBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getNodeTopologyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * nodeTopology defines which nodes have access to the storage
       * for which capacity was reported. If not set, the storage is
       * not accessible from any node in the cluster. If empty, the
       * storage is accessible from all nodes. This field is
       * immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNodeTopologyOrBuilder() {
        if (nodeTopologyBuilder_ != null) {
          return nodeTopologyBuilder_.getMessageOrBuilder();
        } else {
          return nodeTopology_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : nodeTopology_;
        }
      }
      /**
       * <pre>
       * nodeTopology defines which nodes have access to the storage
       * for which capacity was reported. If not set, the storage is
       * not accessible from any node in the cluster. If empty, the
       * storage is accessible from all nodes. This field is
       * immutable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector nodeTopology = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNodeTopologyFieldBuilder() {
        if (nodeTopologyBuilder_ == null) {
          nodeTopologyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNodeTopology(),
                  getParentForChildren(),
                  isClean());
          nodeTopology_ = null;
        }
        return nodeTopologyBuilder_;
      }

      private java.lang.Object storageClassName_ = "";
      /**
       * <pre>
       * storageClassName represents the name of the StorageClass that the reported capacity applies to.
       * It must meet the same requirements as the name of a StorageClass
       * object (non-empty, DNS subdomain). If that object no longer exists,
       * the CSIStorageCapacity object is obsolete and should be removed by its
       * creator.
       * This field is immutable.
       * </pre>
       *
       * <code>optional string storageClassName = 3;</code>
       * @return Whether the storageClassName field is set.
       */
      public boolean hasStorageClassName() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * storageClassName represents the name of the StorageClass that the reported capacity applies to.
       * It must meet the same requirements as the name of a StorageClass
       * object (non-empty, DNS subdomain). If that object no longer exists,
       * the CSIStorageCapacity object is obsolete and should be removed by its
       * creator.
       * This field is immutable.
       * </pre>
       *
       * <code>optional string storageClassName = 3;</code>
       * @return The storageClassName.
       */
      public java.lang.String getStorageClassName() {
        java.lang.Object ref = storageClassName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            storageClassName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * storageClassName represents the name of the StorageClass that the reported capacity applies to.
       * It must meet the same requirements as the name of a StorageClass
       * object (non-empty, DNS subdomain). If that object no longer exists,
       * the CSIStorageCapacity object is obsolete and should be removed by its
       * creator.
       * This field is immutable.
       * </pre>
       *
       * <code>optional string storageClassName = 3;</code>
       * @return The bytes for storageClassName.
       */
      public com.google.protobuf.ByteString
          getStorageClassNameBytes() {
        java.lang.Object ref = storageClassName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          storageClassName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * storageClassName represents the name of the StorageClass that the reported capacity applies to.
       * It must meet the same requirements as the name of a StorageClass
       * object (non-empty, DNS subdomain). If that object no longer exists,
       * the CSIStorageCapacity object is obsolete and should be removed by its
       * creator.
       * This field is immutable.
       * </pre>
       *
       * <code>optional string storageClassName = 3;</code>
       * @param value The storageClassName to set.
       * @return This builder for chaining.
       */
      public Builder setStorageClassName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        storageClassName_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * storageClassName represents the name of the StorageClass that the reported capacity applies to.
       * It must meet the same requirements as the name of a StorageClass
       * object (non-empty, DNS subdomain). If that object no longer exists,
       * the CSIStorageCapacity object is obsolete and should be removed by its
       * creator.
       * This field is immutable.
       * </pre>
       *
       * <code>optional string storageClassName = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearStorageClassName() {
        storageClassName_ = getDefaultInstance().getStorageClassName();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * storageClassName represents the name of the StorageClass that the reported capacity applies to.
       * It must meet the same requirements as the name of a StorageClass
       * object (non-empty, DNS subdomain). If that object no longer exists,
       * the CSIStorageCapacity object is obsolete and should be removed by its
       * creator.
       * This field is immutable.
       * </pre>
       *
       * <code>optional string storageClassName = 3;</code>
       * @param value The bytes for storageClassName to set.
       * @return This builder for chaining.
       */
      public Builder setStorageClassNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        storageClassName_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Resource.Quantity capacity_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Resource.Quantity, io.kubernetes.client.proto.Resource.Quantity.Builder, io.kubernetes.client.proto.Resource.QuantityOrBuilder> capacityBuilder_;
      /**
       * <pre>
       * capacity is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * The semantic is currently (CSI spec 1.2) defined as:
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If not set, that information is currently
       * unavailable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
       * @return Whether the capacity field is set.
       */
      public boolean hasCapacity() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * capacity is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * The semantic is currently (CSI spec 1.2) defined as:
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If not set, that information is currently
       * unavailable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
       * @return The capacity.
       */
      public io.kubernetes.client.proto.Resource.Quantity getCapacity() {
        if (capacityBuilder_ == null) {
          return capacity_ == null ? io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance() : capacity_;
        } else {
          return capacityBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * capacity is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * The semantic is currently (CSI spec 1.2) defined as:
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If not set, that information is currently
       * unavailable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
       */
      public Builder setCapacity(io.kubernetes.client.proto.Resource.Quantity value) {
        if (capacityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          capacity_ = value;
        } else {
          capacityBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * capacity is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * The semantic is currently (CSI spec 1.2) defined as:
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If not set, that information is currently
       * unavailable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
       */
      public Builder setCapacity(
          io.kubernetes.client.proto.Resource.Quantity.Builder builderForValue) {
        if (capacityBuilder_ == null) {
          capacity_ = builderForValue.build();
        } else {
          capacityBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * capacity is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * The semantic is currently (CSI spec 1.2) defined as:
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If not set, that information is currently
       * unavailable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
       */
      public Builder mergeCapacity(io.kubernetes.client.proto.Resource.Quantity value) {
        if (capacityBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            capacity_ != null &&
            capacity_ != io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance()) {
            getCapacityBuilder().mergeFrom(value);
          } else {
            capacity_ = value;
          }
        } else {
          capacityBuilder_.mergeFrom(value);
        }
        if (capacity_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * capacity is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * The semantic is currently (CSI spec 1.2) defined as:
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If not set, that information is currently
       * unavailable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
       */
      public Builder clearCapacity() {
        bitField0_ = (bitField0_ & ~0x00000008);
        capacity_ = null;
        if (capacityBuilder_ != null) {
          capacityBuilder_.dispose();
          capacityBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * capacity is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * The semantic is currently (CSI spec 1.2) defined as:
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If not set, that information is currently
       * unavailable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
       */
      public io.kubernetes.client.proto.Resource.Quantity.Builder getCapacityBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getCapacityFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * capacity is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * The semantic is currently (CSI spec 1.2) defined as:
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If not set, that information is currently
       * unavailable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
       */
      public io.kubernetes.client.proto.Resource.QuantityOrBuilder getCapacityOrBuilder() {
        if (capacityBuilder_ != null) {
          return capacityBuilder_.getMessageOrBuilder();
        } else {
          return capacity_ == null ?
              io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance() : capacity_;
        }
      }
      /**
       * <pre>
       * capacity is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * The semantic is currently (CSI spec 1.2) defined as:
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If not set, that information is currently
       * unavailable.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Resource.Quantity, io.kubernetes.client.proto.Resource.Quantity.Builder, io.kubernetes.client.proto.Resource.QuantityOrBuilder> 
          getCapacityFieldBuilder() {
        if (capacityBuilder_ == null) {
          capacityBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Resource.Quantity, io.kubernetes.client.proto.Resource.Quantity.Builder, io.kubernetes.client.proto.Resource.QuantityOrBuilder>(
                  getCapacity(),
                  getParentForChildren(),
                  isClean());
          capacity_ = null;
        }
        return capacityBuilder_;
      }

      private io.kubernetes.client.proto.Resource.Quantity maximumVolumeSize_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Resource.Quantity, io.kubernetes.client.proto.Resource.Quantity.Builder, io.kubernetes.client.proto.Resource.QuantityOrBuilder> maximumVolumeSizeBuilder_;
      /**
       * <pre>
       * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * This is defined since CSI spec 1.4.0 as the largest size
       * that may be used in a
       * CreateVolumeRequest.capacity_range.required_bytes field to
       * create a volume with the same parameters as those in
       * GetCapacityRequest. The corresponding value in the Kubernetes
       * API is ResourceRequirements.Requests in a volume claim.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
       * @return Whether the maximumVolumeSize field is set.
       */
      public boolean hasMaximumVolumeSize() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * This is defined since CSI spec 1.4.0 as the largest size
       * that may be used in a
       * CreateVolumeRequest.capacity_range.required_bytes field to
       * create a volume with the same parameters as those in
       * GetCapacityRequest. The corresponding value in the Kubernetes
       * API is ResourceRequirements.Requests in a volume claim.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
       * @return The maximumVolumeSize.
       */
      public io.kubernetes.client.proto.Resource.Quantity getMaximumVolumeSize() {
        if (maximumVolumeSizeBuilder_ == null) {
          return maximumVolumeSize_ == null ? io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance() : maximumVolumeSize_;
        } else {
          return maximumVolumeSizeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * This is defined since CSI spec 1.4.0 as the largest size
       * that may be used in a
       * CreateVolumeRequest.capacity_range.required_bytes field to
       * create a volume with the same parameters as those in
       * GetCapacityRequest. The corresponding value in the Kubernetes
       * API is ResourceRequirements.Requests in a volume claim.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
       */
      public Builder setMaximumVolumeSize(io.kubernetes.client.proto.Resource.Quantity value) {
        if (maximumVolumeSizeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maximumVolumeSize_ = value;
        } else {
          maximumVolumeSizeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * This is defined since CSI spec 1.4.0 as the largest size
       * that may be used in a
       * CreateVolumeRequest.capacity_range.required_bytes field to
       * create a volume with the same parameters as those in
       * GetCapacityRequest. The corresponding value in the Kubernetes
       * API is ResourceRequirements.Requests in a volume claim.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
       */
      public Builder setMaximumVolumeSize(
          io.kubernetes.client.proto.Resource.Quantity.Builder builderForValue) {
        if (maximumVolumeSizeBuilder_ == null) {
          maximumVolumeSize_ = builderForValue.build();
        } else {
          maximumVolumeSizeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * This is defined since CSI spec 1.4.0 as the largest size
       * that may be used in a
       * CreateVolumeRequest.capacity_range.required_bytes field to
       * create a volume with the same parameters as those in
       * GetCapacityRequest. The corresponding value in the Kubernetes
       * API is ResourceRequirements.Requests in a volume claim.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
       */
      public Builder mergeMaximumVolumeSize(io.kubernetes.client.proto.Resource.Quantity value) {
        if (maximumVolumeSizeBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            maximumVolumeSize_ != null &&
            maximumVolumeSize_ != io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance()) {
            getMaximumVolumeSizeBuilder().mergeFrom(value);
          } else {
            maximumVolumeSize_ = value;
          }
        } else {
          maximumVolumeSizeBuilder_.mergeFrom(value);
        }
        if (maximumVolumeSize_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * This is defined since CSI spec 1.4.0 as the largest size
       * that may be used in a
       * CreateVolumeRequest.capacity_range.required_bytes field to
       * create a volume with the same parameters as those in
       * GetCapacityRequest. The corresponding value in the Kubernetes
       * API is ResourceRequirements.Requests in a volume claim.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
       */
      public Builder clearMaximumVolumeSize() {
        bitField0_ = (bitField0_ & ~0x00000010);
        maximumVolumeSize_ = null;
        if (maximumVolumeSizeBuilder_ != null) {
          maximumVolumeSizeBuilder_.dispose();
          maximumVolumeSizeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * This is defined since CSI spec 1.4.0 as the largest size
       * that may be used in a
       * CreateVolumeRequest.capacity_range.required_bytes field to
       * create a volume with the same parameters as those in
       * GetCapacityRequest. The corresponding value in the Kubernetes
       * API is ResourceRequirements.Requests in a volume claim.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
       */
      public io.kubernetes.client.proto.Resource.Quantity.Builder getMaximumVolumeSizeBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getMaximumVolumeSizeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * This is defined since CSI spec 1.4.0 as the largest size
       * that may be used in a
       * CreateVolumeRequest.capacity_range.required_bytes field to
       * create a volume with the same parameters as those in
       * GetCapacityRequest. The corresponding value in the Kubernetes
       * API is ResourceRequirements.Requests in a volume claim.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
       */
      public io.kubernetes.client.proto.Resource.QuantityOrBuilder getMaximumVolumeSizeOrBuilder() {
        if (maximumVolumeSizeBuilder_ != null) {
          return maximumVolumeSizeBuilder_.getMessageOrBuilder();
        } else {
          return maximumVolumeSize_ == null ?
              io.kubernetes.client.proto.Resource.Quantity.getDefaultInstance() : maximumVolumeSize_;
        }
      }
      /**
       * <pre>
       * maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
       * for a GetCapacityRequest with topology and parameters that match the
       * previous fields.
       *
       * This is defined since CSI spec 1.4.0 as the largest size
       * that may be used in a
       * CreateVolumeRequest.capacity_range.required_bytes field to
       * create a volume with the same parameters as those in
       * GetCapacityRequest. The corresponding value in the Kubernetes
       * API is ResourceRequirements.Requests in a volume claim.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximumVolumeSize = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Resource.Quantity, io.kubernetes.client.proto.Resource.Quantity.Builder, io.kubernetes.client.proto.Resource.QuantityOrBuilder> 
          getMaximumVolumeSizeFieldBuilder() {
        if (maximumVolumeSizeBuilder_ == null) {
          maximumVolumeSizeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Resource.Quantity, io.kubernetes.client.proto.Resource.Quantity.Builder, io.kubernetes.client.proto.Resource.QuantityOrBuilder>(
                  getMaximumVolumeSize(),
                  getParentForChildren(),
                  isClean());
          maximumVolumeSize_ = null;
        }
        return maximumVolumeSizeBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.CSIStorageCapacity)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.CSIStorageCapacity)
    private static final io.kubernetes.client.proto.V1Storage.CSIStorageCapacity DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.CSIStorageCapacity();
    }

    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacity getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CSIStorageCapacity>
        PARSER = new com.google.protobuf.AbstractParser<CSIStorageCapacity>() {
      @java.lang.Override
      public CSIStorageCapacity parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CSIStorageCapacity> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CSIStorageCapacity> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIStorageCapacity getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CSIStorageCapacityListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.CSIStorageCapacityList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Storage.CSIStorageCapacity> 
        getItemsList();
    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSIStorageCapacity getItems(int index);
    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * CSIStorageCapacityList is a collection of CSIStorageCapacity objects.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.CSIStorageCapacityList}
   */
  public static final class CSIStorageCapacityList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.CSIStorageCapacityList)
      CSIStorageCapacityListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CSIStorageCapacityList.class.getName());
    }
    // Use CSIStorageCapacityList.newBuilder() to construct.
    private CSIStorageCapacityList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CSIStorageCapacityList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList.class, io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Storage.CSIStorageCapacity> items_;
    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Storage.CSIStorageCapacity> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIStorageCapacity getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * items is the list of CSIStorageCapacity objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList other = (io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CSIStorageCapacityList is a collection of CSIStorageCapacity objects.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.CSIStorageCapacityList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.CSIStorageCapacityList)
        io.kubernetes.client.proto.V1Storage.CSIStorageCapacityListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList.class, io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList build() {
        io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList buildPartial() {
        io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList result = new io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList other) {
        if (other == io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Storage.CSIStorageCapacity m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Storage.CSIStorageCapacity> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Storage.CSIStorageCapacity>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSIStorageCapacity, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder, io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.CSIStorageCapacity> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacity getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Storage.CSIStorageCapacity value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Storage.CSIStorageCapacity> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of CSIStorageCapacity objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.CSIStorageCapacity items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.CSIStorageCapacity, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder, io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Storage.CSIStorageCapacity, io.kubernetes.client.proto.V1Storage.CSIStorageCapacity.Builder, io.kubernetes.client.proto.V1Storage.CSIStorageCapacityOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.CSIStorageCapacityList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.CSIStorageCapacityList)
    private static final io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList();
    }

    public static io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CSIStorageCapacityList>
        PARSER = new com.google.protobuf.AbstractParser<CSIStorageCapacityList>() {
      @java.lang.Override
      public CSIStorageCapacityList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CSIStorageCapacityList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CSIStorageCapacityList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.CSIStorageCapacityList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StorageClassOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.StorageClass)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * provisioner indicates the type of the provisioner.
     * </pre>
     *
     * <code>optional string provisioner = 2;</code>
     * @return Whether the provisioner field is set.
     */
    boolean hasProvisioner();
    /**
     * <pre>
     * provisioner indicates the type of the provisioner.
     * </pre>
     *
     * <code>optional string provisioner = 2;</code>
     * @return The provisioner.
     */
    java.lang.String getProvisioner();
    /**
     * <pre>
     * provisioner indicates the type of the provisioner.
     * </pre>
     *
     * <code>optional string provisioner = 2;</code>
     * @return The bytes for provisioner.
     */
    com.google.protobuf.ByteString
        getProvisionerBytes();

    /**
     * <pre>
     * parameters holds the parameters for the provisioner that should
     * create volumes of this storage class.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 3;</code>
     */
    int getParametersCount();
    /**
     * <pre>
     * parameters holds the parameters for the provisioner that should
     * create volumes of this storage class.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 3;</code>
     */
    boolean containsParameters(
        java.lang.String key);
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getParameters();
    /**
     * <pre>
     * parameters holds the parameters for the provisioner that should
     * create volumes of this storage class.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getParametersMap();
    /**
     * <pre>
     * parameters holds the parameters for the provisioner that should
     * create volumes of this storage class.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 3;</code>
     */
    /* nullable */
java.lang.String getParametersOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue);
    /**
     * <pre>
     * parameters holds the parameters for the provisioner that should
     * create volumes of this storage class.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 3;</code>
     */
    java.lang.String getParametersOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
     * Defaults to Delete.
     * +optional
     * </pre>
     *
     * <code>optional string reclaimPolicy = 4;</code>
     * @return Whether the reclaimPolicy field is set.
     */
    boolean hasReclaimPolicy();
    /**
     * <pre>
     * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
     * Defaults to Delete.
     * +optional
     * </pre>
     *
     * <code>optional string reclaimPolicy = 4;</code>
     * @return The reclaimPolicy.
     */
    java.lang.String getReclaimPolicy();
    /**
     * <pre>
     * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
     * Defaults to Delete.
     * +optional
     * </pre>
     *
     * <code>optional string reclaimPolicy = 4;</code>
     * @return The bytes for reclaimPolicy.
     */
    com.google.protobuf.ByteString
        getReclaimPolicyBytes();

    /**
     * <pre>
     * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
     * e.g. ["ro", "soft"]. Not validated -
     * mount of the PVs will simply fail if one is invalid.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string mountOptions = 5;</code>
     * @return A list containing the mountOptions.
     */
    java.util.List<java.lang.String>
        getMountOptionsList();
    /**
     * <pre>
     * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
     * e.g. ["ro", "soft"]. Not validated -
     * mount of the PVs will simply fail if one is invalid.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string mountOptions = 5;</code>
     * @return The count of mountOptions.
     */
    int getMountOptionsCount();
    /**
     * <pre>
     * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
     * e.g. ["ro", "soft"]. Not validated -
     * mount of the PVs will simply fail if one is invalid.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string mountOptions = 5;</code>
     * @param index The index of the element to return.
     * @return The mountOptions at the given index.
     */
    java.lang.String getMountOptions(int index);
    /**
     * <pre>
     * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
     * e.g. ["ro", "soft"]. Not validated -
     * mount of the PVs will simply fail if one is invalid.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string mountOptions = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the mountOptions at the given index.
     */
    com.google.protobuf.ByteString
        getMountOptionsBytes(int index);

    /**
     * <pre>
     * allowVolumeExpansion shows whether the storage class allow volume expand.
     * +optional
     * </pre>
     *
     * <code>optional bool allowVolumeExpansion = 6;</code>
     * @return Whether the allowVolumeExpansion field is set.
     */
    boolean hasAllowVolumeExpansion();
    /**
     * <pre>
     * allowVolumeExpansion shows whether the storage class allow volume expand.
     * +optional
     * </pre>
     *
     * <code>optional bool allowVolumeExpansion = 6;</code>
     * @return The allowVolumeExpansion.
     */
    boolean getAllowVolumeExpansion();

    /**
     * <pre>
     * volumeBindingMode indicates how PersistentVolumeClaims should be
     * provisioned and bound.  When unset, VolumeBindingImmediate is used.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * </pre>
     *
     * <code>optional string volumeBindingMode = 7;</code>
     * @return Whether the volumeBindingMode field is set.
     */
    boolean hasVolumeBindingMode();
    /**
     * <pre>
     * volumeBindingMode indicates how PersistentVolumeClaims should be
     * provisioned and bound.  When unset, VolumeBindingImmediate is used.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * </pre>
     *
     * <code>optional string volumeBindingMode = 7;</code>
     * @return The volumeBindingMode.
     */
    java.lang.String getVolumeBindingMode();
    /**
     * <pre>
     * volumeBindingMode indicates how PersistentVolumeClaims should be
     * provisioned and bound.  When unset, VolumeBindingImmediate is used.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * </pre>
     *
     * <code>optional string volumeBindingMode = 7;</code>
     * @return The bytes for volumeBindingMode.
     */
    com.google.protobuf.ByteString
        getVolumeBindingModeBytes();

    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1.TopologySelectorTerm> 
        getAllowedTopologiesList();
    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    io.kubernetes.client.proto.V1.TopologySelectorTerm getAllowedTopologies(int index);
    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    int getAllowedTopologiesCount();
    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1.TopologySelectorTermOrBuilder> 
        getAllowedTopologiesOrBuilderList();
    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    io.kubernetes.client.proto.V1.TopologySelectorTermOrBuilder getAllowedTopologiesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * StorageClass describes the parameters for a class of storage for
   * which PersistentVolumes can be dynamically provisioned.
   *
   * StorageClasses are non-namespaced; the name of the storage class
   * according to etcd is in ObjectMeta.Name.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.StorageClass}
   */
  public static final class StorageClass extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.StorageClass)
      StorageClassOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StorageClass.class.getName());
    }
    // Use StorageClass.newBuilder() to construct.
    private StorageClass(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StorageClass() {
      provisioner_ = "";
      reclaimPolicy_ = "";
      mountOptions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      volumeBindingMode_ = "";
      allowedTopologies_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClass_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 3:
          return internalGetParameters();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClass_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.StorageClass.class, io.kubernetes.client.proto.V1Storage.StorageClass.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int PROVISIONER_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object provisioner_ = "";
    /**
     * <pre>
     * provisioner indicates the type of the provisioner.
     * </pre>
     *
     * <code>optional string provisioner = 2;</code>
     * @return Whether the provisioner field is set.
     */
    @java.lang.Override
    public boolean hasProvisioner() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * provisioner indicates the type of the provisioner.
     * </pre>
     *
     * <code>optional string provisioner = 2;</code>
     * @return The provisioner.
     */
    @java.lang.Override
    public java.lang.String getProvisioner() {
      java.lang.Object ref = provisioner_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          provisioner_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * provisioner indicates the type of the provisioner.
     * </pre>
     *
     * <code>optional string provisioner = 2;</code>
     * @return The bytes for provisioner.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getProvisionerBytes() {
      java.lang.Object ref = provisioner_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        provisioner_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PARAMETERS_FIELD_NUMBER = 3;
    private static final class ParametersDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClass_ParametersEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> parameters_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetParameters() {
      if (parameters_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ParametersDefaultEntryHolder.defaultEntry);
      }
      return parameters_;
    }
    public int getParametersCount() {
      return internalGetParameters().getMap().size();
    }
    /**
     * <pre>
     * parameters holds the parameters for the provisioner that should
     * create volumes of this storage class.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 3;</code>
     */
    @java.lang.Override
    public boolean containsParameters(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetParameters().getMap().containsKey(key);
    }
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getParameters() {
      return getParametersMap();
    }
    /**
     * <pre>
     * parameters holds the parameters for the provisioner that should
     * create volumes of this storage class.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 3;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
      return internalGetParameters().getMap();
    }
    /**
     * <pre>
     * parameters holds the parameters for the provisioner that should
     * create volumes of this storage class.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 3;</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getParametersOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * parameters holds the parameters for the provisioner that should
     * create volumes of this storage class.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 3;</code>
     */
    @java.lang.Override
    public java.lang.String getParametersOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int RECLAIMPOLICY_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reclaimPolicy_ = "";
    /**
     * <pre>
     * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
     * Defaults to Delete.
     * +optional
     * </pre>
     *
     * <code>optional string reclaimPolicy = 4;</code>
     * @return Whether the reclaimPolicy field is set.
     */
    @java.lang.Override
    public boolean hasReclaimPolicy() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
     * Defaults to Delete.
     * +optional
     * </pre>
     *
     * <code>optional string reclaimPolicy = 4;</code>
     * @return The reclaimPolicy.
     */
    @java.lang.Override
    public java.lang.String getReclaimPolicy() {
      java.lang.Object ref = reclaimPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reclaimPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
     * Defaults to Delete.
     * +optional
     * </pre>
     *
     * <code>optional string reclaimPolicy = 4;</code>
     * @return The bytes for reclaimPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReclaimPolicyBytes() {
      java.lang.Object ref = reclaimPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reclaimPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MOUNTOPTIONS_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList mountOptions_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
     * e.g. ["ro", "soft"]. Not validated -
     * mount of the PVs will simply fail if one is invalid.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string mountOptions = 5;</code>
     * @return A list containing the mountOptions.
     */
    public com.google.protobuf.ProtocolStringList
        getMountOptionsList() {
      return mountOptions_;
    }
    /**
     * <pre>
     * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
     * e.g. ["ro", "soft"]. Not validated -
     * mount of the PVs will simply fail if one is invalid.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string mountOptions = 5;</code>
     * @return The count of mountOptions.
     */
    public int getMountOptionsCount() {
      return mountOptions_.size();
    }
    /**
     * <pre>
     * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
     * e.g. ["ro", "soft"]. Not validated -
     * mount of the PVs will simply fail if one is invalid.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string mountOptions = 5;</code>
     * @param index The index of the element to return.
     * @return The mountOptions at the given index.
     */
    public java.lang.String getMountOptions(int index) {
      return mountOptions_.get(index);
    }
    /**
     * <pre>
     * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
     * e.g. ["ro", "soft"]. Not validated -
     * mount of the PVs will simply fail if one is invalid.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string mountOptions = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the mountOptions at the given index.
     */
    public com.google.protobuf.ByteString
        getMountOptionsBytes(int index) {
      return mountOptions_.getByteString(index);
    }

    public static final int ALLOWVOLUMEEXPANSION_FIELD_NUMBER = 6;
    private boolean allowVolumeExpansion_ = false;
    /**
     * <pre>
     * allowVolumeExpansion shows whether the storage class allow volume expand.
     * +optional
     * </pre>
     *
     * <code>optional bool allowVolumeExpansion = 6;</code>
     * @return Whether the allowVolumeExpansion field is set.
     */
    @java.lang.Override
    public boolean hasAllowVolumeExpansion() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * allowVolumeExpansion shows whether the storage class allow volume expand.
     * +optional
     * </pre>
     *
     * <code>optional bool allowVolumeExpansion = 6;</code>
     * @return The allowVolumeExpansion.
     */
    @java.lang.Override
    public boolean getAllowVolumeExpansion() {
      return allowVolumeExpansion_;
    }

    public static final int VOLUMEBINDINGMODE_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object volumeBindingMode_ = "";
    /**
     * <pre>
     * volumeBindingMode indicates how PersistentVolumeClaims should be
     * provisioned and bound.  When unset, VolumeBindingImmediate is used.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * </pre>
     *
     * <code>optional string volumeBindingMode = 7;</code>
     * @return Whether the volumeBindingMode field is set.
     */
    @java.lang.Override
    public boolean hasVolumeBindingMode() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * volumeBindingMode indicates how PersistentVolumeClaims should be
     * provisioned and bound.  When unset, VolumeBindingImmediate is used.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * </pre>
     *
     * <code>optional string volumeBindingMode = 7;</code>
     * @return The volumeBindingMode.
     */
    @java.lang.Override
    public java.lang.String getVolumeBindingMode() {
      java.lang.Object ref = volumeBindingMode_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          volumeBindingMode_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * volumeBindingMode indicates how PersistentVolumeClaims should be
     * provisioned and bound.  When unset, VolumeBindingImmediate is used.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * </pre>
     *
     * <code>optional string volumeBindingMode = 7;</code>
     * @return The bytes for volumeBindingMode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVolumeBindingModeBytes() {
      java.lang.Object ref = volumeBindingMode_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeBindingMode_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ALLOWEDTOPOLOGIES_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1.TopologySelectorTerm> allowedTopologies_;
    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1.TopologySelectorTerm> getAllowedTopologiesList() {
      return allowedTopologies_;
    }
    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1.TopologySelectorTermOrBuilder> 
        getAllowedTopologiesOrBuilderList() {
      return allowedTopologies_;
    }
    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    @java.lang.Override
    public int getAllowedTopologiesCount() {
      return allowedTopologies_.size();
    }
    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.TopologySelectorTerm getAllowedTopologies(int index) {
      return allowedTopologies_.get(index);
    }
    /**
     * <pre>
     * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
     * Each volume plugin defines its own supported topology specifications.
     * An empty TopologySelectorTerm list means there is no topology restriction.
     * This field is only honored by servers that enable the VolumeScheduling feature.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.TopologySelectorTermOrBuilder getAllowedTopologiesOrBuilder(
        int index) {
      return allowedTopologies_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, provisioner_);
      }
      com.google.protobuf.GeneratedMessage
        .serializeStringMapTo(
          output,
          internalGetParameters(),
          ParametersDefaultEntryHolder.defaultEntry,
          3);
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, reclaimPolicy_);
      }
      for (int i = 0; i < mountOptions_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, mountOptions_.getRaw(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(6, allowVolumeExpansion_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 7, volumeBindingMode_);
      }
      for (int i = 0; i < allowedTopologies_.size(); i++) {
        output.writeMessage(8, allowedTopologies_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, provisioner_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetParameters().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        parameters__ = ParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, parameters__);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, reclaimPolicy_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < mountOptions_.size(); i++) {
          dataSize += computeStringSizeNoTag(mountOptions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getMountOptionsList().size();
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, allowVolumeExpansion_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(7, volumeBindingMode_);
      }
      for (int i = 0; i < allowedTopologies_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, allowedTopologies_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.StorageClass)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.StorageClass other = (io.kubernetes.client.proto.V1Storage.StorageClass) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasProvisioner() != other.hasProvisioner()) return false;
      if (hasProvisioner()) {
        if (!getProvisioner()
            .equals(other.getProvisioner())) return false;
      }
      if (!internalGetParameters().equals(
          other.internalGetParameters())) return false;
      if (hasReclaimPolicy() != other.hasReclaimPolicy()) return false;
      if (hasReclaimPolicy()) {
        if (!getReclaimPolicy()
            .equals(other.getReclaimPolicy())) return false;
      }
      if (!getMountOptionsList()
          .equals(other.getMountOptionsList())) return false;
      if (hasAllowVolumeExpansion() != other.hasAllowVolumeExpansion()) return false;
      if (hasAllowVolumeExpansion()) {
        if (getAllowVolumeExpansion()
            != other.getAllowVolumeExpansion()) return false;
      }
      if (hasVolumeBindingMode() != other.hasVolumeBindingMode()) return false;
      if (hasVolumeBindingMode()) {
        if (!getVolumeBindingMode()
            .equals(other.getVolumeBindingMode())) return false;
      }
      if (!getAllowedTopologiesList()
          .equals(other.getAllowedTopologiesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasProvisioner()) {
        hash = (37 * hash) + PROVISIONER_FIELD_NUMBER;
        hash = (53 * hash) + getProvisioner().hashCode();
      }
      if (!internalGetParameters().getMap().isEmpty()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetParameters().hashCode();
      }
      if (hasReclaimPolicy()) {
        hash = (37 * hash) + RECLAIMPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getReclaimPolicy().hashCode();
      }
      if (getMountOptionsCount() > 0) {
        hash = (37 * hash) + MOUNTOPTIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMountOptionsList().hashCode();
      }
      if (hasAllowVolumeExpansion()) {
        hash = (37 * hash) + ALLOWVOLUMEEXPANSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAllowVolumeExpansion());
      }
      if (hasVolumeBindingMode()) {
        hash = (37 * hash) + VOLUMEBINDINGMODE_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeBindingMode().hashCode();
      }
      if (getAllowedTopologiesCount() > 0) {
        hash = (37 * hash) + ALLOWEDTOPOLOGIES_FIELD_NUMBER;
        hash = (53 * hash) + getAllowedTopologiesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.StorageClass parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.StorageClass parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClass parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.StorageClass prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StorageClass describes the parameters for a class of storage for
     * which PersistentVolumes can be dynamically provisioned.
     *
     * StorageClasses are non-namespaced; the name of the storage class
     * according to etcd is in ObjectMeta.Name.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.StorageClass}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.StorageClass)
        io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClass_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 3:
            return internalGetParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClass_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.StorageClass.class, io.kubernetes.client.proto.V1Storage.StorageClass.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.StorageClass.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getAllowedTopologiesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        provisioner_ = "";
        internalGetMutableParameters().clear();
        reclaimPolicy_ = "";
        mountOptions_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        allowVolumeExpansion_ = false;
        volumeBindingMode_ = "";
        if (allowedTopologiesBuilder_ == null) {
          allowedTopologies_ = java.util.Collections.emptyList();
        } else {
          allowedTopologies_ = null;
          allowedTopologiesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClass_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.StorageClass getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.StorageClass.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.StorageClass build() {
        io.kubernetes.client.proto.V1Storage.StorageClass result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.StorageClass buildPartial() {
        io.kubernetes.client.proto.V1Storage.StorageClass result = new io.kubernetes.client.proto.V1Storage.StorageClass(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Storage.StorageClass result) {
        if (allowedTopologiesBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            allowedTopologies_ = java.util.Collections.unmodifiableList(allowedTopologies_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.allowedTopologies_ = allowedTopologies_;
        } else {
          result.allowedTopologies_ = allowedTopologiesBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.StorageClass result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.provisioner_ = provisioner_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.parameters_ = internalGetParameters();
          result.parameters_.makeImmutable();
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.reclaimPolicy_ = reclaimPolicy_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          mountOptions_.makeImmutable();
          result.mountOptions_ = mountOptions_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.allowVolumeExpansion_ = allowVolumeExpansion_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.volumeBindingMode_ = volumeBindingMode_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.StorageClass) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.StorageClass)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.StorageClass other) {
        if (other == io.kubernetes.client.proto.V1Storage.StorageClass.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasProvisioner()) {
          provisioner_ = other.provisioner_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        internalGetMutableParameters().mergeFrom(
            other.internalGetParameters());
        bitField0_ |= 0x00000004;
        if (other.hasReclaimPolicy()) {
          reclaimPolicy_ = other.reclaimPolicy_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (!other.mountOptions_.isEmpty()) {
          if (mountOptions_.isEmpty()) {
            mountOptions_ = other.mountOptions_;
            bitField0_ |= 0x00000010;
          } else {
            ensureMountOptionsIsMutable();
            mountOptions_.addAll(other.mountOptions_);
          }
          onChanged();
        }
        if (other.hasAllowVolumeExpansion()) {
          setAllowVolumeExpansion(other.getAllowVolumeExpansion());
        }
        if (other.hasVolumeBindingMode()) {
          volumeBindingMode_ = other.volumeBindingMode_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        if (allowedTopologiesBuilder_ == null) {
          if (!other.allowedTopologies_.isEmpty()) {
            if (allowedTopologies_.isEmpty()) {
              allowedTopologies_ = other.allowedTopologies_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureAllowedTopologiesIsMutable();
              allowedTopologies_.addAll(other.allowedTopologies_);
            }
            onChanged();
          }
        } else {
          if (!other.allowedTopologies_.isEmpty()) {
            if (allowedTopologiesBuilder_.isEmpty()) {
              allowedTopologiesBuilder_.dispose();
              allowedTopologiesBuilder_ = null;
              allowedTopologies_ = other.allowedTopologies_;
              bitField0_ = (bitField0_ & ~0x00000080);
              allowedTopologiesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getAllowedTopologiesFieldBuilder() : null;
            } else {
              allowedTopologiesBuilder_.addAllMessages(other.allowedTopologies_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                provisioner_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                parameters__ = input.readMessage(
                    ParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                internalGetMutableParameters().getMutableMap().put(
                    parameters__.getKey(), parameters__.getValue());
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                reclaimPolicy_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureMountOptionsIsMutable();
                mountOptions_.add(bs);
                break;
              } // case 42
              case 48: {
                allowVolumeExpansion_ = input.readBool();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 58: {
                volumeBindingMode_ = input.readBytes();
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 66: {
                io.kubernetes.client.proto.V1.TopologySelectorTerm m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1.TopologySelectorTerm.parser(),
                        extensionRegistry);
                if (allowedTopologiesBuilder_ == null) {
                  ensureAllowedTopologiesIsMutable();
                  allowedTopologies_.add(m);
                } else {
                  allowedTopologiesBuilder_.addMessage(m);
                }
                break;
              } // case 66
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.lang.Object provisioner_ = "";
      /**
       * <pre>
       * provisioner indicates the type of the provisioner.
       * </pre>
       *
       * <code>optional string provisioner = 2;</code>
       * @return Whether the provisioner field is set.
       */
      public boolean hasProvisioner() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * provisioner indicates the type of the provisioner.
       * </pre>
       *
       * <code>optional string provisioner = 2;</code>
       * @return The provisioner.
       */
      public java.lang.String getProvisioner() {
        java.lang.Object ref = provisioner_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            provisioner_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * provisioner indicates the type of the provisioner.
       * </pre>
       *
       * <code>optional string provisioner = 2;</code>
       * @return The bytes for provisioner.
       */
      public com.google.protobuf.ByteString
          getProvisionerBytes() {
        java.lang.Object ref = provisioner_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          provisioner_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * provisioner indicates the type of the provisioner.
       * </pre>
       *
       * <code>optional string provisioner = 2;</code>
       * @param value The provisioner to set.
       * @return This builder for chaining.
       */
      public Builder setProvisioner(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        provisioner_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * provisioner indicates the type of the provisioner.
       * </pre>
       *
       * <code>optional string provisioner = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearProvisioner() {
        provisioner_ = getDefaultInstance().getProvisioner();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * provisioner indicates the type of the provisioner.
       * </pre>
       *
       * <code>optional string provisioner = 2;</code>
       * @param value The bytes for provisioner to set.
       * @return This builder for chaining.
       */
      public Builder setProvisionerBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        provisioner_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> parameters_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetParameters() {
        if (parameters_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        return parameters_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMutableParameters() {
        if (parameters_ == null) {
          parameters_ = com.google.protobuf.MapField.newMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        if (!parameters_.isMutable()) {
          parameters_ = parameters_.copy();
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return parameters_;
      }
      public int getParametersCount() {
        return internalGetParameters().getMap().size();
      }
      /**
       * <pre>
       * parameters holds the parameters for the provisioner that should
       * create volumes of this storage class.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      @java.lang.Override
      public boolean containsParameters(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetParameters().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getParameters() {
        return getParametersMap();
      }
      /**
       * <pre>
       * parameters holds the parameters for the provisioner that should
       * create volumes of this storage class.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
        return internalGetParameters().getMap();
      }
      /**
       * <pre>
       * parameters holds the parameters for the provisioner that should
       * create volumes of this storage class.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      @java.lang.Override
      public /* nullable */
java.lang.String getParametersOrDefault(
          java.lang.String key,
          /* nullable */
java.lang.String defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * parameters holds the parameters for the provisioner that should
       * create volumes of this storage class.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      @java.lang.Override
      public java.lang.String getParametersOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      public Builder clearParameters() {
        bitField0_ = (bitField0_ & ~0x00000004);
        internalGetMutableParameters().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * parameters holds the parameters for the provisioner that should
       * create volumes of this storage class.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      public Builder removeParameters(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableParameters().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
          getMutableParameters() {
        bitField0_ |= 0x00000004;
        return internalGetMutableParameters().getMutableMap();
      }
      /**
       * <pre>
       * parameters holds the parameters for the provisioner that should
       * create volumes of this storage class.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      public Builder putParameters(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) { throw new NullPointerException("map value"); }
        internalGetMutableParameters().getMutableMap()
            .put(key, value);
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * parameters holds the parameters for the provisioner that should
       * create volumes of this storage class.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      public Builder putAllParameters(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableParameters().getMutableMap()
            .putAll(values);
        bitField0_ |= 0x00000004;
        return this;
      }

      private java.lang.Object reclaimPolicy_ = "";
      /**
       * <pre>
       * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
       * Defaults to Delete.
       * +optional
       * </pre>
       *
       * <code>optional string reclaimPolicy = 4;</code>
       * @return Whether the reclaimPolicy field is set.
       */
      public boolean hasReclaimPolicy() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
       * Defaults to Delete.
       * +optional
       * </pre>
       *
       * <code>optional string reclaimPolicy = 4;</code>
       * @return The reclaimPolicy.
       */
      public java.lang.String getReclaimPolicy() {
        java.lang.Object ref = reclaimPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reclaimPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
       * Defaults to Delete.
       * +optional
       * </pre>
       *
       * <code>optional string reclaimPolicy = 4;</code>
       * @return The bytes for reclaimPolicy.
       */
      public com.google.protobuf.ByteString
          getReclaimPolicyBytes() {
        java.lang.Object ref = reclaimPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reclaimPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
       * Defaults to Delete.
       * +optional
       * </pre>
       *
       * <code>optional string reclaimPolicy = 4;</code>
       * @param value The reclaimPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setReclaimPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reclaimPolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
       * Defaults to Delete.
       * +optional
       * </pre>
       *
       * <code>optional string reclaimPolicy = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearReclaimPolicy() {
        reclaimPolicy_ = getDefaultInstance().getReclaimPolicy();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
       * Defaults to Delete.
       * +optional
       * </pre>
       *
       * <code>optional string reclaimPolicy = 4;</code>
       * @param value The bytes for reclaimPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setReclaimPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reclaimPolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList mountOptions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureMountOptionsIsMutable() {
        if (!mountOptions_.isModifiable()) {
          mountOptions_ = new com.google.protobuf.LazyStringArrayList(mountOptions_);
        }
        bitField0_ |= 0x00000010;
      }
      /**
       * <pre>
       * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
       * e.g. ["ro", "soft"]. Not validated -
       * mount of the PVs will simply fail if one is invalid.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string mountOptions = 5;</code>
       * @return A list containing the mountOptions.
       */
      public com.google.protobuf.ProtocolStringList
          getMountOptionsList() {
        mountOptions_.makeImmutable();
        return mountOptions_;
      }
      /**
       * <pre>
       * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
       * e.g. ["ro", "soft"]. Not validated -
       * mount of the PVs will simply fail if one is invalid.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string mountOptions = 5;</code>
       * @return The count of mountOptions.
       */
      public int getMountOptionsCount() {
        return mountOptions_.size();
      }
      /**
       * <pre>
       * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
       * e.g. ["ro", "soft"]. Not validated -
       * mount of the PVs will simply fail if one is invalid.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string mountOptions = 5;</code>
       * @param index The index of the element to return.
       * @return The mountOptions at the given index.
       */
      public java.lang.String getMountOptions(int index) {
        return mountOptions_.get(index);
      }
      /**
       * <pre>
       * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
       * e.g. ["ro", "soft"]. Not validated -
       * mount of the PVs will simply fail if one is invalid.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string mountOptions = 5;</code>
       * @param index The index of the value to return.
       * @return The bytes of the mountOptions at the given index.
       */
      public com.google.protobuf.ByteString
          getMountOptionsBytes(int index) {
        return mountOptions_.getByteString(index);
      }
      /**
       * <pre>
       * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
       * e.g. ["ro", "soft"]. Not validated -
       * mount of the PVs will simply fail if one is invalid.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string mountOptions = 5;</code>
       * @param index The index to set the value at.
       * @param value The mountOptions to set.
       * @return This builder for chaining.
       */
      public Builder setMountOptions(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureMountOptionsIsMutable();
        mountOptions_.set(index, value);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
       * e.g. ["ro", "soft"]. Not validated -
       * mount of the PVs will simply fail if one is invalid.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string mountOptions = 5;</code>
       * @param value The mountOptions to add.
       * @return This builder for chaining.
       */
      public Builder addMountOptions(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureMountOptionsIsMutable();
        mountOptions_.add(value);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
       * e.g. ["ro", "soft"]. Not validated -
       * mount of the PVs will simply fail if one is invalid.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string mountOptions = 5;</code>
       * @param values The mountOptions to add.
       * @return This builder for chaining.
       */
      public Builder addAllMountOptions(
          java.lang.Iterable<java.lang.String> values) {
        ensureMountOptionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, mountOptions_);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
       * e.g. ["ro", "soft"]. Not validated -
       * mount of the PVs will simply fail if one is invalid.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string mountOptions = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearMountOptions() {
        mountOptions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
       * e.g. ["ro", "soft"]. Not validated -
       * mount of the PVs will simply fail if one is invalid.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string mountOptions = 5;</code>
       * @param value The bytes of the mountOptions to add.
       * @return This builder for chaining.
       */
      public Builder addMountOptionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureMountOptionsIsMutable();
        mountOptions_.add(value);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private boolean allowVolumeExpansion_ ;
      /**
       * <pre>
       * allowVolumeExpansion shows whether the storage class allow volume expand.
       * +optional
       * </pre>
       *
       * <code>optional bool allowVolumeExpansion = 6;</code>
       * @return Whether the allowVolumeExpansion field is set.
       */
      @java.lang.Override
      public boolean hasAllowVolumeExpansion() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * allowVolumeExpansion shows whether the storage class allow volume expand.
       * +optional
       * </pre>
       *
       * <code>optional bool allowVolumeExpansion = 6;</code>
       * @return The allowVolumeExpansion.
       */
      @java.lang.Override
      public boolean getAllowVolumeExpansion() {
        return allowVolumeExpansion_;
      }
      /**
       * <pre>
       * allowVolumeExpansion shows whether the storage class allow volume expand.
       * +optional
       * </pre>
       *
       * <code>optional bool allowVolumeExpansion = 6;</code>
       * @param value The allowVolumeExpansion to set.
       * @return This builder for chaining.
       */
      public Builder setAllowVolumeExpansion(boolean value) {

        allowVolumeExpansion_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * allowVolumeExpansion shows whether the storage class allow volume expand.
       * +optional
       * </pre>
       *
       * <code>optional bool allowVolumeExpansion = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearAllowVolumeExpansion() {
        bitField0_ = (bitField0_ & ~0x00000020);
        allowVolumeExpansion_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object volumeBindingMode_ = "";
      /**
       * <pre>
       * volumeBindingMode indicates how PersistentVolumeClaims should be
       * provisioned and bound.  When unset, VolumeBindingImmediate is used.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * </pre>
       *
       * <code>optional string volumeBindingMode = 7;</code>
       * @return Whether the volumeBindingMode field is set.
       */
      public boolean hasVolumeBindingMode() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * volumeBindingMode indicates how PersistentVolumeClaims should be
       * provisioned and bound.  When unset, VolumeBindingImmediate is used.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * </pre>
       *
       * <code>optional string volumeBindingMode = 7;</code>
       * @return The volumeBindingMode.
       */
      public java.lang.String getVolumeBindingMode() {
        java.lang.Object ref = volumeBindingMode_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            volumeBindingMode_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * volumeBindingMode indicates how PersistentVolumeClaims should be
       * provisioned and bound.  When unset, VolumeBindingImmediate is used.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * </pre>
       *
       * <code>optional string volumeBindingMode = 7;</code>
       * @return The bytes for volumeBindingMode.
       */
      public com.google.protobuf.ByteString
          getVolumeBindingModeBytes() {
        java.lang.Object ref = volumeBindingMode_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeBindingMode_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * volumeBindingMode indicates how PersistentVolumeClaims should be
       * provisioned and bound.  When unset, VolumeBindingImmediate is used.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * </pre>
       *
       * <code>optional string volumeBindingMode = 7;</code>
       * @param value The volumeBindingMode to set.
       * @return This builder for chaining.
       */
      public Builder setVolumeBindingMode(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        volumeBindingMode_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * volumeBindingMode indicates how PersistentVolumeClaims should be
       * provisioned and bound.  When unset, VolumeBindingImmediate is used.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * </pre>
       *
       * <code>optional string volumeBindingMode = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearVolumeBindingMode() {
        volumeBindingMode_ = getDefaultInstance().getVolumeBindingMode();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * volumeBindingMode indicates how PersistentVolumeClaims should be
       * provisioned and bound.  When unset, VolumeBindingImmediate is used.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * </pre>
       *
       * <code>optional string volumeBindingMode = 7;</code>
       * @param value The bytes for volumeBindingMode to set.
       * @return This builder for chaining.
       */
      public Builder setVolumeBindingModeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        volumeBindingMode_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1.TopologySelectorTerm> allowedTopologies_ =
        java.util.Collections.emptyList();
      private void ensureAllowedTopologiesIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          allowedTopologies_ = new java.util.ArrayList<io.kubernetes.client.proto.V1.TopologySelectorTerm>(allowedTopologies_);
          bitField0_ |= 0x00000080;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1.TopologySelectorTerm, io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder, io.kubernetes.client.proto.V1.TopologySelectorTermOrBuilder> allowedTopologiesBuilder_;

      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1.TopologySelectorTerm> getAllowedTopologiesList() {
        if (allowedTopologiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(allowedTopologies_);
        } else {
          return allowedTopologiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public int getAllowedTopologiesCount() {
        if (allowedTopologiesBuilder_ == null) {
          return allowedTopologies_.size();
        } else {
          return allowedTopologiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public io.kubernetes.client.proto.V1.TopologySelectorTerm getAllowedTopologies(int index) {
        if (allowedTopologiesBuilder_ == null) {
          return allowedTopologies_.get(index);
        } else {
          return allowedTopologiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public Builder setAllowedTopologies(
          int index, io.kubernetes.client.proto.V1.TopologySelectorTerm value) {
        if (allowedTopologiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedTopologiesIsMutable();
          allowedTopologies_.set(index, value);
          onChanged();
        } else {
          allowedTopologiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public Builder setAllowedTopologies(
          int index, io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder builderForValue) {
        if (allowedTopologiesBuilder_ == null) {
          ensureAllowedTopologiesIsMutable();
          allowedTopologies_.set(index, builderForValue.build());
          onChanged();
        } else {
          allowedTopologiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public Builder addAllowedTopologies(io.kubernetes.client.proto.V1.TopologySelectorTerm value) {
        if (allowedTopologiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedTopologiesIsMutable();
          allowedTopologies_.add(value);
          onChanged();
        } else {
          allowedTopologiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public Builder addAllowedTopologies(
          int index, io.kubernetes.client.proto.V1.TopologySelectorTerm value) {
        if (allowedTopologiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedTopologiesIsMutable();
          allowedTopologies_.add(index, value);
          onChanged();
        } else {
          allowedTopologiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public Builder addAllowedTopologies(
          io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder builderForValue) {
        if (allowedTopologiesBuilder_ == null) {
          ensureAllowedTopologiesIsMutable();
          allowedTopologies_.add(builderForValue.build());
          onChanged();
        } else {
          allowedTopologiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public Builder addAllowedTopologies(
          int index, io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder builderForValue) {
        if (allowedTopologiesBuilder_ == null) {
          ensureAllowedTopologiesIsMutable();
          allowedTopologies_.add(index, builderForValue.build());
          onChanged();
        } else {
          allowedTopologiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public Builder addAllAllowedTopologies(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1.TopologySelectorTerm> values) {
        if (allowedTopologiesBuilder_ == null) {
          ensureAllowedTopologiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, allowedTopologies_);
          onChanged();
        } else {
          allowedTopologiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public Builder clearAllowedTopologies() {
        if (allowedTopologiesBuilder_ == null) {
          allowedTopologies_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          allowedTopologiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public Builder removeAllowedTopologies(int index) {
        if (allowedTopologiesBuilder_ == null) {
          ensureAllowedTopologiesIsMutable();
          allowedTopologies_.remove(index);
          onChanged();
        } else {
          allowedTopologiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder getAllowedTopologiesBuilder(
          int index) {
        return getAllowedTopologiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public io.kubernetes.client.proto.V1.TopologySelectorTermOrBuilder getAllowedTopologiesOrBuilder(
          int index) {
        if (allowedTopologiesBuilder_ == null) {
          return allowedTopologies_.get(index);  } else {
          return allowedTopologiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1.TopologySelectorTermOrBuilder> 
           getAllowedTopologiesOrBuilderList() {
        if (allowedTopologiesBuilder_ != null) {
          return allowedTopologiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(allowedTopologies_);
        }
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder addAllowedTopologiesBuilder() {
        return getAllowedTopologiesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1.TopologySelectorTerm.getDefaultInstance());
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder addAllowedTopologiesBuilder(
          int index) {
        return getAllowedTopologiesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1.TopologySelectorTerm.getDefaultInstance());
      }
      /**
       * <pre>
       * allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
       * Each volume plugin defines its own supported topology specifications.
       * An empty TopologySelectorTerm list means there is no topology restriction.
       * This field is only honored by servers that enable the VolumeScheduling feature.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.TopologySelectorTerm allowedTopologies = 8;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder> 
           getAllowedTopologiesBuilderList() {
        return getAllowedTopologiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1.TopologySelectorTerm, io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder, io.kubernetes.client.proto.V1.TopologySelectorTermOrBuilder> 
          getAllowedTopologiesFieldBuilder() {
        if (allowedTopologiesBuilder_ == null) {
          allowedTopologiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1.TopologySelectorTerm, io.kubernetes.client.proto.V1.TopologySelectorTerm.Builder, io.kubernetes.client.proto.V1.TopologySelectorTermOrBuilder>(
                  allowedTopologies_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          allowedTopologies_ = null;
        }
        return allowedTopologiesBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.StorageClass)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.StorageClass)
    private static final io.kubernetes.client.proto.V1Storage.StorageClass DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.StorageClass();
    }

    public static io.kubernetes.client.proto.V1Storage.StorageClass getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StorageClass>
        PARSER = new com.google.protobuf.AbstractParser<StorageClass>() {
      @java.lang.Override
      public StorageClass parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StorageClass> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StorageClass> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.StorageClass getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StorageClassListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.StorageClassList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Storage.StorageClass> 
        getItemsList();
    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.StorageClass getItems(int index);
    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * StorageClassList is a collection of storage classes.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.StorageClassList}
   */
  public static final class StorageClassList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.StorageClassList)
      StorageClassListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StorageClassList.class.getName());
    }
    // Use StorageClassList.newBuilder() to construct.
    private StorageClassList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StorageClassList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClassList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClassList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.StorageClassList.class, io.kubernetes.client.proto.V1Storage.StorageClassList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Storage.StorageClass> items_;
    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Storage.StorageClass> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.StorageClass getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * items is the list of StorageClasses
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.StorageClassList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.StorageClassList other = (io.kubernetes.client.proto.V1Storage.StorageClassList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.StorageClassList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.StorageClassList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StorageClassList is a collection of storage classes.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.StorageClassList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.StorageClassList)
        io.kubernetes.client.proto.V1Storage.StorageClassListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClassList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClassList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.StorageClassList.class, io.kubernetes.client.proto.V1Storage.StorageClassList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.StorageClassList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_StorageClassList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.StorageClassList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.StorageClassList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.StorageClassList build() {
        io.kubernetes.client.proto.V1Storage.StorageClassList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.StorageClassList buildPartial() {
        io.kubernetes.client.proto.V1Storage.StorageClassList result = new io.kubernetes.client.proto.V1Storage.StorageClassList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Storage.StorageClassList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.StorageClassList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.StorageClassList) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.StorageClassList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.StorageClassList other) {
        if (other == io.kubernetes.client.proto.V1Storage.StorageClassList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Storage.StorageClass m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Storage.StorageClass.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Storage.StorageClass> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Storage.StorageClass>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.StorageClass, io.kubernetes.client.proto.V1Storage.StorageClass.Builder, io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.StorageClass> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.StorageClass getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.StorageClass value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.StorageClass.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Storage.StorageClass value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.StorageClass value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Storage.StorageClass.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.StorageClass.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Storage.StorageClass> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.StorageClass.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.StorageClass.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Storage.StorageClass.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.StorageClass.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Storage.StorageClass.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of StorageClasses
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.StorageClass items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.StorageClass.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.StorageClass, io.kubernetes.client.proto.V1Storage.StorageClass.Builder, io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Storage.StorageClass, io.kubernetes.client.proto.V1Storage.StorageClass.Builder, io.kubernetes.client.proto.V1Storage.StorageClassOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.StorageClassList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.StorageClassList)
    private static final io.kubernetes.client.proto.V1Storage.StorageClassList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.StorageClassList();
    }

    public static io.kubernetes.client.proto.V1Storage.StorageClassList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StorageClassList>
        PARSER = new com.google.protobuf.AbstractParser<StorageClassList>() {
      @java.lang.Override
      public StorageClassList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StorageClassList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StorageClassList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.StorageClassList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TokenRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.TokenRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * audience is the intended audience of the token in "TokenRequestSpec".
     * It will default to the audiences of kube apiserver.
     * </pre>
     *
     * <code>optional string audience = 1;</code>
     * @return Whether the audience field is set.
     */
    boolean hasAudience();
    /**
     * <pre>
     * audience is the intended audience of the token in "TokenRequestSpec".
     * It will default to the audiences of kube apiserver.
     * </pre>
     *
     * <code>optional string audience = 1;</code>
     * @return The audience.
     */
    java.lang.String getAudience();
    /**
     * <pre>
     * audience is the intended audience of the token in "TokenRequestSpec".
     * It will default to the audiences of kube apiserver.
     * </pre>
     *
     * <code>optional string audience = 1;</code>
     * @return The bytes for audience.
     */
    com.google.protobuf.ByteString
        getAudienceBytes();

    /**
     * <pre>
     * expirationSeconds is the duration of validity of the token in "TokenRequestSpec".
     * It has the same default value of "ExpirationSeconds" in "TokenRequestSpec".
     *
     * +optional
     * </pre>
     *
     * <code>optional int64 expirationSeconds = 2;</code>
     * @return Whether the expirationSeconds field is set.
     */
    boolean hasExpirationSeconds();
    /**
     * <pre>
     * expirationSeconds is the duration of validity of the token in "TokenRequestSpec".
     * It has the same default value of "ExpirationSeconds" in "TokenRequestSpec".
     *
     * +optional
     * </pre>
     *
     * <code>optional int64 expirationSeconds = 2;</code>
     * @return The expirationSeconds.
     */
    long getExpirationSeconds();
  }
  /**
   * <pre>
   * TokenRequest contains parameters of a service account token.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.TokenRequest}
   */
  public static final class TokenRequest extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.TokenRequest)
      TokenRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        TokenRequest.class.getName());
    }
    // Use TokenRequest.newBuilder() to construct.
    private TokenRequest(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private TokenRequest() {
      audience_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_TokenRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_TokenRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.TokenRequest.class, io.kubernetes.client.proto.V1Storage.TokenRequest.Builder.class);
    }

    private int bitField0_;
    public static final int AUDIENCE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object audience_ = "";
    /**
     * <pre>
     * audience is the intended audience of the token in "TokenRequestSpec".
     * It will default to the audiences of kube apiserver.
     * </pre>
     *
     * <code>optional string audience = 1;</code>
     * @return Whether the audience field is set.
     */
    @java.lang.Override
    public boolean hasAudience() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * audience is the intended audience of the token in "TokenRequestSpec".
     * It will default to the audiences of kube apiserver.
     * </pre>
     *
     * <code>optional string audience = 1;</code>
     * @return The audience.
     */
    @java.lang.Override
    public java.lang.String getAudience() {
      java.lang.Object ref = audience_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          audience_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * audience is the intended audience of the token in "TokenRequestSpec".
     * It will default to the audiences of kube apiserver.
     * </pre>
     *
     * <code>optional string audience = 1;</code>
     * @return The bytes for audience.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAudienceBytes() {
      java.lang.Object ref = audience_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        audience_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EXPIRATIONSECONDS_FIELD_NUMBER = 2;
    private long expirationSeconds_ = 0L;
    /**
     * <pre>
     * expirationSeconds is the duration of validity of the token in "TokenRequestSpec".
     * It has the same default value of "ExpirationSeconds" in "TokenRequestSpec".
     *
     * +optional
     * </pre>
     *
     * <code>optional int64 expirationSeconds = 2;</code>
     * @return Whether the expirationSeconds field is set.
     */
    @java.lang.Override
    public boolean hasExpirationSeconds() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * expirationSeconds is the duration of validity of the token in "TokenRequestSpec".
     * It has the same default value of "ExpirationSeconds" in "TokenRequestSpec".
     *
     * +optional
     * </pre>
     *
     * <code>optional int64 expirationSeconds = 2;</code>
     * @return The expirationSeconds.
     */
    @java.lang.Override
    public long getExpirationSeconds() {
      return expirationSeconds_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, audience_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt64(2, expirationSeconds_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, audience_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, expirationSeconds_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.TokenRequest)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.TokenRequest other = (io.kubernetes.client.proto.V1Storage.TokenRequest) obj;

      if (hasAudience() != other.hasAudience()) return false;
      if (hasAudience()) {
        if (!getAudience()
            .equals(other.getAudience())) return false;
      }
      if (hasExpirationSeconds() != other.hasExpirationSeconds()) return false;
      if (hasExpirationSeconds()) {
        if (getExpirationSeconds()
            != other.getExpirationSeconds()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAudience()) {
        hash = (37 * hash) + AUDIENCE_FIELD_NUMBER;
        hash = (53 * hash) + getAudience().hashCode();
      }
      if (hasExpirationSeconds()) {
        hash = (37 * hash) + EXPIRATIONSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getExpirationSeconds());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.TokenRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.TokenRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TokenRequest contains parameters of a service account token.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.TokenRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.TokenRequest)
        io.kubernetes.client.proto.V1Storage.TokenRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_TokenRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_TokenRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.TokenRequest.class, io.kubernetes.client.proto.V1Storage.TokenRequest.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.TokenRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        audience_ = "";
        expirationSeconds_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_TokenRequest_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.TokenRequest getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.TokenRequest.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.TokenRequest build() {
        io.kubernetes.client.proto.V1Storage.TokenRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.TokenRequest buildPartial() {
        io.kubernetes.client.proto.V1Storage.TokenRequest result = new io.kubernetes.client.proto.V1Storage.TokenRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.TokenRequest result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.audience_ = audience_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.expirationSeconds_ = expirationSeconds_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.TokenRequest) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.TokenRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.TokenRequest other) {
        if (other == io.kubernetes.client.proto.V1Storage.TokenRequest.getDefaultInstance()) return this;
        if (other.hasAudience()) {
          audience_ = other.audience_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasExpirationSeconds()) {
          setExpirationSeconds(other.getExpirationSeconds());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                audience_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                expirationSeconds_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object audience_ = "";
      /**
       * <pre>
       * audience is the intended audience of the token in "TokenRequestSpec".
       * It will default to the audiences of kube apiserver.
       * </pre>
       *
       * <code>optional string audience = 1;</code>
       * @return Whether the audience field is set.
       */
      public boolean hasAudience() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * audience is the intended audience of the token in "TokenRequestSpec".
       * It will default to the audiences of kube apiserver.
       * </pre>
       *
       * <code>optional string audience = 1;</code>
       * @return The audience.
       */
      public java.lang.String getAudience() {
        java.lang.Object ref = audience_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            audience_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * audience is the intended audience of the token in "TokenRequestSpec".
       * It will default to the audiences of kube apiserver.
       * </pre>
       *
       * <code>optional string audience = 1;</code>
       * @return The bytes for audience.
       */
      public com.google.protobuf.ByteString
          getAudienceBytes() {
        java.lang.Object ref = audience_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          audience_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * audience is the intended audience of the token in "TokenRequestSpec".
       * It will default to the audiences of kube apiserver.
       * </pre>
       *
       * <code>optional string audience = 1;</code>
       * @param value The audience to set.
       * @return This builder for chaining.
       */
      public Builder setAudience(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        audience_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * audience is the intended audience of the token in "TokenRequestSpec".
       * It will default to the audiences of kube apiserver.
       * </pre>
       *
       * <code>optional string audience = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAudience() {
        audience_ = getDefaultInstance().getAudience();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * audience is the intended audience of the token in "TokenRequestSpec".
       * It will default to the audiences of kube apiserver.
       * </pre>
       *
       * <code>optional string audience = 1;</code>
       * @param value The bytes for audience to set.
       * @return This builder for chaining.
       */
      public Builder setAudienceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        audience_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private long expirationSeconds_ ;
      /**
       * <pre>
       * expirationSeconds is the duration of validity of the token in "TokenRequestSpec".
       * It has the same default value of "ExpirationSeconds" in "TokenRequestSpec".
       *
       * +optional
       * </pre>
       *
       * <code>optional int64 expirationSeconds = 2;</code>
       * @return Whether the expirationSeconds field is set.
       */
      @java.lang.Override
      public boolean hasExpirationSeconds() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * expirationSeconds is the duration of validity of the token in "TokenRequestSpec".
       * It has the same default value of "ExpirationSeconds" in "TokenRequestSpec".
       *
       * +optional
       * </pre>
       *
       * <code>optional int64 expirationSeconds = 2;</code>
       * @return The expirationSeconds.
       */
      @java.lang.Override
      public long getExpirationSeconds() {
        return expirationSeconds_;
      }
      /**
       * <pre>
       * expirationSeconds is the duration of validity of the token in "TokenRequestSpec".
       * It has the same default value of "ExpirationSeconds" in "TokenRequestSpec".
       *
       * +optional
       * </pre>
       *
       * <code>optional int64 expirationSeconds = 2;</code>
       * @param value The expirationSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setExpirationSeconds(long value) {

        expirationSeconds_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * expirationSeconds is the duration of validity of the token in "TokenRequestSpec".
       * It has the same default value of "ExpirationSeconds" in "TokenRequestSpec".
       *
       * +optional
       * </pre>
       *
       * <code>optional int64 expirationSeconds = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpirationSeconds() {
        bitField0_ = (bitField0_ & ~0x00000002);
        expirationSeconds_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.TokenRequest)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.TokenRequest)
    private static final io.kubernetes.client.proto.V1Storage.TokenRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.TokenRequest();
    }

    public static io.kubernetes.client.proto.V1Storage.TokenRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TokenRequest>
        PARSER = new com.google.protobuf.AbstractParser<TokenRequest>() {
      @java.lang.Override
      public TokenRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TokenRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TokenRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.TokenRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeAttachmentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.VolumeAttachment)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * spec represents specification of the desired attach/detach volume behavior.
     * Populated by the Kubernetes system.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    boolean hasSpec();
    /**
     * <pre>
     * spec represents specification of the desired attach/detach volume behavior.
     * Populated by the Kubernetes system.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
     * @return The spec.
     */
    io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec getSpec();
    /**
     * <pre>
     * spec represents specification of the desired attach/detach volume behavior.
     * Populated by the Kubernetes system.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * status represents status of the VolumeAttachment request.
     * Populated by the entity completing the attach or detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * status represents status of the VolumeAttachment request.
     * Populated by the entity completing the attach or detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
     * @return The status.
     */
    io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus getStatus();
    /**
     * <pre>
     * status represents status of the VolumeAttachment request.
     * Populated by the entity completing the attach or detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * VolumeAttachment captures the intent to attach or detach the specified volume
   * to/from the specified node.
   *
   * VolumeAttachment objects are non-namespaced.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachment}
   */
  public static final class VolumeAttachment extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.VolumeAttachment)
      VolumeAttachmentOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        VolumeAttachment.class.getName());
    }
    // Use VolumeAttachment.newBuilder() to construct.
    private VolumeAttachment(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private VolumeAttachment() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachment_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachment_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.VolumeAttachment.class, io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec spec_;
    /**
     * <pre>
     * spec represents specification of the desired attach/detach volume behavior.
     * Populated by the Kubernetes system.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    @java.lang.Override
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * spec represents specification of the desired attach/detach volume behavior.
     * Populated by the Kubernetes system.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
     * @return The spec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * spec represents specification of the desired attach/detach volume behavior.
     * Populated by the Kubernetes system.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus status_;
    /**
     * <pre>
     * status represents status of the VolumeAttachment request.
     * Populated by the entity completing the attach or detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * status represents status of the VolumeAttachment request.
     * Populated by the entity completing the attach or detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
     * @return The status.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * status represents status of the VolumeAttachment request.
     * Populated by the entity completing the attach or detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getStatus());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachment)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.VolumeAttachment other = (io.kubernetes.client.proto.V1Storage.VolumeAttachment) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasSpec() != other.hasSpec()) return false;
      if (hasSpec()) {
        if (!getSpec()
            .equals(other.getSpec())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.VolumeAttachment prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * VolumeAttachment captures the intent to attach or detach the specified volume
     * to/from the specified node.
     *
     * VolumeAttachment objects are non-namespaced.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachment}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.VolumeAttachment)
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachment_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachment_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.VolumeAttachment.class, io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.VolumeAttachment.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachment_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachment getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.VolumeAttachment.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachment build() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachment result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachment buildPartial() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachment result = new io.kubernetes.client.proto.V1Storage.VolumeAttachment(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.VolumeAttachment result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.spec_ = specBuilder_ == null
              ? spec_
              : specBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.status_ = statusBuilder_ == null
              ? status_
              : statusBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachment) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.VolumeAttachment)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.VolumeAttachment other) {
        if (other == io.kubernetes.client.proto.V1Storage.VolumeAttachment.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getStatusFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec spec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * spec represents specification of the desired attach/detach volume behavior.
       * Populated by the Kubernetes system.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
       * @return Whether the spec field is set.
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * spec represents specification of the desired attach/detach volume behavior.
       * Populated by the Kubernetes system.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
       * @return The spec.
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * spec represents specification of the desired attach/detach volume behavior.
       * Populated by the Kubernetes system.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * spec represents specification of the desired attach/detach volume behavior.
       * Populated by the Kubernetes system.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * spec represents specification of the desired attach/detach volume behavior.
       * Populated by the Kubernetes system.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            spec_ != null &&
            spec_ != io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.getDefaultInstance()) {
            getSpecBuilder().mergeFrom(value);
          } else {
            spec_ = value;
          }
        } else {
          specBuilder_.mergeFrom(value);
        }
        if (spec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * spec represents specification of the desired attach/detach volume behavior.
       * Populated by the Kubernetes system.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * spec represents specification of the desired attach/detach volume behavior.
       * Populated by the Kubernetes system.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * spec represents specification of the desired attach/detach volume behavior.
       * Populated by the Kubernetes system.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * spec represents specification of the desired attach/detach volume behavior.
       * Populated by the Kubernetes system.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus status_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus, io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * status represents status of the VolumeAttachment request.
       * Populated by the entity completing the attach or detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * status represents status of the VolumeAttachment request.
       * Populated by the entity completing the attach or detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
       * @return The status.
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * status represents status of the VolumeAttachment request.
       * Populated by the entity completing the attach or detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * status represents status of the VolumeAttachment request.
       * Populated by the entity completing the attach or detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * status represents status of the VolumeAttachment request.
       * Populated by the entity completing the attach or detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            status_ != null &&
            status_ != io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.getDefaultInstance()) {
            getStatusBuilder().mergeFrom(value);
          } else {
            status_ = value;
          }
        } else {
          statusBuilder_.mergeFrom(value);
        }
        if (status_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * status represents status of the VolumeAttachment request.
       * Populated by the entity completing the attach or detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000004);
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * status represents status of the VolumeAttachment request.
       * Populated by the entity completing the attach or detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * status represents status of the VolumeAttachment request.
       * Populated by the entity completing the attach or detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * status represents status of the VolumeAttachment request.
       * Populated by the entity completing the attach or detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus, io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus, io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.VolumeAttachment)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.VolumeAttachment)
    private static final io.kubernetes.client.proto.V1Storage.VolumeAttachment DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.VolumeAttachment();
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachment getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeAttachment>
        PARSER = new com.google.protobuf.AbstractParser<VolumeAttachment>() {
      @java.lang.Override
      public VolumeAttachment parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VolumeAttachment> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeAttachment> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachment getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeAttachmentListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.VolumeAttachmentList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Storage.VolumeAttachment> 
        getItemsList();
    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.VolumeAttachment getItems(int index);
    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * VolumeAttachmentList is a collection of VolumeAttachment objects.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachmentList}
   */
  public static final class VolumeAttachmentList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.VolumeAttachmentList)
      VolumeAttachmentListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        VolumeAttachmentList.class.getName());
    }
    // Use VolumeAttachmentList.newBuilder() to construct.
    private VolumeAttachmentList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private VolumeAttachmentList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentList.class, io.kubernetes.client.proto.V1Storage.VolumeAttachmentList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Storage.VolumeAttachment> items_;
    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Storage.VolumeAttachment> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachment getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * items is the list of VolumeAttachments
     * </pre>
     *
     * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachmentList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.VolumeAttachmentList other = (io.kubernetes.client.proto.V1Storage.VolumeAttachmentList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.VolumeAttachmentList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * VolumeAttachmentList is a collection of VolumeAttachment objects.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachmentList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.VolumeAttachmentList)
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.VolumeAttachmentList.class, io.kubernetes.client.proto.V1Storage.VolumeAttachmentList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.VolumeAttachmentList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.VolumeAttachmentList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentList build() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentList buildPartial() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentList result = new io.kubernetes.client.proto.V1Storage.VolumeAttachmentList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Storage.VolumeAttachmentList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.VolumeAttachmentList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachmentList) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.VolumeAttachmentList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.VolumeAttachmentList other) {
        if (other == io.kubernetes.client.proto.V1Storage.VolumeAttachmentList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Storage.VolumeAttachment m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Storage.VolumeAttachment.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Storage.VolumeAttachment> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Storage.VolumeAttachment>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeAttachment, io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.VolumeAttachment> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachment getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.VolumeAttachment value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Storage.VolumeAttachment value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.VolumeAttachment value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Storage.VolumeAttachment> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Storage.VolumeAttachment.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Storage.VolumeAttachment.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of VolumeAttachments
       * </pre>
       *
       * <code>repeated .k8s.io.api.storage.v1.VolumeAttachment items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeAttachment, io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Storage.VolumeAttachment, io.kubernetes.client.proto.V1Storage.VolumeAttachment.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.VolumeAttachmentList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.VolumeAttachmentList)
    private static final io.kubernetes.client.proto.V1Storage.VolumeAttachmentList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.VolumeAttachmentList();
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeAttachmentList>
        PARSER = new com.google.protobuf.AbstractParser<VolumeAttachmentList>() {
      @java.lang.Override
      public VolumeAttachmentList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VolumeAttachmentList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeAttachmentList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeAttachmentSourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.VolumeAttachmentSource)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * persistentVolumeName represents the name of the persistent volume to attach.
     * +optional
     * </pre>
     *
     * <code>optional string persistentVolumeName = 1;</code>
     * @return Whether the persistentVolumeName field is set.
     */
    boolean hasPersistentVolumeName();
    /**
     * <pre>
     * persistentVolumeName represents the name of the persistent volume to attach.
     * +optional
     * </pre>
     *
     * <code>optional string persistentVolumeName = 1;</code>
     * @return The persistentVolumeName.
     */
    java.lang.String getPersistentVolumeName();
    /**
     * <pre>
     * persistentVolumeName represents the name of the persistent volume to attach.
     * +optional
     * </pre>
     *
     * <code>optional string persistentVolumeName = 1;</code>
     * @return The bytes for persistentVolumeName.
     */
    com.google.protobuf.ByteString
        getPersistentVolumeNameBytes();

    /**
     * <pre>
     * inlineVolumeSpec contains all the information necessary to attach
     * a persistent volume defined by a pod's inline VolumeSource. This field
     * is populated only for the CSIMigration feature. It contains
     * translated fields from a pod's inline VolumeSource to a
     * PersistentVolumeSpec. This field is beta-level and is only
     * honored by servers that enabled the CSIMigration feature.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
     * @return Whether the inlineVolumeSpec field is set.
     */
    boolean hasInlineVolumeSpec();
    /**
     * <pre>
     * inlineVolumeSpec contains all the information necessary to attach
     * a persistent volume defined by a pod's inline VolumeSource. This field
     * is populated only for the CSIMigration feature. It contains
     * translated fields from a pod's inline VolumeSource to a
     * PersistentVolumeSpec. This field is beta-level and is only
     * honored by servers that enabled the CSIMigration feature.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
     * @return The inlineVolumeSpec.
     */
    io.kubernetes.client.proto.V1.PersistentVolumeSpec getInlineVolumeSpec();
    /**
     * <pre>
     * inlineVolumeSpec contains all the information necessary to attach
     * a persistent volume defined by a pod's inline VolumeSource. This field
     * is populated only for the CSIMigration feature. It contains
     * translated fields from a pod's inline VolumeSource to a
     * PersistentVolumeSpec. This field is beta-level and is only
     * honored by servers that enabled the CSIMigration feature.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
     */
    io.kubernetes.client.proto.V1.PersistentVolumeSpecOrBuilder getInlineVolumeSpecOrBuilder();
  }
  /**
   * <pre>
   * VolumeAttachmentSource represents a volume that should be attached.
   * Right now only PersistenVolumes can be attached via external attacher,
   * in future we may allow also inline volumes in pods.
   * Exactly one member can be set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachmentSource}
   */
  public static final class VolumeAttachmentSource extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.VolumeAttachmentSource)
      VolumeAttachmentSourceOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        VolumeAttachmentSource.class.getName());
    }
    // Use VolumeAttachmentSource.newBuilder() to construct.
    private VolumeAttachmentSource(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private VolumeAttachmentSource() {
      persistentVolumeName_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.class, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.Builder.class);
    }

    private int bitField0_;
    public static final int PERSISTENTVOLUMENAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object persistentVolumeName_ = "";
    /**
     * <pre>
     * persistentVolumeName represents the name of the persistent volume to attach.
     * +optional
     * </pre>
     *
     * <code>optional string persistentVolumeName = 1;</code>
     * @return Whether the persistentVolumeName field is set.
     */
    @java.lang.Override
    public boolean hasPersistentVolumeName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * persistentVolumeName represents the name of the persistent volume to attach.
     * +optional
     * </pre>
     *
     * <code>optional string persistentVolumeName = 1;</code>
     * @return The persistentVolumeName.
     */
    @java.lang.Override
    public java.lang.String getPersistentVolumeName() {
      java.lang.Object ref = persistentVolumeName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          persistentVolumeName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * persistentVolumeName represents the name of the persistent volume to attach.
     * +optional
     * </pre>
     *
     * <code>optional string persistentVolumeName = 1;</code>
     * @return The bytes for persistentVolumeName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPersistentVolumeNameBytes() {
      java.lang.Object ref = persistentVolumeName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        persistentVolumeName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INLINEVOLUMESPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1.PersistentVolumeSpec inlineVolumeSpec_;
    /**
     * <pre>
     * inlineVolumeSpec contains all the information necessary to attach
     * a persistent volume defined by a pod's inline VolumeSource. This field
     * is populated only for the CSIMigration feature. It contains
     * translated fields from a pod's inline VolumeSource to a
     * PersistentVolumeSpec. This field is beta-level and is only
     * honored by servers that enabled the CSIMigration feature.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
     * @return Whether the inlineVolumeSpec field is set.
     */
    @java.lang.Override
    public boolean hasInlineVolumeSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * inlineVolumeSpec contains all the information necessary to attach
     * a persistent volume defined by a pod's inline VolumeSource. This field
     * is populated only for the CSIMigration feature. It contains
     * translated fields from a pod's inline VolumeSource to a
     * PersistentVolumeSpec. This field is beta-level and is only
     * honored by servers that enabled the CSIMigration feature.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
     * @return The inlineVolumeSpec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PersistentVolumeSpec getInlineVolumeSpec() {
      return inlineVolumeSpec_ == null ? io.kubernetes.client.proto.V1.PersistentVolumeSpec.getDefaultInstance() : inlineVolumeSpec_;
    }
    /**
     * <pre>
     * inlineVolumeSpec contains all the information necessary to attach
     * a persistent volume defined by a pod's inline VolumeSource. This field
     * is populated only for the CSIMigration feature. It contains
     * translated fields from a pod's inline VolumeSource to a
     * PersistentVolumeSpec. This field is beta-level and is only
     * honored by servers that enabled the CSIMigration feature.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PersistentVolumeSpecOrBuilder getInlineVolumeSpecOrBuilder() {
      return inlineVolumeSpec_ == null ? io.kubernetes.client.proto.V1.PersistentVolumeSpec.getDefaultInstance() : inlineVolumeSpec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, persistentVolumeName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getInlineVolumeSpec());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, persistentVolumeName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getInlineVolumeSpec());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource other = (io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource) obj;

      if (hasPersistentVolumeName() != other.hasPersistentVolumeName()) return false;
      if (hasPersistentVolumeName()) {
        if (!getPersistentVolumeName()
            .equals(other.getPersistentVolumeName())) return false;
      }
      if (hasInlineVolumeSpec() != other.hasInlineVolumeSpec()) return false;
      if (hasInlineVolumeSpec()) {
        if (!getInlineVolumeSpec()
            .equals(other.getInlineVolumeSpec())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPersistentVolumeName()) {
        hash = (37 * hash) + PERSISTENTVOLUMENAME_FIELD_NUMBER;
        hash = (53 * hash) + getPersistentVolumeName().hashCode();
      }
      if (hasInlineVolumeSpec()) {
        hash = (37 * hash) + INLINEVOLUMESPEC_FIELD_NUMBER;
        hash = (53 * hash) + getInlineVolumeSpec().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * VolumeAttachmentSource represents a volume that should be attached.
     * Right now only PersistenVolumes can be attached via external attacher,
     * in future we may allow also inline volumes in pods.
     * Exactly one member can be set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachmentSource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.VolumeAttachmentSource)
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentSourceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.class, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getInlineVolumeSpecFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        persistentVolumeName_ = "";
        inlineVolumeSpec_ = null;
        if (inlineVolumeSpecBuilder_ != null) {
          inlineVolumeSpecBuilder_.dispose();
          inlineVolumeSpecBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource build() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource buildPartial() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource result = new io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.persistentVolumeName_ = persistentVolumeName_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.inlineVolumeSpec_ = inlineVolumeSpecBuilder_ == null
              ? inlineVolumeSpec_
              : inlineVolumeSpecBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource other) {
        if (other == io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.getDefaultInstance()) return this;
        if (other.hasPersistentVolumeName()) {
          persistentVolumeName_ = other.persistentVolumeName_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasInlineVolumeSpec()) {
          mergeInlineVolumeSpec(other.getInlineVolumeSpec());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                persistentVolumeName_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getInlineVolumeSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object persistentVolumeName_ = "";
      /**
       * <pre>
       * persistentVolumeName represents the name of the persistent volume to attach.
       * +optional
       * </pre>
       *
       * <code>optional string persistentVolumeName = 1;</code>
       * @return Whether the persistentVolumeName field is set.
       */
      public boolean hasPersistentVolumeName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * persistentVolumeName represents the name of the persistent volume to attach.
       * +optional
       * </pre>
       *
       * <code>optional string persistentVolumeName = 1;</code>
       * @return The persistentVolumeName.
       */
      public java.lang.String getPersistentVolumeName() {
        java.lang.Object ref = persistentVolumeName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            persistentVolumeName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * persistentVolumeName represents the name of the persistent volume to attach.
       * +optional
       * </pre>
       *
       * <code>optional string persistentVolumeName = 1;</code>
       * @return The bytes for persistentVolumeName.
       */
      public com.google.protobuf.ByteString
          getPersistentVolumeNameBytes() {
        java.lang.Object ref = persistentVolumeName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          persistentVolumeName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * persistentVolumeName represents the name of the persistent volume to attach.
       * +optional
       * </pre>
       *
       * <code>optional string persistentVolumeName = 1;</code>
       * @param value The persistentVolumeName to set.
       * @return This builder for chaining.
       */
      public Builder setPersistentVolumeName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        persistentVolumeName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * persistentVolumeName represents the name of the persistent volume to attach.
       * +optional
       * </pre>
       *
       * <code>optional string persistentVolumeName = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPersistentVolumeName() {
        persistentVolumeName_ = getDefaultInstance().getPersistentVolumeName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * persistentVolumeName represents the name of the persistent volume to attach.
       * +optional
       * </pre>
       *
       * <code>optional string persistentVolumeName = 1;</code>
       * @param value The bytes for persistentVolumeName to set.
       * @return This builder for chaining.
       */
      public Builder setPersistentVolumeNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        persistentVolumeName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1.PersistentVolumeSpec inlineVolumeSpec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PersistentVolumeSpec, io.kubernetes.client.proto.V1.PersistentVolumeSpec.Builder, io.kubernetes.client.proto.V1.PersistentVolumeSpecOrBuilder> inlineVolumeSpecBuilder_;
      /**
       * <pre>
       * inlineVolumeSpec contains all the information necessary to attach
       * a persistent volume defined by a pod's inline VolumeSource. This field
       * is populated only for the CSIMigration feature. It contains
       * translated fields from a pod's inline VolumeSource to a
       * PersistentVolumeSpec. This field is beta-level and is only
       * honored by servers that enabled the CSIMigration feature.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
       * @return Whether the inlineVolumeSpec field is set.
       */
      public boolean hasInlineVolumeSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * inlineVolumeSpec contains all the information necessary to attach
       * a persistent volume defined by a pod's inline VolumeSource. This field
       * is populated only for the CSIMigration feature. It contains
       * translated fields from a pod's inline VolumeSource to a
       * PersistentVolumeSpec. This field is beta-level and is only
       * honored by servers that enabled the CSIMigration feature.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
       * @return The inlineVolumeSpec.
       */
      public io.kubernetes.client.proto.V1.PersistentVolumeSpec getInlineVolumeSpec() {
        if (inlineVolumeSpecBuilder_ == null) {
          return inlineVolumeSpec_ == null ? io.kubernetes.client.proto.V1.PersistentVolumeSpec.getDefaultInstance() : inlineVolumeSpec_;
        } else {
          return inlineVolumeSpecBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * inlineVolumeSpec contains all the information necessary to attach
       * a persistent volume defined by a pod's inline VolumeSource. This field
       * is populated only for the CSIMigration feature. It contains
       * translated fields from a pod's inline VolumeSource to a
       * PersistentVolumeSpec. This field is beta-level and is only
       * honored by servers that enabled the CSIMigration feature.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
       */
      public Builder setInlineVolumeSpec(io.kubernetes.client.proto.V1.PersistentVolumeSpec value) {
        if (inlineVolumeSpecBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          inlineVolumeSpec_ = value;
        } else {
          inlineVolumeSpecBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * inlineVolumeSpec contains all the information necessary to attach
       * a persistent volume defined by a pod's inline VolumeSource. This field
       * is populated only for the CSIMigration feature. It contains
       * translated fields from a pod's inline VolumeSource to a
       * PersistentVolumeSpec. This field is beta-level and is only
       * honored by servers that enabled the CSIMigration feature.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
       */
      public Builder setInlineVolumeSpec(
          io.kubernetes.client.proto.V1.PersistentVolumeSpec.Builder builderForValue) {
        if (inlineVolumeSpecBuilder_ == null) {
          inlineVolumeSpec_ = builderForValue.build();
        } else {
          inlineVolumeSpecBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * inlineVolumeSpec contains all the information necessary to attach
       * a persistent volume defined by a pod's inline VolumeSource. This field
       * is populated only for the CSIMigration feature. It contains
       * translated fields from a pod's inline VolumeSource to a
       * PersistentVolumeSpec. This field is beta-level and is only
       * honored by servers that enabled the CSIMigration feature.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
       */
      public Builder mergeInlineVolumeSpec(io.kubernetes.client.proto.V1.PersistentVolumeSpec value) {
        if (inlineVolumeSpecBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            inlineVolumeSpec_ != null &&
            inlineVolumeSpec_ != io.kubernetes.client.proto.V1.PersistentVolumeSpec.getDefaultInstance()) {
            getInlineVolumeSpecBuilder().mergeFrom(value);
          } else {
            inlineVolumeSpec_ = value;
          }
        } else {
          inlineVolumeSpecBuilder_.mergeFrom(value);
        }
        if (inlineVolumeSpec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * inlineVolumeSpec contains all the information necessary to attach
       * a persistent volume defined by a pod's inline VolumeSource. This field
       * is populated only for the CSIMigration feature. It contains
       * translated fields from a pod's inline VolumeSource to a
       * PersistentVolumeSpec. This field is beta-level and is only
       * honored by servers that enabled the CSIMigration feature.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
       */
      public Builder clearInlineVolumeSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        inlineVolumeSpec_ = null;
        if (inlineVolumeSpecBuilder_ != null) {
          inlineVolumeSpecBuilder_.dispose();
          inlineVolumeSpecBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * inlineVolumeSpec contains all the information necessary to attach
       * a persistent volume defined by a pod's inline VolumeSource. This field
       * is populated only for the CSIMigration feature. It contains
       * translated fields from a pod's inline VolumeSource to a
       * PersistentVolumeSpec. This field is beta-level and is only
       * honored by servers that enabled the CSIMigration feature.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PersistentVolumeSpec.Builder getInlineVolumeSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getInlineVolumeSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * inlineVolumeSpec contains all the information necessary to attach
       * a persistent volume defined by a pod's inline VolumeSource. This field
       * is populated only for the CSIMigration feature. It contains
       * translated fields from a pod's inline VolumeSource to a
       * PersistentVolumeSpec. This field is beta-level and is only
       * honored by servers that enabled the CSIMigration feature.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PersistentVolumeSpecOrBuilder getInlineVolumeSpecOrBuilder() {
        if (inlineVolumeSpecBuilder_ != null) {
          return inlineVolumeSpecBuilder_.getMessageOrBuilder();
        } else {
          return inlineVolumeSpec_ == null ?
              io.kubernetes.client.proto.V1.PersistentVolumeSpec.getDefaultInstance() : inlineVolumeSpec_;
        }
      }
      /**
       * <pre>
       * inlineVolumeSpec contains all the information necessary to attach
       * a persistent volume defined by a pod's inline VolumeSource. This field
       * is populated only for the CSIMigration feature. It contains
       * translated fields from a pod's inline VolumeSource to a
       * PersistentVolumeSpec. This field is beta-level and is only
       * honored by servers that enabled the CSIMigration feature.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PersistentVolumeSpec, io.kubernetes.client.proto.V1.PersistentVolumeSpec.Builder, io.kubernetes.client.proto.V1.PersistentVolumeSpecOrBuilder> 
          getInlineVolumeSpecFieldBuilder() {
        if (inlineVolumeSpecBuilder_ == null) {
          inlineVolumeSpecBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1.PersistentVolumeSpec, io.kubernetes.client.proto.V1.PersistentVolumeSpec.Builder, io.kubernetes.client.proto.V1.PersistentVolumeSpecOrBuilder>(
                  getInlineVolumeSpec(),
                  getParentForChildren(),
                  isClean());
          inlineVolumeSpec_ = null;
        }
        return inlineVolumeSpecBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.VolumeAttachmentSource)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.VolumeAttachmentSource)
    private static final io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource();
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeAttachmentSource>
        PARSER = new com.google.protobuf.AbstractParser<VolumeAttachmentSource>() {
      @java.lang.Override
      public VolumeAttachmentSource parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VolumeAttachmentSource> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeAttachmentSource> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeAttachmentSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.VolumeAttachmentSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * attacher indicates the name of the volume driver that MUST handle this
     * request. This is the name returned by GetPluginName().
     * </pre>
     *
     * <code>optional string attacher = 1;</code>
     * @return Whether the attacher field is set.
     */
    boolean hasAttacher();
    /**
     * <pre>
     * attacher indicates the name of the volume driver that MUST handle this
     * request. This is the name returned by GetPluginName().
     * </pre>
     *
     * <code>optional string attacher = 1;</code>
     * @return The attacher.
     */
    java.lang.String getAttacher();
    /**
     * <pre>
     * attacher indicates the name of the volume driver that MUST handle this
     * request. This is the name returned by GetPluginName().
     * </pre>
     *
     * <code>optional string attacher = 1;</code>
     * @return The bytes for attacher.
     */
    com.google.protobuf.ByteString
        getAttacherBytes();

    /**
     * <pre>
     * source represents the volume that should be attached.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
     * @return Whether the source field is set.
     */
    boolean hasSource();
    /**
     * <pre>
     * source represents the volume that should be attached.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
     * @return The source.
     */
    io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource getSource();
    /**
     * <pre>
     * source represents the volume that should be attached.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
     */
    io.kubernetes.client.proto.V1Storage.VolumeAttachmentSourceOrBuilder getSourceOrBuilder();

    /**
     * <pre>
     * nodeName represents the node that the volume should be attached to.
     * </pre>
     *
     * <code>optional string nodeName = 3;</code>
     * @return Whether the nodeName field is set.
     */
    boolean hasNodeName();
    /**
     * <pre>
     * nodeName represents the node that the volume should be attached to.
     * </pre>
     *
     * <code>optional string nodeName = 3;</code>
     * @return The nodeName.
     */
    java.lang.String getNodeName();
    /**
     * <pre>
     * nodeName represents the node that the volume should be attached to.
     * </pre>
     *
     * <code>optional string nodeName = 3;</code>
     * @return The bytes for nodeName.
     */
    com.google.protobuf.ByteString
        getNodeNameBytes();
  }
  /**
   * <pre>
   * VolumeAttachmentSpec is the specification of a VolumeAttachment request.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachmentSpec}
   */
  public static final class VolumeAttachmentSpec extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.VolumeAttachmentSpec)
      VolumeAttachmentSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        VolumeAttachmentSpec.class.getName());
    }
    // Use VolumeAttachmentSpec.newBuilder() to construct.
    private VolumeAttachmentSpec(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private VolumeAttachmentSpec() {
      attacher_ = "";
      nodeName_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.class, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.Builder.class);
    }

    private int bitField0_;
    public static final int ATTACHER_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object attacher_ = "";
    /**
     * <pre>
     * attacher indicates the name of the volume driver that MUST handle this
     * request. This is the name returned by GetPluginName().
     * </pre>
     *
     * <code>optional string attacher = 1;</code>
     * @return Whether the attacher field is set.
     */
    @java.lang.Override
    public boolean hasAttacher() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * attacher indicates the name of the volume driver that MUST handle this
     * request. This is the name returned by GetPluginName().
     * </pre>
     *
     * <code>optional string attacher = 1;</code>
     * @return The attacher.
     */
    @java.lang.Override
    public java.lang.String getAttacher() {
      java.lang.Object ref = attacher_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          attacher_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * attacher indicates the name of the volume driver that MUST handle this
     * request. This is the name returned by GetPluginName().
     * </pre>
     *
     * <code>optional string attacher = 1;</code>
     * @return The bytes for attacher.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAttacherBytes() {
      java.lang.Object ref = attacher_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        attacher_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SOURCE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource source_;
    /**
     * <pre>
     * source represents the volume that should be attached.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
     * @return Whether the source field is set.
     */
    @java.lang.Override
    public boolean hasSource() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * source represents the volume that should be attached.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
     * @return The source.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource getSource() {
      return source_ == null ? io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.getDefaultInstance() : source_;
    }
    /**
     * <pre>
     * source represents the volume that should be attached.
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSourceOrBuilder getSourceOrBuilder() {
      return source_ == null ? io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.getDefaultInstance() : source_;
    }

    public static final int NODENAME_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object nodeName_ = "";
    /**
     * <pre>
     * nodeName represents the node that the volume should be attached to.
     * </pre>
     *
     * <code>optional string nodeName = 3;</code>
     * @return Whether the nodeName field is set.
     */
    @java.lang.Override
    public boolean hasNodeName() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * nodeName represents the node that the volume should be attached to.
     * </pre>
     *
     * <code>optional string nodeName = 3;</code>
     * @return The nodeName.
     */
    @java.lang.Override
    public java.lang.String getNodeName() {
      java.lang.Object ref = nodeName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          nodeName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * nodeName represents the node that the volume should be attached to.
     * </pre>
     *
     * <code>optional string nodeName = 3;</code>
     * @return The bytes for nodeName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNodeNameBytes() {
      java.lang.Object ref = nodeName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, attacher_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSource());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, nodeName_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, attacher_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSource());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, nodeName_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec other = (io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec) obj;

      if (hasAttacher() != other.hasAttacher()) return false;
      if (hasAttacher()) {
        if (!getAttacher()
            .equals(other.getAttacher())) return false;
      }
      if (hasSource() != other.hasSource()) return false;
      if (hasSource()) {
        if (!getSource()
            .equals(other.getSource())) return false;
      }
      if (hasNodeName() != other.hasNodeName()) return false;
      if (hasNodeName()) {
        if (!getNodeName()
            .equals(other.getNodeName())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAttacher()) {
        hash = (37 * hash) + ATTACHER_FIELD_NUMBER;
        hash = (53 * hash) + getAttacher().hashCode();
      }
      if (hasSource()) {
        hash = (37 * hash) + SOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getSource().hashCode();
      }
      if (hasNodeName()) {
        hash = (37 * hash) + NODENAME_FIELD_NUMBER;
        hash = (53 * hash) + getNodeName().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * VolumeAttachmentSpec is the specification of a VolumeAttachment request.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachmentSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.VolumeAttachmentSpec)
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.class, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getSourceFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        attacher_ = "";
        source_ = null;
        if (sourceBuilder_ != null) {
          sourceBuilder_.dispose();
          sourceBuilder_ = null;
        }
        nodeName_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec build() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec buildPartial() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec result = new io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.attacher_ = attacher_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.source_ = sourceBuilder_ == null
              ? source_
              : sourceBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.nodeName_ = nodeName_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec other) {
        if (other == io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec.getDefaultInstance()) return this;
        if (other.hasAttacher()) {
          attacher_ = other.attacher_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasSource()) {
          mergeSource(other.getSource());
        }
        if (other.hasNodeName()) {
          nodeName_ = other.nodeName_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                attacher_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSourceFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                nodeName_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object attacher_ = "";
      /**
       * <pre>
       * attacher indicates the name of the volume driver that MUST handle this
       * request. This is the name returned by GetPluginName().
       * </pre>
       *
       * <code>optional string attacher = 1;</code>
       * @return Whether the attacher field is set.
       */
      public boolean hasAttacher() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * attacher indicates the name of the volume driver that MUST handle this
       * request. This is the name returned by GetPluginName().
       * </pre>
       *
       * <code>optional string attacher = 1;</code>
       * @return The attacher.
       */
      public java.lang.String getAttacher() {
        java.lang.Object ref = attacher_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            attacher_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * attacher indicates the name of the volume driver that MUST handle this
       * request. This is the name returned by GetPluginName().
       * </pre>
       *
       * <code>optional string attacher = 1;</code>
       * @return The bytes for attacher.
       */
      public com.google.protobuf.ByteString
          getAttacherBytes() {
        java.lang.Object ref = attacher_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          attacher_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * attacher indicates the name of the volume driver that MUST handle this
       * request. This is the name returned by GetPluginName().
       * </pre>
       *
       * <code>optional string attacher = 1;</code>
       * @param value The attacher to set.
       * @return This builder for chaining.
       */
      public Builder setAttacher(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        attacher_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * attacher indicates the name of the volume driver that MUST handle this
       * request. This is the name returned by GetPluginName().
       * </pre>
       *
       * <code>optional string attacher = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAttacher() {
        attacher_ = getDefaultInstance().getAttacher();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * attacher indicates the name of the volume driver that MUST handle this
       * request. This is the name returned by GetPluginName().
       * </pre>
       *
       * <code>optional string attacher = 1;</code>
       * @param value The bytes for attacher to set.
       * @return This builder for chaining.
       */
      public Builder setAttacherBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        attacher_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource source_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSourceOrBuilder> sourceBuilder_;
      /**
       * <pre>
       * source represents the volume that should be attached.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
       * @return Whether the source field is set.
       */
      public boolean hasSource() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * source represents the volume that should be attached.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
       * @return The source.
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource getSource() {
        if (sourceBuilder_ == null) {
          return source_ == null ? io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.getDefaultInstance() : source_;
        } else {
          return sourceBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * source represents the volume that should be attached.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
       */
      public Builder setSource(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource value) {
        if (sourceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          source_ = value;
        } else {
          sourceBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * source represents the volume that should be attached.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
       */
      public Builder setSource(
          io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.Builder builderForValue) {
        if (sourceBuilder_ == null) {
          source_ = builderForValue.build();
        } else {
          sourceBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * source represents the volume that should be attached.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
       */
      public Builder mergeSource(io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource value) {
        if (sourceBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            source_ != null &&
            source_ != io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.getDefaultInstance()) {
            getSourceBuilder().mergeFrom(value);
          } else {
            source_ = value;
          }
        } else {
          sourceBuilder_.mergeFrom(value);
        }
        if (source_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * source represents the volume that should be attached.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
       */
      public Builder clearSource() {
        bitField0_ = (bitField0_ & ~0x00000002);
        source_ = null;
        if (sourceBuilder_ != null) {
          sourceBuilder_.dispose();
          sourceBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * source represents the volume that should be attached.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.Builder getSourceBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSourceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * source represents the volume that should be attached.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSourceOrBuilder getSourceOrBuilder() {
        if (sourceBuilder_ != null) {
          return sourceBuilder_.getMessageOrBuilder();
        } else {
          return source_ == null ?
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.getDefaultInstance() : source_;
        }
      }
      /**
       * <pre>
       * source represents the volume that should be attached.
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeAttachmentSource source = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSourceOrBuilder> 
          getSourceFieldBuilder() {
        if (sourceBuilder_ == null) {
          sourceBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSource.Builder, io.kubernetes.client.proto.V1Storage.VolumeAttachmentSourceOrBuilder>(
                  getSource(),
                  getParentForChildren(),
                  isClean());
          source_ = null;
        }
        return sourceBuilder_;
      }

      private java.lang.Object nodeName_ = "";
      /**
       * <pre>
       * nodeName represents the node that the volume should be attached to.
       * </pre>
       *
       * <code>optional string nodeName = 3;</code>
       * @return Whether the nodeName field is set.
       */
      public boolean hasNodeName() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * nodeName represents the node that the volume should be attached to.
       * </pre>
       *
       * <code>optional string nodeName = 3;</code>
       * @return The nodeName.
       */
      public java.lang.String getNodeName() {
        java.lang.Object ref = nodeName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            nodeName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * nodeName represents the node that the volume should be attached to.
       * </pre>
       *
       * <code>optional string nodeName = 3;</code>
       * @return The bytes for nodeName.
       */
      public com.google.protobuf.ByteString
          getNodeNameBytes() {
        java.lang.Object ref = nodeName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * nodeName represents the node that the volume should be attached to.
       * </pre>
       *
       * <code>optional string nodeName = 3;</code>
       * @param value The nodeName to set.
       * @return This builder for chaining.
       */
      public Builder setNodeName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        nodeName_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * nodeName represents the node that the volume should be attached to.
       * </pre>
       *
       * <code>optional string nodeName = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNodeName() {
        nodeName_ = getDefaultInstance().getNodeName();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * nodeName represents the node that the volume should be attached to.
       * </pre>
       *
       * <code>optional string nodeName = 3;</code>
       * @param value The bytes for nodeName to set.
       * @return This builder for chaining.
       */
      public Builder setNodeNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        nodeName_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.VolumeAttachmentSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.VolumeAttachmentSpec)
    private static final io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec();
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeAttachmentSpec>
        PARSER = new com.google.protobuf.AbstractParser<VolumeAttachmentSpec>() {
      @java.lang.Override
      public VolumeAttachmentSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VolumeAttachmentSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeAttachmentSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeAttachmentStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.VolumeAttachmentStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * attached indicates the volume is successfully attached.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * </pre>
     *
     * <code>optional bool attached = 1;</code>
     * @return Whether the attached field is set.
     */
    boolean hasAttached();
    /**
     * <pre>
     * attached indicates the volume is successfully attached.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * </pre>
     *
     * <code>optional bool attached = 1;</code>
     * @return The attached.
     */
    boolean getAttached();

    /**
     * <pre>
     * attachmentMetadata is populated with any
     * information returned by the attach operation, upon successful attach, that must be passed
     * into subsequent WaitForAttach or Mount calls.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
     */
    int getAttachmentMetadataCount();
    /**
     * <pre>
     * attachmentMetadata is populated with any
     * information returned by the attach operation, upon successful attach, that must be passed
     * into subsequent WaitForAttach or Mount calls.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
     */
    boolean containsAttachmentMetadata(
        java.lang.String key);
    /**
     * Use {@link #getAttachmentMetadataMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getAttachmentMetadata();
    /**
     * <pre>
     * attachmentMetadata is populated with any
     * information returned by the attach operation, upon successful attach, that must be passed
     * into subsequent WaitForAttach or Mount calls.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getAttachmentMetadataMap();
    /**
     * <pre>
     * attachmentMetadata is populated with any
     * information returned by the attach operation, upon successful attach, that must be passed
     * into subsequent WaitForAttach or Mount calls.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
     */
    /* nullable */
java.lang.String getAttachmentMetadataOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue);
    /**
     * <pre>
     * attachmentMetadata is populated with any
     * information returned by the attach operation, upon successful attach, that must be passed
     * into subsequent WaitForAttach or Mount calls.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
     */
    java.lang.String getAttachmentMetadataOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * attachError represents the last error encountered during attach operation, if any.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
     * @return Whether the attachError field is set.
     */
    boolean hasAttachError();
    /**
     * <pre>
     * attachError represents the last error encountered during attach operation, if any.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
     * @return The attachError.
     */
    io.kubernetes.client.proto.V1Storage.VolumeError getAttachError();
    /**
     * <pre>
     * attachError represents the last error encountered during attach operation, if any.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
     */
    io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder getAttachErrorOrBuilder();

    /**
     * <pre>
     * detachError represents the last error encountered during detach operation, if any.
     * This field must only be set by the entity completing the detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
     * @return Whether the detachError field is set.
     */
    boolean hasDetachError();
    /**
     * <pre>
     * detachError represents the last error encountered during detach operation, if any.
     * This field must only be set by the entity completing the detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
     * @return The detachError.
     */
    io.kubernetes.client.proto.V1Storage.VolumeError getDetachError();
    /**
     * <pre>
     * detachError represents the last error encountered during detach operation, if any.
     * This field must only be set by the entity completing the detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
     */
    io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder getDetachErrorOrBuilder();
  }
  /**
   * <pre>
   * VolumeAttachmentStatus is the status of a VolumeAttachment request.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachmentStatus}
   */
  public static final class VolumeAttachmentStatus extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.VolumeAttachmentStatus)
      VolumeAttachmentStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        VolumeAttachmentStatus.class.getName());
    }
    // Use VolumeAttachmentStatus.newBuilder() to construct.
    private VolumeAttachmentStatus(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private VolumeAttachmentStatus() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 2:
          return internalGetAttachmentMetadata();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.class, io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.Builder.class);
    }

    private int bitField0_;
    public static final int ATTACHED_FIELD_NUMBER = 1;
    private boolean attached_ = false;
    /**
     * <pre>
     * attached indicates the volume is successfully attached.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * </pre>
     *
     * <code>optional bool attached = 1;</code>
     * @return Whether the attached field is set.
     */
    @java.lang.Override
    public boolean hasAttached() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * attached indicates the volume is successfully attached.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * </pre>
     *
     * <code>optional bool attached = 1;</code>
     * @return The attached.
     */
    @java.lang.Override
    public boolean getAttached() {
      return attached_;
    }

    public static final int ATTACHMENTMETADATA_FIELD_NUMBER = 2;
    private static final class AttachmentMetadataDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_AttachmentMetadataEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> attachmentMetadata_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetAttachmentMetadata() {
      if (attachmentMetadata_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            AttachmentMetadataDefaultEntryHolder.defaultEntry);
      }
      return attachmentMetadata_;
    }
    public int getAttachmentMetadataCount() {
      return internalGetAttachmentMetadata().getMap().size();
    }
    /**
     * <pre>
     * attachmentMetadata is populated with any
     * information returned by the attach operation, upon successful attach, that must be passed
     * into subsequent WaitForAttach or Mount calls.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
     */
    @java.lang.Override
    public boolean containsAttachmentMetadata(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetAttachmentMetadata().getMap().containsKey(key);
    }
    /**
     * Use {@link #getAttachmentMetadataMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getAttachmentMetadata() {
      return getAttachmentMetadataMap();
    }
    /**
     * <pre>
     * attachmentMetadata is populated with any
     * information returned by the attach operation, upon successful attach, that must be passed
     * into subsequent WaitForAttach or Mount calls.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getAttachmentMetadataMap() {
      return internalGetAttachmentMetadata().getMap();
    }
    /**
     * <pre>
     * attachmentMetadata is populated with any
     * information returned by the attach operation, upon successful attach, that must be passed
     * into subsequent WaitForAttach or Mount calls.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getAttachmentMetadataOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAttachmentMetadata().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * attachmentMetadata is populated with any
     * information returned by the attach operation, upon successful attach, that must be passed
     * into subsequent WaitForAttach or Mount calls.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
     */
    @java.lang.Override
    public java.lang.String getAttachmentMetadataOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAttachmentMetadata().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int ATTACHERROR_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Storage.VolumeError attachError_;
    /**
     * <pre>
     * attachError represents the last error encountered during attach operation, if any.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
     * @return Whether the attachError field is set.
     */
    @java.lang.Override
    public boolean hasAttachError() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * attachError represents the last error encountered during attach operation, if any.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
     * @return The attachError.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeError getAttachError() {
      return attachError_ == null ? io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance() : attachError_;
    }
    /**
     * <pre>
     * attachError represents the last error encountered during attach operation, if any.
     * This field must only be set by the entity completing the attach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder getAttachErrorOrBuilder() {
      return attachError_ == null ? io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance() : attachError_;
    }

    public static final int DETACHERROR_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.V1Storage.VolumeError detachError_;
    /**
     * <pre>
     * detachError represents the last error encountered during detach operation, if any.
     * This field must only be set by the entity completing the detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
     * @return Whether the detachError field is set.
     */
    @java.lang.Override
    public boolean hasDetachError() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * detachError represents the last error encountered during detach operation, if any.
     * This field must only be set by the entity completing the detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
     * @return The detachError.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeError getDetachError() {
      return detachError_ == null ? io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance() : detachError_;
    }
    /**
     * <pre>
     * detachError represents the last error encountered during detach operation, if any.
     * This field must only be set by the entity completing the detach
     * operation, i.e. the external-attacher.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder getDetachErrorOrBuilder() {
      return detachError_ == null ? io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance() : detachError_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(1, attached_);
      }
      com.google.protobuf.GeneratedMessage
        .serializeStringMapTo(
          output,
          internalGetAttachmentMetadata(),
          AttachmentMetadataDefaultEntryHolder.defaultEntry,
          2);
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getAttachError());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(4, getDetachError());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, attached_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetAttachmentMetadata().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        attachmentMetadata__ = AttachmentMetadataDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, attachmentMetadata__);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAttachError());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getDetachError());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus other = (io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus) obj;

      if (hasAttached() != other.hasAttached()) return false;
      if (hasAttached()) {
        if (getAttached()
            != other.getAttached()) return false;
      }
      if (!internalGetAttachmentMetadata().equals(
          other.internalGetAttachmentMetadata())) return false;
      if (hasAttachError() != other.hasAttachError()) return false;
      if (hasAttachError()) {
        if (!getAttachError()
            .equals(other.getAttachError())) return false;
      }
      if (hasDetachError() != other.hasDetachError()) return false;
      if (hasDetachError()) {
        if (!getDetachError()
            .equals(other.getDetachError())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAttached()) {
        hash = (37 * hash) + ATTACHED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAttached());
      }
      if (!internalGetAttachmentMetadata().getMap().isEmpty()) {
        hash = (37 * hash) + ATTACHMENTMETADATA_FIELD_NUMBER;
        hash = (53 * hash) + internalGetAttachmentMetadata().hashCode();
      }
      if (hasAttachError()) {
        hash = (37 * hash) + ATTACHERROR_FIELD_NUMBER;
        hash = (53 * hash) + getAttachError().hashCode();
      }
      if (hasDetachError()) {
        hash = (37 * hash) + DETACHERROR_FIELD_NUMBER;
        hash = (53 * hash) + getDetachError().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * VolumeAttachmentStatus is the status of a VolumeAttachment request.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.VolumeAttachmentStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.VolumeAttachmentStatus)
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 2:
            return internalGetAttachmentMetadata();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableAttachmentMetadata();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.class, io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getAttachErrorFieldBuilder();
          getDetachErrorFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        attached_ = false;
        internalGetMutableAttachmentMetadata().clear();
        attachError_ = null;
        if (attachErrorBuilder_ != null) {
          attachErrorBuilder_.dispose();
          attachErrorBuilder_ = null;
        }
        detachError_ = null;
        if (detachErrorBuilder_ != null) {
          detachErrorBuilder_.dispose();
          detachErrorBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus build() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus buildPartial() {
        io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus result = new io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.attached_ = attached_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.attachmentMetadata_ = internalGetAttachmentMetadata();
          result.attachmentMetadata_.makeImmutable();
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.attachError_ = attachErrorBuilder_ == null
              ? attachError_
              : attachErrorBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.detachError_ = detachErrorBuilder_ == null
              ? detachError_
              : detachErrorBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus other) {
        if (other == io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus.getDefaultInstance()) return this;
        if (other.hasAttached()) {
          setAttached(other.getAttached());
        }
        internalGetMutableAttachmentMetadata().mergeFrom(
            other.internalGetAttachmentMetadata());
        bitField0_ |= 0x00000002;
        if (other.hasAttachError()) {
          mergeAttachError(other.getAttachError());
        }
        if (other.hasDetachError()) {
          mergeDetachError(other.getDetachError());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                attached_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                attachmentMetadata__ = input.readMessage(
                    AttachmentMetadataDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                internalGetMutableAttachmentMetadata().getMutableMap().put(
                    attachmentMetadata__.getKey(), attachmentMetadata__.getValue());
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getAttachErrorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getDetachErrorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean attached_ ;
      /**
       * <pre>
       * attached indicates the volume is successfully attached.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * </pre>
       *
       * <code>optional bool attached = 1;</code>
       * @return Whether the attached field is set.
       */
      @java.lang.Override
      public boolean hasAttached() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * attached indicates the volume is successfully attached.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * </pre>
       *
       * <code>optional bool attached = 1;</code>
       * @return The attached.
       */
      @java.lang.Override
      public boolean getAttached() {
        return attached_;
      }
      /**
       * <pre>
       * attached indicates the volume is successfully attached.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * </pre>
       *
       * <code>optional bool attached = 1;</code>
       * @param value The attached to set.
       * @return This builder for chaining.
       */
      public Builder setAttached(boolean value) {

        attached_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * attached indicates the volume is successfully attached.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * </pre>
       *
       * <code>optional bool attached = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAttached() {
        bitField0_ = (bitField0_ & ~0x00000001);
        attached_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> attachmentMetadata_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetAttachmentMetadata() {
        if (attachmentMetadata_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              AttachmentMetadataDefaultEntryHolder.defaultEntry);
        }
        return attachmentMetadata_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMutableAttachmentMetadata() {
        if (attachmentMetadata_ == null) {
          attachmentMetadata_ = com.google.protobuf.MapField.newMapField(
              AttachmentMetadataDefaultEntryHolder.defaultEntry);
        }
        if (!attachmentMetadata_.isMutable()) {
          attachmentMetadata_ = attachmentMetadata_.copy();
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return attachmentMetadata_;
      }
      public int getAttachmentMetadataCount() {
        return internalGetAttachmentMetadata().getMap().size();
      }
      /**
       * <pre>
       * attachmentMetadata is populated with any
       * information returned by the attach operation, upon successful attach, that must be passed
       * into subsequent WaitForAttach or Mount calls.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
       */
      @java.lang.Override
      public boolean containsAttachmentMetadata(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetAttachmentMetadata().getMap().containsKey(key);
      }
      /**
       * Use {@link #getAttachmentMetadataMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getAttachmentMetadata() {
        return getAttachmentMetadataMap();
      }
      /**
       * <pre>
       * attachmentMetadata is populated with any
       * information returned by the attach operation, upon successful attach, that must be passed
       * into subsequent WaitForAttach or Mount calls.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.String> getAttachmentMetadataMap() {
        return internalGetAttachmentMetadata().getMap();
      }
      /**
       * <pre>
       * attachmentMetadata is populated with any
       * information returned by the attach operation, upon successful attach, that must be passed
       * into subsequent WaitForAttach or Mount calls.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
       */
      @java.lang.Override
      public /* nullable */
java.lang.String getAttachmentMetadataOrDefault(
          java.lang.String key,
          /* nullable */
java.lang.String defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetAttachmentMetadata().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * attachmentMetadata is populated with any
       * information returned by the attach operation, upon successful attach, that must be passed
       * into subsequent WaitForAttach or Mount calls.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
       */
      @java.lang.Override
      public java.lang.String getAttachmentMetadataOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetAttachmentMetadata().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      public Builder clearAttachmentMetadata() {
        bitField0_ = (bitField0_ & ~0x00000002);
        internalGetMutableAttachmentMetadata().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * attachmentMetadata is populated with any
       * information returned by the attach operation, upon successful attach, that must be passed
       * into subsequent WaitForAttach or Mount calls.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
       */
      public Builder removeAttachmentMetadata(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableAttachmentMetadata().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
          getMutableAttachmentMetadata() {
        bitField0_ |= 0x00000002;
        return internalGetMutableAttachmentMetadata().getMutableMap();
      }
      /**
       * <pre>
       * attachmentMetadata is populated with any
       * information returned by the attach operation, upon successful attach, that must be passed
       * into subsequent WaitForAttach or Mount calls.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
       */
      public Builder putAttachmentMetadata(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) { throw new NullPointerException("map value"); }
        internalGetMutableAttachmentMetadata().getMutableMap()
            .put(key, value);
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * attachmentMetadata is populated with any
       * information returned by the attach operation, upon successful attach, that must be passed
       * into subsequent WaitForAttach or Mount calls.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; attachmentMetadata = 2;</code>
       */
      public Builder putAllAttachmentMetadata(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableAttachmentMetadata().getMutableMap()
            .putAll(values);
        bitField0_ |= 0x00000002;
        return this;
      }

      private io.kubernetes.client.proto.V1Storage.VolumeError attachError_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeError, io.kubernetes.client.proto.V1Storage.VolumeError.Builder, io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder> attachErrorBuilder_;
      /**
       * <pre>
       * attachError represents the last error encountered during attach operation, if any.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
       * @return Whether the attachError field is set.
       */
      public boolean hasAttachError() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * attachError represents the last error encountered during attach operation, if any.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
       * @return The attachError.
       */
      public io.kubernetes.client.proto.V1Storage.VolumeError getAttachError() {
        if (attachErrorBuilder_ == null) {
          return attachError_ == null ? io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance() : attachError_;
        } else {
          return attachErrorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * attachError represents the last error encountered during attach operation, if any.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
       */
      public Builder setAttachError(io.kubernetes.client.proto.V1Storage.VolumeError value) {
        if (attachErrorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          attachError_ = value;
        } else {
          attachErrorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * attachError represents the last error encountered during attach operation, if any.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
       */
      public Builder setAttachError(
          io.kubernetes.client.proto.V1Storage.VolumeError.Builder builderForValue) {
        if (attachErrorBuilder_ == null) {
          attachError_ = builderForValue.build();
        } else {
          attachErrorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * attachError represents the last error encountered during attach operation, if any.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
       */
      public Builder mergeAttachError(io.kubernetes.client.proto.V1Storage.VolumeError value) {
        if (attachErrorBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            attachError_ != null &&
            attachError_ != io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance()) {
            getAttachErrorBuilder().mergeFrom(value);
          } else {
            attachError_ = value;
          }
        } else {
          attachErrorBuilder_.mergeFrom(value);
        }
        if (attachError_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * attachError represents the last error encountered during attach operation, if any.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
       */
      public Builder clearAttachError() {
        bitField0_ = (bitField0_ & ~0x00000004);
        attachError_ = null;
        if (attachErrorBuilder_ != null) {
          attachErrorBuilder_.dispose();
          attachErrorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * attachError represents the last error encountered during attach operation, if any.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeError.Builder getAttachErrorBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getAttachErrorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * attachError represents the last error encountered during attach operation, if any.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder getAttachErrorOrBuilder() {
        if (attachErrorBuilder_ != null) {
          return attachErrorBuilder_.getMessageOrBuilder();
        } else {
          return attachError_ == null ?
              io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance() : attachError_;
        }
      }
      /**
       * <pre>
       * attachError represents the last error encountered during attach operation, if any.
       * This field must only be set by the entity completing the attach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError attachError = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeError, io.kubernetes.client.proto.V1Storage.VolumeError.Builder, io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder> 
          getAttachErrorFieldBuilder() {
        if (attachErrorBuilder_ == null) {
          attachErrorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Storage.VolumeError, io.kubernetes.client.proto.V1Storage.VolumeError.Builder, io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder>(
                  getAttachError(),
                  getParentForChildren(),
                  isClean());
          attachError_ = null;
        }
        return attachErrorBuilder_;
      }

      private io.kubernetes.client.proto.V1Storage.VolumeError detachError_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeError, io.kubernetes.client.proto.V1Storage.VolumeError.Builder, io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder> detachErrorBuilder_;
      /**
       * <pre>
       * detachError represents the last error encountered during detach operation, if any.
       * This field must only be set by the entity completing the detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
       * @return Whether the detachError field is set.
       */
      public boolean hasDetachError() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * detachError represents the last error encountered during detach operation, if any.
       * This field must only be set by the entity completing the detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
       * @return The detachError.
       */
      public io.kubernetes.client.proto.V1Storage.VolumeError getDetachError() {
        if (detachErrorBuilder_ == null) {
          return detachError_ == null ? io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance() : detachError_;
        } else {
          return detachErrorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * detachError represents the last error encountered during detach operation, if any.
       * This field must only be set by the entity completing the detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
       */
      public Builder setDetachError(io.kubernetes.client.proto.V1Storage.VolumeError value) {
        if (detachErrorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          detachError_ = value;
        } else {
          detachErrorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * detachError represents the last error encountered during detach operation, if any.
       * This field must only be set by the entity completing the detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
       */
      public Builder setDetachError(
          io.kubernetes.client.proto.V1Storage.VolumeError.Builder builderForValue) {
        if (detachErrorBuilder_ == null) {
          detachError_ = builderForValue.build();
        } else {
          detachErrorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * detachError represents the last error encountered during detach operation, if any.
       * This field must only be set by the entity completing the detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
       */
      public Builder mergeDetachError(io.kubernetes.client.proto.V1Storage.VolumeError value) {
        if (detachErrorBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            detachError_ != null &&
            detachError_ != io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance()) {
            getDetachErrorBuilder().mergeFrom(value);
          } else {
            detachError_ = value;
          }
        } else {
          detachErrorBuilder_.mergeFrom(value);
        }
        if (detachError_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * detachError represents the last error encountered during detach operation, if any.
       * This field must only be set by the entity completing the detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
       */
      public Builder clearDetachError() {
        bitField0_ = (bitField0_ & ~0x00000008);
        detachError_ = null;
        if (detachErrorBuilder_ != null) {
          detachErrorBuilder_.dispose();
          detachErrorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * detachError represents the last error encountered during detach operation, if any.
       * This field must only be set by the entity completing the detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeError.Builder getDetachErrorBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getDetachErrorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * detachError represents the last error encountered during detach operation, if any.
       * This field must only be set by the entity completing the detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
       */
      public io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder getDetachErrorOrBuilder() {
        if (detachErrorBuilder_ != null) {
          return detachErrorBuilder_.getMessageOrBuilder();
        } else {
          return detachError_ == null ?
              io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance() : detachError_;
        }
      }
      /**
       * <pre>
       * detachError represents the last error encountered during detach operation, if any.
       * This field must only be set by the entity completing the detach
       * operation, i.e. the external-attacher.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.storage.v1.VolumeError detachError = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Storage.VolumeError, io.kubernetes.client.proto.V1Storage.VolumeError.Builder, io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder> 
          getDetachErrorFieldBuilder() {
        if (detachErrorBuilder_ == null) {
          detachErrorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Storage.VolumeError, io.kubernetes.client.proto.V1Storage.VolumeError.Builder, io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder>(
                  getDetachError(),
                  getParentForChildren(),
                  isClean());
          detachError_ = null;
        }
        return detachErrorBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.VolumeAttachmentStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.VolumeAttachmentStatus)
    private static final io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus();
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeAttachmentStatus>
        PARSER = new com.google.protobuf.AbstractParser<VolumeAttachmentStatus>() {
      @java.lang.Override
      public VolumeAttachmentStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VolumeAttachmentStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeAttachmentStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeAttachmentStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeErrorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.VolumeError)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * time represents the time the error was encountered.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
     * @return Whether the time field is set.
     */
    boolean hasTime();
    /**
     * <pre>
     * time represents the time the error was encountered.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
     * @return The time.
     */
    io.kubernetes.client.proto.Meta.Time getTime();
    /**
     * <pre>
     * time represents the time the error was encountered.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getTimeOrBuilder();

    /**
     * <pre>
     * message represents the error encountered during Attach or Detach operation.
     * This string may be logged, so it should not contain sensitive
     * information.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * message represents the error encountered during Attach or Detach operation.
     * This string may be logged, so it should not contain sensitive
     * information.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * message represents the error encountered during Attach or Detach operation.
     * This string may be logged, so it should not contain sensitive
     * information.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * <pre>
   * VolumeError captures an error encountered during a volume operation.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.VolumeError}
   */
  public static final class VolumeError extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.VolumeError)
      VolumeErrorOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        VolumeError.class.getName());
    }
    // Use VolumeError.newBuilder() to construct.
    private VolumeError(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private VolumeError() {
      message_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeError_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeError_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.VolumeError.class, io.kubernetes.client.proto.V1Storage.VolumeError.Builder.class);
    }

    private int bitField0_;
    public static final int TIME_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.Time time_;
    /**
     * <pre>
     * time represents the time the error was encountered.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
     * @return Whether the time field is set.
     */
    @java.lang.Override
    public boolean hasTime() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * time represents the time the error was encountered.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
     * @return The time.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getTime() {
      return time_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : time_;
    }
    /**
     * <pre>
     * time represents the time the error was encountered.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getTimeOrBuilder() {
      return time_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : time_;
    }

    public static final int MESSAGE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * message represents the error encountered during Attach or Detach operation.
     * This string may be logged, so it should not contain sensitive
     * information.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * message represents the error encountered during Attach or Detach operation.
     * This string may be logged, so it should not contain sensitive
     * information.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * message represents the error encountered during Attach or Detach operation.
     * This string may be logged, so it should not contain sensitive
     * information.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getTime());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, message_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getTime());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, message_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.VolumeError)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.VolumeError other = (io.kubernetes.client.proto.V1Storage.VolumeError) obj;

      if (hasTime() != other.hasTime()) return false;
      if (hasTime()) {
        if (!getTime()
            .equals(other.getTime())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTime()) {
        hash = (37 * hash) + TIME_FIELD_NUMBER;
        hash = (53 * hash) + getTime().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeError parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeError parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeError parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.VolumeError prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * VolumeError captures an error encountered during a volume operation.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.VolumeError}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.VolumeError)
        io.kubernetes.client.proto.V1Storage.VolumeErrorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeError_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeError_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.VolumeError.class, io.kubernetes.client.proto.V1Storage.VolumeError.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.VolumeError.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getTimeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        time_ = null;
        if (timeBuilder_ != null) {
          timeBuilder_.dispose();
          timeBuilder_ = null;
        }
        message_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeError_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeError getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeError build() {
        io.kubernetes.client.proto.V1Storage.VolumeError result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeError buildPartial() {
        io.kubernetes.client.proto.V1Storage.VolumeError result = new io.kubernetes.client.proto.V1Storage.VolumeError(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.VolumeError result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.time_ = timeBuilder_ == null
              ? time_
              : timeBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.VolumeError) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.VolumeError)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.VolumeError other) {
        if (other == io.kubernetes.client.proto.V1Storage.VolumeError.getDefaultInstance()) return this;
        if (other.hasTime()) {
          mergeTime(other.getTime());
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getTimeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                message_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.Time time_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> timeBuilder_;
      /**
       * <pre>
       * time represents the time the error was encountered.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
       * @return Whether the time field is set.
       */
      public boolean hasTime() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * time represents the time the error was encountered.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
       * @return The time.
       */
      public io.kubernetes.client.proto.Meta.Time getTime() {
        if (timeBuilder_ == null) {
          return time_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : time_;
        } else {
          return timeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * time represents the time the error was encountered.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
       */
      public Builder setTime(io.kubernetes.client.proto.Meta.Time value) {
        if (timeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          time_ = value;
        } else {
          timeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * time represents the time the error was encountered.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
       */
      public Builder setTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (timeBuilder_ == null) {
          time_ = builderForValue.build();
        } else {
          timeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * time represents the time the error was encountered.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
       */
      public Builder mergeTime(io.kubernetes.client.proto.Meta.Time value) {
        if (timeBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            time_ != null &&
            time_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getTimeBuilder().mergeFrom(value);
          } else {
            time_ = value;
          }
        } else {
          timeBuilder_.mergeFrom(value);
        }
        if (time_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * time represents the time the error was encountered.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
       */
      public Builder clearTime() {
        bitField0_ = (bitField0_ & ~0x00000001);
        time_ = null;
        if (timeBuilder_ != null) {
          timeBuilder_.dispose();
          timeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * time represents the time the error was encountered.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getTimeBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * time represents the time the error was encountered.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getTimeOrBuilder() {
        if (timeBuilder_ != null) {
          return timeBuilder_.getMessageOrBuilder();
        } else {
          return time_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : time_;
        }
      }
      /**
       * <pre>
       * time represents the time the error was encountered.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getTimeFieldBuilder() {
        if (timeBuilder_ == null) {
          timeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getTime(),
                  getParentForChildren(),
                  isClean());
          time_ = null;
        }
        return timeBuilder_;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * message represents the error encountered during Attach or Detach operation.
       * This string may be logged, so it should not contain sensitive
       * information.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * message represents the error encountered during Attach or Detach operation.
       * This string may be logged, so it should not contain sensitive
       * information.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * message represents the error encountered during Attach or Detach operation.
       * This string may be logged, so it should not contain sensitive
       * information.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * message represents the error encountered during Attach or Detach operation.
       * This string may be logged, so it should not contain sensitive
       * information.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * message represents the error encountered during Attach or Detach operation.
       * This string may be logged, so it should not contain sensitive
       * information.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * message represents the error encountered during Attach or Detach operation.
       * This string may be logged, so it should not contain sensitive
       * information.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.VolumeError)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.VolumeError)
    private static final io.kubernetes.client.proto.V1Storage.VolumeError DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.VolumeError();
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeError getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeError>
        PARSER = new com.google.protobuf.AbstractParser<VolumeError>() {
      @java.lang.Override
      public VolumeError parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VolumeError> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeError> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeError getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeNodeResourcesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.storage.v1.VolumeNodeResources)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * count indicates the maximum number of unique volumes managed by the CSI driver that can be used on a node.
     * A volume that is both attached and mounted on a node is considered to be used once, not twice.
     * The same rule applies for a unique volume that is shared among multiple pods on the same node.
     * If this field is not specified, then the supported number of volumes on this node is unbounded.
     * +optional
     * </pre>
     *
     * <code>optional int32 count = 1;</code>
     * @return Whether the count field is set.
     */
    boolean hasCount();
    /**
     * <pre>
     * count indicates the maximum number of unique volumes managed by the CSI driver that can be used on a node.
     * A volume that is both attached and mounted on a node is considered to be used once, not twice.
     * The same rule applies for a unique volume that is shared among multiple pods on the same node.
     * If this field is not specified, then the supported number of volumes on this node is unbounded.
     * +optional
     * </pre>
     *
     * <code>optional int32 count = 1;</code>
     * @return The count.
     */
    int getCount();
  }
  /**
   * <pre>
   * VolumeNodeResources is a set of resource limits for scheduling of volumes.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.storage.v1.VolumeNodeResources}
   */
  public static final class VolumeNodeResources extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.storage.v1.VolumeNodeResources)
      VolumeNodeResourcesOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        VolumeNodeResources.class.getName());
    }
    // Use VolumeNodeResources.newBuilder() to construct.
    private VolumeNodeResources(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private VolumeNodeResources() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeNodeResources_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeNodeResources_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Storage.VolumeNodeResources.class, io.kubernetes.client.proto.V1Storage.VolumeNodeResources.Builder.class);
    }

    private int bitField0_;
    public static final int COUNT_FIELD_NUMBER = 1;
    private int count_ = 0;
    /**
     * <pre>
     * count indicates the maximum number of unique volumes managed by the CSI driver that can be used on a node.
     * A volume that is both attached and mounted on a node is considered to be used once, not twice.
     * The same rule applies for a unique volume that is shared among multiple pods on the same node.
     * If this field is not specified, then the supported number of volumes on this node is unbounded.
     * +optional
     * </pre>
     *
     * <code>optional int32 count = 1;</code>
     * @return Whether the count field is set.
     */
    @java.lang.Override
    public boolean hasCount() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * count indicates the maximum number of unique volumes managed by the CSI driver that can be used on a node.
     * A volume that is both attached and mounted on a node is considered to be used once, not twice.
     * The same rule applies for a unique volume that is shared among multiple pods on the same node.
     * If this field is not specified, then the supported number of volumes on this node is unbounded.
     * +optional
     * </pre>
     *
     * <code>optional int32 count = 1;</code>
     * @return The count.
     */
    @java.lang.Override
    public int getCount() {
      return count_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, count_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, count_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Storage.VolumeNodeResources)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Storage.VolumeNodeResources other = (io.kubernetes.client.proto.V1Storage.VolumeNodeResources) obj;

      if (hasCount() != other.hasCount()) return false;
      if (hasCount()) {
        if (getCount()
            != other.getCount()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCount()) {
        hash = (37 * hash) + COUNT_FIELD_NUMBER;
        hash = (53 * hash) + getCount();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Storage.VolumeNodeResources prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * VolumeNodeResources is a set of resource limits for scheduling of volumes.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.storage.v1.VolumeNodeResources}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.storage.v1.VolumeNodeResources)
        io.kubernetes.client.proto.V1Storage.VolumeNodeResourcesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeNodeResources_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeNodeResources_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Storage.VolumeNodeResources.class, io.kubernetes.client.proto.V1Storage.VolumeNodeResources.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Storage.VolumeNodeResources.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        count_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Storage.internal_static_k8s_io_api_storage_v1_VolumeNodeResources_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeNodeResources getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Storage.VolumeNodeResources.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeNodeResources build() {
        io.kubernetes.client.proto.V1Storage.VolumeNodeResources result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Storage.VolumeNodeResources buildPartial() {
        io.kubernetes.client.proto.V1Storage.VolumeNodeResources result = new io.kubernetes.client.proto.V1Storage.VolumeNodeResources(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Storage.VolumeNodeResources result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.count_ = count_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Storage.VolumeNodeResources) {
          return mergeFrom((io.kubernetes.client.proto.V1Storage.VolumeNodeResources)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Storage.VolumeNodeResources other) {
        if (other == io.kubernetes.client.proto.V1Storage.VolumeNodeResources.getDefaultInstance()) return this;
        if (other.hasCount()) {
          setCount(other.getCount());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                count_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int count_ ;
      /**
       * <pre>
       * count indicates the maximum number of unique volumes managed by the CSI driver that can be used on a node.
       * A volume that is both attached and mounted on a node is considered to be used once, not twice.
       * The same rule applies for a unique volume that is shared among multiple pods on the same node.
       * If this field is not specified, then the supported number of volumes on this node is unbounded.
       * +optional
       * </pre>
       *
       * <code>optional int32 count = 1;</code>
       * @return Whether the count field is set.
       */
      @java.lang.Override
      public boolean hasCount() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * count indicates the maximum number of unique volumes managed by the CSI driver that can be used on a node.
       * A volume that is both attached and mounted on a node is considered to be used once, not twice.
       * The same rule applies for a unique volume that is shared among multiple pods on the same node.
       * If this field is not specified, then the supported number of volumes on this node is unbounded.
       * +optional
       * </pre>
       *
       * <code>optional int32 count = 1;</code>
       * @return The count.
       */
      @java.lang.Override
      public int getCount() {
        return count_;
      }
      /**
       * <pre>
       * count indicates the maximum number of unique volumes managed by the CSI driver that can be used on a node.
       * A volume that is both attached and mounted on a node is considered to be used once, not twice.
       * The same rule applies for a unique volume that is shared among multiple pods on the same node.
       * If this field is not specified, then the supported number of volumes on this node is unbounded.
       * +optional
       * </pre>
       *
       * <code>optional int32 count = 1;</code>
       * @param value The count to set.
       * @return This builder for chaining.
       */
      public Builder setCount(int value) {

        count_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * count indicates the maximum number of unique volumes managed by the CSI driver that can be used on a node.
       * A volume that is both attached and mounted on a node is considered to be used once, not twice.
       * The same rule applies for a unique volume that is shared among multiple pods on the same node.
       * If this field is not specified, then the supported number of volumes on this node is unbounded.
       * +optional
       * </pre>
       *
       * <code>optional int32 count = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCount() {
        bitField0_ = (bitField0_ & ~0x00000001);
        count_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.storage.v1.VolumeNodeResources)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.storage.v1.VolumeNodeResources)
    private static final io.kubernetes.client.proto.V1Storage.VolumeNodeResources DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Storage.VolumeNodeResources();
    }

    public static io.kubernetes.client.proto.V1Storage.VolumeNodeResources getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeNodeResources>
        PARSER = new com.google.protobuf.AbstractParser<VolumeNodeResources>() {
      @java.lang.Override
      public VolumeNodeResources parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VolumeNodeResources> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeNodeResources> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Storage.VolumeNodeResources getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_CSIDriver_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_CSIDriver_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_CSIDriverList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_CSIDriverList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_CSIDriverSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_CSIDriverSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_CSINode_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_CSINode_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_CSINodeDriver_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_CSINodeDriver_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_CSINodeList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_CSINodeList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_CSINodeSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_CSINodeSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_StorageClass_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_StorageClass_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_StorageClass_ParametersEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_StorageClass_ParametersEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_StorageClassList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_StorageClassList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_TokenRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_TokenRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_VolumeAttachment_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_VolumeAttachment_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_AttachmentMetadataEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_AttachmentMetadataEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_VolumeError_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_VolumeError_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_storage_v1_VolumeNodeResources_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_storage_v1_VolumeNodeResources_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n%k8s.io/api/storage/v1/generated.proto\022" +
      "\025k8s.io.api.storage.v1\032\"k8s.io/api/core/" +
      "v1/generated.proto\0324k8s.io/apimachinery/" +
      "pkg/api/resource/generated.proto\0324k8s.io" +
      "/apimachinery/pkg/apis/meta/v1/generated" +
      ".proto\032/k8s.io/apimachinery/pkg/runtime/" +
      "generated.proto\0326k8s.io/apimachinery/pkg" +
      "/runtime/schema/generated.proto\"\203\001\n\tCSID" +
      "river\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimach" +
      "inery.pkg.apis.meta.v1.ObjectMeta\0222\n\004spe" +
      "c\030\002 \001(\0132$.k8s.io.api.storage.v1.CSIDrive" +
      "rSpec\"\202\001\n\rCSIDriverList\022@\n\010metadata\030\001 \001(" +
      "\0132..k8s.io.apimachinery.pkg.apis.meta.v1" +
      ".ListMeta\022/\n\005items\030\002 \003(\0132 .k8s.io.api.st" +
      "orage.v1.CSIDriver\"\372\001\n\rCSIDriverSpec\022\026\n\016" +
      "attachRequired\030\001 \001(\010\022\026\n\016podInfoOnMount\030\002" +
      " \001(\010\022\034\n\024volumeLifecycleModes\030\003 \003(\t\022\027\n\017st" +
      "orageCapacity\030\004 \001(\010\022\025\n\rfsGroupPolicy\030\005 \001" +
      "(\t\022:\n\rtokenRequests\030\006 \003(\0132#.k8s.io.api.s" +
      "torage.v1.TokenRequest\022\031\n\021requiresRepubl" +
      "ish\030\007 \001(\010\022\024\n\014seLinuxMount\030\010 \001(\010\"\177\n\007CSINo" +
      "de\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimachine" +
      "ry.pkg.apis.meta.v1.ObjectMeta\0220\n\004spec\030\002" +
      " \001(\0132\".k8s.io.api.storage.v1.CSINodeSpec" +
      "\"\204\001\n\rCSINodeDriver\022\014\n\004name\030\001 \001(\t\022\016\n\006node" +
      "ID\030\002 \001(\t\022\024\n\014topologyKeys\030\003 \003(\t\022?\n\013alloca" +
      "table\030\004 \001(\0132*.k8s.io.api.storage.v1.Volu" +
      "meNodeResources\"~\n\013CSINodeList\022@\n\010metada" +
      "ta\030\001 \001(\0132..k8s.io.apimachinery.pkg.apis." +
      "meta.v1.ListMeta\022-\n\005items\030\002 \003(\0132\036.k8s.io" +
      ".api.storage.v1.CSINode\"D\n\013CSINodeSpec\0225" +
      "\n\007drivers\030\001 \003(\0132$.k8s.io.api.storage.v1." +
      "CSINodeDriver\"\312\002\n\022CSIStorageCapacity\022B\n\010" +
      "metadata\030\001 \001(\01320.k8s.io.apimachinery.pkg" +
      ".apis.meta.v1.ObjectMeta\022I\n\014nodeTopology" +
      "\030\002 \001(\01323.k8s.io.apimachinery.pkg.apis.me" +
      "ta.v1.LabelSelector\022\030\n\020storageClassName\030" +
      "\003 \001(\t\022@\n\010capacity\030\004 \001(\0132..k8s.io.apimach" +
      "inery.pkg.api.resource.Quantity\022I\n\021maxim" +
      "umVolumeSize\030\005 \001(\0132..k8s.io.apimachinery" +
      ".pkg.api.resource.Quantity\"\224\001\n\026CSIStorag" +
      "eCapacityList\022@\n\010metadata\030\001 \001(\0132..k8s.io" +
      ".apimachinery.pkg.apis.meta.v1.ListMeta\022" +
      "8\n\005items\030\002 \003(\0132).k8s.io.api.storage.v1.C" +
      "SIStorageCapacity\"\216\003\n\014StorageClass\022B\n\010me" +
      "tadata\030\001 \001(\01320.k8s.io.apimachinery.pkg.a" +
      "pis.meta.v1.ObjectMeta\022\023\n\013provisioner\030\002 " +
      "\001(\t\022G\n\nparameters\030\003 \003(\01323.k8s.io.api.sto" +
      "rage.v1.StorageClass.ParametersEntry\022\025\n\r" +
      "reclaimPolicy\030\004 \001(\t\022\024\n\014mountOptions\030\005 \003(" +
      "\t\022\034\n\024allowVolumeExpansion\030\006 \001(\010\022\031\n\021volum" +
      "eBindingMode\030\007 \001(\t\022C\n\021allowedTopologies\030" +
      "\010 \003(\0132(.k8s.io.api.core.v1.TopologySelec" +
      "torTerm\0321\n\017ParametersEntry\022\013\n\003key\030\001 \001(\t\022" +
      "\r\n\005value\030\002 \001(\t:\0028\001\"\210\001\n\020StorageClassList\022" +
      "@\n\010metadata\030\001 \001(\0132..k8s.io.apimachinery." +
      "pkg.apis.meta.v1.ListMeta\0222\n\005items\030\002 \003(\013" +
      "2#.k8s.io.api.storage.v1.StorageClass\";\n" +
      "\014TokenRequest\022\020\n\010audience\030\001 \001(\t\022\031\n\021expir" +
      "ationSeconds\030\002 \001(\003\"\320\001\n\020VolumeAttachment\022" +
      "B\n\010metadata\030\001 \001(\01320.k8s.io.apimachinery." +
      "pkg.apis.meta.v1.ObjectMeta\0229\n\004spec\030\002 \001(" +
      "\0132+.k8s.io.api.storage.v1.VolumeAttachme" +
      "ntSpec\022=\n\006status\030\003 \001(\0132-.k8s.io.api.stor" +
      "age.v1.VolumeAttachmentStatus\"\220\001\n\024Volume" +
      "AttachmentList\022@\n\010metadata\030\001 \001(\0132..k8s.i" +
      "o.apimachinery.pkg.apis.meta.v1.ListMeta" +
      "\0226\n\005items\030\002 \003(\0132\'.k8s.io.api.storage.v1." +
      "VolumeAttachment\"z\n\026VolumeAttachmentSour" +
      "ce\022\034\n\024persistentVolumeName\030\001 \001(\t\022B\n\020inli" +
      "neVolumeSpec\030\002 \001(\0132(.k8s.io.api.core.v1." +
      "PersistentVolumeSpec\"y\n\024VolumeAttachment" +
      "Spec\022\020\n\010attacher\030\001 \001(\t\022=\n\006source\030\002 \001(\0132-" +
      ".k8s.io.api.storage.v1.VolumeAttachmentS" +
      "ource\022\020\n\010nodeName\030\003 \001(\t\"\272\002\n\026VolumeAttach" +
      "mentStatus\022\020\n\010attached\030\001 \001(\010\022a\n\022attachme" +
      "ntMetadata\030\002 \003(\0132E.k8s.io.api.storage.v1" +
      ".VolumeAttachmentStatus.AttachmentMetada" +
      "taEntry\0227\n\013attachError\030\003 \001(\0132\".k8s.io.ap" +
      "i.storage.v1.VolumeError\0227\n\013detachError\030" +
      "\004 \001(\0132\".k8s.io.api.storage.v1.VolumeErro" +
      "r\0329\n\027AttachmentMetadataEntry\022\013\n\003key\030\001 \001(" +
      "\t\022\r\n\005value\030\002 \001(\t:\0028\001\"X\n\013VolumeError\0228\n\004t" +
      "ime\030\001 \001(\0132*.k8s.io.apimachinery.pkg.apis" +
      ".meta.v1.Time\022\017\n\007message\030\002 \001(\t\"$\n\023Volume" +
      "NodeResources\022\r\n\005count\030\001 \001(\005B>\n\032io.kuber" +
      "netes.client.protoB\tV1StorageZ\025k8s.io/ap" +
      "i/storage/v1"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.kubernetes.client.proto.V1.getDescriptor(),
          io.kubernetes.client.proto.Resource.getDescriptor(),
          io.kubernetes.client.proto.Meta.getDescriptor(),
          io.kubernetes.client.proto.Runtime.getDescriptor(),
          io.kubernetes.client.proto.RuntimeSchema.getDescriptor(),
        });
    internal_static_k8s_io_api_storage_v1_CSIDriver_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_k8s_io_api_storage_v1_CSIDriver_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_CSIDriver_descriptor,
        new java.lang.String[] { "Metadata", "Spec", });
    internal_static_k8s_io_api_storage_v1_CSIDriverList_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_k8s_io_api_storage_v1_CSIDriverList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_CSIDriverList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_storage_v1_CSIDriverSpec_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_k8s_io_api_storage_v1_CSIDriverSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_CSIDriverSpec_descriptor,
        new java.lang.String[] { "AttachRequired", "PodInfoOnMount", "VolumeLifecycleModes", "StorageCapacity", "FsGroupPolicy", "TokenRequests", "RequiresRepublish", "SeLinuxMount", });
    internal_static_k8s_io_api_storage_v1_CSINode_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_k8s_io_api_storage_v1_CSINode_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_CSINode_descriptor,
        new java.lang.String[] { "Metadata", "Spec", });
    internal_static_k8s_io_api_storage_v1_CSINodeDriver_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_k8s_io_api_storage_v1_CSINodeDriver_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_CSINodeDriver_descriptor,
        new java.lang.String[] { "Name", "NodeID", "TopologyKeys", "Allocatable", });
    internal_static_k8s_io_api_storage_v1_CSINodeList_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_k8s_io_api_storage_v1_CSINodeList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_CSINodeList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_storage_v1_CSINodeSpec_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_k8s_io_api_storage_v1_CSINodeSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_CSINodeSpec_descriptor,
        new java.lang.String[] { "Drivers", });
    internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_CSIStorageCapacity_descriptor,
        new java.lang.String[] { "Metadata", "NodeTopology", "StorageClassName", "Capacity", "MaximumVolumeSize", });
    internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_CSIStorageCapacityList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_storage_v1_StorageClass_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_k8s_io_api_storage_v1_StorageClass_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_StorageClass_descriptor,
        new java.lang.String[] { "Metadata", "Provisioner", "Parameters", "ReclaimPolicy", "MountOptions", "AllowVolumeExpansion", "VolumeBindingMode", "AllowedTopologies", });
    internal_static_k8s_io_api_storage_v1_StorageClass_ParametersEntry_descriptor =
      internal_static_k8s_io_api_storage_v1_StorageClass_descriptor.getNestedTypes().get(0);
    internal_static_k8s_io_api_storage_v1_StorageClass_ParametersEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_StorageClass_ParametersEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_k8s_io_api_storage_v1_StorageClassList_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_k8s_io_api_storage_v1_StorageClassList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_StorageClassList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_storage_v1_TokenRequest_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_k8s_io_api_storage_v1_TokenRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_TokenRequest_descriptor,
        new java.lang.String[] { "Audience", "ExpirationSeconds", });
    internal_static_k8s_io_api_storage_v1_VolumeAttachment_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_k8s_io_api_storage_v1_VolumeAttachment_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_VolumeAttachment_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_VolumeAttachmentList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_VolumeAttachmentSource_descriptor,
        new java.lang.String[] { "PersistentVolumeName", "InlineVolumeSpec", });
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_VolumeAttachmentSpec_descriptor,
        new java.lang.String[] { "Attacher", "Source", "NodeName", });
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_descriptor,
        new java.lang.String[] { "Attached", "AttachmentMetadata", "AttachError", "DetachError", });
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_AttachmentMetadataEntry_descriptor =
      internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_descriptor.getNestedTypes().get(0);
    internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_AttachmentMetadataEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_VolumeAttachmentStatus_AttachmentMetadataEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_k8s_io_api_storage_v1_VolumeError_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_k8s_io_api_storage_v1_VolumeError_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_VolumeError_descriptor,
        new java.lang.String[] { "Time", "Message", });
    internal_static_k8s_io_api_storage_v1_VolumeNodeResources_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_k8s_io_api_storage_v1_VolumeNodeResources_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_storage_v1_VolumeNodeResources_descriptor,
        new java.lang.String[] { "Count", });
    descriptor.resolveAllFeaturesImmutable();
    io.kubernetes.client.proto.V1.getDescriptor();
    io.kubernetes.client.proto.Resource.getDescriptor();
    io.kubernetes.client.proto.Meta.getDescriptor();
    io.kubernetes.client.proto.Runtime.getDescriptor();
    io.kubernetes.client.proto.RuntimeSchema.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
