// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto
// Protobuf Java Version: 4.26.1

package io.kubernetes.client.proto;

public final class Meta {
  private Meta() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 26,
      /* patch= */ 1,
      /* suffix= */ "",
      Meta.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface APIGroupOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * name is the name of the group.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * name is the name of the group.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * name is the name of the group.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.GroupVersionForDiscovery> 
        getVersionsList();
    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    io.kubernetes.client.proto.Meta.GroupVersionForDiscovery getVersions(int index);
    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    int getVersionsCount();
    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder> 
        getVersionsOrBuilderList();
    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder getVersionsOrBuilder(
        int index);

    /**
     * <pre>
     * preferredVersion is the version preferred by the API server, which
     * probably is the storage version.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
     * @return Whether the preferredVersion field is set.
     */
    boolean hasPreferredVersion();
    /**
     * <pre>
     * preferredVersion is the version preferred by the API server, which
     * probably is the storage version.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
     * @return The preferredVersion.
     */
    io.kubernetes.client.proto.Meta.GroupVersionForDiscovery getPreferredVersion();
    /**
     * <pre>
     * preferredVersion is the version preferred by the API server, which
     * probably is the storage version.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
     */
    io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder getPreferredVersionOrBuilder();

    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> 
        getServerAddressByClientCIDRsList();
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR getServerAddressByClientCIDRs(int index);
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    int getServerAddressByClientCIDRsCount();
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> 
        getServerAddressByClientCIDRsOrBuilderList();
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder getServerAddressByClientCIDRsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * APIGroup contains the name, the supported versions, and the preferred version
   * of a group.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup}
   */
  public static final class APIGroup extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup)
      APIGroupOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        APIGroup.class.getName());
    }
    // Use APIGroup.newBuilder() to construct.
    private APIGroup(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private APIGroup() {
      name_ = "";
      versions_ = java.util.Collections.emptyList();
      serverAddressByClientCIDRs_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.APIGroup.class, io.kubernetes.client.proto.Meta.APIGroup.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * name is the name of the group.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * name is the name of the group.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * name is the name of the group.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSIONS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.GroupVersionForDiscovery> versions_;
    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.GroupVersionForDiscovery> getVersionsList() {
      return versions_;
    }
    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder> 
        getVersionsOrBuilderList() {
      return versions_;
    }
    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    @java.lang.Override
    public int getVersionsCount() {
      return versions_.size();
    }
    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery getVersions(int index) {
      return versions_.get(index);
    }
    /**
     * <pre>
     * versions are the versions supported in this group.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder getVersionsOrBuilder(
        int index) {
      return versions_.get(index);
    }

    public static final int PREFERREDVERSION_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.GroupVersionForDiscovery preferredVersion_;
    /**
     * <pre>
     * preferredVersion is the version preferred by the API server, which
     * probably is the storage version.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
     * @return Whether the preferredVersion field is set.
     */
    @java.lang.Override
    public boolean hasPreferredVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * preferredVersion is the version preferred by the API server, which
     * probably is the storage version.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
     * @return The preferredVersion.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery getPreferredVersion() {
      return preferredVersion_ == null ? io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.getDefaultInstance() : preferredVersion_;
    }
    /**
     * <pre>
     * preferredVersion is the version preferred by the API server, which
     * probably is the storage version.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder getPreferredVersionOrBuilder() {
      return preferredVersion_ == null ? io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.getDefaultInstance() : preferredVersion_;
    }

    public static final int SERVERADDRESSBYCLIENTCIDRS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> serverAddressByClientCIDRs_;
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> getServerAddressByClientCIDRsList() {
      return serverAddressByClientCIDRs_;
    }
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> 
        getServerAddressByClientCIDRsOrBuilderList() {
      return serverAddressByClientCIDRs_;
    }
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    @java.lang.Override
    public int getServerAddressByClientCIDRsCount() {
      return serverAddressByClientCIDRs_.size();
    }
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR getServerAddressByClientCIDRs(int index) {
      return serverAddressByClientCIDRs_.get(index);
    }
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder getServerAddressByClientCIDRsOrBuilder(
        int index) {
      return serverAddressByClientCIDRs_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      for (int i = 0; i < versions_.size(); i++) {
        output.writeMessage(2, versions_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getPreferredVersion());
      }
      for (int i = 0; i < serverAddressByClientCIDRs_.size(); i++) {
        output.writeMessage(4, serverAddressByClientCIDRs_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      for (int i = 0; i < versions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, versions_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getPreferredVersion());
      }
      for (int i = 0; i < serverAddressByClientCIDRs_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, serverAddressByClientCIDRs_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.APIGroup)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.APIGroup other = (io.kubernetes.client.proto.Meta.APIGroup) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (!getVersionsList()
          .equals(other.getVersionsList())) return false;
      if (hasPreferredVersion() != other.hasPreferredVersion()) return false;
      if (hasPreferredVersion()) {
        if (!getPreferredVersion()
            .equals(other.getPreferredVersion())) return false;
      }
      if (!getServerAddressByClientCIDRsList()
          .equals(other.getServerAddressByClientCIDRsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (getVersionsCount() > 0) {
        hash = (37 * hash) + VERSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getVersionsList().hashCode();
      }
      if (hasPreferredVersion()) {
        hash = (37 * hash) + PREFERREDVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getPreferredVersion().hashCode();
      }
      if (getServerAddressByClientCIDRsCount() > 0) {
        hash = (37 * hash) + SERVERADDRESSBYCLIENTCIDRS_FIELD_NUMBER;
        hash = (53 * hash) + getServerAddressByClientCIDRsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.APIGroup parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.APIGroup parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIGroup parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.APIGroup prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * APIGroup contains the name, the supported versions, and the preferred version
     * of a group.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup)
        io.kubernetes.client.proto.Meta.APIGroupOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.APIGroup.class, io.kubernetes.client.proto.Meta.APIGroup.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.APIGroup.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getVersionsFieldBuilder();
          getPreferredVersionFieldBuilder();
          getServerAddressByClientCIDRsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        if (versionsBuilder_ == null) {
          versions_ = java.util.Collections.emptyList();
        } else {
          versions_ = null;
          versionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        preferredVersion_ = null;
        if (preferredVersionBuilder_ != null) {
          preferredVersionBuilder_.dispose();
          preferredVersionBuilder_ = null;
        }
        if (serverAddressByClientCIDRsBuilder_ == null) {
          serverAddressByClientCIDRs_ = java.util.Collections.emptyList();
        } else {
          serverAddressByClientCIDRs_ = null;
          serverAddressByClientCIDRsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIGroup getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.APIGroup.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIGroup build() {
        io.kubernetes.client.proto.Meta.APIGroup result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIGroup buildPartial() {
        io.kubernetes.client.proto.Meta.APIGroup result = new io.kubernetes.client.proto.Meta.APIGroup(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.Meta.APIGroup result) {
        if (versionsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            versions_ = java.util.Collections.unmodifiableList(versions_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.versions_ = versions_;
        } else {
          result.versions_ = versionsBuilder_.build();
        }
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            serverAddressByClientCIDRs_ = java.util.Collections.unmodifiableList(serverAddressByClientCIDRs_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.serverAddressByClientCIDRs_ = serverAddressByClientCIDRs_;
        } else {
          result.serverAddressByClientCIDRs_ = serverAddressByClientCIDRsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.APIGroup result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.preferredVersion_ = preferredVersionBuilder_ == null
              ? preferredVersion_
              : preferredVersionBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.APIGroup) {
          return mergeFrom((io.kubernetes.client.proto.Meta.APIGroup)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.APIGroup other) {
        if (other == io.kubernetes.client.proto.Meta.APIGroup.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (versionsBuilder_ == null) {
          if (!other.versions_.isEmpty()) {
            if (versions_.isEmpty()) {
              versions_ = other.versions_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureVersionsIsMutable();
              versions_.addAll(other.versions_);
            }
            onChanged();
          }
        } else {
          if (!other.versions_.isEmpty()) {
            if (versionsBuilder_.isEmpty()) {
              versionsBuilder_.dispose();
              versionsBuilder_ = null;
              versions_ = other.versions_;
              bitField0_ = (bitField0_ & ~0x00000002);
              versionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getVersionsFieldBuilder() : null;
            } else {
              versionsBuilder_.addAllMessages(other.versions_);
            }
          }
        }
        if (other.hasPreferredVersion()) {
          mergePreferredVersion(other.getPreferredVersion());
        }
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (!other.serverAddressByClientCIDRs_.isEmpty()) {
            if (serverAddressByClientCIDRs_.isEmpty()) {
              serverAddressByClientCIDRs_ = other.serverAddressByClientCIDRs_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureServerAddressByClientCIDRsIsMutable();
              serverAddressByClientCIDRs_.addAll(other.serverAddressByClientCIDRs_);
            }
            onChanged();
          }
        } else {
          if (!other.serverAddressByClientCIDRs_.isEmpty()) {
            if (serverAddressByClientCIDRsBuilder_.isEmpty()) {
              serverAddressByClientCIDRsBuilder_.dispose();
              serverAddressByClientCIDRsBuilder_ = null;
              serverAddressByClientCIDRs_ = other.serverAddressByClientCIDRs_;
              bitField0_ = (bitField0_ & ~0x00000008);
              serverAddressByClientCIDRsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getServerAddressByClientCIDRsFieldBuilder() : null;
            } else {
              serverAddressByClientCIDRsBuilder_.addAllMessages(other.serverAddressByClientCIDRs_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.Meta.GroupVersionForDiscovery m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.parser(),
                        extensionRegistry);
                if (versionsBuilder_ == null) {
                  ensureVersionsIsMutable();
                  versions_.add(m);
                } else {
                  versionsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getPreferredVersionFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.parser(),
                        extensionRegistry);
                if (serverAddressByClientCIDRsBuilder_ == null) {
                  ensureServerAddressByClientCIDRsIsMutable();
                  serverAddressByClientCIDRs_.add(m);
                } else {
                  serverAddressByClientCIDRsBuilder_.addMessage(m);
                }
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * name is the name of the group.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * name is the name of the group.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * name is the name of the group.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * name is the name of the group.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the name of the group.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the name of the group.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.GroupVersionForDiscovery> versions_ =
        java.util.Collections.emptyList();
      private void ensureVersionsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          versions_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.GroupVersionForDiscovery>(versions_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.GroupVersionForDiscovery, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder, io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder> versionsBuilder_;

      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.GroupVersionForDiscovery> getVersionsList() {
        if (versionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(versions_);
        } else {
          return versionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public int getVersionsCount() {
        if (versionsBuilder_ == null) {
          return versions_.size();
        } else {
          return versionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery getVersions(int index) {
        if (versionsBuilder_ == null) {
          return versions_.get(index);
        } else {
          return versionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public Builder setVersions(
          int index, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery value) {
        if (versionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVersionsIsMutable();
          versions_.set(index, value);
          onChanged();
        } else {
          versionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public Builder setVersions(
          int index, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder builderForValue) {
        if (versionsBuilder_ == null) {
          ensureVersionsIsMutable();
          versions_.set(index, builderForValue.build());
          onChanged();
        } else {
          versionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public Builder addVersions(io.kubernetes.client.proto.Meta.GroupVersionForDiscovery value) {
        if (versionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVersionsIsMutable();
          versions_.add(value);
          onChanged();
        } else {
          versionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public Builder addVersions(
          int index, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery value) {
        if (versionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVersionsIsMutable();
          versions_.add(index, value);
          onChanged();
        } else {
          versionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public Builder addVersions(
          io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder builderForValue) {
        if (versionsBuilder_ == null) {
          ensureVersionsIsMutable();
          versions_.add(builderForValue.build());
          onChanged();
        } else {
          versionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public Builder addVersions(
          int index, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder builderForValue) {
        if (versionsBuilder_ == null) {
          ensureVersionsIsMutable();
          versions_.add(index, builderForValue.build());
          onChanged();
        } else {
          versionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public Builder addAllVersions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.GroupVersionForDiscovery> values) {
        if (versionsBuilder_ == null) {
          ensureVersionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, versions_);
          onChanged();
        } else {
          versionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public Builder clearVersions() {
        if (versionsBuilder_ == null) {
          versions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          versionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public Builder removeVersions(int index) {
        if (versionsBuilder_ == null) {
          ensureVersionsIsMutable();
          versions_.remove(index);
          onChanged();
        } else {
          versionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder getVersionsBuilder(
          int index) {
        return getVersionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder getVersionsOrBuilder(
          int index) {
        if (versionsBuilder_ == null) {
          return versions_.get(index);  } else {
          return versionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder> 
           getVersionsOrBuilderList() {
        if (versionsBuilder_ != null) {
          return versionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(versions_);
        }
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder addVersionsBuilder() {
        return getVersionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.getDefaultInstance());
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder addVersionsBuilder(
          int index) {
        return getVersionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.getDefaultInstance());
      }
      /**
       * <pre>
       * versions are the versions supported in this group.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder> 
           getVersionsBuilderList() {
        return getVersionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.GroupVersionForDiscovery, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder, io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder> 
          getVersionsFieldBuilder() {
        if (versionsBuilder_ == null) {
          versionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.GroupVersionForDiscovery, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder, io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder>(
                  versions_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          versions_ = null;
        }
        return versionsBuilder_;
      }

      private io.kubernetes.client.proto.Meta.GroupVersionForDiscovery preferredVersion_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.GroupVersionForDiscovery, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder, io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder> preferredVersionBuilder_;
      /**
       * <pre>
       * preferredVersion is the version preferred by the API server, which
       * probably is the storage version.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
       * @return Whether the preferredVersion field is set.
       */
      public boolean hasPreferredVersion() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * preferredVersion is the version preferred by the API server, which
       * probably is the storage version.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
       * @return The preferredVersion.
       */
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery getPreferredVersion() {
        if (preferredVersionBuilder_ == null) {
          return preferredVersion_ == null ? io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.getDefaultInstance() : preferredVersion_;
        } else {
          return preferredVersionBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * preferredVersion is the version preferred by the API server, which
       * probably is the storage version.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
       */
      public Builder setPreferredVersion(io.kubernetes.client.proto.Meta.GroupVersionForDiscovery value) {
        if (preferredVersionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          preferredVersion_ = value;
        } else {
          preferredVersionBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * preferredVersion is the version preferred by the API server, which
       * probably is the storage version.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
       */
      public Builder setPreferredVersion(
          io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder builderForValue) {
        if (preferredVersionBuilder_ == null) {
          preferredVersion_ = builderForValue.build();
        } else {
          preferredVersionBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * preferredVersion is the version preferred by the API server, which
       * probably is the storage version.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
       */
      public Builder mergePreferredVersion(io.kubernetes.client.proto.Meta.GroupVersionForDiscovery value) {
        if (preferredVersionBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            preferredVersion_ != null &&
            preferredVersion_ != io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.getDefaultInstance()) {
            getPreferredVersionBuilder().mergeFrom(value);
          } else {
            preferredVersion_ = value;
          }
        } else {
          preferredVersionBuilder_.mergeFrom(value);
        }
        if (preferredVersion_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * preferredVersion is the version preferred by the API server, which
       * probably is the storage version.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
       */
      public Builder clearPreferredVersion() {
        bitField0_ = (bitField0_ & ~0x00000004);
        preferredVersion_ = null;
        if (preferredVersionBuilder_ != null) {
          preferredVersionBuilder_.dispose();
          preferredVersionBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * preferredVersion is the version preferred by the API server, which
       * probably is the storage version.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder getPreferredVersionBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getPreferredVersionFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * preferredVersion is the version preferred by the API server, which
       * probably is the storage version.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder getPreferredVersionOrBuilder() {
        if (preferredVersionBuilder_ != null) {
          return preferredVersionBuilder_.getMessageOrBuilder();
        } else {
          return preferredVersion_ == null ?
              io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.getDefaultInstance() : preferredVersion_;
        }
      }
      /**
       * <pre>
       * preferredVersion is the version preferred by the API server, which
       * probably is the storage version.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.GroupVersionForDiscovery, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder, io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder> 
          getPreferredVersionFieldBuilder() {
        if (preferredVersionBuilder_ == null) {
          preferredVersionBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.GroupVersionForDiscovery, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder, io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder>(
                  getPreferredVersion(),
                  getParentForChildren(),
                  isClean());
          preferredVersion_ = null;
        }
        return preferredVersionBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> serverAddressByClientCIDRs_ =
        java.util.Collections.emptyList();
      private void ensureServerAddressByClientCIDRsIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          serverAddressByClientCIDRs_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR>(serverAddressByClientCIDRs_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> serverAddressByClientCIDRsBuilder_;

      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> getServerAddressByClientCIDRsList() {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(serverAddressByClientCIDRs_);
        } else {
          return serverAddressByClientCIDRsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public int getServerAddressByClientCIDRsCount() {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          return serverAddressByClientCIDRs_.size();
        } else {
          return serverAddressByClientCIDRsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR getServerAddressByClientCIDRs(int index) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          return serverAddressByClientCIDRs_.get(index);
        } else {
          return serverAddressByClientCIDRsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public Builder setServerAddressByClientCIDRs(
          int index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR value) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.set(index, value);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public Builder setServerAddressByClientCIDRs(
          int index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder builderForValue) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.set(index, builderForValue.build());
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public Builder addServerAddressByClientCIDRs(io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR value) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.add(value);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public Builder addServerAddressByClientCIDRs(
          int index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR value) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.add(index, value);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public Builder addServerAddressByClientCIDRs(
          io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder builderForValue) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.add(builderForValue.build());
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public Builder addServerAddressByClientCIDRs(
          int index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder builderForValue) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.add(index, builderForValue.build());
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public Builder addAllServerAddressByClientCIDRs(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> values) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, serverAddressByClientCIDRs_);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public Builder clearServerAddressByClientCIDRs() {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          serverAddressByClientCIDRs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public Builder removeServerAddressByClientCIDRs(int index) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.remove(index);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder getServerAddressByClientCIDRsBuilder(
          int index) {
        return getServerAddressByClientCIDRsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder getServerAddressByClientCIDRsOrBuilder(
          int index) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          return serverAddressByClientCIDRs_.get(index);  } else {
          return serverAddressByClientCIDRsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> 
           getServerAddressByClientCIDRsOrBuilderList() {
        if (serverAddressByClientCIDRsBuilder_ != null) {
          return serverAddressByClientCIDRsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(serverAddressByClientCIDRs_);
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder addServerAddressByClientCIDRsBuilder() {
        return getServerAddressByClientCIDRsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.getDefaultInstance());
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder addServerAddressByClientCIDRsBuilder(
          int index) {
        return getServerAddressByClientCIDRsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.getDefaultInstance());
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder> 
           getServerAddressByClientCIDRsBuilderList() {
        return getServerAddressByClientCIDRsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> 
          getServerAddressByClientCIDRsFieldBuilder() {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          serverAddressByClientCIDRsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder>(
                  serverAddressByClientCIDRs_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          serverAddressByClientCIDRs_ = null;
        }
        return serverAddressByClientCIDRsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup)
    private static final io.kubernetes.client.proto.Meta.APIGroup DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.APIGroup();
    }

    public static io.kubernetes.client.proto.Meta.APIGroup getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<APIGroup>
        PARSER = new com.google.protobuf.AbstractParser<APIGroup>() {
      @java.lang.Override
      public APIGroup parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<APIGroup> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<APIGroup> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.APIGroup getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface APIGroupListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.APIGroup> 
        getGroupsList();
    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    io.kubernetes.client.proto.Meta.APIGroup getGroups(int index);
    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    int getGroupsCount();
    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.APIGroupOrBuilder> 
        getGroupsOrBuilderList();
    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    io.kubernetes.client.proto.Meta.APIGroupOrBuilder getGroupsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * APIGroupList is a list of APIGroup, to allow clients to discover the API at
   * /apis.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList}
   */
  public static final class APIGroupList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList)
      APIGroupListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        APIGroupList.class.getName());
    }
    // Use APIGroupList.newBuilder() to construct.
    private APIGroupList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private APIGroupList() {
      groups_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.APIGroupList.class, io.kubernetes.client.proto.Meta.APIGroupList.Builder.class);
    }

    public static final int GROUPS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.APIGroup> groups_;
    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.APIGroup> getGroupsList() {
      return groups_;
    }
    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.APIGroupOrBuilder> 
        getGroupsOrBuilderList() {
      return groups_;
    }
    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    @java.lang.Override
    public int getGroupsCount() {
      return groups_.size();
    }
    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.APIGroup getGroups(int index) {
      return groups_.get(index);
    }
    /**
     * <pre>
     * groups is a list of APIGroup.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.APIGroupOrBuilder getGroupsOrBuilder(
        int index) {
      return groups_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < groups_.size(); i++) {
        output.writeMessage(1, groups_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < groups_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, groups_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.APIGroupList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.APIGroupList other = (io.kubernetes.client.proto.Meta.APIGroupList) obj;

      if (!getGroupsList()
          .equals(other.getGroupsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getGroupsCount() > 0) {
        hash = (37 * hash) + GROUPS_FIELD_NUMBER;
        hash = (53 * hash) + getGroupsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.APIGroupList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.APIGroupList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIGroupList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.APIGroupList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * APIGroupList is a list of APIGroup, to allow clients to discover the API at
     * /apis.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList)
        io.kubernetes.client.proto.Meta.APIGroupListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.APIGroupList.class, io.kubernetes.client.proto.Meta.APIGroupList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.APIGroupList.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (groupsBuilder_ == null) {
          groups_ = java.util.Collections.emptyList();
        } else {
          groups_ = null;
          groupsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIGroupList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.APIGroupList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIGroupList build() {
        io.kubernetes.client.proto.Meta.APIGroupList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIGroupList buildPartial() {
        io.kubernetes.client.proto.Meta.APIGroupList result = new io.kubernetes.client.proto.Meta.APIGroupList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.Meta.APIGroupList result) {
        if (groupsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            groups_ = java.util.Collections.unmodifiableList(groups_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.groups_ = groups_;
        } else {
          result.groups_ = groupsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.APIGroupList result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.APIGroupList) {
          return mergeFrom((io.kubernetes.client.proto.Meta.APIGroupList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.APIGroupList other) {
        if (other == io.kubernetes.client.proto.Meta.APIGroupList.getDefaultInstance()) return this;
        if (groupsBuilder_ == null) {
          if (!other.groups_.isEmpty()) {
            if (groups_.isEmpty()) {
              groups_ = other.groups_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureGroupsIsMutable();
              groups_.addAll(other.groups_);
            }
            onChanged();
          }
        } else {
          if (!other.groups_.isEmpty()) {
            if (groupsBuilder_.isEmpty()) {
              groupsBuilder_.dispose();
              groupsBuilder_ = null;
              groups_ = other.groups_;
              bitField0_ = (bitField0_ & ~0x00000001);
              groupsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getGroupsFieldBuilder() : null;
            } else {
              groupsBuilder_.addAllMessages(other.groups_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                io.kubernetes.client.proto.Meta.APIGroup m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.APIGroup.parser(),
                        extensionRegistry);
                if (groupsBuilder_ == null) {
                  ensureGroupsIsMutable();
                  groups_.add(m);
                } else {
                  groupsBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.Meta.APIGroup> groups_ =
        java.util.Collections.emptyList();
      private void ensureGroupsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          groups_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.APIGroup>(groups_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.APIGroup, io.kubernetes.client.proto.Meta.APIGroup.Builder, io.kubernetes.client.proto.Meta.APIGroupOrBuilder> groupsBuilder_;

      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.APIGroup> getGroupsList() {
        if (groupsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(groups_);
        } else {
          return groupsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public int getGroupsCount() {
        if (groupsBuilder_ == null) {
          return groups_.size();
        } else {
          return groupsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.APIGroup getGroups(int index) {
        if (groupsBuilder_ == null) {
          return groups_.get(index);
        } else {
          return groupsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public Builder setGroups(
          int index, io.kubernetes.client.proto.Meta.APIGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.set(index, value);
          onChanged();
        } else {
          groupsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public Builder setGroups(
          int index, io.kubernetes.client.proto.Meta.APIGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.set(index, builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public Builder addGroups(io.kubernetes.client.proto.Meta.APIGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.add(value);
          onChanged();
        } else {
          groupsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public Builder addGroups(
          int index, io.kubernetes.client.proto.Meta.APIGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.add(index, value);
          onChanged();
        } else {
          groupsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public Builder addGroups(
          io.kubernetes.client.proto.Meta.APIGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.add(builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public Builder addGroups(
          int index, io.kubernetes.client.proto.Meta.APIGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.add(index, builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public Builder addAllGroups(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.APIGroup> values) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, groups_);
          onChanged();
        } else {
          groupsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public Builder clearGroups() {
        if (groupsBuilder_ == null) {
          groups_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          groupsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public Builder removeGroups(int index) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.remove(index);
          onChanged();
        } else {
          groupsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.APIGroup.Builder getGroupsBuilder(
          int index) {
        return getGroupsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.APIGroupOrBuilder getGroupsOrBuilder(
          int index) {
        if (groupsBuilder_ == null) {
          return groups_.get(index);  } else {
          return groupsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.APIGroupOrBuilder> 
           getGroupsOrBuilderList() {
        if (groupsBuilder_ != null) {
          return groupsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(groups_);
        }
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.APIGroup.Builder addGroupsBuilder() {
        return getGroupsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.APIGroup.getDefaultInstance());
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.APIGroup.Builder addGroupsBuilder(
          int index) {
        return getGroupsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.APIGroup.getDefaultInstance());
      }
      /**
       * <pre>
       * groups is a list of APIGroup.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.APIGroup.Builder> 
           getGroupsBuilderList() {
        return getGroupsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.APIGroup, io.kubernetes.client.proto.Meta.APIGroup.Builder, io.kubernetes.client.proto.Meta.APIGroupOrBuilder> 
          getGroupsFieldBuilder() {
        if (groupsBuilder_ == null) {
          groupsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.APIGroup, io.kubernetes.client.proto.Meta.APIGroup.Builder, io.kubernetes.client.proto.Meta.APIGroupOrBuilder>(
                  groups_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          groups_ = null;
        }
        return groupsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList)
    private static final io.kubernetes.client.proto.Meta.APIGroupList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.APIGroupList();
    }

    public static io.kubernetes.client.proto.Meta.APIGroupList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<APIGroupList>
        PARSER = new com.google.protobuf.AbstractParser<APIGroupList>() {
      @java.lang.Override
      public APIGroupList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<APIGroupList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<APIGroupList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.APIGroupList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface APIResourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * name is the plural name of the resource.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * name is the plural name of the resource.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * name is the plural name of the resource.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
     * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
     * from the kubectl CLI interface.
     * </pre>
     *
     * <code>optional string singularName = 6;</code>
     * @return Whether the singularName field is set.
     */
    boolean hasSingularName();
    /**
     * <pre>
     * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
     * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
     * from the kubectl CLI interface.
     * </pre>
     *
     * <code>optional string singularName = 6;</code>
     * @return The singularName.
     */
    java.lang.String getSingularName();
    /**
     * <pre>
     * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
     * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
     * from the kubectl CLI interface.
     * </pre>
     *
     * <code>optional string singularName = 6;</code>
     * @return The bytes for singularName.
     */
    com.google.protobuf.ByteString
        getSingularNameBytes();

    /**
     * <pre>
     * namespaced indicates if a resource is namespaced or not.
     * </pre>
     *
     * <code>optional bool namespaced = 2;</code>
     * @return Whether the namespaced field is set.
     */
    boolean hasNamespaced();
    /**
     * <pre>
     * namespaced indicates if a resource is namespaced or not.
     * </pre>
     *
     * <code>optional bool namespaced = 2;</code>
     * @return The namespaced.
     */
    boolean getNamespaced();

    /**
     * <pre>
     * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
     * For subresources, this may have a different value, for example: Scale".
     * </pre>
     *
     * <code>optional string group = 8;</code>
     * @return Whether the group field is set.
     */
    boolean hasGroup();
    /**
     * <pre>
     * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
     * For subresources, this may have a different value, for example: Scale".
     * </pre>
     *
     * <code>optional string group = 8;</code>
     * @return The group.
     */
    java.lang.String getGroup();
    /**
     * <pre>
     * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
     * For subresources, this may have a different value, for example: Scale".
     * </pre>
     *
     * <code>optional string group = 8;</code>
     * @return The bytes for group.
     */
    com.google.protobuf.ByteString
        getGroupBytes();

    /**
     * <pre>
     * version is the preferred version of the resource.  Empty implies the version of the containing resource list
     * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
     * </pre>
     *
     * <code>optional string version = 9;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <pre>
     * version is the preferred version of the resource.  Empty implies the version of the containing resource list
     * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
     * </pre>
     *
     * <code>optional string version = 9;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <pre>
     * version is the preferred version of the resource.  Empty implies the version of the containing resource list
     * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
     * </pre>
     *
     * <code>optional string version = 9;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <pre>
     * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return Whether the kind field is set.
     */
    boolean hasKind();
    /**
     * <pre>
     * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return The kind.
     */
    java.lang.String getKind();
    /**
     * <pre>
     * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return The bytes for kind.
     */
    com.google.protobuf.ByteString
        getKindBytes();

    /**
     * <pre>
     * verbs is a list of supported kube verbs (this includes get, list, watch, create,
     * update, patch, delete, deletecollection, and proxy)
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
     * @return Whether the verbs field is set.
     */
    boolean hasVerbs();
    /**
     * <pre>
     * verbs is a list of supported kube verbs (this includes get, list, watch, create,
     * update, patch, delete, deletecollection, and proxy)
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
     * @return The verbs.
     */
    io.kubernetes.client.proto.Meta.Verbs getVerbs();
    /**
     * <pre>
     * verbs is a list of supported kube verbs (this includes get, list, watch, create,
     * update, patch, delete, deletecollection, and proxy)
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
     */
    io.kubernetes.client.proto.Meta.VerbsOrBuilder getVerbsOrBuilder();

    /**
     * <pre>
     * shortNames is a list of suggested short names of the resource.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string shortNames = 5;</code>
     * @return A list containing the shortNames.
     */
    java.util.List<java.lang.String>
        getShortNamesList();
    /**
     * <pre>
     * shortNames is a list of suggested short names of the resource.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string shortNames = 5;</code>
     * @return The count of shortNames.
     */
    int getShortNamesCount();
    /**
     * <pre>
     * shortNames is a list of suggested short names of the resource.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string shortNames = 5;</code>
     * @param index The index of the element to return.
     * @return The shortNames at the given index.
     */
    java.lang.String getShortNames(int index);
    /**
     * <pre>
     * shortNames is a list of suggested short names of the resource.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string shortNames = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the shortNames at the given index.
     */
    com.google.protobuf.ByteString
        getShortNamesBytes(int index);

    /**
     * <pre>
     * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string categories = 7;</code>
     * @return A list containing the categories.
     */
    java.util.List<java.lang.String>
        getCategoriesList();
    /**
     * <pre>
     * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string categories = 7;</code>
     * @return The count of categories.
     */
    int getCategoriesCount();
    /**
     * <pre>
     * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string categories = 7;</code>
     * @param index The index of the element to return.
     * @return The categories at the given index.
     */
    java.lang.String getCategories(int index);
    /**
     * <pre>
     * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string categories = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the categories at the given index.
     */
    com.google.protobuf.ByteString
        getCategoriesBytes(int index);

    /**
     * <pre>
     * The hash value of the storage version, the version this resource is
     * converted to when written to the data store. Value must be treated
     * as opaque by clients. Only equality comparison on the value is valid.
     * This is an alpha feature and may change or be removed in the future.
     * The field is populated by the apiserver only if the
     * StorageVersionHash feature gate is enabled.
     * This field will remain optional even if it graduates.
     * +optional
     * </pre>
     *
     * <code>optional string storageVersionHash = 10;</code>
     * @return Whether the storageVersionHash field is set.
     */
    boolean hasStorageVersionHash();
    /**
     * <pre>
     * The hash value of the storage version, the version this resource is
     * converted to when written to the data store. Value must be treated
     * as opaque by clients. Only equality comparison on the value is valid.
     * This is an alpha feature and may change or be removed in the future.
     * The field is populated by the apiserver only if the
     * StorageVersionHash feature gate is enabled.
     * This field will remain optional even if it graduates.
     * +optional
     * </pre>
     *
     * <code>optional string storageVersionHash = 10;</code>
     * @return The storageVersionHash.
     */
    java.lang.String getStorageVersionHash();
    /**
     * <pre>
     * The hash value of the storage version, the version this resource is
     * converted to when written to the data store. Value must be treated
     * as opaque by clients. Only equality comparison on the value is valid.
     * This is an alpha feature and may change or be removed in the future.
     * The field is populated by the apiserver only if the
     * StorageVersionHash feature gate is enabled.
     * This field will remain optional even if it graduates.
     * +optional
     * </pre>
     *
     * <code>optional string storageVersionHash = 10;</code>
     * @return The bytes for storageVersionHash.
     */
    com.google.protobuf.ByteString
        getStorageVersionHashBytes();
  }
  /**
   * <pre>
   * APIResource specifies the name of a resource and whether it is namespaced.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIResource}
   */
  public static final class APIResource extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource)
      APIResourceOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        APIResource.class.getName());
    }
    // Use APIResource.newBuilder() to construct.
    private APIResource(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private APIResource() {
      name_ = "";
      singularName_ = "";
      group_ = "";
      version_ = "";
      kind_ = "";
      shortNames_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      categories_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      storageVersionHash_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.APIResource.class, io.kubernetes.client.proto.Meta.APIResource.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * name is the plural name of the resource.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * name is the plural name of the resource.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * name is the plural name of the resource.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SINGULARNAME_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object singularName_ = "";
    /**
     * <pre>
     * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
     * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
     * from the kubectl CLI interface.
     * </pre>
     *
     * <code>optional string singularName = 6;</code>
     * @return Whether the singularName field is set.
     */
    @java.lang.Override
    public boolean hasSingularName() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
     * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
     * from the kubectl CLI interface.
     * </pre>
     *
     * <code>optional string singularName = 6;</code>
     * @return The singularName.
     */
    @java.lang.Override
    public java.lang.String getSingularName() {
      java.lang.Object ref = singularName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          singularName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
     * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
     * from the kubectl CLI interface.
     * </pre>
     *
     * <code>optional string singularName = 6;</code>
     * @return The bytes for singularName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSingularNameBytes() {
      java.lang.Object ref = singularName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        singularName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACED_FIELD_NUMBER = 2;
    private boolean namespaced_ = false;
    /**
     * <pre>
     * namespaced indicates if a resource is namespaced or not.
     * </pre>
     *
     * <code>optional bool namespaced = 2;</code>
     * @return Whether the namespaced field is set.
     */
    @java.lang.Override
    public boolean hasNamespaced() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * namespaced indicates if a resource is namespaced or not.
     * </pre>
     *
     * <code>optional bool namespaced = 2;</code>
     * @return The namespaced.
     */
    @java.lang.Override
    public boolean getNamespaced() {
      return namespaced_;
    }

    public static final int GROUP_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object group_ = "";
    /**
     * <pre>
     * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
     * For subresources, this may have a different value, for example: Scale".
     * </pre>
     *
     * <code>optional string group = 8;</code>
     * @return Whether the group field is set.
     */
    @java.lang.Override
    public boolean hasGroup() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
     * For subresources, this may have a different value, for example: Scale".
     * </pre>
     *
     * <code>optional string group = 8;</code>
     * @return The group.
     */
    @java.lang.Override
    public java.lang.String getGroup() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          group_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
     * For subresources, this may have a different value, for example: Scale".
     * </pre>
     *
     * <code>optional string group = 8;</code>
     * @return The bytes for group.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroupBytes() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        group_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private volatile java.lang.Object version_ = "";
    /**
     * <pre>
     * version is the preferred version of the resource.  Empty implies the version of the containing resource list
     * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
     * </pre>
     *
     * <code>optional string version = 9;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * version is the preferred version of the resource.  Empty implies the version of the containing resource list
     * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
     * </pre>
     *
     * <code>optional string version = 9;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * version is the preferred version of the resource.  Empty implies the version of the containing resource list
     * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
     * </pre>
     *
     * <code>optional string version = 9;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KIND_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object kind_ = "";
    /**
     * <pre>
     * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return Whether the kind field is set.
     */
    @java.lang.Override
    public boolean hasKind() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return The kind.
     */
    @java.lang.Override
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          kind_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return The bytes for kind.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERBS_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.Meta.Verbs verbs_;
    /**
     * <pre>
     * verbs is a list of supported kube verbs (this includes get, list, watch, create,
     * update, patch, delete, deletecollection, and proxy)
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
     * @return Whether the verbs field is set.
     */
    @java.lang.Override
    public boolean hasVerbs() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * verbs is a list of supported kube verbs (this includes get, list, watch, create,
     * update, patch, delete, deletecollection, and proxy)
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
     * @return The verbs.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Verbs getVerbs() {
      return verbs_ == null ? io.kubernetes.client.proto.Meta.Verbs.getDefaultInstance() : verbs_;
    }
    /**
     * <pre>
     * verbs is a list of supported kube verbs (this includes get, list, watch, create,
     * update, patch, delete, deletecollection, and proxy)
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.VerbsOrBuilder getVerbsOrBuilder() {
      return verbs_ == null ? io.kubernetes.client.proto.Meta.Verbs.getDefaultInstance() : verbs_;
    }

    public static final int SHORTNAMES_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList shortNames_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * shortNames is a list of suggested short names of the resource.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string shortNames = 5;</code>
     * @return A list containing the shortNames.
     */
    public com.google.protobuf.ProtocolStringList
        getShortNamesList() {
      return shortNames_;
    }
    /**
     * <pre>
     * shortNames is a list of suggested short names of the resource.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string shortNames = 5;</code>
     * @return The count of shortNames.
     */
    public int getShortNamesCount() {
      return shortNames_.size();
    }
    /**
     * <pre>
     * shortNames is a list of suggested short names of the resource.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string shortNames = 5;</code>
     * @param index The index of the element to return.
     * @return The shortNames at the given index.
     */
    public java.lang.String getShortNames(int index) {
      return shortNames_.get(index);
    }
    /**
     * <pre>
     * shortNames is a list of suggested short names of the resource.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string shortNames = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the shortNames at the given index.
     */
    public com.google.protobuf.ByteString
        getShortNamesBytes(int index) {
      return shortNames_.getByteString(index);
    }

    public static final int CATEGORIES_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList categories_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string categories = 7;</code>
     * @return A list containing the categories.
     */
    public com.google.protobuf.ProtocolStringList
        getCategoriesList() {
      return categories_;
    }
    /**
     * <pre>
     * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string categories = 7;</code>
     * @return The count of categories.
     */
    public int getCategoriesCount() {
      return categories_.size();
    }
    /**
     * <pre>
     * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string categories = 7;</code>
     * @param index The index of the element to return.
     * @return The categories at the given index.
     */
    public java.lang.String getCategories(int index) {
      return categories_.get(index);
    }
    /**
     * <pre>
     * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string categories = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the categories at the given index.
     */
    public com.google.protobuf.ByteString
        getCategoriesBytes(int index) {
      return categories_.getByteString(index);
    }

    public static final int STORAGEVERSIONHASH_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private volatile java.lang.Object storageVersionHash_ = "";
    /**
     * <pre>
     * The hash value of the storage version, the version this resource is
     * converted to when written to the data store. Value must be treated
     * as opaque by clients. Only equality comparison on the value is valid.
     * This is an alpha feature and may change or be removed in the future.
     * The field is populated by the apiserver only if the
     * StorageVersionHash feature gate is enabled.
     * This field will remain optional even if it graduates.
     * +optional
     * </pre>
     *
     * <code>optional string storageVersionHash = 10;</code>
     * @return Whether the storageVersionHash field is set.
     */
    @java.lang.Override
    public boolean hasStorageVersionHash() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The hash value of the storage version, the version this resource is
     * converted to when written to the data store. Value must be treated
     * as opaque by clients. Only equality comparison on the value is valid.
     * This is an alpha feature and may change or be removed in the future.
     * The field is populated by the apiserver only if the
     * StorageVersionHash feature gate is enabled.
     * This field will remain optional even if it graduates.
     * +optional
     * </pre>
     *
     * <code>optional string storageVersionHash = 10;</code>
     * @return The storageVersionHash.
     */
    @java.lang.Override
    public java.lang.String getStorageVersionHash() {
      java.lang.Object ref = storageVersionHash_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          storageVersionHash_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The hash value of the storage version, the version this resource is
     * converted to when written to the data store. Value must be treated
     * as opaque by clients. Only equality comparison on the value is valid.
     * This is an alpha feature and may change or be removed in the future.
     * The field is populated by the apiserver only if the
     * StorageVersionHash feature gate is enabled.
     * This field will remain optional even if it graduates.
     * +optional
     * </pre>
     *
     * <code>optional string storageVersionHash = 10;</code>
     * @return The bytes for storageVersionHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStorageVersionHashBytes() {
      java.lang.Object ref = storageVersionHash_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        storageVersionHash_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(2, namespaced_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, kind_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(4, getVerbs());
      }
      for (int i = 0; i < shortNames_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, shortNames_.getRaw(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, singularName_);
      }
      for (int i = 0; i < categories_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 7, categories_.getRaw(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, group_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 9, version_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 10, storageVersionHash_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, namespaced_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, kind_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getVerbs());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < shortNames_.size(); i++) {
          dataSize += computeStringSizeNoTag(shortNames_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getShortNamesList().size();
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, singularName_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < categories_.size(); i++) {
          dataSize += computeStringSizeNoTag(categories_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getCategoriesList().size();
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, group_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(9, version_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(10, storageVersionHash_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.APIResource)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.APIResource other = (io.kubernetes.client.proto.Meta.APIResource) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasSingularName() != other.hasSingularName()) return false;
      if (hasSingularName()) {
        if (!getSingularName()
            .equals(other.getSingularName())) return false;
      }
      if (hasNamespaced() != other.hasNamespaced()) return false;
      if (hasNamespaced()) {
        if (getNamespaced()
            != other.getNamespaced()) return false;
      }
      if (hasGroup() != other.hasGroup()) return false;
      if (hasGroup()) {
        if (!getGroup()
            .equals(other.getGroup())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (!getVersion()
            .equals(other.getVersion())) return false;
      }
      if (hasKind() != other.hasKind()) return false;
      if (hasKind()) {
        if (!getKind()
            .equals(other.getKind())) return false;
      }
      if (hasVerbs() != other.hasVerbs()) return false;
      if (hasVerbs()) {
        if (!getVerbs()
            .equals(other.getVerbs())) return false;
      }
      if (!getShortNamesList()
          .equals(other.getShortNamesList())) return false;
      if (!getCategoriesList()
          .equals(other.getCategoriesList())) return false;
      if (hasStorageVersionHash() != other.hasStorageVersionHash()) return false;
      if (hasStorageVersionHash()) {
        if (!getStorageVersionHash()
            .equals(other.getStorageVersionHash())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasSingularName()) {
        hash = (37 * hash) + SINGULARNAME_FIELD_NUMBER;
        hash = (53 * hash) + getSingularName().hashCode();
      }
      if (hasNamespaced()) {
        hash = (37 * hash) + NAMESPACED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getNamespaced());
      }
      if (hasGroup()) {
        hash = (37 * hash) + GROUP_FIELD_NUMBER;
        hash = (53 * hash) + getGroup().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion().hashCode();
      }
      if (hasKind()) {
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + getKind().hashCode();
      }
      if (hasVerbs()) {
        hash = (37 * hash) + VERBS_FIELD_NUMBER;
        hash = (53 * hash) + getVerbs().hashCode();
      }
      if (getShortNamesCount() > 0) {
        hash = (37 * hash) + SHORTNAMES_FIELD_NUMBER;
        hash = (53 * hash) + getShortNamesList().hashCode();
      }
      if (getCategoriesCount() > 0) {
        hash = (37 * hash) + CATEGORIES_FIELD_NUMBER;
        hash = (53 * hash) + getCategoriesList().hashCode();
      }
      if (hasStorageVersionHash()) {
        hash = (37 * hash) + STORAGEVERSIONHASH_FIELD_NUMBER;
        hash = (53 * hash) + getStorageVersionHash().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.APIResource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.APIResource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIResource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.APIResource prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * APIResource specifies the name of a resource and whether it is namespaced.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIResource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource)
        io.kubernetes.client.proto.Meta.APIResourceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.APIResource.class, io.kubernetes.client.proto.Meta.APIResource.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.APIResource.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getVerbsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        singularName_ = "";
        namespaced_ = false;
        group_ = "";
        version_ = "";
        kind_ = "";
        verbs_ = null;
        if (verbsBuilder_ != null) {
          verbsBuilder_.dispose();
          verbsBuilder_ = null;
        }
        shortNames_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        categories_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        storageVersionHash_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIResource getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.APIResource.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIResource build() {
        io.kubernetes.client.proto.Meta.APIResource result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIResource buildPartial() {
        io.kubernetes.client.proto.Meta.APIResource result = new io.kubernetes.client.proto.Meta.APIResource(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.APIResource result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.singularName_ = singularName_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.namespaced_ = namespaced_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.group_ = group_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.kind_ = kind_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.verbs_ = verbsBuilder_ == null
              ? verbs_
              : verbsBuilder_.build();
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          shortNames_.makeImmutable();
          result.shortNames_ = shortNames_;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          categories_.makeImmutable();
          result.categories_ = categories_;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.storageVersionHash_ = storageVersionHash_;
          to_bitField0_ |= 0x00000080;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.APIResource) {
          return mergeFrom((io.kubernetes.client.proto.Meta.APIResource)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.APIResource other) {
        if (other == io.kubernetes.client.proto.Meta.APIResource.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasSingularName()) {
          singularName_ = other.singularName_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasNamespaced()) {
          setNamespaced(other.getNamespaced());
        }
        if (other.hasGroup()) {
          group_ = other.group_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasVersion()) {
          version_ = other.version_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasKind()) {
          kind_ = other.kind_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (other.hasVerbs()) {
          mergeVerbs(other.getVerbs());
        }
        if (!other.shortNames_.isEmpty()) {
          if (shortNames_.isEmpty()) {
            shortNames_ = other.shortNames_;
            bitField0_ |= 0x00000080;
          } else {
            ensureShortNamesIsMutable();
            shortNames_.addAll(other.shortNames_);
          }
          onChanged();
        }
        if (!other.categories_.isEmpty()) {
          if (categories_.isEmpty()) {
            categories_ = other.categories_;
            bitField0_ |= 0x00000100;
          } else {
            ensureCategoriesIsMutable();
            categories_.addAll(other.categories_);
          }
          onChanged();
        }
        if (other.hasStorageVersionHash()) {
          storageVersionHash_ = other.storageVersionHash_;
          bitField0_ |= 0x00000200;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                namespaced_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 16
              case 26: {
                kind_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getVerbsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 34
              case 42: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureShortNamesIsMutable();
                shortNames_.add(bs);
                break;
              } // case 42
              case 50: {
                singularName_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 50
              case 58: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureCategoriesIsMutable();
                categories_.add(bs);
                break;
              } // case 58
              case 66: {
                group_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 66
              case 74: {
                version_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 74
              case 82: {
                storageVersionHash_ = input.readBytes();
                bitField0_ |= 0x00000200;
                break;
              } // case 82
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * name is the plural name of the resource.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * name is the plural name of the resource.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * name is the plural name of the resource.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * name is the plural name of the resource.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the plural name of the resource.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the plural name of the resource.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object singularName_ = "";
      /**
       * <pre>
       * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
       * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
       * from the kubectl CLI interface.
       * </pre>
       *
       * <code>optional string singularName = 6;</code>
       * @return Whether the singularName field is set.
       */
      public boolean hasSingularName() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
       * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
       * from the kubectl CLI interface.
       * </pre>
       *
       * <code>optional string singularName = 6;</code>
       * @return The singularName.
       */
      public java.lang.String getSingularName() {
        java.lang.Object ref = singularName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            singularName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
       * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
       * from the kubectl CLI interface.
       * </pre>
       *
       * <code>optional string singularName = 6;</code>
       * @return The bytes for singularName.
       */
      public com.google.protobuf.ByteString
          getSingularNameBytes() {
        java.lang.Object ref = singularName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          singularName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
       * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
       * from the kubectl CLI interface.
       * </pre>
       *
       * <code>optional string singularName = 6;</code>
       * @param value The singularName to set.
       * @return This builder for chaining.
       */
      public Builder setSingularName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        singularName_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
       * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
       * from the kubectl CLI interface.
       * </pre>
       *
       * <code>optional string singularName = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearSingularName() {
        singularName_ = getDefaultInstance().getSingularName();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
       * The singularName is more correct for reporting status on a single item and both singular and plural are allowed
       * from the kubectl CLI interface.
       * </pre>
       *
       * <code>optional string singularName = 6;</code>
       * @param value The bytes for singularName to set.
       * @return This builder for chaining.
       */
      public Builder setSingularNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        singularName_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private boolean namespaced_ ;
      /**
       * <pre>
       * namespaced indicates if a resource is namespaced or not.
       * </pre>
       *
       * <code>optional bool namespaced = 2;</code>
       * @return Whether the namespaced field is set.
       */
      @java.lang.Override
      public boolean hasNamespaced() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * namespaced indicates if a resource is namespaced or not.
       * </pre>
       *
       * <code>optional bool namespaced = 2;</code>
       * @return The namespaced.
       */
      @java.lang.Override
      public boolean getNamespaced() {
        return namespaced_;
      }
      /**
       * <pre>
       * namespaced indicates if a resource is namespaced or not.
       * </pre>
       *
       * <code>optional bool namespaced = 2;</code>
       * @param value The namespaced to set.
       * @return This builder for chaining.
       */
      public Builder setNamespaced(boolean value) {

        namespaced_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespaced indicates if a resource is namespaced or not.
       * </pre>
       *
       * <code>optional bool namespaced = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNamespaced() {
        bitField0_ = (bitField0_ & ~0x00000004);
        namespaced_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object group_ = "";
      /**
       * <pre>
       * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
       * For subresources, this may have a different value, for example: Scale".
       * </pre>
       *
       * <code>optional string group = 8;</code>
       * @return Whether the group field is set.
       */
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
       * For subresources, this may have a different value, for example: Scale".
       * </pre>
       *
       * <code>optional string group = 8;</code>
       * @return The group.
       */
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
       * For subresources, this may have a different value, for example: Scale".
       * </pre>
       *
       * <code>optional string group = 8;</code>
       * @return The bytes for group.
       */
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
       * For subresources, this may have a different value, for example: Scale".
       * </pre>
       *
       * <code>optional string group = 8;</code>
       * @param value The group to set.
       * @return This builder for chaining.
       */
      public Builder setGroup(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
       * For subresources, this may have a different value, for example: Scale".
       * </pre>
       *
       * <code>optional string group = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearGroup() {
        group_ = getDefaultInstance().getGroup();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * group is the preferred group of the resource.  Empty implies the group of the containing resource list.
       * For subresources, this may have a different value, for example: Scale".
       * </pre>
       *
       * <code>optional string group = 8;</code>
       * @param value The bytes for group to set.
       * @return This builder for chaining.
       */
      public Builder setGroupBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object version_ = "";
      /**
       * <pre>
       * version is the preferred version of the resource.  Empty implies the version of the containing resource list
       * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
       * </pre>
       *
       * <code>optional string version = 9;</code>
       * @return Whether the version field is set.
       */
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * version is the preferred version of the resource.  Empty implies the version of the containing resource list
       * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
       * </pre>
       *
       * <code>optional string version = 9;</code>
       * @return The version.
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * version is the preferred version of the resource.  Empty implies the version of the containing resource list
       * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
       * </pre>
       *
       * <code>optional string version = 9;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * version is the preferred version of the resource.  Empty implies the version of the containing resource list
       * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
       * </pre>
       *
       * <code>optional string version = 9;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * version is the preferred version of the resource.  Empty implies the version of the containing resource list
       * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
       * </pre>
       *
       * <code>optional string version = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        version_ = getDefaultInstance().getVersion();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * version is the preferred version of the resource.  Empty implies the version of the containing resource list
       * For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
       * </pre>
       *
       * <code>optional string version = 9;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object kind_ = "";
      /**
       * <pre>
       * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @return Whether the kind field is set.
       */
      public boolean hasKind() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @return The kind.
       */
      public java.lang.String getKind() {
        java.lang.Object ref = kind_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            kind_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @return The bytes for kind.
       */
      public com.google.protobuf.ByteString
          getKindBytes() {
        java.lang.Object ref = kind_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          kind_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @param value The kind to set.
       * @return This builder for chaining.
       */
      public Builder setKind(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearKind() {
        kind_ = getDefaultInstance().getKind();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @param value The bytes for kind to set.
       * @return This builder for chaining.
       */
      public Builder setKindBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Verbs verbs_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Verbs, io.kubernetes.client.proto.Meta.Verbs.Builder, io.kubernetes.client.proto.Meta.VerbsOrBuilder> verbsBuilder_;
      /**
       * <pre>
       * verbs is a list of supported kube verbs (this includes get, list, watch, create,
       * update, patch, delete, deletecollection, and proxy)
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
       * @return Whether the verbs field is set.
       */
      public boolean hasVerbs() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * verbs is a list of supported kube verbs (this includes get, list, watch, create,
       * update, patch, delete, deletecollection, and proxy)
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
       * @return The verbs.
       */
      public io.kubernetes.client.proto.Meta.Verbs getVerbs() {
        if (verbsBuilder_ == null) {
          return verbs_ == null ? io.kubernetes.client.proto.Meta.Verbs.getDefaultInstance() : verbs_;
        } else {
          return verbsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * verbs is a list of supported kube verbs (this includes get, list, watch, create,
       * update, patch, delete, deletecollection, and proxy)
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
       */
      public Builder setVerbs(io.kubernetes.client.proto.Meta.Verbs value) {
        if (verbsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          verbs_ = value;
        } else {
          verbsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * verbs is a list of supported kube verbs (this includes get, list, watch, create,
       * update, patch, delete, deletecollection, and proxy)
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
       */
      public Builder setVerbs(
          io.kubernetes.client.proto.Meta.Verbs.Builder builderForValue) {
        if (verbsBuilder_ == null) {
          verbs_ = builderForValue.build();
        } else {
          verbsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * verbs is a list of supported kube verbs (this includes get, list, watch, create,
       * update, patch, delete, deletecollection, and proxy)
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
       */
      public Builder mergeVerbs(io.kubernetes.client.proto.Meta.Verbs value) {
        if (verbsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            verbs_ != null &&
            verbs_ != io.kubernetes.client.proto.Meta.Verbs.getDefaultInstance()) {
            getVerbsBuilder().mergeFrom(value);
          } else {
            verbs_ = value;
          }
        } else {
          verbsBuilder_.mergeFrom(value);
        }
        if (verbs_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * verbs is a list of supported kube verbs (this includes get, list, watch, create,
       * update, patch, delete, deletecollection, and proxy)
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
       */
      public Builder clearVerbs() {
        bitField0_ = (bitField0_ & ~0x00000040);
        verbs_ = null;
        if (verbsBuilder_ != null) {
          verbsBuilder_.dispose();
          verbsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * verbs is a list of supported kube verbs (this includes get, list, watch, create,
       * update, patch, delete, deletecollection, and proxy)
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.Verbs.Builder getVerbsBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getVerbsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * verbs is a list of supported kube verbs (this includes get, list, watch, create,
       * update, patch, delete, deletecollection, and proxy)
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.VerbsOrBuilder getVerbsOrBuilder() {
        if (verbsBuilder_ != null) {
          return verbsBuilder_.getMessageOrBuilder();
        } else {
          return verbs_ == null ?
              io.kubernetes.client.proto.Meta.Verbs.getDefaultInstance() : verbs_;
        }
      }
      /**
       * <pre>
       * verbs is a list of supported kube verbs (this includes get, list, watch, create,
       * update, patch, delete, deletecollection, and proxy)
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Verbs, io.kubernetes.client.proto.Meta.Verbs.Builder, io.kubernetes.client.proto.Meta.VerbsOrBuilder> 
          getVerbsFieldBuilder() {
        if (verbsBuilder_ == null) {
          verbsBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Verbs, io.kubernetes.client.proto.Meta.Verbs.Builder, io.kubernetes.client.proto.Meta.VerbsOrBuilder>(
                  getVerbs(),
                  getParentForChildren(),
                  isClean());
          verbs_ = null;
        }
        return verbsBuilder_;
      }

      private com.google.protobuf.LazyStringArrayList shortNames_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureShortNamesIsMutable() {
        if (!shortNames_.isModifiable()) {
          shortNames_ = new com.google.protobuf.LazyStringArrayList(shortNames_);
        }
        bitField0_ |= 0x00000080;
      }
      /**
       * <pre>
       * shortNames is a list of suggested short names of the resource.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string shortNames = 5;</code>
       * @return A list containing the shortNames.
       */
      public com.google.protobuf.ProtocolStringList
          getShortNamesList() {
        shortNames_.makeImmutable();
        return shortNames_;
      }
      /**
       * <pre>
       * shortNames is a list of suggested short names of the resource.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string shortNames = 5;</code>
       * @return The count of shortNames.
       */
      public int getShortNamesCount() {
        return shortNames_.size();
      }
      /**
       * <pre>
       * shortNames is a list of suggested short names of the resource.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string shortNames = 5;</code>
       * @param index The index of the element to return.
       * @return The shortNames at the given index.
       */
      public java.lang.String getShortNames(int index) {
        return shortNames_.get(index);
      }
      /**
       * <pre>
       * shortNames is a list of suggested short names of the resource.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string shortNames = 5;</code>
       * @param index The index of the value to return.
       * @return The bytes of the shortNames at the given index.
       */
      public com.google.protobuf.ByteString
          getShortNamesBytes(int index) {
        return shortNames_.getByteString(index);
      }
      /**
       * <pre>
       * shortNames is a list of suggested short names of the resource.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string shortNames = 5;</code>
       * @param index The index to set the value at.
       * @param value The shortNames to set.
       * @return This builder for chaining.
       */
      public Builder setShortNames(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureShortNamesIsMutable();
        shortNames_.set(index, value);
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * shortNames is a list of suggested short names of the resource.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string shortNames = 5;</code>
       * @param value The shortNames to add.
       * @return This builder for chaining.
       */
      public Builder addShortNames(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureShortNamesIsMutable();
        shortNames_.add(value);
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * shortNames is a list of suggested short names of the resource.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string shortNames = 5;</code>
       * @param values The shortNames to add.
       * @return This builder for chaining.
       */
      public Builder addAllShortNames(
          java.lang.Iterable<java.lang.String> values) {
        ensureShortNamesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, shortNames_);
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * shortNames is a list of suggested short names of the resource.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string shortNames = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearShortNames() {
        shortNames_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * shortNames is a list of suggested short names of the resource.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string shortNames = 5;</code>
       * @param value The bytes of the shortNames to add.
       * @return This builder for chaining.
       */
      public Builder addShortNamesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureShortNamesIsMutable();
        shortNames_.add(value);
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList categories_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureCategoriesIsMutable() {
        if (!categories_.isModifiable()) {
          categories_ = new com.google.protobuf.LazyStringArrayList(categories_);
        }
        bitField0_ |= 0x00000100;
      }
      /**
       * <pre>
       * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string categories = 7;</code>
       * @return A list containing the categories.
       */
      public com.google.protobuf.ProtocolStringList
          getCategoriesList() {
        categories_.makeImmutable();
        return categories_;
      }
      /**
       * <pre>
       * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string categories = 7;</code>
       * @return The count of categories.
       */
      public int getCategoriesCount() {
        return categories_.size();
      }
      /**
       * <pre>
       * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string categories = 7;</code>
       * @param index The index of the element to return.
       * @return The categories at the given index.
       */
      public java.lang.String getCategories(int index) {
        return categories_.get(index);
      }
      /**
       * <pre>
       * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string categories = 7;</code>
       * @param index The index of the value to return.
       * @return The bytes of the categories at the given index.
       */
      public com.google.protobuf.ByteString
          getCategoriesBytes(int index) {
        return categories_.getByteString(index);
      }
      /**
       * <pre>
       * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string categories = 7;</code>
       * @param index The index to set the value at.
       * @param value The categories to set.
       * @return This builder for chaining.
       */
      public Builder setCategories(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureCategoriesIsMutable();
        categories_.set(index, value);
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string categories = 7;</code>
       * @param value The categories to add.
       * @return This builder for chaining.
       */
      public Builder addCategories(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureCategoriesIsMutable();
        categories_.add(value);
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string categories = 7;</code>
       * @param values The categories to add.
       * @return This builder for chaining.
       */
      public Builder addAllCategories(
          java.lang.Iterable<java.lang.String> values) {
        ensureCategoriesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, categories_);
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string categories = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearCategories() {
        categories_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000100);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string categories = 7;</code>
       * @param value The bytes of the categories to add.
       * @return This builder for chaining.
       */
      public Builder addCategoriesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureCategoriesIsMutable();
        categories_.add(value);
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      private java.lang.Object storageVersionHash_ = "";
      /**
       * <pre>
       * The hash value of the storage version, the version this resource is
       * converted to when written to the data store. Value must be treated
       * as opaque by clients. Only equality comparison on the value is valid.
       * This is an alpha feature and may change or be removed in the future.
       * The field is populated by the apiserver only if the
       * StorageVersionHash feature gate is enabled.
       * This field will remain optional even if it graduates.
       * +optional
       * </pre>
       *
       * <code>optional string storageVersionHash = 10;</code>
       * @return Whether the storageVersionHash field is set.
       */
      public boolean hasStorageVersionHash() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * The hash value of the storage version, the version this resource is
       * converted to when written to the data store. Value must be treated
       * as opaque by clients. Only equality comparison on the value is valid.
       * This is an alpha feature and may change or be removed in the future.
       * The field is populated by the apiserver only if the
       * StorageVersionHash feature gate is enabled.
       * This field will remain optional even if it graduates.
       * +optional
       * </pre>
       *
       * <code>optional string storageVersionHash = 10;</code>
       * @return The storageVersionHash.
       */
      public java.lang.String getStorageVersionHash() {
        java.lang.Object ref = storageVersionHash_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            storageVersionHash_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The hash value of the storage version, the version this resource is
       * converted to when written to the data store. Value must be treated
       * as opaque by clients. Only equality comparison on the value is valid.
       * This is an alpha feature and may change or be removed in the future.
       * The field is populated by the apiserver only if the
       * StorageVersionHash feature gate is enabled.
       * This field will remain optional even if it graduates.
       * +optional
       * </pre>
       *
       * <code>optional string storageVersionHash = 10;</code>
       * @return The bytes for storageVersionHash.
       */
      public com.google.protobuf.ByteString
          getStorageVersionHashBytes() {
        java.lang.Object ref = storageVersionHash_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          storageVersionHash_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The hash value of the storage version, the version this resource is
       * converted to when written to the data store. Value must be treated
       * as opaque by clients. Only equality comparison on the value is valid.
       * This is an alpha feature and may change or be removed in the future.
       * The field is populated by the apiserver only if the
       * StorageVersionHash feature gate is enabled.
       * This field will remain optional even if it graduates.
       * +optional
       * </pre>
       *
       * <code>optional string storageVersionHash = 10;</code>
       * @param value The storageVersionHash to set.
       * @return This builder for chaining.
       */
      public Builder setStorageVersionHash(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        storageVersionHash_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash value of the storage version, the version this resource is
       * converted to when written to the data store. Value must be treated
       * as opaque by clients. Only equality comparison on the value is valid.
       * This is an alpha feature and may change or be removed in the future.
       * The field is populated by the apiserver only if the
       * StorageVersionHash feature gate is enabled.
       * This field will remain optional even if it graduates.
       * +optional
       * </pre>
       *
       * <code>optional string storageVersionHash = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearStorageVersionHash() {
        storageVersionHash_ = getDefaultInstance().getStorageVersionHash();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash value of the storage version, the version this resource is
       * converted to when written to the data store. Value must be treated
       * as opaque by clients. Only equality comparison on the value is valid.
       * This is an alpha feature and may change or be removed in the future.
       * The field is populated by the apiserver only if the
       * StorageVersionHash feature gate is enabled.
       * This field will remain optional even if it graduates.
       * +optional
       * </pre>
       *
       * <code>optional string storageVersionHash = 10;</code>
       * @param value The bytes for storageVersionHash to set.
       * @return This builder for chaining.
       */
      public Builder setStorageVersionHashBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        storageVersionHash_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource)
    private static final io.kubernetes.client.proto.Meta.APIResource DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.APIResource();
    }

    public static io.kubernetes.client.proto.Meta.APIResource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<APIResource>
        PARSER = new com.google.protobuf.AbstractParser<APIResource>() {
      @java.lang.Override
      public APIResource parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<APIResource> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<APIResource> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.APIResource getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface APIResourceListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * groupVersion is the group and version this APIResourceList is for.
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return Whether the groupVersion field is set.
     */
    boolean hasGroupVersion();
    /**
     * <pre>
     * groupVersion is the group and version this APIResourceList is for.
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return The groupVersion.
     */
    java.lang.String getGroupVersion();
    /**
     * <pre>
     * groupVersion is the group and version this APIResourceList is for.
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return The bytes for groupVersion.
     */
    com.google.protobuf.ByteString
        getGroupVersionBytes();

    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.APIResource> 
        getResourcesList();
    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    io.kubernetes.client.proto.Meta.APIResource getResources(int index);
    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    int getResourcesCount();
    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.APIResourceOrBuilder> 
        getResourcesOrBuilderList();
    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    io.kubernetes.client.proto.Meta.APIResourceOrBuilder getResourcesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * APIResourceList is a list of APIResource, it is used to expose the name of the
   * resources supported in a specific group and version, and if the resource
   * is namespaced.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList}
   */
  public static final class APIResourceList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList)
      APIResourceListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        APIResourceList.class.getName());
    }
    // Use APIResourceList.newBuilder() to construct.
    private APIResourceList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private APIResourceList() {
      groupVersion_ = "";
      resources_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.APIResourceList.class, io.kubernetes.client.proto.Meta.APIResourceList.Builder.class);
    }

    private int bitField0_;
    public static final int GROUPVERSION_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object groupVersion_ = "";
    /**
     * <pre>
     * groupVersion is the group and version this APIResourceList is for.
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return Whether the groupVersion field is set.
     */
    @java.lang.Override
    public boolean hasGroupVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * groupVersion is the group and version this APIResourceList is for.
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return The groupVersion.
     */
    @java.lang.Override
    public java.lang.String getGroupVersion() {
      java.lang.Object ref = groupVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          groupVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * groupVersion is the group and version this APIResourceList is for.
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return The bytes for groupVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroupVersionBytes() {
      java.lang.Object ref = groupVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        groupVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RESOURCES_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.APIResource> resources_;
    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.APIResource> getResourcesList() {
      return resources_;
    }
    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.APIResourceOrBuilder> 
        getResourcesOrBuilderList() {
      return resources_;
    }
    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    @java.lang.Override
    public int getResourcesCount() {
      return resources_.size();
    }
    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.APIResource getResources(int index) {
      return resources_.get(index);
    }
    /**
     * <pre>
     * resources contains the name of the resources and if they are namespaced.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.APIResourceOrBuilder getResourcesOrBuilder(
        int index) {
      return resources_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, groupVersion_);
      }
      for (int i = 0; i < resources_.size(); i++) {
        output.writeMessage(2, resources_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, groupVersion_);
      }
      for (int i = 0; i < resources_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, resources_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.APIResourceList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.APIResourceList other = (io.kubernetes.client.proto.Meta.APIResourceList) obj;

      if (hasGroupVersion() != other.hasGroupVersion()) return false;
      if (hasGroupVersion()) {
        if (!getGroupVersion()
            .equals(other.getGroupVersion())) return false;
      }
      if (!getResourcesList()
          .equals(other.getResourcesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGroupVersion()) {
        hash = (37 * hash) + GROUPVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getGroupVersion().hashCode();
      }
      if (getResourcesCount() > 0) {
        hash = (37 * hash) + RESOURCES_FIELD_NUMBER;
        hash = (53 * hash) + getResourcesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.APIResourceList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.APIResourceList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIResourceList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.APIResourceList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * APIResourceList is a list of APIResource, it is used to expose the name of the
     * resources supported in a specific group and version, and if the resource
     * is namespaced.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList)
        io.kubernetes.client.proto.Meta.APIResourceListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.APIResourceList.class, io.kubernetes.client.proto.Meta.APIResourceList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.APIResourceList.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        groupVersion_ = "";
        if (resourcesBuilder_ == null) {
          resources_ = java.util.Collections.emptyList();
        } else {
          resources_ = null;
          resourcesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIResourceList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.APIResourceList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIResourceList build() {
        io.kubernetes.client.proto.Meta.APIResourceList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIResourceList buildPartial() {
        io.kubernetes.client.proto.Meta.APIResourceList result = new io.kubernetes.client.proto.Meta.APIResourceList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.Meta.APIResourceList result) {
        if (resourcesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            resources_ = java.util.Collections.unmodifiableList(resources_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.resources_ = resources_;
        } else {
          result.resources_ = resourcesBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.APIResourceList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.groupVersion_ = groupVersion_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.APIResourceList) {
          return mergeFrom((io.kubernetes.client.proto.Meta.APIResourceList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.APIResourceList other) {
        if (other == io.kubernetes.client.proto.Meta.APIResourceList.getDefaultInstance()) return this;
        if (other.hasGroupVersion()) {
          groupVersion_ = other.groupVersion_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (resourcesBuilder_ == null) {
          if (!other.resources_.isEmpty()) {
            if (resources_.isEmpty()) {
              resources_ = other.resources_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureResourcesIsMutable();
              resources_.addAll(other.resources_);
            }
            onChanged();
          }
        } else {
          if (!other.resources_.isEmpty()) {
            if (resourcesBuilder_.isEmpty()) {
              resourcesBuilder_.dispose();
              resourcesBuilder_ = null;
              resources_ = other.resources_;
              bitField0_ = (bitField0_ & ~0x00000002);
              resourcesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getResourcesFieldBuilder() : null;
            } else {
              resourcesBuilder_.addAllMessages(other.resources_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                groupVersion_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.Meta.APIResource m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.APIResource.parser(),
                        extensionRegistry);
                if (resourcesBuilder_ == null) {
                  ensureResourcesIsMutable();
                  resources_.add(m);
                } else {
                  resourcesBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object groupVersion_ = "";
      /**
       * <pre>
       * groupVersion is the group and version this APIResourceList is for.
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @return Whether the groupVersion field is set.
       */
      public boolean hasGroupVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * groupVersion is the group and version this APIResourceList is for.
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @return The groupVersion.
       */
      public java.lang.String getGroupVersion() {
        java.lang.Object ref = groupVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            groupVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * groupVersion is the group and version this APIResourceList is for.
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @return The bytes for groupVersion.
       */
      public com.google.protobuf.ByteString
          getGroupVersionBytes() {
        java.lang.Object ref = groupVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          groupVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * groupVersion is the group and version this APIResourceList is for.
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @param value The groupVersion to set.
       * @return This builder for chaining.
       */
      public Builder setGroupVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        groupVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * groupVersion is the group and version this APIResourceList is for.
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGroupVersion() {
        groupVersion_ = getDefaultInstance().getGroupVersion();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * groupVersion is the group and version this APIResourceList is for.
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @param value The bytes for groupVersion to set.
       * @return This builder for chaining.
       */
      public Builder setGroupVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        groupVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.APIResource> resources_ =
        java.util.Collections.emptyList();
      private void ensureResourcesIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          resources_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.APIResource>(resources_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.APIResource, io.kubernetes.client.proto.Meta.APIResource.Builder, io.kubernetes.client.proto.Meta.APIResourceOrBuilder> resourcesBuilder_;

      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.APIResource> getResourcesList() {
        if (resourcesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(resources_);
        } else {
          return resourcesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public int getResourcesCount() {
        if (resourcesBuilder_ == null) {
          return resources_.size();
        } else {
          return resourcesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.APIResource getResources(int index) {
        if (resourcesBuilder_ == null) {
          return resources_.get(index);
        } else {
          return resourcesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public Builder setResources(
          int index, io.kubernetes.client.proto.Meta.APIResource value) {
        if (resourcesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourcesIsMutable();
          resources_.set(index, value);
          onChanged();
        } else {
          resourcesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public Builder setResources(
          int index, io.kubernetes.client.proto.Meta.APIResource.Builder builderForValue) {
        if (resourcesBuilder_ == null) {
          ensureResourcesIsMutable();
          resources_.set(index, builderForValue.build());
          onChanged();
        } else {
          resourcesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public Builder addResources(io.kubernetes.client.proto.Meta.APIResource value) {
        if (resourcesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourcesIsMutable();
          resources_.add(value);
          onChanged();
        } else {
          resourcesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public Builder addResources(
          int index, io.kubernetes.client.proto.Meta.APIResource value) {
        if (resourcesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourcesIsMutable();
          resources_.add(index, value);
          onChanged();
        } else {
          resourcesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public Builder addResources(
          io.kubernetes.client.proto.Meta.APIResource.Builder builderForValue) {
        if (resourcesBuilder_ == null) {
          ensureResourcesIsMutable();
          resources_.add(builderForValue.build());
          onChanged();
        } else {
          resourcesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public Builder addResources(
          int index, io.kubernetes.client.proto.Meta.APIResource.Builder builderForValue) {
        if (resourcesBuilder_ == null) {
          ensureResourcesIsMutable();
          resources_.add(index, builderForValue.build());
          onChanged();
        } else {
          resourcesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public Builder addAllResources(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.APIResource> values) {
        if (resourcesBuilder_ == null) {
          ensureResourcesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, resources_);
          onChanged();
        } else {
          resourcesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public Builder clearResources() {
        if (resourcesBuilder_ == null) {
          resources_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          resourcesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public Builder removeResources(int index) {
        if (resourcesBuilder_ == null) {
          ensureResourcesIsMutable();
          resources_.remove(index);
          onChanged();
        } else {
          resourcesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.APIResource.Builder getResourcesBuilder(
          int index) {
        return getResourcesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.APIResourceOrBuilder getResourcesOrBuilder(
          int index) {
        if (resourcesBuilder_ == null) {
          return resources_.get(index);  } else {
          return resourcesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.APIResourceOrBuilder> 
           getResourcesOrBuilderList() {
        if (resourcesBuilder_ != null) {
          return resourcesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(resources_);
        }
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.APIResource.Builder addResourcesBuilder() {
        return getResourcesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.APIResource.getDefaultInstance());
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.APIResource.Builder addResourcesBuilder(
          int index) {
        return getResourcesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.APIResource.getDefaultInstance());
      }
      /**
       * <pre>
       * resources contains the name of the resources and if they are namespaced.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.APIResource.Builder> 
           getResourcesBuilderList() {
        return getResourcesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.APIResource, io.kubernetes.client.proto.Meta.APIResource.Builder, io.kubernetes.client.proto.Meta.APIResourceOrBuilder> 
          getResourcesFieldBuilder() {
        if (resourcesBuilder_ == null) {
          resourcesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.APIResource, io.kubernetes.client.proto.Meta.APIResource.Builder, io.kubernetes.client.proto.Meta.APIResourceOrBuilder>(
                  resources_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          resources_ = null;
        }
        return resourcesBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList)
    private static final io.kubernetes.client.proto.Meta.APIResourceList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.APIResourceList();
    }

    public static io.kubernetes.client.proto.Meta.APIResourceList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<APIResourceList>
        PARSER = new com.google.protobuf.AbstractParser<APIResourceList>() {
      @java.lang.Override
      public APIResourceList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<APIResourceList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<APIResourceList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.APIResourceList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface APIVersionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * versions are the api versions that are available.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string versions = 1;</code>
     * @return A list containing the versions.
     */
    java.util.List<java.lang.String>
        getVersionsList();
    /**
     * <pre>
     * versions are the api versions that are available.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string versions = 1;</code>
     * @return The count of versions.
     */
    int getVersionsCount();
    /**
     * <pre>
     * versions are the api versions that are available.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string versions = 1;</code>
     * @param index The index of the element to return.
     * @return The versions at the given index.
     */
    java.lang.String getVersions(int index);
    /**
     * <pre>
     * versions are the api versions that are available.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string versions = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the versions at the given index.
     */
    com.google.protobuf.ByteString
        getVersionsBytes(int index);

    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> 
        getServerAddressByClientCIDRsList();
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR getServerAddressByClientCIDRs(int index);
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    int getServerAddressByClientCIDRsCount();
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> 
        getServerAddressByClientCIDRsOrBuilderList();
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder getServerAddressByClientCIDRsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * APIVersions lists the versions that are available, to allow clients to
   * discover the API at /api, which is the root path of the legacy v1 API.
   *
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions}
   */
  public static final class APIVersions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions)
      APIVersionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        APIVersions.class.getName());
    }
    // Use APIVersions.newBuilder() to construct.
    private APIVersions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private APIVersions() {
      versions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      serverAddressByClientCIDRs_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.APIVersions.class, io.kubernetes.client.proto.Meta.APIVersions.Builder.class);
    }

    public static final int VERSIONS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList versions_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * versions are the api versions that are available.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string versions = 1;</code>
     * @return A list containing the versions.
     */
    public com.google.protobuf.ProtocolStringList
        getVersionsList() {
      return versions_;
    }
    /**
     * <pre>
     * versions are the api versions that are available.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string versions = 1;</code>
     * @return The count of versions.
     */
    public int getVersionsCount() {
      return versions_.size();
    }
    /**
     * <pre>
     * versions are the api versions that are available.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string versions = 1;</code>
     * @param index The index of the element to return.
     * @return The versions at the given index.
     */
    public java.lang.String getVersions(int index) {
      return versions_.get(index);
    }
    /**
     * <pre>
     * versions are the api versions that are available.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string versions = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the versions at the given index.
     */
    public com.google.protobuf.ByteString
        getVersionsBytes(int index) {
      return versions_.getByteString(index);
    }

    public static final int SERVERADDRESSBYCLIENTCIDRS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> serverAddressByClientCIDRs_;
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> getServerAddressByClientCIDRsList() {
      return serverAddressByClientCIDRs_;
    }
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> 
        getServerAddressByClientCIDRsOrBuilderList() {
      return serverAddressByClientCIDRs_;
    }
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    @java.lang.Override
    public int getServerAddressByClientCIDRsCount() {
      return serverAddressByClientCIDRs_.size();
    }
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR getServerAddressByClientCIDRs(int index) {
      return serverAddressByClientCIDRs_.get(index);
    }
    /**
     * <pre>
     * a map of client CIDR to server address that is serving this group.
     * This is to help clients reach servers in the most network-efficient way possible.
     * Clients can use the appropriate server address as per the CIDR that they match.
     * In case of multiple matches, clients should use the longest matching CIDR.
     * The server returns only those CIDRs that it thinks that the client can match.
     * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
     * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder getServerAddressByClientCIDRsOrBuilder(
        int index) {
      return serverAddressByClientCIDRs_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < versions_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, versions_.getRaw(i));
      }
      for (int i = 0; i < serverAddressByClientCIDRs_.size(); i++) {
        output.writeMessage(2, serverAddressByClientCIDRs_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < versions_.size(); i++) {
          dataSize += computeStringSizeNoTag(versions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getVersionsList().size();
      }
      for (int i = 0; i < serverAddressByClientCIDRs_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, serverAddressByClientCIDRs_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.APIVersions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.APIVersions other = (io.kubernetes.client.proto.Meta.APIVersions) obj;

      if (!getVersionsList()
          .equals(other.getVersionsList())) return false;
      if (!getServerAddressByClientCIDRsList()
          .equals(other.getServerAddressByClientCIDRsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getVersionsCount() > 0) {
        hash = (37 * hash) + VERSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getVersionsList().hashCode();
      }
      if (getServerAddressByClientCIDRsCount() > 0) {
        hash = (37 * hash) + SERVERADDRESSBYCLIENTCIDRS_FIELD_NUMBER;
        hash = (53 * hash) + getServerAddressByClientCIDRsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.APIVersions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.APIVersions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.APIVersions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.APIVersions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * APIVersions lists the versions that are available, to allow clients to
     * discover the API at /api, which is the root path of the legacy v1 API.
     *
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions)
        io.kubernetes.client.proto.Meta.APIVersionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.APIVersions.class, io.kubernetes.client.proto.Meta.APIVersions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.APIVersions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        versions_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        if (serverAddressByClientCIDRsBuilder_ == null) {
          serverAddressByClientCIDRs_ = java.util.Collections.emptyList();
        } else {
          serverAddressByClientCIDRs_ = null;
          serverAddressByClientCIDRsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIVersions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.APIVersions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIVersions build() {
        io.kubernetes.client.proto.Meta.APIVersions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.APIVersions buildPartial() {
        io.kubernetes.client.proto.Meta.APIVersions result = new io.kubernetes.client.proto.Meta.APIVersions(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.Meta.APIVersions result) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            serverAddressByClientCIDRs_ = java.util.Collections.unmodifiableList(serverAddressByClientCIDRs_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.serverAddressByClientCIDRs_ = serverAddressByClientCIDRs_;
        } else {
          result.serverAddressByClientCIDRs_ = serverAddressByClientCIDRsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.APIVersions result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          versions_.makeImmutable();
          result.versions_ = versions_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.APIVersions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.APIVersions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.APIVersions other) {
        if (other == io.kubernetes.client.proto.Meta.APIVersions.getDefaultInstance()) return this;
        if (!other.versions_.isEmpty()) {
          if (versions_.isEmpty()) {
            versions_ = other.versions_;
            bitField0_ |= 0x00000001;
          } else {
            ensureVersionsIsMutable();
            versions_.addAll(other.versions_);
          }
          onChanged();
        }
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (!other.serverAddressByClientCIDRs_.isEmpty()) {
            if (serverAddressByClientCIDRs_.isEmpty()) {
              serverAddressByClientCIDRs_ = other.serverAddressByClientCIDRs_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureServerAddressByClientCIDRsIsMutable();
              serverAddressByClientCIDRs_.addAll(other.serverAddressByClientCIDRs_);
            }
            onChanged();
          }
        } else {
          if (!other.serverAddressByClientCIDRs_.isEmpty()) {
            if (serverAddressByClientCIDRsBuilder_.isEmpty()) {
              serverAddressByClientCIDRsBuilder_.dispose();
              serverAddressByClientCIDRsBuilder_ = null;
              serverAddressByClientCIDRs_ = other.serverAddressByClientCIDRs_;
              bitField0_ = (bitField0_ & ~0x00000002);
              serverAddressByClientCIDRsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getServerAddressByClientCIDRsFieldBuilder() : null;
            } else {
              serverAddressByClientCIDRsBuilder_.addAllMessages(other.serverAddressByClientCIDRs_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureVersionsIsMutable();
                versions_.add(bs);
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.parser(),
                        extensionRegistry);
                if (serverAddressByClientCIDRsBuilder_ == null) {
                  ensureServerAddressByClientCIDRsIsMutable();
                  serverAddressByClientCIDRs_.add(m);
                } else {
                  serverAddressByClientCIDRsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList versions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureVersionsIsMutable() {
        if (!versions_.isModifiable()) {
          versions_ = new com.google.protobuf.LazyStringArrayList(versions_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * versions are the api versions that are available.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string versions = 1;</code>
       * @return A list containing the versions.
       */
      public com.google.protobuf.ProtocolStringList
          getVersionsList() {
        versions_.makeImmutable();
        return versions_;
      }
      /**
       * <pre>
       * versions are the api versions that are available.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string versions = 1;</code>
       * @return The count of versions.
       */
      public int getVersionsCount() {
        return versions_.size();
      }
      /**
       * <pre>
       * versions are the api versions that are available.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string versions = 1;</code>
       * @param index The index of the element to return.
       * @return The versions at the given index.
       */
      public java.lang.String getVersions(int index) {
        return versions_.get(index);
      }
      /**
       * <pre>
       * versions are the api versions that are available.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string versions = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the versions at the given index.
       */
      public com.google.protobuf.ByteString
          getVersionsBytes(int index) {
        return versions_.getByteString(index);
      }
      /**
       * <pre>
       * versions are the api versions that are available.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string versions = 1;</code>
       * @param index The index to set the value at.
       * @param value The versions to set.
       * @return This builder for chaining.
       */
      public Builder setVersions(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureVersionsIsMutable();
        versions_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * versions are the api versions that are available.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string versions = 1;</code>
       * @param value The versions to add.
       * @return This builder for chaining.
       */
      public Builder addVersions(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureVersionsIsMutable();
        versions_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * versions are the api versions that are available.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string versions = 1;</code>
       * @param values The versions to add.
       * @return This builder for chaining.
       */
      public Builder addAllVersions(
          java.lang.Iterable<java.lang.String> values) {
        ensureVersionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, versions_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * versions are the api versions that are available.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string versions = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersions() {
        versions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * versions are the api versions that are available.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string versions = 1;</code>
       * @param value The bytes of the versions to add.
       * @return This builder for chaining.
       */
      public Builder addVersionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureVersionsIsMutable();
        versions_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> serverAddressByClientCIDRs_ =
        java.util.Collections.emptyList();
      private void ensureServerAddressByClientCIDRsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          serverAddressByClientCIDRs_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR>(serverAddressByClientCIDRs_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> serverAddressByClientCIDRsBuilder_;

      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> getServerAddressByClientCIDRsList() {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(serverAddressByClientCIDRs_);
        } else {
          return serverAddressByClientCIDRsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public int getServerAddressByClientCIDRsCount() {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          return serverAddressByClientCIDRs_.size();
        } else {
          return serverAddressByClientCIDRsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR getServerAddressByClientCIDRs(int index) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          return serverAddressByClientCIDRs_.get(index);
        } else {
          return serverAddressByClientCIDRsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public Builder setServerAddressByClientCIDRs(
          int index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR value) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.set(index, value);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public Builder setServerAddressByClientCIDRs(
          int index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder builderForValue) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.set(index, builderForValue.build());
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public Builder addServerAddressByClientCIDRs(io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR value) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.add(value);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public Builder addServerAddressByClientCIDRs(
          int index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR value) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.add(index, value);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public Builder addServerAddressByClientCIDRs(
          io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder builderForValue) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.add(builderForValue.build());
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public Builder addServerAddressByClientCIDRs(
          int index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder builderForValue) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.add(index, builderForValue.build());
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public Builder addAllServerAddressByClientCIDRs(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR> values) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, serverAddressByClientCIDRs_);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public Builder clearServerAddressByClientCIDRs() {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          serverAddressByClientCIDRs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public Builder removeServerAddressByClientCIDRs(int index) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          ensureServerAddressByClientCIDRsIsMutable();
          serverAddressByClientCIDRs_.remove(index);
          onChanged();
        } else {
          serverAddressByClientCIDRsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder getServerAddressByClientCIDRsBuilder(
          int index) {
        return getServerAddressByClientCIDRsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder getServerAddressByClientCIDRsOrBuilder(
          int index) {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          return serverAddressByClientCIDRs_.get(index);  } else {
          return serverAddressByClientCIDRsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> 
           getServerAddressByClientCIDRsOrBuilderList() {
        if (serverAddressByClientCIDRsBuilder_ != null) {
          return serverAddressByClientCIDRsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(serverAddressByClientCIDRs_);
        }
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder addServerAddressByClientCIDRsBuilder() {
        return getServerAddressByClientCIDRsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.getDefaultInstance());
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder addServerAddressByClientCIDRsBuilder(
          int index) {
        return getServerAddressByClientCIDRsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.getDefaultInstance());
      }
      /**
       * <pre>
       * a map of client CIDR to server address that is serving this group.
       * This is to help clients reach servers in the most network-efficient way possible.
       * Clients can use the appropriate server address as per the CIDR that they match.
       * In case of multiple matches, clients should use the longest matching CIDR.
       * The server returns only those CIDRs that it thinks that the client can match.
       * For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
       * Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder> 
           getServerAddressByClientCIDRsBuilderList() {
        return getServerAddressByClientCIDRsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder> 
          getServerAddressByClientCIDRsFieldBuilder() {
        if (serverAddressByClientCIDRsBuilder_ == null) {
          serverAddressByClientCIDRsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder>(
                  serverAddressByClientCIDRs_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          serverAddressByClientCIDRs_ = null;
        }
        return serverAddressByClientCIDRsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions)
    private static final io.kubernetes.client.proto.Meta.APIVersions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.APIVersions();
    }

    public static io.kubernetes.client.proto.Meta.APIVersions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<APIVersions>
        PARSER = new com.google.protobuf.AbstractParser<APIVersions>() {
      @java.lang.Override
      public APIVersions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<APIVersions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<APIVersions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.APIVersions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ApplyOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return A list containing the dryRun.
     */
    java.util.List<java.lang.String>
        getDryRunList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return The count of dryRun.
     */
    int getDryRunCount();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    java.lang.String getDryRun(int index);
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    com.google.protobuf.ByteString
        getDryRunBytes(int index);

    /**
     * <pre>
     * Force is going to "force" Apply requests. It means user will
     * re-acquire conflicting fields owned by other people.
     * </pre>
     *
     * <code>optional bool force = 2;</code>
     * @return Whether the force field is set.
     */
    boolean hasForce();
    /**
     * <pre>
     * Force is going to "force" Apply requests. It means user will
     * re-acquire conflicting fields owned by other people.
     * </pre>
     *
     * <code>optional bool force = 2;</code>
     * @return The force.
     */
    boolean getForce();

    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required.
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return Whether the fieldManager field is set.
     */
    boolean hasFieldManager();
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required.
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The fieldManager.
     */
    java.lang.String getFieldManager();
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required.
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The bytes for fieldManager.
     */
    com.google.protobuf.ByteString
        getFieldManagerBytes();
  }
  /**
   * <pre>
   * ApplyOptions may be provided when applying an API object.
   * FieldManager is required for apply requests.
   * ApplyOptions is equivalent to PatchOptions. It is provided as a convenience with documentation
   * that speaks specifically to how the options fields relate to apply.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions}
   */
  public static final class ApplyOptions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions)
      ApplyOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ApplyOptions.class.getName());
    }
    // Use ApplyOptions.newBuilder() to construct.
    private ApplyOptions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ApplyOptions() {
      dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      fieldManager_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.ApplyOptions.class, io.kubernetes.client.proto.Meta.ApplyOptions.Builder.class);
    }

    private int bitField0_;
    public static final int DRYRUN_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList dryRun_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return A list containing the dryRun.
     */
    public com.google.protobuf.ProtocolStringList
        getDryRunList() {
      return dryRun_;
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return The count of dryRun.
     */
    public int getDryRunCount() {
      return dryRun_.size();
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    public java.lang.String getDryRun(int index) {
      return dryRun_.get(index);
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    public com.google.protobuf.ByteString
        getDryRunBytes(int index) {
      return dryRun_.getByteString(index);
    }

    public static final int FORCE_FIELD_NUMBER = 2;
    private boolean force_ = false;
    /**
     * <pre>
     * Force is going to "force" Apply requests. It means user will
     * re-acquire conflicting fields owned by other people.
     * </pre>
     *
     * <code>optional bool force = 2;</code>
     * @return Whether the force field is set.
     */
    @java.lang.Override
    public boolean hasForce() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Force is going to "force" Apply requests. It means user will
     * re-acquire conflicting fields owned by other people.
     * </pre>
     *
     * <code>optional bool force = 2;</code>
     * @return The force.
     */
    @java.lang.Override
    public boolean getForce() {
      return force_;
    }

    public static final int FIELDMANAGER_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldManager_ = "";
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required.
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return Whether the fieldManager field is set.
     */
    @java.lang.Override
    public boolean hasFieldManager() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required.
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The fieldManager.
     */
    @java.lang.Override
    public java.lang.String getFieldManager() {
      java.lang.Object ref = fieldManager_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldManager_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required.
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The bytes for fieldManager.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldManagerBytes() {
      java.lang.Object ref = fieldManager_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldManager_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < dryRun_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, dryRun_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(2, force_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, fieldManager_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < dryRun_.size(); i++) {
          dataSize += computeStringSizeNoTag(dryRun_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getDryRunList().size();
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, force_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, fieldManager_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.ApplyOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.ApplyOptions other = (io.kubernetes.client.proto.Meta.ApplyOptions) obj;

      if (!getDryRunList()
          .equals(other.getDryRunList())) return false;
      if (hasForce() != other.hasForce()) return false;
      if (hasForce()) {
        if (getForce()
            != other.getForce()) return false;
      }
      if (hasFieldManager() != other.hasFieldManager()) return false;
      if (hasFieldManager()) {
        if (!getFieldManager()
            .equals(other.getFieldManager())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getDryRunCount() > 0) {
        hash = (37 * hash) + DRYRUN_FIELD_NUMBER;
        hash = (53 * hash) + getDryRunList().hashCode();
      }
      if (hasForce()) {
        hash = (37 * hash) + FORCE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getForce());
      }
      if (hasFieldManager()) {
        hash = (37 * hash) + FIELDMANAGER_FIELD_NUMBER;
        hash = (53 * hash) + getFieldManager().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.ApplyOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.ApplyOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ApplyOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.ApplyOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ApplyOptions may be provided when applying an API object.
     * FieldManager is required for apply requests.
     * ApplyOptions is equivalent to PatchOptions. It is provided as a convenience with documentation
     * that speaks specifically to how the options fields relate to apply.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions)
        io.kubernetes.client.proto.Meta.ApplyOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.ApplyOptions.class, io.kubernetes.client.proto.Meta.ApplyOptions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.ApplyOptions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        dryRun_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        force_ = false;
        fieldManager_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ApplyOptions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.ApplyOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ApplyOptions build() {
        io.kubernetes.client.proto.Meta.ApplyOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ApplyOptions buildPartial() {
        io.kubernetes.client.proto.Meta.ApplyOptions result = new io.kubernetes.client.proto.Meta.ApplyOptions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.ApplyOptions result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          dryRun_.makeImmutable();
          result.dryRun_ = dryRun_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.force_ = force_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.fieldManager_ = fieldManager_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.ApplyOptions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.ApplyOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.ApplyOptions other) {
        if (other == io.kubernetes.client.proto.Meta.ApplyOptions.getDefaultInstance()) return this;
        if (!other.dryRun_.isEmpty()) {
          if (dryRun_.isEmpty()) {
            dryRun_ = other.dryRun_;
            bitField0_ |= 0x00000001;
          } else {
            ensureDryRunIsMutable();
            dryRun_.addAll(other.dryRun_);
          }
          onChanged();
        }
        if (other.hasForce()) {
          setForce(other.getForce());
        }
        if (other.hasFieldManager()) {
          fieldManager_ = other.fieldManager_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureDryRunIsMutable();
                dryRun_.add(bs);
                break;
              } // case 10
              case 16: {
                force_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                fieldManager_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureDryRunIsMutable() {
        if (!dryRun_.isModifiable()) {
          dryRun_ = new com.google.protobuf.LazyStringArrayList(dryRun_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return A list containing the dryRun.
       */
      public com.google.protobuf.ProtocolStringList
          getDryRunList() {
        dryRun_.makeImmutable();
        return dryRun_;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return The count of dryRun.
       */
      public int getDryRunCount() {
        return dryRun_.size();
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index of the element to return.
       * @return The dryRun at the given index.
       */
      public java.lang.String getDryRun(int index) {
        return dryRun_.get(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the dryRun at the given index.
       */
      public com.google.protobuf.ByteString
          getDryRunBytes(int index) {
        return dryRun_.getByteString(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index to set the value at.
       * @param value The dryRun to set.
       * @return This builder for chaining.
       */
      public Builder setDryRun(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param value The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRun(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param values The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addAllDryRun(
          java.lang.Iterable<java.lang.String> values) {
        ensureDryRunIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, dryRun_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDryRun() {
        dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param value The bytes of the dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRunBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private boolean force_ ;
      /**
       * <pre>
       * Force is going to "force" Apply requests. It means user will
       * re-acquire conflicting fields owned by other people.
       * </pre>
       *
       * <code>optional bool force = 2;</code>
       * @return Whether the force field is set.
       */
      @java.lang.Override
      public boolean hasForce() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Force is going to "force" Apply requests. It means user will
       * re-acquire conflicting fields owned by other people.
       * </pre>
       *
       * <code>optional bool force = 2;</code>
       * @return The force.
       */
      @java.lang.Override
      public boolean getForce() {
        return force_;
      }
      /**
       * <pre>
       * Force is going to "force" Apply requests. It means user will
       * re-acquire conflicting fields owned by other people.
       * </pre>
       *
       * <code>optional bool force = 2;</code>
       * @param value The force to set.
       * @return This builder for chaining.
       */
      public Builder setForce(boolean value) {

        force_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Force is going to "force" Apply requests. It means user will
       * re-acquire conflicting fields owned by other people.
       * </pre>
       *
       * <code>optional bool force = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearForce() {
        bitField0_ = (bitField0_ & ~0x00000002);
        force_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object fieldManager_ = "";
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required.
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return Whether the fieldManager field is set.
       */
      public boolean hasFieldManager() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required.
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return The fieldManager.
       */
      public java.lang.String getFieldManager() {
        java.lang.Object ref = fieldManager_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldManager_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required.
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return The bytes for fieldManager.
       */
      public com.google.protobuf.ByteString
          getFieldManagerBytes() {
        java.lang.Object ref = fieldManager_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldManager_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required.
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @param value The fieldManager to set.
       * @return This builder for chaining.
       */
      public Builder setFieldManager(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldManager_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required.
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldManager() {
        fieldManager_ = getDefaultInstance().getFieldManager();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required.
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @param value The bytes for fieldManager to set.
       * @return This builder for chaining.
       */
      public Builder setFieldManagerBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldManager_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions)
    private static final io.kubernetes.client.proto.Meta.ApplyOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.ApplyOptions();
    }

    public static io.kubernetes.client.proto.Meta.ApplyOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ApplyOptions>
        PARSER = new com.google.protobuf.AbstractParser<ApplyOptions>() {
      @java.lang.Override
      public ApplyOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ApplyOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ApplyOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ApplyOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.Condition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * type of condition in CamelCase or in foo.example.com/CamelCase.
     * ---
     * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
     * useful (see .node.status.conditions), the ability to deconflict is important.
     * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
     * +kubebuilder:validation:MaxLength=316
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * type of condition in CamelCase or in foo.example.com/CamelCase.
     * ---
     * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
     * useful (see .node.status.conditions), the ability to deconflict is important.
     * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
     * +kubebuilder:validation:MaxLength=316
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * type of condition in CamelCase or in foo.example.com/CamelCase.
     * ---
     * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
     * useful (see .node.status.conditions), the ability to deconflict is important.
     * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
     * +kubebuilder:validation:MaxLength=316
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * status of the condition, one of True, False, Unknown.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Enum=True;False;Unknown
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * status of the condition, one of True, False, Unknown.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Enum=True;False;Unknown
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    java.lang.String getStatus();
    /**
     * <pre>
     * status of the condition, one of True, False, Unknown.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Enum=True;False;Unknown
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    com.google.protobuf.ByteString
        getStatusBytes();

    /**
     * <pre>
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     * +optional
     * +kubebuilder:validation:Minimum=0
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     * @return Whether the observedGeneration field is set.
     */
    boolean hasObservedGeneration();
    /**
     * <pre>
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     * +optional
     * +kubebuilder:validation:Minimum=0
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     * @return The observedGeneration.
     */
    long getObservedGeneration();

    /**
     * <pre>
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Type=string
     * +kubebuilder:validation:Format=date-time
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    boolean hasLastTransitionTime();
    /**
     * <pre>
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Type=string
     * +kubebuilder:validation:Format=date-time
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     * @return The lastTransitionTime.
     */
    io.kubernetes.client.proto.Meta.Time getLastTransitionTime();
    /**
     * <pre>
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Type=string
     * +kubebuilder:validation:Format=date-time
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder();

    /**
     * <pre>
     * reason contains a programmatic identifier indicating the reason for the condition's last transition.
     * Producers of specific condition types may define expected values and meanings for this field,
     * and whether the values are considered a guaranteed API.
     * The value should be a CamelCase string.
     * This field may not be empty.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=1024
     * +kubebuilder:validation:MinLength=1
     * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * reason contains a programmatic identifier indicating the reason for the condition's last transition.
     * Producers of specific condition types may define expected values and meanings for this field,
     * and whether the values are considered a guaranteed API.
     * The value should be a CamelCase string.
     * This field may not be empty.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=1024
     * +kubebuilder:validation:MinLength=1
     * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * reason contains a programmatic identifier indicating the reason for the condition's last transition.
     * Producers of specific condition types may define expected values and meanings for this field,
     * and whether the values are considered a guaranteed API.
     * The value should be a CamelCase string.
     * This field may not be empty.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=1024
     * +kubebuilder:validation:MinLength=1
     * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=32768
     * </pre>
     *
     * <code>optional string message = 6;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=32768
     * </pre>
     *
     * <code>optional string message = 6;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=32768
     * </pre>
     *
     * <code>optional string message = 6;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * <pre>
   * Condition contains details for one aspect of the current state of this API Resource.
   * ---
   * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
   *
   * type FooStatus struct{
   * // Represents the observations of a foo's current state.
   * // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
   * // +patchMergeKey=type
   * // +patchStrategy=merge
   * // +listType=map
   * // +listMapKey=type
   * Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
   *
   * // other fields
   * }
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Condition}
   */
  public static final class Condition extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Condition)
      ConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Condition.class.getName());
    }
    // Use Condition.newBuilder() to construct.
    private Condition(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Condition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.Condition.class, io.kubernetes.client.proto.Meta.Condition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <pre>
     * type of condition in CamelCase or in foo.example.com/CamelCase.
     * ---
     * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
     * useful (see .node.status.conditions), the ability to deconflict is important.
     * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
     * +kubebuilder:validation:MaxLength=316
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * type of condition in CamelCase or in foo.example.com/CamelCase.
     * ---
     * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
     * useful (see .node.status.conditions), the ability to deconflict is important.
     * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
     * +kubebuilder:validation:MaxLength=316
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * type of condition in CamelCase or in foo.example.com/CamelCase.
     * ---
     * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
     * useful (see .node.status.conditions), the ability to deconflict is important.
     * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
     * +kubebuilder:validation:MaxLength=316
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object status_ = "";
    /**
     * <pre>
     * status of the condition, one of True, False, Unknown.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Enum=True;False;Unknown
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * status of the condition, one of True, False, Unknown.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Enum=True;False;Unknown
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    @java.lang.Override
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * status of the condition, one of True, False, Unknown.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Enum=True;False;Unknown
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 3;
    private long observedGeneration_ = 0L;
    /**
     * <pre>
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     * +optional
     * +kubebuilder:validation:Minimum=0
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     * @return Whether the observedGeneration field is set.
     */
    @java.lang.Override
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * observedGeneration represents the .metadata.generation that the condition was set based upon.
     * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
     * with respect to the current state of the instance.
     * +optional
     * +kubebuilder:validation:Minimum=0
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     * @return The observedGeneration.
     */
    @java.lang.Override
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int LASTTRANSITIONTIME_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
    /**
     * <pre>
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Type=string
     * +kubebuilder:validation:Format=date-time
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    @java.lang.Override
    public boolean hasLastTransitionTime() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Type=string
     * +kubebuilder:validation:Format=date-time
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     * @return The lastTransitionTime.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }
    /**
     * <pre>
     * lastTransitionTime is the last time the condition transitioned from one status to another.
     * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:Type=string
     * +kubebuilder:validation:Format=date-time
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * reason contains a programmatic identifier indicating the reason for the condition's last transition.
     * Producers of specific condition types may define expected values and meanings for this field,
     * and whether the values are considered a guaranteed API.
     * The value should be a CamelCase string.
     * This field may not be empty.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=1024
     * +kubebuilder:validation:MinLength=1
     * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * reason contains a programmatic identifier indicating the reason for the condition's last transition.
     * Producers of specific condition types may define expected values and meanings for this field,
     * and whether the values are considered a guaranteed API.
     * The value should be a CamelCase string.
     * This field may not be empty.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=1024
     * +kubebuilder:validation:MinLength=1
     * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * reason contains a programmatic identifier indicating the reason for the condition's last transition.
     * Producers of specific condition types may define expected values and meanings for this field,
     * and whether the values are considered a guaranteed API.
     * The value should be a CamelCase string.
     * This field may not be empty.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=1024
     * +kubebuilder:validation:MinLength=1
     * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=32768
     * </pre>
     *
     * <code>optional string message = 6;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=32768
     * </pre>
     *
     * <code>optional string message = 6;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * message is a human readable message indicating details about the transition.
     * This may be an empty string.
     * +required
     * +kubebuilder:validation:Required
     * +kubebuilder:validation:MaxLength=32768
     * </pre>
     *
     * <code>optional string message = 6;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt64(3, observedGeneration_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, reason_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, message_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, observedGeneration_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, reason_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, message_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.Condition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.Condition other = (io.kubernetes.client.proto.Meta.Condition) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (hasObservedGeneration() != other.hasObservedGeneration()) return false;
      if (hasObservedGeneration()) {
        if (getObservedGeneration()
            != other.getObservedGeneration()) return false;
      }
      if (hasLastTransitionTime() != other.hasLastTransitionTime()) return false;
      if (hasLastTransitionTime()) {
        if (!getLastTransitionTime()
            .equals(other.getLastTransitionTime())) return false;
      }
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getObservedGeneration());
      }
      if (hasLastTransitionTime()) {
        hash = (37 * hash) + LASTTRANSITIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastTransitionTime().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.Condition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Condition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Condition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Condition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Condition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Condition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Condition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Condition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.Condition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.Condition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Condition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Condition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.Condition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Condition contains details for one aspect of the current state of this API Resource.
     * ---
     * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
     *
     * type FooStatus struct{
     * // Represents the observations of a foo's current state.
     * // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
     * // +patchMergeKey=type
     * // +patchStrategy=merge
     * // +listType=map
     * // +listMapKey=type
     * Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
     *
     * // other fields
     * }
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Condition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Condition)
        io.kubernetes.client.proto.Meta.ConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.Condition.class, io.kubernetes.client.proto.Meta.Condition.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.Condition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getLastTransitionTimeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        status_ = "";
        observedGeneration_ = 0L;
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        reason_ = "";
        message_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Condition getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.Condition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Condition build() {
        io.kubernetes.client.proto.Meta.Condition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Condition buildPartial() {
        io.kubernetes.client.proto.Meta.Condition result = new io.kubernetes.client.proto.Meta.Condition(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.Condition result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.observedGeneration_ = observedGeneration_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.lastTransitionTime_ = lastTransitionTimeBuilder_ == null
              ? lastTransitionTime_
              : lastTransitionTimeBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000020;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.Condition) {
          return mergeFrom((io.kubernetes.client.proto.Meta.Condition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.Condition other) {
        if (other == io.kubernetes.client.proto.Meta.Condition.getDefaultInstance()) return this;
        if (other.hasType()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasStatus()) {
          status_ = other.status_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasLastTransitionTime()) {
          mergeLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                status_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                observedGeneration_ = input.readInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                input.readMessage(
                    getLastTransitionTimeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                reason_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                message_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       * ---
       * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
       * useful (see .node.status.conditions), the ability to deconflict is important.
       * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
       * +kubebuilder:validation:MaxLength=316
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       * ---
       * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
       * useful (see .node.status.conditions), the ability to deconflict is important.
       * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
       * +kubebuilder:validation:MaxLength=316
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       * ---
       * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
       * useful (see .node.status.conditions), the ability to deconflict is important.
       * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
       * +kubebuilder:validation:MaxLength=316
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       * ---
       * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
       * useful (see .node.status.conditions), the ability to deconflict is important.
       * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
       * +kubebuilder:validation:MaxLength=316
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       * ---
       * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
       * useful (see .node.status.conditions), the ability to deconflict is important.
       * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
       * +kubebuilder:validation:MaxLength=316
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       * ---
       * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
       * useful (see .node.status.conditions), the ability to deconflict is important.
       * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(&#92;.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#47;)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
       * +kubebuilder:validation:MaxLength=316
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       * <pre>
       * status of the condition, one of True, False, Unknown.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Enum=True;False;Unknown
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * status of the condition, one of True, False, Unknown.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Enum=True;False;Unknown
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The status.
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * status of the condition, one of True, False, Unknown.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Enum=True;False;Unknown
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The bytes for status.
       */
      public com.google.protobuf.ByteString
          getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * status of the condition, one of True, False, Unknown.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Enum=True;False;Unknown
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * status of the condition, one of True, False, Unknown.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Enum=True;False;Unknown
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        status_ = getDefaultInstance().getStatus();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * status of the condition, one of True, False, Unknown.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Enum=True;False;Unknown
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The bytes for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private long observedGeneration_ ;
      /**
       * <pre>
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       * +optional
       * +kubebuilder:validation:Minimum=0
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       * @return Whether the observedGeneration field is set.
       */
      @java.lang.Override
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       * +optional
       * +kubebuilder:validation:Minimum=0
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       * @return The observedGeneration.
       */
      @java.lang.Override
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       * <pre>
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       * +optional
       * +kubebuilder:validation:Minimum=0
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       * @param value The observedGeneration to set.
       * @return This builder for chaining.
       */
      public Builder setObservedGeneration(long value) {

        observedGeneration_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       * +optional
       * +kubebuilder:validation:Minimum=0
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000004);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastTransitionTimeBuilder_;
      /**
       * <pre>
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Type=string
       * +kubebuilder:validation:Format=date-time
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       * @return Whether the lastTransitionTime field is set.
       */
      public boolean hasLastTransitionTime() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Type=string
       * +kubebuilder:validation:Format=date-time
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       * @return The lastTransitionTime.
       */
      public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        } else {
          return lastTransitionTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Type=string
       * +kubebuilder:validation:Format=date-time
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public Builder setLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastTransitionTime_ = value;
        } else {
          lastTransitionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Type=string
       * +kubebuilder:validation:Format=date-time
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public Builder setLastTransitionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = builderForValue.build();
        } else {
          lastTransitionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Type=string
       * +kubebuilder:validation:Format=date-time
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public Builder mergeLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            lastTransitionTime_ != null &&
            lastTransitionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getLastTransitionTimeBuilder().mergeFrom(value);
          } else {
            lastTransitionTime_ = value;
          }
        } else {
          lastTransitionTimeBuilder_.mergeFrom(value);
        }
        if (lastTransitionTime_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Type=string
       * +kubebuilder:validation:Format=date-time
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public Builder clearLastTransitionTime() {
        bitField0_ = (bitField0_ & ~0x00000008);
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Type=string
       * +kubebuilder:validation:Format=date-time
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastTransitionTimeBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getLastTransitionTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Type=string
       * +kubebuilder:validation:Format=date-time
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
        if (lastTransitionTimeBuilder_ != null) {
          return lastTransitionTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastTransitionTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        }
      }
      /**
       * <pre>
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:Type=string
       * +kubebuilder:validation:Format=date-time
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastTransitionTimeFieldBuilder() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTimeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastTransitionTime(),
                  getParentForChildren(),
                  isClean());
          lastTransitionTime_ = null;
        }
        return lastTransitionTimeBuilder_;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=1024
       * +kubebuilder:validation:MinLength=1
       * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=1024
       * +kubebuilder:validation:MinLength=1
       * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=1024
       * +kubebuilder:validation:MinLength=1
       * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=1024
       * +kubebuilder:validation:MinLength=1
       * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=1024
       * +kubebuilder:validation:MinLength=1
       * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=1024
       * +kubebuilder:validation:MinLength=1
       * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=32768
       * </pre>
       *
       * <code>optional string message = 6;</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=32768
       * </pre>
       *
       * <code>optional string message = 6;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=32768
       * </pre>
       *
       * <code>optional string message = 6;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=32768
       * </pre>
       *
       * <code>optional string message = 6;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=32768
       * </pre>
       *
       * <code>optional string message = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       * +required
       * +kubebuilder:validation:Required
       * +kubebuilder:validation:MaxLength=32768
       * </pre>
       *
       * <code>optional string message = 6;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Condition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Condition)
    private static final io.kubernetes.client.proto.Meta.Condition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.Condition();
    }

    public static io.kubernetes.client.proto.Meta.Condition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Condition>
        PARSER = new com.google.protobuf.AbstractParser<Condition>() {
      @java.lang.Override
      public Condition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Condition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Condition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Condition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CreateOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return A list containing the dryRun.
     */
    java.util.List<java.lang.String>
        getDryRunList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return The count of dryRun.
     */
    int getDryRunCount();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    java.lang.String getDryRun(int index);
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    com.google.protobuf.ByteString
        getDryRunBytes(int index);

    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return Whether the fieldManager field is set.
     */
    boolean hasFieldManager();
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The fieldManager.
     */
    java.lang.String getFieldManager();
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The bytes for fieldManager.
     */
    com.google.protobuf.ByteString
        getFieldManagerBytes();

    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return Whether the fieldValidation field is set.
     */
    boolean hasFieldValidation();
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return The fieldValidation.
     */
    java.lang.String getFieldValidation();
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return The bytes for fieldValidation.
     */
    com.google.protobuf.ByteString
        getFieldValidationBytes();
  }
  /**
   * <pre>
   * CreateOptions may be provided when creating an API object.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions}
   */
  public static final class CreateOptions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions)
      CreateOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        CreateOptions.class.getName());
    }
    // Use CreateOptions.newBuilder() to construct.
    private CreateOptions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CreateOptions() {
      dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      fieldManager_ = "";
      fieldValidation_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.CreateOptions.class, io.kubernetes.client.proto.Meta.CreateOptions.Builder.class);
    }

    private int bitField0_;
    public static final int DRYRUN_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList dryRun_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return A list containing the dryRun.
     */
    public com.google.protobuf.ProtocolStringList
        getDryRunList() {
      return dryRun_;
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return The count of dryRun.
     */
    public int getDryRunCount() {
      return dryRun_.size();
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    public java.lang.String getDryRun(int index) {
      return dryRun_.get(index);
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    public com.google.protobuf.ByteString
        getDryRunBytes(int index) {
      return dryRun_.getByteString(index);
    }

    public static final int FIELDMANAGER_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldManager_ = "";
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return Whether the fieldManager field is set.
     */
    @java.lang.Override
    public boolean hasFieldManager() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The fieldManager.
     */
    @java.lang.Override
    public java.lang.String getFieldManager() {
      java.lang.Object ref = fieldManager_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldManager_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The bytes for fieldManager.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldManagerBytes() {
      java.lang.Object ref = fieldManager_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldManager_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FIELDVALIDATION_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldValidation_ = "";
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return Whether the fieldValidation field is set.
     */
    @java.lang.Override
    public boolean hasFieldValidation() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return The fieldValidation.
     */
    @java.lang.Override
    public java.lang.String getFieldValidation() {
      java.lang.Object ref = fieldValidation_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldValidation_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return The bytes for fieldValidation.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldValidationBytes() {
      java.lang.Object ref = fieldValidation_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldValidation_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < dryRun_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, dryRun_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, fieldManager_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, fieldValidation_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < dryRun_.size(); i++) {
          dataSize += computeStringSizeNoTag(dryRun_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getDryRunList().size();
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, fieldManager_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, fieldValidation_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.CreateOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.CreateOptions other = (io.kubernetes.client.proto.Meta.CreateOptions) obj;

      if (!getDryRunList()
          .equals(other.getDryRunList())) return false;
      if (hasFieldManager() != other.hasFieldManager()) return false;
      if (hasFieldManager()) {
        if (!getFieldManager()
            .equals(other.getFieldManager())) return false;
      }
      if (hasFieldValidation() != other.hasFieldValidation()) return false;
      if (hasFieldValidation()) {
        if (!getFieldValidation()
            .equals(other.getFieldValidation())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getDryRunCount() > 0) {
        hash = (37 * hash) + DRYRUN_FIELD_NUMBER;
        hash = (53 * hash) + getDryRunList().hashCode();
      }
      if (hasFieldManager()) {
        hash = (37 * hash) + FIELDMANAGER_FIELD_NUMBER;
        hash = (53 * hash) + getFieldManager().hashCode();
      }
      if (hasFieldValidation()) {
        hash = (37 * hash) + FIELDVALIDATION_FIELD_NUMBER;
        hash = (53 * hash) + getFieldValidation().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.CreateOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.CreateOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.CreateOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.CreateOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CreateOptions may be provided when creating an API object.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions)
        io.kubernetes.client.proto.Meta.CreateOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.CreateOptions.class, io.kubernetes.client.proto.Meta.CreateOptions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.CreateOptions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        dryRun_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        fieldManager_ = "";
        fieldValidation_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.CreateOptions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.CreateOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.CreateOptions build() {
        io.kubernetes.client.proto.Meta.CreateOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.CreateOptions buildPartial() {
        io.kubernetes.client.proto.Meta.CreateOptions result = new io.kubernetes.client.proto.Meta.CreateOptions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.CreateOptions result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          dryRun_.makeImmutable();
          result.dryRun_ = dryRun_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.fieldManager_ = fieldManager_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.fieldValidation_ = fieldValidation_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.CreateOptions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.CreateOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.CreateOptions other) {
        if (other == io.kubernetes.client.proto.Meta.CreateOptions.getDefaultInstance()) return this;
        if (!other.dryRun_.isEmpty()) {
          if (dryRun_.isEmpty()) {
            dryRun_ = other.dryRun_;
            bitField0_ |= 0x00000001;
          } else {
            ensureDryRunIsMutable();
            dryRun_.addAll(other.dryRun_);
          }
          onChanged();
        }
        if (other.hasFieldManager()) {
          fieldManager_ = other.fieldManager_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasFieldValidation()) {
          fieldValidation_ = other.fieldValidation_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureDryRunIsMutable();
                dryRun_.add(bs);
                break;
              } // case 10
              case 26: {
                fieldManager_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 26
              case 34: {
                fieldValidation_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureDryRunIsMutable() {
        if (!dryRun_.isModifiable()) {
          dryRun_ = new com.google.protobuf.LazyStringArrayList(dryRun_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return A list containing the dryRun.
       */
      public com.google.protobuf.ProtocolStringList
          getDryRunList() {
        dryRun_.makeImmutable();
        return dryRun_;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return The count of dryRun.
       */
      public int getDryRunCount() {
        return dryRun_.size();
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index of the element to return.
       * @return The dryRun at the given index.
       */
      public java.lang.String getDryRun(int index) {
        return dryRun_.get(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the dryRun at the given index.
       */
      public com.google.protobuf.ByteString
          getDryRunBytes(int index) {
        return dryRun_.getByteString(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index to set the value at.
       * @param value The dryRun to set.
       * @return This builder for chaining.
       */
      public Builder setDryRun(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param value The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRun(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param values The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addAllDryRun(
          java.lang.Iterable<java.lang.String> values) {
        ensureDryRunIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, dryRun_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDryRun() {
        dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param value The bytes of the dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRunBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object fieldManager_ = "";
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return Whether the fieldManager field is set.
       */
      public boolean hasFieldManager() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return The fieldManager.
       */
      public java.lang.String getFieldManager() {
        java.lang.Object ref = fieldManager_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldManager_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return The bytes for fieldManager.
       */
      public com.google.protobuf.ByteString
          getFieldManagerBytes() {
        java.lang.Object ref = fieldManager_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldManager_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @param value The fieldManager to set.
       * @return This builder for chaining.
       */
      public Builder setFieldManager(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldManager_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldManager() {
        fieldManager_ = getDefaultInstance().getFieldManager();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @param value The bytes for fieldManager to set.
       * @return This builder for chaining.
       */
      public Builder setFieldManagerBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldManager_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object fieldValidation_ = "";
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @return Whether the fieldValidation field is set.
       */
      public boolean hasFieldValidation() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @return The fieldValidation.
       */
      public java.lang.String getFieldValidation() {
        java.lang.Object ref = fieldValidation_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldValidation_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @return The bytes for fieldValidation.
       */
      public com.google.protobuf.ByteString
          getFieldValidationBytes() {
        java.lang.Object ref = fieldValidation_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldValidation_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @param value The fieldValidation to set.
       * @return This builder for chaining.
       */
      public Builder setFieldValidation(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldValidation_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldValidation() {
        fieldValidation_ = getDefaultInstance().getFieldValidation();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @param value The bytes for fieldValidation to set.
       * @return This builder for chaining.
       */
      public Builder setFieldValidationBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldValidation_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions)
    private static final io.kubernetes.client.proto.Meta.CreateOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.CreateOptions();
    }

    public static io.kubernetes.client.proto.Meta.CreateOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CreateOptions>
        PARSER = new com.google.protobuf.AbstractParser<CreateOptions>() {
      @java.lang.Override
      public CreateOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CreateOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CreateOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.CreateOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeleteOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The duration in seconds before the object should be deleted. Value must be non-negative integer.
     * The value zero indicates delete immediately. If this value is nil, the default grace period for the
     * specified type will be used.
     * Defaults to a per object value if not specified. zero means delete immediately.
     * +optional
     * </pre>
     *
     * <code>optional int64 gracePeriodSeconds = 1;</code>
     * @return Whether the gracePeriodSeconds field is set.
     */
    boolean hasGracePeriodSeconds();
    /**
     * <pre>
     * The duration in seconds before the object should be deleted. Value must be non-negative integer.
     * The value zero indicates delete immediately. If this value is nil, the default grace period for the
     * specified type will be used.
     * Defaults to a per object value if not specified. zero means delete immediately.
     * +optional
     * </pre>
     *
     * <code>optional int64 gracePeriodSeconds = 1;</code>
     * @return The gracePeriodSeconds.
     */
    long getGracePeriodSeconds();

    /**
     * <pre>
     * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
     * returned.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
     * @return Whether the preconditions field is set.
     */
    boolean hasPreconditions();
    /**
     * <pre>
     * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
     * returned.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
     * @return The preconditions.
     */
    io.kubernetes.client.proto.Meta.Preconditions getPreconditions();
    /**
     * <pre>
     * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
     * returned.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
     */
    io.kubernetes.client.proto.Meta.PreconditionsOrBuilder getPreconditionsOrBuilder();

    /**
     * <pre>
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
     * Should the dependent objects be orphaned. If true/false, the "orphan"
     * finalizer will be added to/removed from the object's finalizers list.
     * Either this field or PropagationPolicy may be set, but not both.
     * +optional
     * </pre>
     *
     * <code>optional bool orphanDependents = 3;</code>
     * @return Whether the orphanDependents field is set.
     */
    boolean hasOrphanDependents();
    /**
     * <pre>
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
     * Should the dependent objects be orphaned. If true/false, the "orphan"
     * finalizer will be added to/removed from the object's finalizers list.
     * Either this field or PropagationPolicy may be set, but not both.
     * +optional
     * </pre>
     *
     * <code>optional bool orphanDependents = 3;</code>
     * @return The orphanDependents.
     */
    boolean getOrphanDependents();

    /**
     * <pre>
     * Whether and how garbage collection will be performed.
     * Either this field or OrphanDependents may be set, but not both.
     * The default policy is decided by the existing finalizer set in the
     * metadata.finalizers and the resource-specific default policy.
     * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
     * allow the garbage collector to delete the dependents in the background;
     * 'Foreground' - a cascading policy that deletes all dependents in the
     * foreground.
     * +optional
     * </pre>
     *
     * <code>optional string propagationPolicy = 4;</code>
     * @return Whether the propagationPolicy field is set.
     */
    boolean hasPropagationPolicy();
    /**
     * <pre>
     * Whether and how garbage collection will be performed.
     * Either this field or OrphanDependents may be set, but not both.
     * The default policy is decided by the existing finalizer set in the
     * metadata.finalizers and the resource-specific default policy.
     * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
     * allow the garbage collector to delete the dependents in the background;
     * 'Foreground' - a cascading policy that deletes all dependents in the
     * foreground.
     * +optional
     * </pre>
     *
     * <code>optional string propagationPolicy = 4;</code>
     * @return The propagationPolicy.
     */
    java.lang.String getPropagationPolicy();
    /**
     * <pre>
     * Whether and how garbage collection will be performed.
     * Either this field or OrphanDependents may be set, but not both.
     * The default policy is decided by the existing finalizer set in the
     * metadata.finalizers and the resource-specific default policy.
     * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
     * allow the garbage collector to delete the dependents in the background;
     * 'Foreground' - a cascading policy that deletes all dependents in the
     * foreground.
     * +optional
     * </pre>
     *
     * <code>optional string propagationPolicy = 4;</code>
     * @return The bytes for propagationPolicy.
     */
    com.google.protobuf.ByteString
        getPropagationPolicyBytes();

    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 5;</code>
     * @return A list containing the dryRun.
     */
    java.util.List<java.lang.String>
        getDryRunList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 5;</code>
     * @return The count of dryRun.
     */
    int getDryRunCount();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 5;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    java.lang.String getDryRun(int index);
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    com.google.protobuf.ByteString
        getDryRunBytes(int index);
  }
  /**
   * <pre>
   * DeleteOptions may be provided when deleting an API object.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions}
   */
  public static final class DeleteOptions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions)
      DeleteOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DeleteOptions.class.getName());
    }
    // Use DeleteOptions.newBuilder() to construct.
    private DeleteOptions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DeleteOptions() {
      propagationPolicy_ = "";
      dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.DeleteOptions.class, io.kubernetes.client.proto.Meta.DeleteOptions.Builder.class);
    }

    private int bitField0_;
    public static final int GRACEPERIODSECONDS_FIELD_NUMBER = 1;
    private long gracePeriodSeconds_ = 0L;
    /**
     * <pre>
     * The duration in seconds before the object should be deleted. Value must be non-negative integer.
     * The value zero indicates delete immediately. If this value is nil, the default grace period for the
     * specified type will be used.
     * Defaults to a per object value if not specified. zero means delete immediately.
     * +optional
     * </pre>
     *
     * <code>optional int64 gracePeriodSeconds = 1;</code>
     * @return Whether the gracePeriodSeconds field is set.
     */
    @java.lang.Override
    public boolean hasGracePeriodSeconds() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The duration in seconds before the object should be deleted. Value must be non-negative integer.
     * The value zero indicates delete immediately. If this value is nil, the default grace period for the
     * specified type will be used.
     * Defaults to a per object value if not specified. zero means delete immediately.
     * +optional
     * </pre>
     *
     * <code>optional int64 gracePeriodSeconds = 1;</code>
     * @return The gracePeriodSeconds.
     */
    @java.lang.Override
    public long getGracePeriodSeconds() {
      return gracePeriodSeconds_;
    }

    public static final int PRECONDITIONS_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.Preconditions preconditions_;
    /**
     * <pre>
     * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
     * returned.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
     * @return Whether the preconditions field is set.
     */
    @java.lang.Override
    public boolean hasPreconditions() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
     * returned.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
     * @return The preconditions.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Preconditions getPreconditions() {
      return preconditions_ == null ? io.kubernetes.client.proto.Meta.Preconditions.getDefaultInstance() : preconditions_;
    }
    /**
     * <pre>
     * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
     * returned.
     * +k8s:conversion-gen=false
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.PreconditionsOrBuilder getPreconditionsOrBuilder() {
      return preconditions_ == null ? io.kubernetes.client.proto.Meta.Preconditions.getDefaultInstance() : preconditions_;
    }

    public static final int ORPHANDEPENDENTS_FIELD_NUMBER = 3;
    private boolean orphanDependents_ = false;
    /**
     * <pre>
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
     * Should the dependent objects be orphaned. If true/false, the "orphan"
     * finalizer will be added to/removed from the object's finalizers list.
     * Either this field or PropagationPolicy may be set, but not both.
     * +optional
     * </pre>
     *
     * <code>optional bool orphanDependents = 3;</code>
     * @return Whether the orphanDependents field is set.
     */
    @java.lang.Override
    public boolean hasOrphanDependents() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
     * Should the dependent objects be orphaned. If true/false, the "orphan"
     * finalizer will be added to/removed from the object's finalizers list.
     * Either this field or PropagationPolicy may be set, but not both.
     * +optional
     * </pre>
     *
     * <code>optional bool orphanDependents = 3;</code>
     * @return The orphanDependents.
     */
    @java.lang.Override
    public boolean getOrphanDependents() {
      return orphanDependents_;
    }

    public static final int PROPAGATIONPOLICY_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object propagationPolicy_ = "";
    /**
     * <pre>
     * Whether and how garbage collection will be performed.
     * Either this field or OrphanDependents may be set, but not both.
     * The default policy is decided by the existing finalizer set in the
     * metadata.finalizers and the resource-specific default policy.
     * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
     * allow the garbage collector to delete the dependents in the background;
     * 'Foreground' - a cascading policy that deletes all dependents in the
     * foreground.
     * +optional
     * </pre>
     *
     * <code>optional string propagationPolicy = 4;</code>
     * @return Whether the propagationPolicy field is set.
     */
    @java.lang.Override
    public boolean hasPropagationPolicy() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Whether and how garbage collection will be performed.
     * Either this field or OrphanDependents may be set, but not both.
     * The default policy is decided by the existing finalizer set in the
     * metadata.finalizers and the resource-specific default policy.
     * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
     * allow the garbage collector to delete the dependents in the background;
     * 'Foreground' - a cascading policy that deletes all dependents in the
     * foreground.
     * +optional
     * </pre>
     *
     * <code>optional string propagationPolicy = 4;</code>
     * @return The propagationPolicy.
     */
    @java.lang.Override
    public java.lang.String getPropagationPolicy() {
      java.lang.Object ref = propagationPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          propagationPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Whether and how garbage collection will be performed.
     * Either this field or OrphanDependents may be set, but not both.
     * The default policy is decided by the existing finalizer set in the
     * metadata.finalizers and the resource-specific default policy.
     * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
     * allow the garbage collector to delete the dependents in the background;
     * 'Foreground' - a cascading policy that deletes all dependents in the
     * foreground.
     * +optional
     * </pre>
     *
     * <code>optional string propagationPolicy = 4;</code>
     * @return The bytes for propagationPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPropagationPolicyBytes() {
      java.lang.Object ref = propagationPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        propagationPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DRYRUN_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList dryRun_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 5;</code>
     * @return A list containing the dryRun.
     */
    public com.google.protobuf.ProtocolStringList
        getDryRunList() {
      return dryRun_;
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 5;</code>
     * @return The count of dryRun.
     */
    public int getDryRunCount() {
      return dryRun_.size();
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 5;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    public java.lang.String getDryRun(int index) {
      return dryRun_.get(index);
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    public com.google.protobuf.ByteString
        getDryRunBytes(int index) {
      return dryRun_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, gracePeriodSeconds_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getPreconditions());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(3, orphanDependents_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, propagationPolicy_);
      }
      for (int i = 0; i < dryRun_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, dryRun_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, gracePeriodSeconds_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getPreconditions());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, orphanDependents_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, propagationPolicy_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < dryRun_.size(); i++) {
          dataSize += computeStringSizeNoTag(dryRun_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getDryRunList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.DeleteOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.DeleteOptions other = (io.kubernetes.client.proto.Meta.DeleteOptions) obj;

      if (hasGracePeriodSeconds() != other.hasGracePeriodSeconds()) return false;
      if (hasGracePeriodSeconds()) {
        if (getGracePeriodSeconds()
            != other.getGracePeriodSeconds()) return false;
      }
      if (hasPreconditions() != other.hasPreconditions()) return false;
      if (hasPreconditions()) {
        if (!getPreconditions()
            .equals(other.getPreconditions())) return false;
      }
      if (hasOrphanDependents() != other.hasOrphanDependents()) return false;
      if (hasOrphanDependents()) {
        if (getOrphanDependents()
            != other.getOrphanDependents()) return false;
      }
      if (hasPropagationPolicy() != other.hasPropagationPolicy()) return false;
      if (hasPropagationPolicy()) {
        if (!getPropagationPolicy()
            .equals(other.getPropagationPolicy())) return false;
      }
      if (!getDryRunList()
          .equals(other.getDryRunList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGracePeriodSeconds()) {
        hash = (37 * hash) + GRACEPERIODSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getGracePeriodSeconds());
      }
      if (hasPreconditions()) {
        hash = (37 * hash) + PRECONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getPreconditions().hashCode();
      }
      if (hasOrphanDependents()) {
        hash = (37 * hash) + ORPHANDEPENDENTS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getOrphanDependents());
      }
      if (hasPropagationPolicy()) {
        hash = (37 * hash) + PROPAGATIONPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getPropagationPolicy().hashCode();
      }
      if (getDryRunCount() > 0) {
        hash = (37 * hash) + DRYRUN_FIELD_NUMBER;
        hash = (53 * hash) + getDryRunList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.DeleteOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.DeleteOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.DeleteOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.DeleteOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DeleteOptions may be provided when deleting an API object.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions)
        io.kubernetes.client.proto.Meta.DeleteOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.DeleteOptions.class, io.kubernetes.client.proto.Meta.DeleteOptions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.DeleteOptions.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getPreconditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        gracePeriodSeconds_ = 0L;
        preconditions_ = null;
        if (preconditionsBuilder_ != null) {
          preconditionsBuilder_.dispose();
          preconditionsBuilder_ = null;
        }
        orphanDependents_ = false;
        propagationPolicy_ = "";
        dryRun_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.DeleteOptions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.DeleteOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.DeleteOptions build() {
        io.kubernetes.client.proto.Meta.DeleteOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.DeleteOptions buildPartial() {
        io.kubernetes.client.proto.Meta.DeleteOptions result = new io.kubernetes.client.proto.Meta.DeleteOptions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.DeleteOptions result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.gracePeriodSeconds_ = gracePeriodSeconds_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.preconditions_ = preconditionsBuilder_ == null
              ? preconditions_
              : preconditionsBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.orphanDependents_ = orphanDependents_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.propagationPolicy_ = propagationPolicy_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          dryRun_.makeImmutable();
          result.dryRun_ = dryRun_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.DeleteOptions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.DeleteOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.DeleteOptions other) {
        if (other == io.kubernetes.client.proto.Meta.DeleteOptions.getDefaultInstance()) return this;
        if (other.hasGracePeriodSeconds()) {
          setGracePeriodSeconds(other.getGracePeriodSeconds());
        }
        if (other.hasPreconditions()) {
          mergePreconditions(other.getPreconditions());
        }
        if (other.hasOrphanDependents()) {
          setOrphanDependents(other.getOrphanDependents());
        }
        if (other.hasPropagationPolicy()) {
          propagationPolicy_ = other.propagationPolicy_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (!other.dryRun_.isEmpty()) {
          if (dryRun_.isEmpty()) {
            dryRun_ = other.dryRun_;
            bitField0_ |= 0x00000010;
          } else {
            ensureDryRunIsMutable();
            dryRun_.addAll(other.dryRun_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                gracePeriodSeconds_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                input.readMessage(
                    getPreconditionsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                orphanDependents_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                propagationPolicy_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureDryRunIsMutable();
                dryRun_.add(bs);
                break;
              } // case 42
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long gracePeriodSeconds_ ;
      /**
       * <pre>
       * The duration in seconds before the object should be deleted. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default grace period for the
       * specified type will be used.
       * Defaults to a per object value if not specified. zero means delete immediately.
       * +optional
       * </pre>
       *
       * <code>optional int64 gracePeriodSeconds = 1;</code>
       * @return Whether the gracePeriodSeconds field is set.
       */
      @java.lang.Override
      public boolean hasGracePeriodSeconds() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The duration in seconds before the object should be deleted. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default grace period for the
       * specified type will be used.
       * Defaults to a per object value if not specified. zero means delete immediately.
       * +optional
       * </pre>
       *
       * <code>optional int64 gracePeriodSeconds = 1;</code>
       * @return The gracePeriodSeconds.
       */
      @java.lang.Override
      public long getGracePeriodSeconds() {
        return gracePeriodSeconds_;
      }
      /**
       * <pre>
       * The duration in seconds before the object should be deleted. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default grace period for the
       * specified type will be used.
       * Defaults to a per object value if not specified. zero means delete immediately.
       * +optional
       * </pre>
       *
       * <code>optional int64 gracePeriodSeconds = 1;</code>
       * @param value The gracePeriodSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setGracePeriodSeconds(long value) {

        gracePeriodSeconds_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The duration in seconds before the object should be deleted. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default grace period for the
       * specified type will be used.
       * Defaults to a per object value if not specified. zero means delete immediately.
       * +optional
       * </pre>
       *
       * <code>optional int64 gracePeriodSeconds = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGracePeriodSeconds() {
        bitField0_ = (bitField0_ & ~0x00000001);
        gracePeriodSeconds_ = 0L;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Preconditions preconditions_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Preconditions, io.kubernetes.client.proto.Meta.Preconditions.Builder, io.kubernetes.client.proto.Meta.PreconditionsOrBuilder> preconditionsBuilder_;
      /**
       * <pre>
       * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
       * returned.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
       * @return Whether the preconditions field is set.
       */
      public boolean hasPreconditions() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
       * returned.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
       * @return The preconditions.
       */
      public io.kubernetes.client.proto.Meta.Preconditions getPreconditions() {
        if (preconditionsBuilder_ == null) {
          return preconditions_ == null ? io.kubernetes.client.proto.Meta.Preconditions.getDefaultInstance() : preconditions_;
        } else {
          return preconditionsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
       * returned.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
       */
      public Builder setPreconditions(io.kubernetes.client.proto.Meta.Preconditions value) {
        if (preconditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          preconditions_ = value;
        } else {
          preconditionsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
       * returned.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
       */
      public Builder setPreconditions(
          io.kubernetes.client.proto.Meta.Preconditions.Builder builderForValue) {
        if (preconditionsBuilder_ == null) {
          preconditions_ = builderForValue.build();
        } else {
          preconditionsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
       * returned.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
       */
      public Builder mergePreconditions(io.kubernetes.client.proto.Meta.Preconditions value) {
        if (preconditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            preconditions_ != null &&
            preconditions_ != io.kubernetes.client.proto.Meta.Preconditions.getDefaultInstance()) {
            getPreconditionsBuilder().mergeFrom(value);
          } else {
            preconditions_ = value;
          }
        } else {
          preconditionsBuilder_.mergeFrom(value);
        }
        if (preconditions_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
       * returned.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
       */
      public Builder clearPreconditions() {
        bitField0_ = (bitField0_ & ~0x00000002);
        preconditions_ = null;
        if (preconditionsBuilder_ != null) {
          preconditionsBuilder_.dispose();
          preconditionsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
       * returned.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.Preconditions.Builder getPreconditionsBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getPreconditionsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
       * returned.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.PreconditionsOrBuilder getPreconditionsOrBuilder() {
        if (preconditionsBuilder_ != null) {
          return preconditionsBuilder_.getMessageOrBuilder();
        } else {
          return preconditions_ == null ?
              io.kubernetes.client.proto.Meta.Preconditions.getDefaultInstance() : preconditions_;
        }
      }
      /**
       * <pre>
       * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
       * returned.
       * +k8s:conversion-gen=false
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Preconditions, io.kubernetes.client.proto.Meta.Preconditions.Builder, io.kubernetes.client.proto.Meta.PreconditionsOrBuilder> 
          getPreconditionsFieldBuilder() {
        if (preconditionsBuilder_ == null) {
          preconditionsBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Preconditions, io.kubernetes.client.proto.Meta.Preconditions.Builder, io.kubernetes.client.proto.Meta.PreconditionsOrBuilder>(
                  getPreconditions(),
                  getParentForChildren(),
                  isClean());
          preconditions_ = null;
        }
        return preconditionsBuilder_;
      }

      private boolean orphanDependents_ ;
      /**
       * <pre>
       * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
       * Should the dependent objects be orphaned. If true/false, the "orphan"
       * finalizer will be added to/removed from the object's finalizers list.
       * Either this field or PropagationPolicy may be set, but not both.
       * +optional
       * </pre>
       *
       * <code>optional bool orphanDependents = 3;</code>
       * @return Whether the orphanDependents field is set.
       */
      @java.lang.Override
      public boolean hasOrphanDependents() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
       * Should the dependent objects be orphaned. If true/false, the "orphan"
       * finalizer will be added to/removed from the object's finalizers list.
       * Either this field or PropagationPolicy may be set, but not both.
       * +optional
       * </pre>
       *
       * <code>optional bool orphanDependents = 3;</code>
       * @return The orphanDependents.
       */
      @java.lang.Override
      public boolean getOrphanDependents() {
        return orphanDependents_;
      }
      /**
       * <pre>
       * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
       * Should the dependent objects be orphaned. If true/false, the "orphan"
       * finalizer will be added to/removed from the object's finalizers list.
       * Either this field or PropagationPolicy may be set, but not both.
       * +optional
       * </pre>
       *
       * <code>optional bool orphanDependents = 3;</code>
       * @param value The orphanDependents to set.
       * @return This builder for chaining.
       */
      public Builder setOrphanDependents(boolean value) {

        orphanDependents_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
       * Should the dependent objects be orphaned. If true/false, the "orphan"
       * finalizer will be added to/removed from the object's finalizers list.
       * Either this field or PropagationPolicy may be set, but not both.
       * +optional
       * </pre>
       *
       * <code>optional bool orphanDependents = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearOrphanDependents() {
        bitField0_ = (bitField0_ & ~0x00000004);
        orphanDependents_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object propagationPolicy_ = "";
      /**
       * <pre>
       * Whether and how garbage collection will be performed.
       * Either this field or OrphanDependents may be set, but not both.
       * The default policy is decided by the existing finalizer set in the
       * metadata.finalizers and the resource-specific default policy.
       * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
       * allow the garbage collector to delete the dependents in the background;
       * 'Foreground' - a cascading policy that deletes all dependents in the
       * foreground.
       * +optional
       * </pre>
       *
       * <code>optional string propagationPolicy = 4;</code>
       * @return Whether the propagationPolicy field is set.
       */
      public boolean hasPropagationPolicy() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Whether and how garbage collection will be performed.
       * Either this field or OrphanDependents may be set, but not both.
       * The default policy is decided by the existing finalizer set in the
       * metadata.finalizers and the resource-specific default policy.
       * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
       * allow the garbage collector to delete the dependents in the background;
       * 'Foreground' - a cascading policy that deletes all dependents in the
       * foreground.
       * +optional
       * </pre>
       *
       * <code>optional string propagationPolicy = 4;</code>
       * @return The propagationPolicy.
       */
      public java.lang.String getPropagationPolicy() {
        java.lang.Object ref = propagationPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            propagationPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Whether and how garbage collection will be performed.
       * Either this field or OrphanDependents may be set, but not both.
       * The default policy is decided by the existing finalizer set in the
       * metadata.finalizers and the resource-specific default policy.
       * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
       * allow the garbage collector to delete the dependents in the background;
       * 'Foreground' - a cascading policy that deletes all dependents in the
       * foreground.
       * +optional
       * </pre>
       *
       * <code>optional string propagationPolicy = 4;</code>
       * @return The bytes for propagationPolicy.
       */
      public com.google.protobuf.ByteString
          getPropagationPolicyBytes() {
        java.lang.Object ref = propagationPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          propagationPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Whether and how garbage collection will be performed.
       * Either this field or OrphanDependents may be set, but not both.
       * The default policy is decided by the existing finalizer set in the
       * metadata.finalizers and the resource-specific default policy.
       * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
       * allow the garbage collector to delete the dependents in the background;
       * 'Foreground' - a cascading policy that deletes all dependents in the
       * foreground.
       * +optional
       * </pre>
       *
       * <code>optional string propagationPolicy = 4;</code>
       * @param value The propagationPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setPropagationPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        propagationPolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether and how garbage collection will be performed.
       * Either this field or OrphanDependents may be set, but not both.
       * The default policy is decided by the existing finalizer set in the
       * metadata.finalizers and the resource-specific default policy.
       * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
       * allow the garbage collector to delete the dependents in the background;
       * 'Foreground' - a cascading policy that deletes all dependents in the
       * foreground.
       * +optional
       * </pre>
       *
       * <code>optional string propagationPolicy = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPropagationPolicy() {
        propagationPolicy_ = getDefaultInstance().getPropagationPolicy();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether and how garbage collection will be performed.
       * Either this field or OrphanDependents may be set, but not both.
       * The default policy is decided by the existing finalizer set in the
       * metadata.finalizers and the resource-specific default policy.
       * Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
       * allow the garbage collector to delete the dependents in the background;
       * 'Foreground' - a cascading policy that deletes all dependents in the
       * foreground.
       * +optional
       * </pre>
       *
       * <code>optional string propagationPolicy = 4;</code>
       * @param value The bytes for propagationPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setPropagationPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        propagationPolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureDryRunIsMutable() {
        if (!dryRun_.isModifiable()) {
          dryRun_ = new com.google.protobuf.LazyStringArrayList(dryRun_);
        }
        bitField0_ |= 0x00000010;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 5;</code>
       * @return A list containing the dryRun.
       */
      public com.google.protobuf.ProtocolStringList
          getDryRunList() {
        dryRun_.makeImmutable();
        return dryRun_;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 5;</code>
       * @return The count of dryRun.
       */
      public int getDryRunCount() {
        return dryRun_.size();
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 5;</code>
       * @param index The index of the element to return.
       * @return The dryRun at the given index.
       */
      public java.lang.String getDryRun(int index) {
        return dryRun_.get(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 5;</code>
       * @param index The index of the value to return.
       * @return The bytes of the dryRun at the given index.
       */
      public com.google.protobuf.ByteString
          getDryRunBytes(int index) {
        return dryRun_.getByteString(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 5;</code>
       * @param index The index to set the value at.
       * @param value The dryRun to set.
       * @return This builder for chaining.
       */
      public Builder setDryRun(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.set(index, value);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 5;</code>
       * @param value The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRun(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 5;</code>
       * @param values The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addAllDryRun(
          java.lang.Iterable<java.lang.String> values) {
        ensureDryRunIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, dryRun_);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearDryRun() {
        dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 5;</code>
       * @param value The bytes of the dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRunBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions)
    private static final io.kubernetes.client.proto.Meta.DeleteOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.DeleteOptions();
    }

    public static io.kubernetes.client.proto.Meta.DeleteOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeleteOptions>
        PARSER = new com.google.protobuf.AbstractParser<DeleteOptions>() {
      @java.lang.Override
      public DeleteOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeleteOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeleteOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.DeleteOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DurationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.Duration)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional int64 duration = 1;</code>
     * @return Whether the duration field is set.
     */
    boolean hasDuration();
    /**
     * <code>optional int64 duration = 1;</code>
     * @return The duration.
     */
    long getDuration();
  }
  /**
   * <pre>
   * Duration is a wrapper around time.Duration which supports correct
   * marshaling to YAML and JSON. In particular, it marshals into strings, which
   * can be used as map keys in json.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Duration}
   */
  public static final class Duration extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Duration)
      DurationOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Duration.class.getName());
    }
    // Use Duration.newBuilder() to construct.
    private Duration(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Duration() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.Duration.class, io.kubernetes.client.proto.Meta.Duration.Builder.class);
    }

    private int bitField0_;
    public static final int DURATION_FIELD_NUMBER = 1;
    private long duration_ = 0L;
    /**
     * <code>optional int64 duration = 1;</code>
     * @return Whether the duration field is set.
     */
    @java.lang.Override
    public boolean hasDuration() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional int64 duration = 1;</code>
     * @return The duration.
     */
    @java.lang.Override
    public long getDuration() {
      return duration_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, duration_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, duration_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.Duration)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.Duration other = (io.kubernetes.client.proto.Meta.Duration) obj;

      if (hasDuration() != other.hasDuration()) return false;
      if (hasDuration()) {
        if (getDuration()
            != other.getDuration()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasDuration()) {
        hash = (37 * hash) + DURATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDuration());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.Duration parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Duration parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Duration parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Duration parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Duration parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Duration parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Duration parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Duration parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.Duration parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.Duration parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Duration parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Duration parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.Duration prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Duration is a wrapper around time.Duration which supports correct
     * marshaling to YAML and JSON. In particular, it marshals into strings, which
     * can be used as map keys in json.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Duration}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Duration)
        io.kubernetes.client.proto.Meta.DurationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.Duration.class, io.kubernetes.client.proto.Meta.Duration.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.Duration.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        duration_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Duration getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.Duration.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Duration build() {
        io.kubernetes.client.proto.Meta.Duration result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Duration buildPartial() {
        io.kubernetes.client.proto.Meta.Duration result = new io.kubernetes.client.proto.Meta.Duration(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.Duration result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.duration_ = duration_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.Duration) {
          return mergeFrom((io.kubernetes.client.proto.Meta.Duration)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.Duration other) {
        if (other == io.kubernetes.client.proto.Meta.Duration.getDefaultInstance()) return this;
        if (other.hasDuration()) {
          setDuration(other.getDuration());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                duration_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long duration_ ;
      /**
       * <code>optional int64 duration = 1;</code>
       * @return Whether the duration field is set.
       */
      @java.lang.Override
      public boolean hasDuration() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional int64 duration = 1;</code>
       * @return The duration.
       */
      @java.lang.Override
      public long getDuration() {
        return duration_;
      }
      /**
       * <code>optional int64 duration = 1;</code>
       * @param value The duration to set.
       * @return This builder for chaining.
       */
      public Builder setDuration(long value) {

        duration_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional int64 duration = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDuration() {
        bitField0_ = (bitField0_ & ~0x00000001);
        duration_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Duration)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Duration)
    private static final io.kubernetes.client.proto.Meta.Duration DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.Duration();
    }

    public static io.kubernetes.client.proto.Meta.Duration getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Duration>
        PARSER = new com.google.protobuf.AbstractParser<Duration>() {
      @java.lang.Override
      public Duration parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Duration> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Duration> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Duration getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface FieldsV1OrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Raw is the underlying serialization of this object.
     * </pre>
     *
     * <code>optional bytes Raw = 1;</code>
     * @return Whether the raw field is set.
     */
    boolean hasRaw();
    /**
     * <pre>
     * Raw is the underlying serialization of this object.
     * </pre>
     *
     * <code>optional bytes Raw = 1;</code>
     * @return The raw.
     */
    com.google.protobuf.ByteString getRaw();
  }
  /**
   * <pre>
   * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
   *
   * Each key is either a '.' representing the field itself, and will always map to an empty set,
   * or a string representing a sub-field or item. The string will follow one of these four formats:
   * 'f:&lt;name&gt;', where &lt;name&gt; is the name of a field in a struct, or key in a map
   * 'v:&lt;value&gt;', where &lt;value&gt; is the exact json formatted value of a list item
   * 'i:&lt;index&gt;', where &lt;index&gt; is position of a item in a list
   * 'k:&lt;keys&gt;', where &lt;keys&gt; is a map of  a list item's key fields to their unique values
   * If a key maps to an empty Fields value, the field that key represents is part of the set.
   *
   * The exact format is defined in sigs.k8s.io/structured-merge-diff
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1}
   */
  public static final class FieldsV1 extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1)
      FieldsV1OrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        FieldsV1.class.getName());
    }
    // Use FieldsV1.newBuilder() to construct.
    private FieldsV1(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private FieldsV1() {
      raw_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.FieldsV1.class, io.kubernetes.client.proto.Meta.FieldsV1.Builder.class);
    }

    private int bitField0_;
    public static final int RAW_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString raw_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Raw is the underlying serialization of this object.
     * </pre>
     *
     * <code>optional bytes Raw = 1;</code>
     * @return Whether the raw field is set.
     */
    @java.lang.Override
    public boolean hasRaw() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Raw is the underlying serialization of this object.
     * </pre>
     *
     * <code>optional bytes Raw = 1;</code>
     * @return The raw.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRaw() {
      return raw_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBytes(1, raw_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, raw_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.FieldsV1)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.FieldsV1 other = (io.kubernetes.client.proto.Meta.FieldsV1) obj;

      if (hasRaw() != other.hasRaw()) return false;
      if (hasRaw()) {
        if (!getRaw()
            .equals(other.getRaw())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasRaw()) {
        hash = (37 * hash) + RAW_FIELD_NUMBER;
        hash = (53 * hash) + getRaw().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.FieldsV1 parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.FieldsV1 parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.FieldsV1 parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.FieldsV1 prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
     *
     * Each key is either a '.' representing the field itself, and will always map to an empty set,
     * or a string representing a sub-field or item. The string will follow one of these four formats:
     * 'f:&lt;name&gt;', where &lt;name&gt; is the name of a field in a struct, or key in a map
     * 'v:&lt;value&gt;', where &lt;value&gt; is the exact json formatted value of a list item
     * 'i:&lt;index&gt;', where &lt;index&gt; is position of a item in a list
     * 'k:&lt;keys&gt;', where &lt;keys&gt; is a map of  a list item's key fields to their unique values
     * If a key maps to an empty Fields value, the field that key represents is part of the set.
     *
     * The exact format is defined in sigs.k8s.io/structured-merge-diff
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1)
        io.kubernetes.client.proto.Meta.FieldsV1OrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.FieldsV1.class, io.kubernetes.client.proto.Meta.FieldsV1.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.FieldsV1.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        raw_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.FieldsV1 getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.FieldsV1.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.FieldsV1 build() {
        io.kubernetes.client.proto.Meta.FieldsV1 result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.FieldsV1 buildPartial() {
        io.kubernetes.client.proto.Meta.FieldsV1 result = new io.kubernetes.client.proto.Meta.FieldsV1(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.FieldsV1 result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.raw_ = raw_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.FieldsV1) {
          return mergeFrom((io.kubernetes.client.proto.Meta.FieldsV1)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.FieldsV1 other) {
        if (other == io.kubernetes.client.proto.Meta.FieldsV1.getDefaultInstance()) return this;
        if (other.hasRaw()) {
          setRaw(other.getRaw());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                raw_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString raw_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Raw is the underlying serialization of this object.
       * </pre>
       *
       * <code>optional bytes Raw = 1;</code>
       * @return Whether the raw field is set.
       */
      @java.lang.Override
      public boolean hasRaw() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Raw is the underlying serialization of this object.
       * </pre>
       *
       * <code>optional bytes Raw = 1;</code>
       * @return The raw.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRaw() {
        return raw_;
      }
      /**
       * <pre>
       * Raw is the underlying serialization of this object.
       * </pre>
       *
       * <code>optional bytes Raw = 1;</code>
       * @param value The raw to set.
       * @return This builder for chaining.
       */
      public Builder setRaw(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        raw_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Raw is the underlying serialization of this object.
       * </pre>
       *
       * <code>optional bytes Raw = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRaw() {
        bitField0_ = (bitField0_ & ~0x00000001);
        raw_ = getDefaultInstance().getRaw();
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1)
    private static final io.kubernetes.client.proto.Meta.FieldsV1 DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.FieldsV1();
    }

    public static io.kubernetes.client.proto.Meta.FieldsV1 getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<FieldsV1>
        PARSER = new com.google.protobuf.AbstractParser<FieldsV1>() {
      @java.lang.Override
      public FieldsV1 parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<FieldsV1> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FieldsV1> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.FieldsV1 getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 1;</code>
     * @return Whether the resourceVersion field is set.
     */
    boolean hasResourceVersion();
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 1;</code>
     * @return The resourceVersion.
     */
    java.lang.String getResourceVersion();
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 1;</code>
     * @return The bytes for resourceVersion.
     */
    com.google.protobuf.ByteString
        getResourceVersionBytes();
  }
  /**
   * <pre>
   * GetOptions is the standard query options to the standard REST get call.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions}
   */
  public static final class GetOptions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions)
      GetOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GetOptions.class.getName());
    }
    // Use GetOptions.newBuilder() to construct.
    private GetOptions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GetOptions() {
      resourceVersion_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.GetOptions.class, io.kubernetes.client.proto.Meta.GetOptions.Builder.class);
    }

    private int bitField0_;
    public static final int RESOURCEVERSION_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resourceVersion_ = "";
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 1;</code>
     * @return Whether the resourceVersion field is set.
     */
    @java.lang.Override
    public boolean hasResourceVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 1;</code>
     * @return The resourceVersion.
     */
    @java.lang.Override
    public java.lang.String getResourceVersion() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          resourceVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 1;</code>
     * @return The bytes for resourceVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceVersionBytes() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resourceVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, resourceVersion_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, resourceVersion_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.GetOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.GetOptions other = (io.kubernetes.client.proto.Meta.GetOptions) obj;

      if (hasResourceVersion() != other.hasResourceVersion()) return false;
      if (hasResourceVersion()) {
        if (!getResourceVersion()
            .equals(other.getResourceVersion())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasResourceVersion()) {
        hash = (37 * hash) + RESOURCEVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getResourceVersion().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.GetOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.GetOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GetOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.GetOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * GetOptions is the standard query options to the standard REST get call.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions)
        io.kubernetes.client.proto.Meta.GetOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.GetOptions.class, io.kubernetes.client.proto.Meta.GetOptions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.GetOptions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        resourceVersion_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GetOptions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.GetOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GetOptions build() {
        io.kubernetes.client.proto.Meta.GetOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GetOptions buildPartial() {
        io.kubernetes.client.proto.Meta.GetOptions result = new io.kubernetes.client.proto.Meta.GetOptions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.GetOptions result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.resourceVersion_ = resourceVersion_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.GetOptions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.GetOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.GetOptions other) {
        if (other == io.kubernetes.client.proto.Meta.GetOptions.getDefaultInstance()) return this;
        if (other.hasResourceVersion()) {
          resourceVersion_ = other.resourceVersion_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                resourceVersion_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object resourceVersion_ = "";
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 1;</code>
       * @return Whether the resourceVersion field is set.
       */
      public boolean hasResourceVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 1;</code>
       * @return The resourceVersion.
       */
      public java.lang.String getResourceVersion() {
        java.lang.Object ref = resourceVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            resourceVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 1;</code>
       * @return The bytes for resourceVersion.
       */
      public com.google.protobuf.ByteString
          getResourceVersionBytes() {
        java.lang.Object ref = resourceVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resourceVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 1;</code>
       * @param value The resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceVersion() {
        resourceVersion_ = getDefaultInstance().getResourceVersion();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 1;</code>
       * @param value The bytes for resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions)
    private static final io.kubernetes.client.proto.Meta.GetOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.GetOptions();
    }

    public static io.kubernetes.client.proto.Meta.GetOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetOptions>
        PARSER = new com.google.protobuf.AbstractParser<GetOptions>() {
      @java.lang.Override
      public GetOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GetOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GetOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GroupKindOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    boolean hasGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    java.lang.String getGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    com.google.protobuf.ByteString
        getGroupBytes();

    /**
     * <code>optional string kind = 2;</code>
     * @return Whether the kind field is set.
     */
    boolean hasKind();
    /**
     * <code>optional string kind = 2;</code>
     * @return The kind.
     */
    java.lang.String getKind();
    /**
     * <code>optional string kind = 2;</code>
     * @return The bytes for kind.
     */
    com.google.protobuf.ByteString
        getKindBytes();
  }
  /**
   * <pre>
   * GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying
   * concepts during lookup stages without having partially valid types
   *
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind}
   */
  public static final class GroupKind extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind)
      GroupKindOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GroupKind.class.getName());
    }
    // Use GroupKind.newBuilder() to construct.
    private GroupKind(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GroupKind() {
      group_ = "";
      kind_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.GroupKind.class, io.kubernetes.client.proto.Meta.GroupKind.Builder.class);
    }

    private int bitField0_;
    public static final int GROUP_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object group_ = "";
    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    @java.lang.Override
    public boolean hasGroup() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    @java.lang.Override
    public java.lang.String getGroup() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          group_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroupBytes() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        group_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KIND_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object kind_ = "";
    /**
     * <code>optional string kind = 2;</code>
     * @return Whether the kind field is set.
     */
    @java.lang.Override
    public boolean hasKind() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string kind = 2;</code>
     * @return The kind.
     */
    @java.lang.Override
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          kind_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string kind = 2;</code>
     * @return The bytes for kind.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, kind_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, kind_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.GroupKind)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.GroupKind other = (io.kubernetes.client.proto.Meta.GroupKind) obj;

      if (hasGroup() != other.hasGroup()) return false;
      if (hasGroup()) {
        if (!getGroup()
            .equals(other.getGroup())) return false;
      }
      if (hasKind() != other.hasKind()) return false;
      if (hasKind()) {
        if (!getKind()
            .equals(other.getKind())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGroup()) {
        hash = (37 * hash) + GROUP_FIELD_NUMBER;
        hash = (53 * hash) + getGroup().hashCode();
      }
      if (hasKind()) {
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + getKind().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.GroupKind parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.GroupKind parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupKind parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.GroupKind prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying
     * concepts during lookup stages without having partially valid types
     *
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind)
        io.kubernetes.client.proto.Meta.GroupKindOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.GroupKind.class, io.kubernetes.client.proto.Meta.GroupKind.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.GroupKind.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        group_ = "";
        kind_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupKind getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.GroupKind.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupKind build() {
        io.kubernetes.client.proto.Meta.GroupKind result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupKind buildPartial() {
        io.kubernetes.client.proto.Meta.GroupKind result = new io.kubernetes.client.proto.Meta.GroupKind(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.GroupKind result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.group_ = group_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.kind_ = kind_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.GroupKind) {
          return mergeFrom((io.kubernetes.client.proto.Meta.GroupKind)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.GroupKind other) {
        if (other == io.kubernetes.client.proto.Meta.GroupKind.getDefaultInstance()) return this;
        if (other.hasGroup()) {
          group_ = other.group_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasKind()) {
          kind_ = other.kind_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                group_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                kind_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object group_ = "";
      /**
       * <code>optional string group = 1;</code>
       * @return Whether the group field is set.
       */
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The group.
       */
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The bytes for group.
       */
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The group to set.
       * @return This builder for chaining.
       */
      public Builder setGroup(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGroup() {
        group_ = getDefaultInstance().getGroup();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The bytes for group to set.
       * @return This builder for chaining.
       */
      public Builder setGroupBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object kind_ = "";
      /**
       * <code>optional string kind = 2;</code>
       * @return Whether the kind field is set.
       */
      public boolean hasKind() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string kind = 2;</code>
       * @return The kind.
       */
      public java.lang.String getKind() {
        java.lang.Object ref = kind_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            kind_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string kind = 2;</code>
       * @return The bytes for kind.
       */
      public com.google.protobuf.ByteString
          getKindBytes() {
        java.lang.Object ref = kind_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          kind_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string kind = 2;</code>
       * @param value The kind to set.
       * @return This builder for chaining.
       */
      public Builder setKind(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional string kind = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearKind() {
        kind_ = getDefaultInstance().getKind();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <code>optional string kind = 2;</code>
       * @param value The bytes for kind to set.
       * @return This builder for chaining.
       */
      public Builder setKindBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind)
    private static final io.kubernetes.client.proto.Meta.GroupKind DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.GroupKind();
    }

    public static io.kubernetes.client.proto.Meta.GroupKind getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GroupKind>
        PARSER = new com.google.protobuf.AbstractParser<GroupKind>() {
      @java.lang.Override
      public GroupKind parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GroupKind> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GroupKind> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupKind getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GroupResourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    boolean hasGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    java.lang.String getGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    com.google.protobuf.ByteString
        getGroupBytes();

    /**
     * <code>optional string resource = 2;</code>
     * @return Whether the resource field is set.
     */
    boolean hasResource();
    /**
     * <code>optional string resource = 2;</code>
     * @return The resource.
     */
    java.lang.String getResource();
    /**
     * <code>optional string resource = 2;</code>
     * @return The bytes for resource.
     */
    com.google.protobuf.ByteString
        getResourceBytes();
  }
  /**
   * <pre>
   * GroupResource specifies a Group and a Resource, but does not force a version.  This is useful for identifying
   * concepts during lookup stages without having partially valid types
   *
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource}
   */
  public static final class GroupResource extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource)
      GroupResourceOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GroupResource.class.getName());
    }
    // Use GroupResource.newBuilder() to construct.
    private GroupResource(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GroupResource() {
      group_ = "";
      resource_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.GroupResource.class, io.kubernetes.client.proto.Meta.GroupResource.Builder.class);
    }

    private int bitField0_;
    public static final int GROUP_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object group_ = "";
    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    @java.lang.Override
    public boolean hasGroup() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    @java.lang.Override
    public java.lang.String getGroup() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          group_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroupBytes() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        group_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RESOURCE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resource_ = "";
    /**
     * <code>optional string resource = 2;</code>
     * @return Whether the resource field is set.
     */
    @java.lang.Override
    public boolean hasResource() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string resource = 2;</code>
     * @return The resource.
     */
    @java.lang.Override
    public java.lang.String getResource() {
      java.lang.Object ref = resource_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          resource_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string resource = 2;</code>
     * @return The bytes for resource.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceBytes() {
      java.lang.Object ref = resource_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resource_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, resource_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, resource_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.GroupResource)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.GroupResource other = (io.kubernetes.client.proto.Meta.GroupResource) obj;

      if (hasGroup() != other.hasGroup()) return false;
      if (hasGroup()) {
        if (!getGroup()
            .equals(other.getGroup())) return false;
      }
      if (hasResource() != other.hasResource()) return false;
      if (hasResource()) {
        if (!getResource()
            .equals(other.getResource())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGroup()) {
        hash = (37 * hash) + GROUP_FIELD_NUMBER;
        hash = (53 * hash) + getGroup().hashCode();
      }
      if (hasResource()) {
        hash = (37 * hash) + RESOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getResource().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.GroupResource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.GroupResource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupResource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.GroupResource prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * GroupResource specifies a Group and a Resource, but does not force a version.  This is useful for identifying
     * concepts during lookup stages without having partially valid types
     *
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource)
        io.kubernetes.client.proto.Meta.GroupResourceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.GroupResource.class, io.kubernetes.client.proto.Meta.GroupResource.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.GroupResource.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        group_ = "";
        resource_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupResource getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.GroupResource.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupResource build() {
        io.kubernetes.client.proto.Meta.GroupResource result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupResource buildPartial() {
        io.kubernetes.client.proto.Meta.GroupResource result = new io.kubernetes.client.proto.Meta.GroupResource(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.GroupResource result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.group_ = group_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.resource_ = resource_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.GroupResource) {
          return mergeFrom((io.kubernetes.client.proto.Meta.GroupResource)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.GroupResource other) {
        if (other == io.kubernetes.client.proto.Meta.GroupResource.getDefaultInstance()) return this;
        if (other.hasGroup()) {
          group_ = other.group_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasResource()) {
          resource_ = other.resource_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                group_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                resource_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object group_ = "";
      /**
       * <code>optional string group = 1;</code>
       * @return Whether the group field is set.
       */
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The group.
       */
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The bytes for group.
       */
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The group to set.
       * @return This builder for chaining.
       */
      public Builder setGroup(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGroup() {
        group_ = getDefaultInstance().getGroup();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The bytes for group to set.
       * @return This builder for chaining.
       */
      public Builder setGroupBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object resource_ = "";
      /**
       * <code>optional string resource = 2;</code>
       * @return Whether the resource field is set.
       */
      public boolean hasResource() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string resource = 2;</code>
       * @return The resource.
       */
      public java.lang.String getResource() {
        java.lang.Object ref = resource_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            resource_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string resource = 2;</code>
       * @return The bytes for resource.
       */
      public com.google.protobuf.ByteString
          getResourceBytes() {
        java.lang.Object ref = resource_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resource_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string resource = 2;</code>
       * @param value The resource to set.
       * @return This builder for chaining.
       */
      public Builder setResource(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resource_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional string resource = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearResource() {
        resource_ = getDefaultInstance().getResource();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <code>optional string resource = 2;</code>
       * @param value The bytes for resource to set.
       * @return This builder for chaining.
       */
      public Builder setResourceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        resource_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource)
    private static final io.kubernetes.client.proto.Meta.GroupResource DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.GroupResource();
    }

    public static io.kubernetes.client.proto.Meta.GroupResource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GroupResource>
        PARSER = new com.google.protobuf.AbstractParser<GroupResource>() {
      @java.lang.Override
      public GroupResource parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GroupResource> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GroupResource> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupResource getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GroupVersionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    boolean hasGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    java.lang.String getGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    com.google.protobuf.ByteString
        getGroupBytes();

    /**
     * <code>optional string version = 2;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <code>optional string version = 2;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <code>optional string version = 2;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();
  }
  /**
   * <pre>
   * GroupVersion contains the "group" and the "version", which uniquely identifies the API.
   *
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion}
   */
  public static final class GroupVersion extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion)
      GroupVersionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GroupVersion.class.getName());
    }
    // Use GroupVersion.newBuilder() to construct.
    private GroupVersion(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GroupVersion() {
      group_ = "";
      version_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.GroupVersion.class, io.kubernetes.client.proto.Meta.GroupVersion.Builder.class);
    }

    private int bitField0_;
    public static final int GROUP_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object group_ = "";
    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    @java.lang.Override
    public boolean hasGroup() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    @java.lang.Override
    public java.lang.String getGroup() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          group_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroupBytes() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        group_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object version_ = "";
    /**
     * <code>optional string version = 2;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string version = 2;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string version = 2;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, version_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, version_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.GroupVersion)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.GroupVersion other = (io.kubernetes.client.proto.Meta.GroupVersion) obj;

      if (hasGroup() != other.hasGroup()) return false;
      if (hasGroup()) {
        if (!getGroup()
            .equals(other.getGroup())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (!getVersion()
            .equals(other.getVersion())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGroup()) {
        hash = (37 * hash) + GROUP_FIELD_NUMBER;
        hash = (53 * hash) + getGroup().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.GroupVersion parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.GroupVersion parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersion parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.GroupVersion prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * GroupVersion contains the "group" and the "version", which uniquely identifies the API.
     *
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion)
        io.kubernetes.client.proto.Meta.GroupVersionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.GroupVersion.class, io.kubernetes.client.proto.Meta.GroupVersion.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.GroupVersion.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        group_ = "";
        version_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersion getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.GroupVersion.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersion build() {
        io.kubernetes.client.proto.Meta.GroupVersion result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersion buildPartial() {
        io.kubernetes.client.proto.Meta.GroupVersion result = new io.kubernetes.client.proto.Meta.GroupVersion(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.GroupVersion result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.group_ = group_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.GroupVersion) {
          return mergeFrom((io.kubernetes.client.proto.Meta.GroupVersion)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.GroupVersion other) {
        if (other == io.kubernetes.client.proto.Meta.GroupVersion.getDefaultInstance()) return this;
        if (other.hasGroup()) {
          group_ = other.group_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasVersion()) {
          version_ = other.version_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                group_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                version_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object group_ = "";
      /**
       * <code>optional string group = 1;</code>
       * @return Whether the group field is set.
       */
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The group.
       */
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The bytes for group.
       */
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The group to set.
       * @return This builder for chaining.
       */
      public Builder setGroup(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGroup() {
        group_ = getDefaultInstance().getGroup();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The bytes for group to set.
       * @return This builder for chaining.
       */
      public Builder setGroupBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object version_ = "";
      /**
       * <code>optional string version = 2;</code>
       * @return Whether the version field is set.
       */
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string version = 2;</code>
       * @return The version.
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string version = 2;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string version = 2;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        version_ = getDefaultInstance().getVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 2;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion)
    private static final io.kubernetes.client.proto.Meta.GroupVersion DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.GroupVersion();
    }

    public static io.kubernetes.client.proto.Meta.GroupVersion getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GroupVersion>
        PARSER = new com.google.protobuf.AbstractParser<GroupVersion>() {
      @java.lang.Override
      public GroupVersion parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GroupVersion> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GroupVersion> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupVersion getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GroupVersionForDiscoveryOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * groupVersion specifies the API group and version in the form "group/version"
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return Whether the groupVersion field is set.
     */
    boolean hasGroupVersion();
    /**
     * <pre>
     * groupVersion specifies the API group and version in the form "group/version"
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return The groupVersion.
     */
    java.lang.String getGroupVersion();
    /**
     * <pre>
     * groupVersion specifies the API group and version in the form "group/version"
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return The bytes for groupVersion.
     */
    com.google.protobuf.ByteString
        getGroupVersionBytes();

    /**
     * <pre>
     * version specifies the version in the form of "version". This is to save
     * the clients the trouble of splitting the GroupVersion.
     * </pre>
     *
     * <code>optional string version = 2;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <pre>
     * version specifies the version in the form of "version". This is to save
     * the clients the trouble of splitting the GroupVersion.
     * </pre>
     *
     * <code>optional string version = 2;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <pre>
     * version specifies the version in the form of "version". This is to save
     * the clients the trouble of splitting the GroupVersion.
     * </pre>
     *
     * <code>optional string version = 2;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();
  }
  /**
   * <pre>
   * GroupVersion contains the "group/version" and "version" string of a version.
   * It is made a struct to keep extensibility.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery}
   */
  public static final class GroupVersionForDiscovery extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
      GroupVersionForDiscoveryOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GroupVersionForDiscovery.class.getName());
    }
    // Use GroupVersionForDiscovery.newBuilder() to construct.
    private GroupVersionForDiscovery(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GroupVersionForDiscovery() {
      groupVersion_ = "";
      version_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.class, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder.class);
    }

    private int bitField0_;
    public static final int GROUPVERSION_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object groupVersion_ = "";
    /**
     * <pre>
     * groupVersion specifies the API group and version in the form "group/version"
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return Whether the groupVersion field is set.
     */
    @java.lang.Override
    public boolean hasGroupVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * groupVersion specifies the API group and version in the form "group/version"
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return The groupVersion.
     */
    @java.lang.Override
    public java.lang.String getGroupVersion() {
      java.lang.Object ref = groupVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          groupVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * groupVersion specifies the API group and version in the form "group/version"
     * </pre>
     *
     * <code>optional string groupVersion = 1;</code>
     * @return The bytes for groupVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroupVersionBytes() {
      java.lang.Object ref = groupVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        groupVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object version_ = "";
    /**
     * <pre>
     * version specifies the version in the form of "version". This is to save
     * the clients the trouble of splitting the GroupVersion.
     * </pre>
     *
     * <code>optional string version = 2;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * version specifies the version in the form of "version". This is to save
     * the clients the trouble of splitting the GroupVersion.
     * </pre>
     *
     * <code>optional string version = 2;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * version specifies the version in the form of "version". This is to save
     * the clients the trouble of splitting the GroupVersion.
     * </pre>
     *
     * <code>optional string version = 2;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, groupVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, version_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, groupVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, version_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.GroupVersionForDiscovery)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.GroupVersionForDiscovery other = (io.kubernetes.client.proto.Meta.GroupVersionForDiscovery) obj;

      if (hasGroupVersion() != other.hasGroupVersion()) return false;
      if (hasGroupVersion()) {
        if (!getGroupVersion()
            .equals(other.getGroupVersion())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (!getVersion()
            .equals(other.getVersion())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGroupVersion()) {
        hash = (37 * hash) + GROUPVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getGroupVersion().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.GroupVersionForDiscovery prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * GroupVersion contains the "group/version" and "version" string of a version.
     * It is made a struct to keep extensibility.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
        io.kubernetes.client.proto.Meta.GroupVersionForDiscoveryOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.class, io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        groupVersion_ = "";
        version_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery build() {
        io.kubernetes.client.proto.Meta.GroupVersionForDiscovery result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery buildPartial() {
        io.kubernetes.client.proto.Meta.GroupVersionForDiscovery result = new io.kubernetes.client.proto.Meta.GroupVersionForDiscovery(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.GroupVersionForDiscovery result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.groupVersion_ = groupVersion_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.GroupVersionForDiscovery) {
          return mergeFrom((io.kubernetes.client.proto.Meta.GroupVersionForDiscovery)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.GroupVersionForDiscovery other) {
        if (other == io.kubernetes.client.proto.Meta.GroupVersionForDiscovery.getDefaultInstance()) return this;
        if (other.hasGroupVersion()) {
          groupVersion_ = other.groupVersion_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasVersion()) {
          version_ = other.version_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                groupVersion_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                version_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object groupVersion_ = "";
      /**
       * <pre>
       * groupVersion specifies the API group and version in the form "group/version"
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @return Whether the groupVersion field is set.
       */
      public boolean hasGroupVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * groupVersion specifies the API group and version in the form "group/version"
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @return The groupVersion.
       */
      public java.lang.String getGroupVersion() {
        java.lang.Object ref = groupVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            groupVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * groupVersion specifies the API group and version in the form "group/version"
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @return The bytes for groupVersion.
       */
      public com.google.protobuf.ByteString
          getGroupVersionBytes() {
        java.lang.Object ref = groupVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          groupVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * groupVersion specifies the API group and version in the form "group/version"
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @param value The groupVersion to set.
       * @return This builder for chaining.
       */
      public Builder setGroupVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        groupVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * groupVersion specifies the API group and version in the form "group/version"
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGroupVersion() {
        groupVersion_ = getDefaultInstance().getGroupVersion();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * groupVersion specifies the API group and version in the form "group/version"
       * </pre>
       *
       * <code>optional string groupVersion = 1;</code>
       * @param value The bytes for groupVersion to set.
       * @return This builder for chaining.
       */
      public Builder setGroupVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        groupVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object version_ = "";
      /**
       * <pre>
       * version specifies the version in the form of "version". This is to save
       * the clients the trouble of splitting the GroupVersion.
       * </pre>
       *
       * <code>optional string version = 2;</code>
       * @return Whether the version field is set.
       */
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * version specifies the version in the form of "version". This is to save
       * the clients the trouble of splitting the GroupVersion.
       * </pre>
       *
       * <code>optional string version = 2;</code>
       * @return The version.
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * version specifies the version in the form of "version". This is to save
       * the clients the trouble of splitting the GroupVersion.
       * </pre>
       *
       * <code>optional string version = 2;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * version specifies the version in the form of "version". This is to save
       * the clients the trouble of splitting the GroupVersion.
       * </pre>
       *
       * <code>optional string version = 2;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * version specifies the version in the form of "version". This is to save
       * the clients the trouble of splitting the GroupVersion.
       * </pre>
       *
       * <code>optional string version = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        version_ = getDefaultInstance().getVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * version specifies the version in the form of "version". This is to save
       * the clients the trouble of splitting the GroupVersion.
       * </pre>
       *
       * <code>optional string version = 2;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
    private static final io.kubernetes.client.proto.Meta.GroupVersionForDiscovery DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.GroupVersionForDiscovery();
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionForDiscovery getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GroupVersionForDiscovery>
        PARSER = new com.google.protobuf.AbstractParser<GroupVersionForDiscovery>() {
      @java.lang.Override
      public GroupVersionForDiscovery parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GroupVersionForDiscovery> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GroupVersionForDiscovery> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupVersionForDiscovery getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GroupVersionKindOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    boolean hasGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    java.lang.String getGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    com.google.protobuf.ByteString
        getGroupBytes();

    /**
     * <code>optional string version = 2;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <code>optional string version = 2;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <code>optional string version = 2;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <code>optional string kind = 3;</code>
     * @return Whether the kind field is set.
     */
    boolean hasKind();
    /**
     * <code>optional string kind = 3;</code>
     * @return The kind.
     */
    java.lang.String getKind();
    /**
     * <code>optional string kind = 3;</code>
     * @return The bytes for kind.
     */
    com.google.protobuf.ByteString
        getKindBytes();
  }
  /**
   * <pre>
   * GroupVersionKind unambiguously identifies a kind.  It doesn't anonymously include GroupVersion
   * to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling
   *
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind}
   */
  public static final class GroupVersionKind extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind)
      GroupVersionKindOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GroupVersionKind.class.getName());
    }
    // Use GroupVersionKind.newBuilder() to construct.
    private GroupVersionKind(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GroupVersionKind() {
      group_ = "";
      version_ = "";
      kind_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.GroupVersionKind.class, io.kubernetes.client.proto.Meta.GroupVersionKind.Builder.class);
    }

    private int bitField0_;
    public static final int GROUP_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object group_ = "";
    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    @java.lang.Override
    public boolean hasGroup() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    @java.lang.Override
    public java.lang.String getGroup() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          group_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroupBytes() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        group_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object version_ = "";
    /**
     * <code>optional string version = 2;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string version = 2;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string version = 2;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KIND_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object kind_ = "";
    /**
     * <code>optional string kind = 3;</code>
     * @return Whether the kind field is set.
     */
    @java.lang.Override
    public boolean hasKind() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional string kind = 3;</code>
     * @return The kind.
     */
    @java.lang.Override
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          kind_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string kind = 3;</code>
     * @return The bytes for kind.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, version_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, kind_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, version_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, kind_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.GroupVersionKind)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.GroupVersionKind other = (io.kubernetes.client.proto.Meta.GroupVersionKind) obj;

      if (hasGroup() != other.hasGroup()) return false;
      if (hasGroup()) {
        if (!getGroup()
            .equals(other.getGroup())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (!getVersion()
            .equals(other.getVersion())) return false;
      }
      if (hasKind() != other.hasKind()) return false;
      if (hasKind()) {
        if (!getKind()
            .equals(other.getKind())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGroup()) {
        hash = (37 * hash) + GROUP_FIELD_NUMBER;
        hash = (53 * hash) + getGroup().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion().hashCode();
      }
      if (hasKind()) {
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + getKind().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionKind parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.GroupVersionKind prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * GroupVersionKind unambiguously identifies a kind.  It doesn't anonymously include GroupVersion
     * to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling
     *
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind)
        io.kubernetes.client.proto.Meta.GroupVersionKindOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.GroupVersionKind.class, io.kubernetes.client.proto.Meta.GroupVersionKind.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.GroupVersionKind.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        group_ = "";
        version_ = "";
        kind_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersionKind getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.GroupVersionKind.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersionKind build() {
        io.kubernetes.client.proto.Meta.GroupVersionKind result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersionKind buildPartial() {
        io.kubernetes.client.proto.Meta.GroupVersionKind result = new io.kubernetes.client.proto.Meta.GroupVersionKind(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.GroupVersionKind result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.group_ = group_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.kind_ = kind_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.GroupVersionKind) {
          return mergeFrom((io.kubernetes.client.proto.Meta.GroupVersionKind)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.GroupVersionKind other) {
        if (other == io.kubernetes.client.proto.Meta.GroupVersionKind.getDefaultInstance()) return this;
        if (other.hasGroup()) {
          group_ = other.group_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasVersion()) {
          version_ = other.version_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasKind()) {
          kind_ = other.kind_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                group_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                version_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                kind_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object group_ = "";
      /**
       * <code>optional string group = 1;</code>
       * @return Whether the group field is set.
       */
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The group.
       */
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The bytes for group.
       */
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The group to set.
       * @return This builder for chaining.
       */
      public Builder setGroup(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGroup() {
        group_ = getDefaultInstance().getGroup();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The bytes for group to set.
       * @return This builder for chaining.
       */
      public Builder setGroupBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object version_ = "";
      /**
       * <code>optional string version = 2;</code>
       * @return Whether the version field is set.
       */
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string version = 2;</code>
       * @return The version.
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string version = 2;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string version = 2;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        version_ = getDefaultInstance().getVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 2;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object kind_ = "";
      /**
       * <code>optional string kind = 3;</code>
       * @return Whether the kind field is set.
       */
      public boolean hasKind() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional string kind = 3;</code>
       * @return The kind.
       */
      public java.lang.String getKind() {
        java.lang.Object ref = kind_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            kind_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string kind = 3;</code>
       * @return The bytes for kind.
       */
      public com.google.protobuf.ByteString
          getKindBytes() {
        java.lang.Object ref = kind_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          kind_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string kind = 3;</code>
       * @param value The kind to set.
       * @return This builder for chaining.
       */
      public Builder setKind(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional string kind = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearKind() {
        kind_ = getDefaultInstance().getKind();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <code>optional string kind = 3;</code>
       * @param value The bytes for kind to set.
       * @return This builder for chaining.
       */
      public Builder setKindBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind)
    private static final io.kubernetes.client.proto.Meta.GroupVersionKind DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.GroupVersionKind();
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionKind getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GroupVersionKind>
        PARSER = new com.google.protobuf.AbstractParser<GroupVersionKind>() {
      @java.lang.Override
      public GroupVersionKind parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GroupVersionKind> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GroupVersionKind> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupVersionKind getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GroupVersionResourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    boolean hasGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    java.lang.String getGroup();
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    com.google.protobuf.ByteString
        getGroupBytes();

    /**
     * <code>optional string version = 2;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <code>optional string version = 2;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <code>optional string version = 2;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <code>optional string resource = 3;</code>
     * @return Whether the resource field is set.
     */
    boolean hasResource();
    /**
     * <code>optional string resource = 3;</code>
     * @return The resource.
     */
    java.lang.String getResource();
    /**
     * <code>optional string resource = 3;</code>
     * @return The bytes for resource.
     */
    com.google.protobuf.ByteString
        getResourceBytes();
  }
  /**
   * <pre>
   * GroupVersionResource unambiguously identifies a resource.  It doesn't anonymously include GroupVersion
   * to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling
   *
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource}
   */
  public static final class GroupVersionResource extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource)
      GroupVersionResourceOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GroupVersionResource.class.getName());
    }
    // Use GroupVersionResource.newBuilder() to construct.
    private GroupVersionResource(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GroupVersionResource() {
      group_ = "";
      version_ = "";
      resource_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.GroupVersionResource.class, io.kubernetes.client.proto.Meta.GroupVersionResource.Builder.class);
    }

    private int bitField0_;
    public static final int GROUP_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object group_ = "";
    /**
     * <code>optional string group = 1;</code>
     * @return Whether the group field is set.
     */
    @java.lang.Override
    public boolean hasGroup() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The group.
     */
    @java.lang.Override
    public java.lang.String getGroup() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          group_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string group = 1;</code>
     * @return The bytes for group.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroupBytes() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        group_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object version_ = "";
    /**
     * <code>optional string version = 2;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string version = 2;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string version = 2;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RESOURCE_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resource_ = "";
    /**
     * <code>optional string resource = 3;</code>
     * @return Whether the resource field is set.
     */
    @java.lang.Override
    public boolean hasResource() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional string resource = 3;</code>
     * @return The resource.
     */
    @java.lang.Override
    public java.lang.String getResource() {
      java.lang.Object ref = resource_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          resource_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string resource = 3;</code>
     * @return The bytes for resource.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceBytes() {
      java.lang.Object ref = resource_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resource_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, version_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, resource_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, group_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, version_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, resource_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.GroupVersionResource)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.GroupVersionResource other = (io.kubernetes.client.proto.Meta.GroupVersionResource) obj;

      if (hasGroup() != other.hasGroup()) return false;
      if (hasGroup()) {
        if (!getGroup()
            .equals(other.getGroup())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (!getVersion()
            .equals(other.getVersion())) return false;
      }
      if (hasResource() != other.hasResource()) return false;
      if (hasResource()) {
        if (!getResource()
            .equals(other.getResource())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGroup()) {
        hash = (37 * hash) + GROUP_FIELD_NUMBER;
        hash = (53 * hash) + getGroup().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion().hashCode();
      }
      if (hasResource()) {
        hash = (37 * hash) + RESOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getResource().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.GroupVersionResource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.GroupVersionResource prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * GroupVersionResource unambiguously identifies a resource.  It doesn't anonymously include GroupVersion
     * to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling
     *
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource)
        io.kubernetes.client.proto.Meta.GroupVersionResourceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.GroupVersionResource.class, io.kubernetes.client.proto.Meta.GroupVersionResource.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.GroupVersionResource.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        group_ = "";
        version_ = "";
        resource_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersionResource getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.GroupVersionResource.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersionResource build() {
        io.kubernetes.client.proto.Meta.GroupVersionResource result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.GroupVersionResource buildPartial() {
        io.kubernetes.client.proto.Meta.GroupVersionResource result = new io.kubernetes.client.proto.Meta.GroupVersionResource(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.GroupVersionResource result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.group_ = group_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.resource_ = resource_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.GroupVersionResource) {
          return mergeFrom((io.kubernetes.client.proto.Meta.GroupVersionResource)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.GroupVersionResource other) {
        if (other == io.kubernetes.client.proto.Meta.GroupVersionResource.getDefaultInstance()) return this;
        if (other.hasGroup()) {
          group_ = other.group_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasVersion()) {
          version_ = other.version_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasResource()) {
          resource_ = other.resource_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                group_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                version_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                resource_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object group_ = "";
      /**
       * <code>optional string group = 1;</code>
       * @return Whether the group field is set.
       */
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The group.
       */
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The bytes for group.
       */
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The group to set.
       * @return This builder for chaining.
       */
      public Builder setGroup(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGroup() {
        group_ = getDefaultInstance().getGroup();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string group = 1;</code>
       * @param value The bytes for group to set.
       * @return This builder for chaining.
       */
      public Builder setGroupBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object version_ = "";
      /**
       * <code>optional string version = 2;</code>
       * @return Whether the version field is set.
       */
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string version = 2;</code>
       * @return The version.
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string version = 2;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string version = 2;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        version_ = getDefaultInstance().getVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 2;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object resource_ = "";
      /**
       * <code>optional string resource = 3;</code>
       * @return Whether the resource field is set.
       */
      public boolean hasResource() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional string resource = 3;</code>
       * @return The resource.
       */
      public java.lang.String getResource() {
        java.lang.Object ref = resource_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            resource_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string resource = 3;</code>
       * @return The bytes for resource.
       */
      public com.google.protobuf.ByteString
          getResourceBytes() {
        java.lang.Object ref = resource_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resource_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string resource = 3;</code>
       * @param value The resource to set.
       * @return This builder for chaining.
       */
      public Builder setResource(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resource_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional string resource = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearResource() {
        resource_ = getDefaultInstance().getResource();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <code>optional string resource = 3;</code>
       * @param value The bytes for resource to set.
       * @return This builder for chaining.
       */
      public Builder setResourceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        resource_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource)
    private static final io.kubernetes.client.proto.Meta.GroupVersionResource DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.GroupVersionResource();
    }

    public static io.kubernetes.client.proto.Meta.GroupVersionResource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GroupVersionResource>
        PARSER = new com.google.protobuf.AbstractParser<GroupVersionResource>() {
      @java.lang.Override
      public GroupVersionResource parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GroupVersionResource> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GroupVersionResource> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.GroupVersionResource getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LabelSelectorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; matchLabels = 1;</code>
     */
    int getMatchLabelsCount();
    /**
     * <pre>
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; matchLabels = 1;</code>
     */
    boolean containsMatchLabels(
        java.lang.String key);
    /**
     * Use {@link #getMatchLabelsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getMatchLabels();
    /**
     * <pre>
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; matchLabels = 1;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getMatchLabelsMap();
    /**
     * <pre>
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; matchLabels = 1;</code>
     */
    /* nullable */
java.lang.String getMatchLabelsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue);
    /**
     * <pre>
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; matchLabels = 1;</code>
     */
    java.lang.String getMatchLabelsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.LabelSelectorRequirement> 
        getMatchExpressionsList();
    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorRequirement getMatchExpressions(int index);
    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    int getMatchExpressionsCount();
    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder> 
        getMatchExpressionsOrBuilderList();
    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder getMatchExpressionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * A label selector is a label query over a set of resources. The result of matchLabels and
   * matchExpressions are ANDed. An empty label selector matches all objects. A null
   * label selector matches no objects.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector}
   */
  public static final class LabelSelector extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector)
      LabelSelectorOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        LabelSelector.class.getName());
    }
    // Use LabelSelector.newBuilder() to construct.
    private LabelSelector(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private LabelSelector() {
      matchExpressions_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetMatchLabels();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.LabelSelector.class, io.kubernetes.client.proto.Meta.LabelSelector.Builder.class);
    }

    public static final int MATCHLABELS_FIELD_NUMBER = 1;
    private static final class MatchLabelsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_MatchLabelsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> matchLabels_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetMatchLabels() {
      if (matchLabels_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            MatchLabelsDefaultEntryHolder.defaultEntry);
      }
      return matchLabels_;
    }
    public int getMatchLabelsCount() {
      return internalGetMatchLabels().getMap().size();
    }
    /**
     * <pre>
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; matchLabels = 1;</code>
     */
    @java.lang.Override
    public boolean containsMatchLabels(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetMatchLabels().getMap().containsKey(key);
    }
    /**
     * Use {@link #getMatchLabelsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getMatchLabels() {
      return getMatchLabelsMap();
    }
    /**
     * <pre>
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; matchLabels = 1;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getMatchLabelsMap() {
      return internalGetMatchLabels().getMap();
    }
    /**
     * <pre>
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; matchLabels = 1;</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getMatchLabelsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetMatchLabels().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
     * map is equivalent to an element of matchExpressions, whose key field is "key", the
     * operator is "In", and the values array contains only "value". The requirements are ANDed.
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; matchLabels = 1;</code>
     */
    @java.lang.Override
    public java.lang.String getMatchLabelsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetMatchLabels().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int MATCHEXPRESSIONS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.LabelSelectorRequirement> matchExpressions_;
    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.LabelSelectorRequirement> getMatchExpressionsList() {
      return matchExpressions_;
    }
    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder> 
        getMatchExpressionsOrBuilderList() {
      return matchExpressions_;
    }
    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    @java.lang.Override
    public int getMatchExpressionsCount() {
      return matchExpressions_.size();
    }
    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorRequirement getMatchExpressions(int index) {
      return matchExpressions_.get(index);
    }
    /**
     * <pre>
     * matchExpressions is a list of label selector requirements. The requirements are ANDed.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder getMatchExpressionsOrBuilder(
        int index) {
      return matchExpressions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .serializeStringMapTo(
          output,
          internalGetMatchLabels(),
          MatchLabelsDefaultEntryHolder.defaultEntry,
          1);
      for (int i = 0; i < matchExpressions_.size(); i++) {
        output.writeMessage(2, matchExpressions_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetMatchLabels().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        matchLabels__ = MatchLabelsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, matchLabels__);
      }
      for (int i = 0; i < matchExpressions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, matchExpressions_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.LabelSelector)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.LabelSelector other = (io.kubernetes.client.proto.Meta.LabelSelector) obj;

      if (!internalGetMatchLabels().equals(
          other.internalGetMatchLabels())) return false;
      if (!getMatchExpressionsList()
          .equals(other.getMatchExpressionsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetMatchLabels().getMap().isEmpty()) {
        hash = (37 * hash) + MATCHLABELS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetMatchLabels().hashCode();
      }
      if (getMatchExpressionsCount() > 0) {
        hash = (37 * hash) + MATCHEXPRESSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchExpressionsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.LabelSelector parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.LabelSelector parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelector parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.LabelSelector prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A label selector is a label query over a set of resources. The result of matchLabels and
     * matchExpressions are ANDed. An empty label selector matches all objects. A null
     * label selector matches no objects.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector)
        io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetMatchLabels();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableMatchLabels();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.LabelSelector.class, io.kubernetes.client.proto.Meta.LabelSelector.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.LabelSelector.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        internalGetMutableMatchLabels().clear();
        if (matchExpressionsBuilder_ == null) {
          matchExpressions_ = java.util.Collections.emptyList();
        } else {
          matchExpressions_ = null;
          matchExpressionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.LabelSelector getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.LabelSelector build() {
        io.kubernetes.client.proto.Meta.LabelSelector result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.LabelSelector buildPartial() {
        io.kubernetes.client.proto.Meta.LabelSelector result = new io.kubernetes.client.proto.Meta.LabelSelector(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.Meta.LabelSelector result) {
        if (matchExpressionsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            matchExpressions_ = java.util.Collections.unmodifiableList(matchExpressions_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.matchExpressions_ = matchExpressions_;
        } else {
          result.matchExpressions_ = matchExpressionsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.LabelSelector result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.matchLabels_ = internalGetMatchLabels();
          result.matchLabels_.makeImmutable();
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.LabelSelector) {
          return mergeFrom((io.kubernetes.client.proto.Meta.LabelSelector)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.LabelSelector other) {
        if (other == io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) return this;
        internalGetMutableMatchLabels().mergeFrom(
            other.internalGetMatchLabels());
        bitField0_ |= 0x00000001;
        if (matchExpressionsBuilder_ == null) {
          if (!other.matchExpressions_.isEmpty()) {
            if (matchExpressions_.isEmpty()) {
              matchExpressions_ = other.matchExpressions_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureMatchExpressionsIsMutable();
              matchExpressions_.addAll(other.matchExpressions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchExpressions_.isEmpty()) {
            if (matchExpressionsBuilder_.isEmpty()) {
              matchExpressionsBuilder_.dispose();
              matchExpressionsBuilder_ = null;
              matchExpressions_ = other.matchExpressions_;
              bitField0_ = (bitField0_ & ~0x00000002);
              matchExpressionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getMatchExpressionsFieldBuilder() : null;
            } else {
              matchExpressionsBuilder_.addAllMessages(other.matchExpressions_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                matchLabels__ = input.readMessage(
                    MatchLabelsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                internalGetMutableMatchLabels().getMutableMap().put(
                    matchLabels__.getKey(), matchLabels__.getValue());
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.Meta.LabelSelectorRequirement m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.LabelSelectorRequirement.parser(),
                        extensionRegistry);
                if (matchExpressionsBuilder_ == null) {
                  ensureMatchExpressionsIsMutable();
                  matchExpressions_.add(m);
                } else {
                  matchExpressionsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> matchLabels_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMatchLabels() {
        if (matchLabels_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              MatchLabelsDefaultEntryHolder.defaultEntry);
        }
        return matchLabels_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMutableMatchLabels() {
        if (matchLabels_ == null) {
          matchLabels_ = com.google.protobuf.MapField.newMapField(
              MatchLabelsDefaultEntryHolder.defaultEntry);
        }
        if (!matchLabels_.isMutable()) {
          matchLabels_ = matchLabels_.copy();
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return matchLabels_;
      }
      public int getMatchLabelsCount() {
        return internalGetMatchLabels().getMap().size();
      }
      /**
       * <pre>
       * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
       * map is equivalent to an element of matchExpressions, whose key field is "key", the
       * operator is "In", and the values array contains only "value". The requirements are ANDed.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; matchLabels = 1;</code>
       */
      @java.lang.Override
      public boolean containsMatchLabels(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetMatchLabels().getMap().containsKey(key);
      }
      /**
       * Use {@link #getMatchLabelsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getMatchLabels() {
        return getMatchLabelsMap();
      }
      /**
       * <pre>
       * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
       * map is equivalent to an element of matchExpressions, whose key field is "key", the
       * operator is "In", and the values array contains only "value". The requirements are ANDed.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; matchLabels = 1;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.String> getMatchLabelsMap() {
        return internalGetMatchLabels().getMap();
      }
      /**
       * <pre>
       * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
       * map is equivalent to an element of matchExpressions, whose key field is "key", the
       * operator is "In", and the values array contains only "value". The requirements are ANDed.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; matchLabels = 1;</code>
       */
      @java.lang.Override
      public /* nullable */
java.lang.String getMatchLabelsOrDefault(
          java.lang.String key,
          /* nullable */
java.lang.String defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetMatchLabels().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
       * map is equivalent to an element of matchExpressions, whose key field is "key", the
       * operator is "In", and the values array contains only "value". The requirements are ANDed.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; matchLabels = 1;</code>
       */
      @java.lang.Override
      public java.lang.String getMatchLabelsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetMatchLabels().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      public Builder clearMatchLabels() {
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutableMatchLabels().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
       * map is equivalent to an element of matchExpressions, whose key field is "key", the
       * operator is "In", and the values array contains only "value". The requirements are ANDed.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; matchLabels = 1;</code>
       */
      public Builder removeMatchLabels(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableMatchLabels().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
          getMutableMatchLabels() {
        bitField0_ |= 0x00000001;
        return internalGetMutableMatchLabels().getMutableMap();
      }
      /**
       * <pre>
       * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
       * map is equivalent to an element of matchExpressions, whose key field is "key", the
       * operator is "In", and the values array contains only "value". The requirements are ANDed.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; matchLabels = 1;</code>
       */
      public Builder putMatchLabels(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) { throw new NullPointerException("map value"); }
        internalGetMutableMatchLabels().getMutableMap()
            .put(key, value);
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
       * map is equivalent to an element of matchExpressions, whose key field is "key", the
       * operator is "In", and the values array contains only "value". The requirements are ANDed.
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; matchLabels = 1;</code>
       */
      public Builder putAllMatchLabels(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableMatchLabels().getMutableMap()
            .putAll(values);
        bitField0_ |= 0x00000001;
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.LabelSelectorRequirement> matchExpressions_ =
        java.util.Collections.emptyList();
      private void ensureMatchExpressionsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          matchExpressions_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.LabelSelectorRequirement>(matchExpressions_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelectorRequirement, io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder, io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder> matchExpressionsBuilder_;

      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.LabelSelectorRequirement> getMatchExpressionsList() {
        if (matchExpressionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchExpressions_);
        } else {
          return matchExpressionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public int getMatchExpressionsCount() {
        if (matchExpressionsBuilder_ == null) {
          return matchExpressions_.size();
        } else {
          return matchExpressionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorRequirement getMatchExpressions(int index) {
        if (matchExpressionsBuilder_ == null) {
          return matchExpressions_.get(index);
        } else {
          return matchExpressionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public Builder setMatchExpressions(
          int index, io.kubernetes.client.proto.Meta.LabelSelectorRequirement value) {
        if (matchExpressionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchExpressionsIsMutable();
          matchExpressions_.set(index, value);
          onChanged();
        } else {
          matchExpressionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public Builder setMatchExpressions(
          int index, io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder builderForValue) {
        if (matchExpressionsBuilder_ == null) {
          ensureMatchExpressionsIsMutable();
          matchExpressions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchExpressionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public Builder addMatchExpressions(io.kubernetes.client.proto.Meta.LabelSelectorRequirement value) {
        if (matchExpressionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchExpressionsIsMutable();
          matchExpressions_.add(value);
          onChanged();
        } else {
          matchExpressionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public Builder addMatchExpressions(
          int index, io.kubernetes.client.proto.Meta.LabelSelectorRequirement value) {
        if (matchExpressionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchExpressionsIsMutable();
          matchExpressions_.add(index, value);
          onChanged();
        } else {
          matchExpressionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public Builder addMatchExpressions(
          io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder builderForValue) {
        if (matchExpressionsBuilder_ == null) {
          ensureMatchExpressionsIsMutable();
          matchExpressions_.add(builderForValue.build());
          onChanged();
        } else {
          matchExpressionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public Builder addMatchExpressions(
          int index, io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder builderForValue) {
        if (matchExpressionsBuilder_ == null) {
          ensureMatchExpressionsIsMutable();
          matchExpressions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchExpressionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public Builder addAllMatchExpressions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.LabelSelectorRequirement> values) {
        if (matchExpressionsBuilder_ == null) {
          ensureMatchExpressionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchExpressions_);
          onChanged();
        } else {
          matchExpressionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public Builder clearMatchExpressions() {
        if (matchExpressionsBuilder_ == null) {
          matchExpressions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          matchExpressionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public Builder removeMatchExpressions(int index) {
        if (matchExpressionsBuilder_ == null) {
          ensureMatchExpressionsIsMutable();
          matchExpressions_.remove(index);
          onChanged();
        } else {
          matchExpressionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder getMatchExpressionsBuilder(
          int index) {
        return getMatchExpressionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder getMatchExpressionsOrBuilder(
          int index) {
        if (matchExpressionsBuilder_ == null) {
          return matchExpressions_.get(index);  } else {
          return matchExpressionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder> 
           getMatchExpressionsOrBuilderList() {
        if (matchExpressionsBuilder_ != null) {
          return matchExpressionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchExpressions_);
        }
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder addMatchExpressionsBuilder() {
        return getMatchExpressionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.LabelSelectorRequirement.getDefaultInstance());
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder addMatchExpressionsBuilder(
          int index) {
        return getMatchExpressionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.LabelSelectorRequirement.getDefaultInstance());
      }
      /**
       * <pre>
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder> 
           getMatchExpressionsBuilderList() {
        return getMatchExpressionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelectorRequirement, io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder, io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder> 
          getMatchExpressionsFieldBuilder() {
        if (matchExpressionsBuilder_ == null) {
          matchExpressionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelectorRequirement, io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder, io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder>(
                  matchExpressions_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          matchExpressions_ = null;
        }
        return matchExpressionsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector)
    private static final io.kubernetes.client.proto.Meta.LabelSelector DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.LabelSelector();
    }

    public static io.kubernetes.client.proto.Meta.LabelSelector getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LabelSelector>
        PARSER = new com.google.protobuf.AbstractParser<LabelSelector>() {
      @java.lang.Override
      public LabelSelector parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LabelSelector> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LabelSelector> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LabelSelectorRequirementOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * key is the label key that the selector applies to.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <pre>
     * key is the label key that the selector applies to.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <pre>
     * key is the label key that the selector applies to.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <pre>
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     * @return Whether the operator field is set.
     */
    boolean hasOperator();
    /**
     * <pre>
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     * @return The operator.
     */
    java.lang.String getOperator();
    /**
     * <pre>
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     * @return The bytes for operator.
     */
    com.google.protobuf.ByteString
        getOperatorBytes();

    /**
     * <pre>
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string values = 3;</code>
     * @return A list containing the values.
     */
    java.util.List<java.lang.String>
        getValuesList();
    /**
     * <pre>
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string values = 3;</code>
     * @return The count of values.
     */
    int getValuesCount();
    /**
     * <pre>
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string values = 3;</code>
     * @param index The index of the element to return.
     * @return The values at the given index.
     */
    java.lang.String getValues(int index);
    /**
     * <pre>
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string values = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the values at the given index.
     */
    com.google.protobuf.ByteString
        getValuesBytes(int index);
  }
  /**
   * <pre>
   * A label selector requirement is a selector that contains values, a key, and an operator that
   * relates the key and values.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement}
   */
  public static final class LabelSelectorRequirement extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement)
      LabelSelectorRequirementOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        LabelSelectorRequirement.class.getName());
    }
    // Use LabelSelectorRequirement.newBuilder() to construct.
    private LabelSelectorRequirement(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private LabelSelectorRequirement() {
      key_ = "";
      operator_ = "";
      values_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.LabelSelectorRequirement.class, io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder.class);
    }

    private int bitField0_;
    public static final int KEY_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object key_ = "";
    /**
     * <pre>
     * key is the label key that the selector applies to.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * key is the label key that the selector applies to.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          key_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * key is the label key that the selector applies to.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OPERATOR_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object operator_ = "";
    /**
     * <pre>
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     * @return Whether the operator field is set.
     */
    @java.lang.Override
    public boolean hasOperator() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     * @return The operator.
     */
    @java.lang.Override
    public java.lang.String getOperator() {
      java.lang.Object ref = operator_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          operator_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and DoesNotExist.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     * @return The bytes for operator.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOperatorBytes() {
      java.lang.Object ref = operator_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        operator_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList values_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string values = 3;</code>
     * @return A list containing the values.
     */
    public com.google.protobuf.ProtocolStringList
        getValuesList() {
      return values_;
    }
    /**
     * <pre>
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string values = 3;</code>
     * @return The count of values.
     */
    public int getValuesCount() {
      return values_.size();
    }
    /**
     * <pre>
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string values = 3;</code>
     * @param index The index of the element to return.
     * @return The values at the given index.
     */
    public java.lang.String getValues(int index) {
      return values_.get(index);
    }
    /**
     * <pre>
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or DoesNotExist,
     * the values array must be empty. This array is replaced during a strategic
     * merge patch.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string values = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the values at the given index.
     */
    public com.google.protobuf.ByteString
        getValuesBytes(int index) {
      return values_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, key_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, operator_);
      }
      for (int i = 0; i < values_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, values_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, key_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, operator_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < values_.size(); i++) {
          dataSize += computeStringSizeNoTag(values_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getValuesList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.LabelSelectorRequirement)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.LabelSelectorRequirement other = (io.kubernetes.client.proto.Meta.LabelSelectorRequirement) obj;

      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (hasOperator() != other.hasOperator()) return false;
      if (hasOperator()) {
        if (!getOperator()
            .equals(other.getOperator())) return false;
      }
      if (!getValuesList()
          .equals(other.getValuesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasOperator()) {
        hash = (37 * hash) + OPERATOR_FIELD_NUMBER;
        hash = (53 * hash) + getOperator().hashCode();
      }
      if (getValuesCount() > 0) {
        hash = (37 * hash) + VALUES_FIELD_NUMBER;
        hash = (53 * hash) + getValuesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.LabelSelectorRequirement prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A label selector requirement is a selector that contains values, a key, and an operator that
     * relates the key and values.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement)
        io.kubernetes.client.proto.Meta.LabelSelectorRequirementOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.LabelSelectorRequirement.class, io.kubernetes.client.proto.Meta.LabelSelectorRequirement.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.LabelSelectorRequirement.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        key_ = "";
        operator_ = "";
        values_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.LabelSelectorRequirement getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.LabelSelectorRequirement.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.LabelSelectorRequirement build() {
        io.kubernetes.client.proto.Meta.LabelSelectorRequirement result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.LabelSelectorRequirement buildPartial() {
        io.kubernetes.client.proto.Meta.LabelSelectorRequirement result = new io.kubernetes.client.proto.Meta.LabelSelectorRequirement(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.LabelSelectorRequirement result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.key_ = key_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.operator_ = operator_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          values_.makeImmutable();
          result.values_ = values_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.LabelSelectorRequirement) {
          return mergeFrom((io.kubernetes.client.proto.Meta.LabelSelectorRequirement)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.LabelSelectorRequirement other) {
        if (other == io.kubernetes.client.proto.Meta.LabelSelectorRequirement.getDefaultInstance()) return this;
        if (other.hasKey()) {
          key_ = other.key_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasOperator()) {
          operator_ = other.operator_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (!other.values_.isEmpty()) {
          if (values_.isEmpty()) {
            values_ = other.values_;
            bitField0_ |= 0x00000004;
          } else {
            ensureValuesIsMutable();
            values_.addAll(other.values_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                key_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                operator_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureValuesIsMutable();
                values_.add(bs);
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object key_ = "";
      /**
       * <pre>
       * key is the label key that the selector applies to.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @return Whether the key field is set.
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * key is the label key that the selector applies to.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @return The key.
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * key is the label key that the selector applies to.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @return The bytes for key.
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * key is the label key that the selector applies to.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key is the label key that the selector applies to.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        key_ = getDefaultInstance().getKey();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key is the label key that the selector applies to.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object operator_ = "";
      /**
       * <pre>
       * operator represents a key's relationship to a set of values.
       * Valid operators are In, NotIn, Exists and DoesNotExist.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       * @return Whether the operator field is set.
       */
      public boolean hasOperator() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * operator represents a key's relationship to a set of values.
       * Valid operators are In, NotIn, Exists and DoesNotExist.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       * @return The operator.
       */
      public java.lang.String getOperator() {
        java.lang.Object ref = operator_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            operator_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * operator represents a key's relationship to a set of values.
       * Valid operators are In, NotIn, Exists and DoesNotExist.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       * @return The bytes for operator.
       */
      public com.google.protobuf.ByteString
          getOperatorBytes() {
        java.lang.Object ref = operator_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          operator_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * operator represents a key's relationship to a set of values.
       * Valid operators are In, NotIn, Exists and DoesNotExist.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       * @param value The operator to set.
       * @return This builder for chaining.
       */
      public Builder setOperator(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        operator_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * operator represents a key's relationship to a set of values.
       * Valid operators are In, NotIn, Exists and DoesNotExist.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearOperator() {
        operator_ = getDefaultInstance().getOperator();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * operator represents a key's relationship to a set of values.
       * Valid operators are In, NotIn, Exists and DoesNotExist.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       * @param value The bytes for operator to set.
       * @return This builder for chaining.
       */
      public Builder setOperatorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        operator_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList values_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureValuesIsMutable() {
        if (!values_.isModifiable()) {
          values_ = new com.google.protobuf.LazyStringArrayList(values_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <pre>
       * values is an array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. This array is replaced during a strategic
       * merge patch.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string values = 3;</code>
       * @return A list containing the values.
       */
      public com.google.protobuf.ProtocolStringList
          getValuesList() {
        values_.makeImmutable();
        return values_;
      }
      /**
       * <pre>
       * values is an array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. This array is replaced during a strategic
       * merge patch.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string values = 3;</code>
       * @return The count of values.
       */
      public int getValuesCount() {
        return values_.size();
      }
      /**
       * <pre>
       * values is an array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. This array is replaced during a strategic
       * merge patch.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string values = 3;</code>
       * @param index The index of the element to return.
       * @return The values at the given index.
       */
      public java.lang.String getValues(int index) {
        return values_.get(index);
      }
      /**
       * <pre>
       * values is an array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. This array is replaced during a strategic
       * merge patch.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string values = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the values at the given index.
       */
      public com.google.protobuf.ByteString
          getValuesBytes(int index) {
        return values_.getByteString(index);
      }
      /**
       * <pre>
       * values is an array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. This array is replaced during a strategic
       * merge patch.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string values = 3;</code>
       * @param index The index to set the value at.
       * @param value The values to set.
       * @return This builder for chaining.
       */
      public Builder setValues(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureValuesIsMutable();
        values_.set(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * values is an array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. This array is replaced during a strategic
       * merge patch.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string values = 3;</code>
       * @param value The values to add.
       * @return This builder for chaining.
       */
      public Builder addValues(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureValuesIsMutable();
        values_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * values is an array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. This array is replaced during a strategic
       * merge patch.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string values = 3;</code>
       * @param values The values to add.
       * @return This builder for chaining.
       */
      public Builder addAllValues(
          java.lang.Iterable<java.lang.String> values) {
        ensureValuesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, values_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * values is an array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. This array is replaced during a strategic
       * merge patch.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string values = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearValues() {
        values_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * values is an array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. This array is replaced during a strategic
       * merge patch.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string values = 3;</code>
       * @param value The bytes of the values to add.
       * @return This builder for chaining.
       */
      public Builder addValuesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureValuesIsMutable();
        values_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement)
    private static final io.kubernetes.client.proto.Meta.LabelSelectorRequirement DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.LabelSelectorRequirement();
    }

    public static io.kubernetes.client.proto.Meta.LabelSelectorRequirement getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LabelSelectorRequirement>
        PARSER = new com.google.protobuf.AbstractParser<LabelSelectorRequirement>() {
      @java.lang.Override
      public LabelSelectorRequirement parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LabelSelectorRequirement> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LabelSelectorRequirement> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorRequirement getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.List)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.Runtime.RawExtension> 
        getItemsList();
    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    io.kubernetes.client.proto.Runtime.RawExtension getItems(int index);
    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * List holds a list of objects, which may not be known by the server.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.List}
   */
  public static final class List extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.List)
      ListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        List.class.getName());
    }
    // Use List.newBuilder() to construct.
    private List(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private List() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.List.class, io.kubernetes.client.proto.Meta.List.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Runtime.RawExtension> items_;
    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Runtime.RawExtension> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Runtime.RawExtension getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of objects
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.List)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.List other = (io.kubernetes.client.proto.Meta.List) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.List parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.List parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.List parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.List parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.List parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.List parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.List parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.List parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.List parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.List parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.List parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.List parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.List prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * List holds a list of objects, which may not be known by the server.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.List}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.List)
        io.kubernetes.client.proto.Meta.ListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.List.class, io.kubernetes.client.proto.Meta.List.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.List.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.List getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.List.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.List build() {
        io.kubernetes.client.proto.Meta.List result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.List buildPartial() {
        io.kubernetes.client.proto.Meta.List result = new io.kubernetes.client.proto.Meta.List(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.Meta.List result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.List result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.List) {
          return mergeFrom((io.kubernetes.client.proto.Meta.List)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.List other) {
        if (other == io.kubernetes.client.proto.Meta.List.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.Runtime.RawExtension m =
                    input.readMessage(
                        io.kubernetes.client.proto.Runtime.RawExtension.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.Runtime.RawExtension> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.Runtime.RawExtension>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Runtime.RawExtension, io.kubernetes.client.proto.Runtime.RawExtension.Builder, io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Runtime.RawExtension> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public io.kubernetes.client.proto.Runtime.RawExtension getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.Runtime.RawExtension value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.Runtime.RawExtension.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.Runtime.RawExtension value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.Runtime.RawExtension value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.Runtime.RawExtension.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.Runtime.RawExtension.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Runtime.RawExtension> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public io.kubernetes.client.proto.Runtime.RawExtension.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public io.kubernetes.client.proto.Runtime.RawExtension.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance());
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public io.kubernetes.client.proto.Runtime.RawExtension.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance());
      }
      /**
       * <pre>
       * List of objects
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Runtime.RawExtension.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Runtime.RawExtension, io.kubernetes.client.proto.Runtime.RawExtension.Builder, io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Runtime.RawExtension, io.kubernetes.client.proto.Runtime.RawExtension.Builder, io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.List)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.List)
    private static final io.kubernetes.client.proto.Meta.List DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.List();
    }

    public static io.kubernetes.client.proto.Meta.List getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<List>
        PARSER = new com.google.protobuf.AbstractParser<List>() {
      @java.lang.Override
      public List parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<List> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<List> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.List getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListMetaOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 1;</code>
     * @return Whether the selfLink field is set.
     */
    boolean hasSelfLink();
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 1;</code>
     * @return The selfLink.
     */
    java.lang.String getSelfLink();
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 1;</code>
     * @return The bytes for selfLink.
     */
    com.google.protobuf.ByteString
        getSelfLinkBytes();

    /**
     * <pre>
     * String that identifies the server's internal version of this object that
     * can be used by clients to determine when objects have changed.
     * Value must be treated as opaque by clients and passed unmodified back to the server.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return Whether the resourceVersion field is set.
     */
    boolean hasResourceVersion();
    /**
     * <pre>
     * String that identifies the server's internal version of this object that
     * can be used by clients to determine when objects have changed.
     * Value must be treated as opaque by clients and passed unmodified back to the server.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return The resourceVersion.
     */
    java.lang.String getResourceVersion();
    /**
     * <pre>
     * String that identifies the server's internal version of this object that
     * can be used by clients to determine when objects have changed.
     * Value must be treated as opaque by clients and passed unmodified back to the server.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return The bytes for resourceVersion.
     */
    com.google.protobuf.ByteString
        getResourceVersionBytes();

    /**
     * <pre>
     * continue may be set if the user set a limit on the number of items returned, and indicates that
     * the server has more data available. The value is opaque and may be used to issue another request
     * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
     * consistent list may not be possible if the server configuration has changed or more than a few
     * minutes have passed. The resourceVersion field returned when using this continue value will be
     * identical to the value in the first response, unless you have received this token from an error
     * message.
     * </pre>
     *
     * <code>optional string continue = 3;</code>
     * @return Whether the continue field is set.
     */
    boolean hasContinue();
    /**
     * <pre>
     * continue may be set if the user set a limit on the number of items returned, and indicates that
     * the server has more data available. The value is opaque and may be used to issue another request
     * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
     * consistent list may not be possible if the server configuration has changed or more than a few
     * minutes have passed. The resourceVersion field returned when using this continue value will be
     * identical to the value in the first response, unless you have received this token from an error
     * message.
     * </pre>
     *
     * <code>optional string continue = 3;</code>
     * @return The continue.
     */
    java.lang.String getContinue();
    /**
     * <pre>
     * continue may be set if the user set a limit on the number of items returned, and indicates that
     * the server has more data available. The value is opaque and may be used to issue another request
     * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
     * consistent list may not be possible if the server configuration has changed or more than a few
     * minutes have passed. The resourceVersion field returned when using this continue value will be
     * identical to the value in the first response, unless you have received this token from an error
     * message.
     * </pre>
     *
     * <code>optional string continue = 3;</code>
     * @return The bytes for continue.
     */
    com.google.protobuf.ByteString
        getContinueBytes();

    /**
     * <pre>
     * remainingItemCount is the number of subsequent items in the list which are not included in this
     * list response. If the list request contained label or field selectors, then the number of
     * remaining items is unknown and the field will be left unset and omitted during serialization.
     * If the list is complete (either because it is not chunking or because this is the last chunk),
     * then there are no more remaining items and this field will be left unset and omitted during
     * serialization.
     * Servers older than v1.15 do not set this field.
     * The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
     * should not rely on the remainingItemCount to be set or to be exact.
     * +optional
     * </pre>
     *
     * <code>optional int64 remainingItemCount = 4;</code>
     * @return Whether the remainingItemCount field is set.
     */
    boolean hasRemainingItemCount();
    /**
     * <pre>
     * remainingItemCount is the number of subsequent items in the list which are not included in this
     * list response. If the list request contained label or field selectors, then the number of
     * remaining items is unknown and the field will be left unset and omitted during serialization.
     * If the list is complete (either because it is not chunking or because this is the last chunk),
     * then there are no more remaining items and this field will be left unset and omitted during
     * serialization.
     * Servers older than v1.15 do not set this field.
     * The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
     * should not rely on the remainingItemCount to be set or to be exact.
     * +optional
     * </pre>
     *
     * <code>optional int64 remainingItemCount = 4;</code>
     * @return The remainingItemCount.
     */
    long getRemainingItemCount();
  }
  /**
   * <pre>
   * ListMeta describes metadata that synthetic resources must have, including lists and
   * various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta}
   */
  public static final class ListMeta extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta)
      ListMetaOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ListMeta.class.getName());
    }
    // Use ListMeta.newBuilder() to construct.
    private ListMeta(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ListMeta() {
      selfLink_ = "";
      resourceVersion_ = "";
      continue_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.ListMeta.class, io.kubernetes.client.proto.Meta.ListMeta.Builder.class);
    }

    private int bitField0_;
    public static final int SELFLINK_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object selfLink_ = "";
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 1;</code>
     * @return Whether the selfLink field is set.
     */
    @java.lang.Override
    public boolean hasSelfLink() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 1;</code>
     * @return The selfLink.
     */
    @java.lang.Override
    public java.lang.String getSelfLink() {
      java.lang.Object ref = selfLink_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          selfLink_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 1;</code>
     * @return The bytes for selfLink.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSelfLinkBytes() {
      java.lang.Object ref = selfLink_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        selfLink_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RESOURCEVERSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resourceVersion_ = "";
    /**
     * <pre>
     * String that identifies the server's internal version of this object that
     * can be used by clients to determine when objects have changed.
     * Value must be treated as opaque by clients and passed unmodified back to the server.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return Whether the resourceVersion field is set.
     */
    @java.lang.Override
    public boolean hasResourceVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * String that identifies the server's internal version of this object that
     * can be used by clients to determine when objects have changed.
     * Value must be treated as opaque by clients and passed unmodified back to the server.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return The resourceVersion.
     */
    @java.lang.Override
    public java.lang.String getResourceVersion() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          resourceVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * String that identifies the server's internal version of this object that
     * can be used by clients to determine when objects have changed.
     * Value must be treated as opaque by clients and passed unmodified back to the server.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return The bytes for resourceVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceVersionBytes() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resourceVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CONTINUE_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object continue_ = "";
    /**
     * <pre>
     * continue may be set if the user set a limit on the number of items returned, and indicates that
     * the server has more data available. The value is opaque and may be used to issue another request
     * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
     * consistent list may not be possible if the server configuration has changed or more than a few
     * minutes have passed. The resourceVersion field returned when using this continue value will be
     * identical to the value in the first response, unless you have received this token from an error
     * message.
     * </pre>
     *
     * <code>optional string continue = 3;</code>
     * @return Whether the continue field is set.
     */
    @java.lang.Override
    public boolean hasContinue() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * continue may be set if the user set a limit on the number of items returned, and indicates that
     * the server has more data available. The value is opaque and may be used to issue another request
     * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
     * consistent list may not be possible if the server configuration has changed or more than a few
     * minutes have passed. The resourceVersion field returned when using this continue value will be
     * identical to the value in the first response, unless you have received this token from an error
     * message.
     * </pre>
     *
     * <code>optional string continue = 3;</code>
     * @return The continue.
     */
    @java.lang.Override
    public java.lang.String getContinue() {
      java.lang.Object ref = continue_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          continue_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * continue may be set if the user set a limit on the number of items returned, and indicates that
     * the server has more data available. The value is opaque and may be used to issue another request
     * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
     * consistent list may not be possible if the server configuration has changed or more than a few
     * minutes have passed. The resourceVersion field returned when using this continue value will be
     * identical to the value in the first response, unless you have received this token from an error
     * message.
     * </pre>
     *
     * <code>optional string continue = 3;</code>
     * @return The bytes for continue.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getContinueBytes() {
      java.lang.Object ref = continue_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        continue_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REMAININGITEMCOUNT_FIELD_NUMBER = 4;
    private long remainingItemCount_ = 0L;
    /**
     * <pre>
     * remainingItemCount is the number of subsequent items in the list which are not included in this
     * list response. If the list request contained label or field selectors, then the number of
     * remaining items is unknown and the field will be left unset and omitted during serialization.
     * If the list is complete (either because it is not chunking or because this is the last chunk),
     * then there are no more remaining items and this field will be left unset and omitted during
     * serialization.
     * Servers older than v1.15 do not set this field.
     * The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
     * should not rely on the remainingItemCount to be set or to be exact.
     * +optional
     * </pre>
     *
     * <code>optional int64 remainingItemCount = 4;</code>
     * @return Whether the remainingItemCount field is set.
     */
    @java.lang.Override
    public boolean hasRemainingItemCount() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * remainingItemCount is the number of subsequent items in the list which are not included in this
     * list response. If the list request contained label or field selectors, then the number of
     * remaining items is unknown and the field will be left unset and omitted during serialization.
     * If the list is complete (either because it is not chunking or because this is the last chunk),
     * then there are no more remaining items and this field will be left unset and omitted during
     * serialization.
     * Servers older than v1.15 do not set this field.
     * The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
     * should not rely on the remainingItemCount to be set or to be exact.
     * +optional
     * </pre>
     *
     * <code>optional int64 remainingItemCount = 4;</code>
     * @return The remainingItemCount.
     */
    @java.lang.Override
    public long getRemainingItemCount() {
      return remainingItemCount_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, selfLink_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, resourceVersion_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, continue_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt64(4, remainingItemCount_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, selfLink_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, resourceVersion_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, continue_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, remainingItemCount_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.ListMeta)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.ListMeta other = (io.kubernetes.client.proto.Meta.ListMeta) obj;

      if (hasSelfLink() != other.hasSelfLink()) return false;
      if (hasSelfLink()) {
        if (!getSelfLink()
            .equals(other.getSelfLink())) return false;
      }
      if (hasResourceVersion() != other.hasResourceVersion()) return false;
      if (hasResourceVersion()) {
        if (!getResourceVersion()
            .equals(other.getResourceVersion())) return false;
      }
      if (hasContinue() != other.hasContinue()) return false;
      if (hasContinue()) {
        if (!getContinue()
            .equals(other.getContinue())) return false;
      }
      if (hasRemainingItemCount() != other.hasRemainingItemCount()) return false;
      if (hasRemainingItemCount()) {
        if (getRemainingItemCount()
            != other.getRemainingItemCount()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSelfLink()) {
        hash = (37 * hash) + SELFLINK_FIELD_NUMBER;
        hash = (53 * hash) + getSelfLink().hashCode();
      }
      if (hasResourceVersion()) {
        hash = (37 * hash) + RESOURCEVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getResourceVersion().hashCode();
      }
      if (hasContinue()) {
        hash = (37 * hash) + CONTINUE_FIELD_NUMBER;
        hash = (53 * hash) + getContinue().hashCode();
      }
      if (hasRemainingItemCount()) {
        hash = (37 * hash) + REMAININGITEMCOUNT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getRemainingItemCount());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.ListMeta parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.ListMeta parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ListMeta parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.ListMeta prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ListMeta describes metadata that synthetic resources must have, including lists and
     * various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta)
        io.kubernetes.client.proto.Meta.ListMetaOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.ListMeta.class, io.kubernetes.client.proto.Meta.ListMeta.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.ListMeta.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        selfLink_ = "";
        resourceVersion_ = "";
        continue_ = "";
        remainingItemCount_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ListMeta getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ListMeta build() {
        io.kubernetes.client.proto.Meta.ListMeta result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ListMeta buildPartial() {
        io.kubernetes.client.proto.Meta.ListMeta result = new io.kubernetes.client.proto.Meta.ListMeta(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.ListMeta result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.selfLink_ = selfLink_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.resourceVersion_ = resourceVersion_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.continue_ = continue_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.remainingItemCount_ = remainingItemCount_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.ListMeta) {
          return mergeFrom((io.kubernetes.client.proto.Meta.ListMeta)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.ListMeta other) {
        if (other == io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) return this;
        if (other.hasSelfLink()) {
          selfLink_ = other.selfLink_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasResourceVersion()) {
          resourceVersion_ = other.resourceVersion_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasContinue()) {
          continue_ = other.continue_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasRemainingItemCount()) {
          setRemainingItemCount(other.getRemainingItemCount());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                selfLink_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                resourceVersion_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                continue_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                remainingItemCount_ = input.readInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object selfLink_ = "";
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 1;</code>
       * @return Whether the selfLink field is set.
       */
      public boolean hasSelfLink() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 1;</code>
       * @return The selfLink.
       */
      public java.lang.String getSelfLink() {
        java.lang.Object ref = selfLink_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            selfLink_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 1;</code>
       * @return The bytes for selfLink.
       */
      public com.google.protobuf.ByteString
          getSelfLinkBytes() {
        java.lang.Object ref = selfLink_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          selfLink_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 1;</code>
       * @param value The selfLink to set.
       * @return This builder for chaining.
       */
      public Builder setSelfLink(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        selfLink_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSelfLink() {
        selfLink_ = getDefaultInstance().getSelfLink();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 1;</code>
       * @param value The bytes for selfLink to set.
       * @return This builder for chaining.
       */
      public Builder setSelfLinkBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        selfLink_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object resourceVersion_ = "";
      /**
       * <pre>
       * String that identifies the server's internal version of this object that
       * can be used by clients to determine when objects have changed.
       * Value must be treated as opaque by clients and passed unmodified back to the server.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @return Whether the resourceVersion field is set.
       */
      public boolean hasResourceVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * String that identifies the server's internal version of this object that
       * can be used by clients to determine when objects have changed.
       * Value must be treated as opaque by clients and passed unmodified back to the server.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @return The resourceVersion.
       */
      public java.lang.String getResourceVersion() {
        java.lang.Object ref = resourceVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            resourceVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * String that identifies the server's internal version of this object that
       * can be used by clients to determine when objects have changed.
       * Value must be treated as opaque by clients and passed unmodified back to the server.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @return The bytes for resourceVersion.
       */
      public com.google.protobuf.ByteString
          getResourceVersionBytes() {
        java.lang.Object ref = resourceVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resourceVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * String that identifies the server's internal version of this object that
       * can be used by clients to determine when objects have changed.
       * Value must be treated as opaque by clients and passed unmodified back to the server.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @param value The resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * String that identifies the server's internal version of this object that
       * can be used by clients to determine when objects have changed.
       * Value must be treated as opaque by clients and passed unmodified back to the server.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceVersion() {
        resourceVersion_ = getDefaultInstance().getResourceVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * String that identifies the server's internal version of this object that
       * can be used by clients to determine when objects have changed.
       * Value must be treated as opaque by clients and passed unmodified back to the server.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @param value The bytes for resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object continue_ = "";
      /**
       * <pre>
       * continue may be set if the user set a limit on the number of items returned, and indicates that
       * the server has more data available. The value is opaque and may be used to issue another request
       * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
       * consistent list may not be possible if the server configuration has changed or more than a few
       * minutes have passed. The resourceVersion field returned when using this continue value will be
       * identical to the value in the first response, unless you have received this token from an error
       * message.
       * </pre>
       *
       * <code>optional string continue = 3;</code>
       * @return Whether the continue field is set.
       */
      public boolean hasContinue() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * continue may be set if the user set a limit on the number of items returned, and indicates that
       * the server has more data available. The value is opaque and may be used to issue another request
       * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
       * consistent list may not be possible if the server configuration has changed or more than a few
       * minutes have passed. The resourceVersion field returned when using this continue value will be
       * identical to the value in the first response, unless you have received this token from an error
       * message.
       * </pre>
       *
       * <code>optional string continue = 3;</code>
       * @return The continue.
       */
      public java.lang.String getContinue() {
        java.lang.Object ref = continue_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            continue_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * continue may be set if the user set a limit on the number of items returned, and indicates that
       * the server has more data available. The value is opaque and may be used to issue another request
       * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
       * consistent list may not be possible if the server configuration has changed or more than a few
       * minutes have passed. The resourceVersion field returned when using this continue value will be
       * identical to the value in the first response, unless you have received this token from an error
       * message.
       * </pre>
       *
       * <code>optional string continue = 3;</code>
       * @return The bytes for continue.
       */
      public com.google.protobuf.ByteString
          getContinueBytes() {
        java.lang.Object ref = continue_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          continue_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * continue may be set if the user set a limit on the number of items returned, and indicates that
       * the server has more data available. The value is opaque and may be used to issue another request
       * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
       * consistent list may not be possible if the server configuration has changed or more than a few
       * minutes have passed. The resourceVersion field returned when using this continue value will be
       * identical to the value in the first response, unless you have received this token from an error
       * message.
       * </pre>
       *
       * <code>optional string continue = 3;</code>
       * @param value The continue to set.
       * @return This builder for chaining.
       */
      public Builder setContinue(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        continue_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * continue may be set if the user set a limit on the number of items returned, and indicates that
       * the server has more data available. The value is opaque and may be used to issue another request
       * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
       * consistent list may not be possible if the server configuration has changed or more than a few
       * minutes have passed. The resourceVersion field returned when using this continue value will be
       * identical to the value in the first response, unless you have received this token from an error
       * message.
       * </pre>
       *
       * <code>optional string continue = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearContinue() {
        continue_ = getDefaultInstance().getContinue();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * continue may be set if the user set a limit on the number of items returned, and indicates that
       * the server has more data available. The value is opaque and may be used to issue another request
       * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
       * consistent list may not be possible if the server configuration has changed or more than a few
       * minutes have passed. The resourceVersion field returned when using this continue value will be
       * identical to the value in the first response, unless you have received this token from an error
       * message.
       * </pre>
       *
       * <code>optional string continue = 3;</code>
       * @param value The bytes for continue to set.
       * @return This builder for chaining.
       */
      public Builder setContinueBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        continue_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private long remainingItemCount_ ;
      /**
       * <pre>
       * remainingItemCount is the number of subsequent items in the list which are not included in this
       * list response. If the list request contained label or field selectors, then the number of
       * remaining items is unknown and the field will be left unset and omitted during serialization.
       * If the list is complete (either because it is not chunking or because this is the last chunk),
       * then there are no more remaining items and this field will be left unset and omitted during
       * serialization.
       * Servers older than v1.15 do not set this field.
       * The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
       * should not rely on the remainingItemCount to be set or to be exact.
       * +optional
       * </pre>
       *
       * <code>optional int64 remainingItemCount = 4;</code>
       * @return Whether the remainingItemCount field is set.
       */
      @java.lang.Override
      public boolean hasRemainingItemCount() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * remainingItemCount is the number of subsequent items in the list which are not included in this
       * list response. If the list request contained label or field selectors, then the number of
       * remaining items is unknown and the field will be left unset and omitted during serialization.
       * If the list is complete (either because it is not chunking or because this is the last chunk),
       * then there are no more remaining items and this field will be left unset and omitted during
       * serialization.
       * Servers older than v1.15 do not set this field.
       * The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
       * should not rely on the remainingItemCount to be set or to be exact.
       * +optional
       * </pre>
       *
       * <code>optional int64 remainingItemCount = 4;</code>
       * @return The remainingItemCount.
       */
      @java.lang.Override
      public long getRemainingItemCount() {
        return remainingItemCount_;
      }
      /**
       * <pre>
       * remainingItemCount is the number of subsequent items in the list which are not included in this
       * list response. If the list request contained label or field selectors, then the number of
       * remaining items is unknown and the field will be left unset and omitted during serialization.
       * If the list is complete (either because it is not chunking or because this is the last chunk),
       * then there are no more remaining items and this field will be left unset and omitted during
       * serialization.
       * Servers older than v1.15 do not set this field.
       * The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
       * should not rely on the remainingItemCount to be set or to be exact.
       * +optional
       * </pre>
       *
       * <code>optional int64 remainingItemCount = 4;</code>
       * @param value The remainingItemCount to set.
       * @return This builder for chaining.
       */
      public Builder setRemainingItemCount(long value) {

        remainingItemCount_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * remainingItemCount is the number of subsequent items in the list which are not included in this
       * list response. If the list request contained label or field selectors, then the number of
       * remaining items is unknown and the field will be left unset and omitted during serialization.
       * If the list is complete (either because it is not chunking or because this is the last chunk),
       * then there are no more remaining items and this field will be left unset and omitted during
       * serialization.
       * Servers older than v1.15 do not set this field.
       * The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
       * should not rely on the remainingItemCount to be set or to be exact.
       * +optional
       * </pre>
       *
       * <code>optional int64 remainingItemCount = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemainingItemCount() {
        bitField0_ = (bitField0_ & ~0x00000008);
        remainingItemCount_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta)
    private static final io.kubernetes.client.proto.Meta.ListMeta DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.ListMeta();
    }

    public static io.kubernetes.client.proto.Meta.ListMeta getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListMeta>
        PARSER = new com.google.protobuf.AbstractParser<ListMeta>() {
      @java.lang.Override
      public ListMeta parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ListMeta> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListMeta> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A selector to restrict the list of returned objects by their labels.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string labelSelector = 1;</code>
     * @return Whether the labelSelector field is set.
     */
    boolean hasLabelSelector();
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their labels.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string labelSelector = 1;</code>
     * @return The labelSelector.
     */
    java.lang.String getLabelSelector();
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their labels.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string labelSelector = 1;</code>
     * @return The bytes for labelSelector.
     */
    com.google.protobuf.ByteString
        getLabelSelectorBytes();

    /**
     * <pre>
     * A selector to restrict the list of returned objects by their fields.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string fieldSelector = 2;</code>
     * @return Whether the fieldSelector field is set.
     */
    boolean hasFieldSelector();
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their fields.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string fieldSelector = 2;</code>
     * @return The fieldSelector.
     */
    java.lang.String getFieldSelector();
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their fields.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string fieldSelector = 2;</code>
     * @return The bytes for fieldSelector.
     */
    com.google.protobuf.ByteString
        getFieldSelectorBytes();

    /**
     * <pre>
     * Watch for changes to the described resources and return them as a stream of
     * add, update, and remove notifications. Specify resourceVersion.
     * +optional
     * </pre>
     *
     * <code>optional bool watch = 3;</code>
     * @return Whether the watch field is set.
     */
    boolean hasWatch();
    /**
     * <pre>
     * Watch for changes to the described resources and return them as a stream of
     * add, update, and remove notifications. Specify resourceVersion.
     * +optional
     * </pre>
     *
     * <code>optional bool watch = 3;</code>
     * @return The watch.
     */
    boolean getWatch();

    /**
     * <pre>
     * allowWatchBookmarks requests watch events with type "BOOKMARK".
     * Servers that do not implement bookmarks may ignore this flag and
     * bookmarks are sent at the server's discretion. Clients should not
     * assume bookmarks are returned at any specific interval, nor may they
     * assume the server will send any BOOKMARK event during a session.
     * If this is not a watch, this field is ignored.
     * +optional
     * </pre>
     *
     * <code>optional bool allowWatchBookmarks = 9;</code>
     * @return Whether the allowWatchBookmarks field is set.
     */
    boolean hasAllowWatchBookmarks();
    /**
     * <pre>
     * allowWatchBookmarks requests watch events with type "BOOKMARK".
     * Servers that do not implement bookmarks may ignore this flag and
     * bookmarks are sent at the server's discretion. Clients should not
     * assume bookmarks are returned at any specific interval, nor may they
     * assume the server will send any BOOKMARK event during a session.
     * If this is not a watch, this field is ignored.
     * +optional
     * </pre>
     *
     * <code>optional bool allowWatchBookmarks = 9;</code>
     * @return The allowWatchBookmarks.
     */
    boolean getAllowWatchBookmarks();

    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 4;</code>
     * @return Whether the resourceVersion field is set.
     */
    boolean hasResourceVersion();
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 4;</code>
     * @return The resourceVersion.
     */
    java.lang.String getResourceVersion();
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 4;</code>
     * @return The bytes for resourceVersion.
     */
    com.google.protobuf.ByteString
        getResourceVersionBytes();

    /**
     * <pre>
     * resourceVersionMatch determines how resourceVersion is applied to list calls.
     * It is highly recommended that resourceVersionMatch be set for list calls where
     * resourceVersion is set
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersionMatch = 10;</code>
     * @return Whether the resourceVersionMatch field is set.
     */
    boolean hasResourceVersionMatch();
    /**
     * <pre>
     * resourceVersionMatch determines how resourceVersion is applied to list calls.
     * It is highly recommended that resourceVersionMatch be set for list calls where
     * resourceVersion is set
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersionMatch = 10;</code>
     * @return The resourceVersionMatch.
     */
    java.lang.String getResourceVersionMatch();
    /**
     * <pre>
     * resourceVersionMatch determines how resourceVersion is applied to list calls.
     * It is highly recommended that resourceVersionMatch be set for list calls where
     * resourceVersion is set
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersionMatch = 10;</code>
     * @return The bytes for resourceVersionMatch.
     */
    com.google.protobuf.ByteString
        getResourceVersionMatchBytes();

    /**
     * <pre>
     * Timeout for the list/watch call.
     * This limits the duration of the call, regardless of any activity or inactivity.
     * +optional
     * </pre>
     *
     * <code>optional int64 timeoutSeconds = 5;</code>
     * @return Whether the timeoutSeconds field is set.
     */
    boolean hasTimeoutSeconds();
    /**
     * <pre>
     * Timeout for the list/watch call.
     * This limits the duration of the call, regardless of any activity or inactivity.
     * +optional
     * </pre>
     *
     * <code>optional int64 timeoutSeconds = 5;</code>
     * @return The timeoutSeconds.
     */
    long getTimeoutSeconds();

    /**
     * <pre>
     * limit is a maximum number of responses to return for a list call. If more items exist, the
     * server will set the `continue` field on the list metadata to a value that can be used with the
     * same initial query to retrieve the next set of results. Setting a limit may return fewer than
     * the requested amount of items (up to zero items) in the event all requested objects are
     * filtered out and clients should only use the presence of the continue field to determine whether
     * more results are available. Servers may choose not to support the limit argument and will return
     * all of the available results. If limit is specified and the continue field is empty, clients may
     * assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing
     * a single list call without a limit - that is, no objects created, modified, or deleted after the
     * first request is issued will be included in any subsequent continued requests. This is sometimes
     * referred to as a consistent snapshot, and ensures that a client that is using limit to receive
     * smaller chunks of a very large result can ensure they see all possible objects. If objects are
     * updated during a chunked list the version of the object that was present at the time the first list
     * result was calculated is returned.
     * </pre>
     *
     * <code>optional int64 limit = 7;</code>
     * @return Whether the limit field is set.
     */
    boolean hasLimit();
    /**
     * <pre>
     * limit is a maximum number of responses to return for a list call. If more items exist, the
     * server will set the `continue` field on the list metadata to a value that can be used with the
     * same initial query to retrieve the next set of results. Setting a limit may return fewer than
     * the requested amount of items (up to zero items) in the event all requested objects are
     * filtered out and clients should only use the presence of the continue field to determine whether
     * more results are available. Servers may choose not to support the limit argument and will return
     * all of the available results. If limit is specified and the continue field is empty, clients may
     * assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing
     * a single list call without a limit - that is, no objects created, modified, or deleted after the
     * first request is issued will be included in any subsequent continued requests. This is sometimes
     * referred to as a consistent snapshot, and ensures that a client that is using limit to receive
     * smaller chunks of a very large result can ensure they see all possible objects. If objects are
     * updated during a chunked list the version of the object that was present at the time the first list
     * result was calculated is returned.
     * </pre>
     *
     * <code>optional int64 limit = 7;</code>
     * @return The limit.
     */
    long getLimit();

    /**
     * <pre>
     * The continue option should be set when retrieving more results from the server. Since this value is
     * server defined, clients may only use the continue value from a previous query result with identical
     * query parameters (except for the value of continue) and the server may reject a continue value it
     * does not recognize. If the specified continue value is no longer valid whether due to expiration
     * (generally five to fifteen minutes) or a configuration change on the server, the server will
     * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
     * consistent list, it must restart their list without the continue field. Otherwise, the client may
     * send another list request with the token received with the 410 error, the server will respond with
     * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
     * previous list results - objects that are created, modified, or deleted after the first list request
     * will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last
     * resourceVersion value returned by the server and not miss any modifications.
     * </pre>
     *
     * <code>optional string continue = 8;</code>
     * @return Whether the continue field is set.
     */
    boolean hasContinue();
    /**
     * <pre>
     * The continue option should be set when retrieving more results from the server. Since this value is
     * server defined, clients may only use the continue value from a previous query result with identical
     * query parameters (except for the value of continue) and the server may reject a continue value it
     * does not recognize. If the specified continue value is no longer valid whether due to expiration
     * (generally five to fifteen minutes) or a configuration change on the server, the server will
     * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
     * consistent list, it must restart their list without the continue field. Otherwise, the client may
     * send another list request with the token received with the 410 error, the server will respond with
     * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
     * previous list results - objects that are created, modified, or deleted after the first list request
     * will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last
     * resourceVersion value returned by the server and not miss any modifications.
     * </pre>
     *
     * <code>optional string continue = 8;</code>
     * @return The continue.
     */
    java.lang.String getContinue();
    /**
     * <pre>
     * The continue option should be set when retrieving more results from the server. Since this value is
     * server defined, clients may only use the continue value from a previous query result with identical
     * query parameters (except for the value of continue) and the server may reject a continue value it
     * does not recognize. If the specified continue value is no longer valid whether due to expiration
     * (generally five to fifteen minutes) or a configuration change on the server, the server will
     * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
     * consistent list, it must restart their list without the continue field. Otherwise, the client may
     * send another list request with the token received with the 410 error, the server will respond with
     * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
     * previous list results - objects that are created, modified, or deleted after the first list request
     * will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last
     * resourceVersion value returned by the server and not miss any modifications.
     * </pre>
     *
     * <code>optional string continue = 8;</code>
     * @return The bytes for continue.
     */
    com.google.protobuf.ByteString
        getContinueBytes();

    /**
     * <pre>
     * `sendInitialEvents=true` may be set together with `watch=true`.
     * In that case, the watch stream will begin with synthetic events to
     * produce the current state of objects in the collection. Once all such
     * events have been sent, a synthetic "Bookmark" event  will be sent.
     * The bookmark will report the ResourceVersion (RV) corresponding to the
     * set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation.
     * Afterwards, the watch stream will proceed as usual, sending watch events
     * corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch`
     * option to also be set. The semantic of the watch request is as following:
     * - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward
     * compatibility reasons) and to false otherwise.
     * +optional
     * </pre>
     *
     * <code>optional bool sendInitialEvents = 11;</code>
     * @return Whether the sendInitialEvents field is set.
     */
    boolean hasSendInitialEvents();
    /**
     * <pre>
     * `sendInitialEvents=true` may be set together with `watch=true`.
     * In that case, the watch stream will begin with synthetic events to
     * produce the current state of objects in the collection. Once all such
     * events have been sent, a synthetic "Bookmark" event  will be sent.
     * The bookmark will report the ResourceVersion (RV) corresponding to the
     * set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation.
     * Afterwards, the watch stream will proceed as usual, sending watch events
     * corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch`
     * option to also be set. The semantic of the watch request is as following:
     * - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward
     * compatibility reasons) and to false otherwise.
     * +optional
     * </pre>
     *
     * <code>optional bool sendInitialEvents = 11;</code>
     * @return The sendInitialEvents.
     */
    boolean getSendInitialEvents();
  }
  /**
   * <pre>
   * ListOptions is the query options to a standard REST list call.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions}
   */
  public static final class ListOptions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions)
      ListOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ListOptions.class.getName());
    }
    // Use ListOptions.newBuilder() to construct.
    private ListOptions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ListOptions() {
      labelSelector_ = "";
      fieldSelector_ = "";
      resourceVersion_ = "";
      resourceVersionMatch_ = "";
      continue_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.ListOptions.class, io.kubernetes.client.proto.Meta.ListOptions.Builder.class);
    }

    private int bitField0_;
    public static final int LABELSELECTOR_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object labelSelector_ = "";
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their labels.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string labelSelector = 1;</code>
     * @return Whether the labelSelector field is set.
     */
    @java.lang.Override
    public boolean hasLabelSelector() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their labels.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string labelSelector = 1;</code>
     * @return The labelSelector.
     */
    @java.lang.Override
    public java.lang.String getLabelSelector() {
      java.lang.Object ref = labelSelector_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          labelSelector_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their labels.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string labelSelector = 1;</code>
     * @return The bytes for labelSelector.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelSelectorBytes() {
      java.lang.Object ref = labelSelector_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        labelSelector_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FIELDSELECTOR_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldSelector_ = "";
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their fields.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string fieldSelector = 2;</code>
     * @return Whether the fieldSelector field is set.
     */
    @java.lang.Override
    public boolean hasFieldSelector() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their fields.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string fieldSelector = 2;</code>
     * @return The fieldSelector.
     */
    @java.lang.Override
    public java.lang.String getFieldSelector() {
      java.lang.Object ref = fieldSelector_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldSelector_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A selector to restrict the list of returned objects by their fields.
     * Defaults to everything.
     * +optional
     * </pre>
     *
     * <code>optional string fieldSelector = 2;</code>
     * @return The bytes for fieldSelector.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldSelectorBytes() {
      java.lang.Object ref = fieldSelector_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldSelector_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WATCH_FIELD_NUMBER = 3;
    private boolean watch_ = false;
    /**
     * <pre>
     * Watch for changes to the described resources and return them as a stream of
     * add, update, and remove notifications. Specify resourceVersion.
     * +optional
     * </pre>
     *
     * <code>optional bool watch = 3;</code>
     * @return Whether the watch field is set.
     */
    @java.lang.Override
    public boolean hasWatch() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Watch for changes to the described resources and return them as a stream of
     * add, update, and remove notifications. Specify resourceVersion.
     * +optional
     * </pre>
     *
     * <code>optional bool watch = 3;</code>
     * @return The watch.
     */
    @java.lang.Override
    public boolean getWatch() {
      return watch_;
    }

    public static final int ALLOWWATCHBOOKMARKS_FIELD_NUMBER = 9;
    private boolean allowWatchBookmarks_ = false;
    /**
     * <pre>
     * allowWatchBookmarks requests watch events with type "BOOKMARK".
     * Servers that do not implement bookmarks may ignore this flag and
     * bookmarks are sent at the server's discretion. Clients should not
     * assume bookmarks are returned at any specific interval, nor may they
     * assume the server will send any BOOKMARK event during a session.
     * If this is not a watch, this field is ignored.
     * +optional
     * </pre>
     *
     * <code>optional bool allowWatchBookmarks = 9;</code>
     * @return Whether the allowWatchBookmarks field is set.
     */
    @java.lang.Override
    public boolean hasAllowWatchBookmarks() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * allowWatchBookmarks requests watch events with type "BOOKMARK".
     * Servers that do not implement bookmarks may ignore this flag and
     * bookmarks are sent at the server's discretion. Clients should not
     * assume bookmarks are returned at any specific interval, nor may they
     * assume the server will send any BOOKMARK event during a session.
     * If this is not a watch, this field is ignored.
     * +optional
     * </pre>
     *
     * <code>optional bool allowWatchBookmarks = 9;</code>
     * @return The allowWatchBookmarks.
     */
    @java.lang.Override
    public boolean getAllowWatchBookmarks() {
      return allowWatchBookmarks_;
    }

    public static final int RESOURCEVERSION_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resourceVersion_ = "";
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 4;</code>
     * @return Whether the resourceVersion field is set.
     */
    @java.lang.Override
    public boolean hasResourceVersion() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 4;</code>
     * @return The resourceVersion.
     */
    @java.lang.Override
    public java.lang.String getResourceVersion() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          resourceVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * resourceVersion sets a constraint on what resource versions a request may be served from.
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 4;</code>
     * @return The bytes for resourceVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceVersionBytes() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resourceVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RESOURCEVERSIONMATCH_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resourceVersionMatch_ = "";
    /**
     * <pre>
     * resourceVersionMatch determines how resourceVersion is applied to list calls.
     * It is highly recommended that resourceVersionMatch be set for list calls where
     * resourceVersion is set
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersionMatch = 10;</code>
     * @return Whether the resourceVersionMatch field is set.
     */
    @java.lang.Override
    public boolean hasResourceVersionMatch() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * resourceVersionMatch determines how resourceVersion is applied to list calls.
     * It is highly recommended that resourceVersionMatch be set for list calls where
     * resourceVersion is set
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersionMatch = 10;</code>
     * @return The resourceVersionMatch.
     */
    @java.lang.Override
    public java.lang.String getResourceVersionMatch() {
      java.lang.Object ref = resourceVersionMatch_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          resourceVersionMatch_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * resourceVersionMatch determines how resourceVersion is applied to list calls.
     * It is highly recommended that resourceVersionMatch be set for list calls where
     * resourceVersion is set
     * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
     * details.
     *
     * Defaults to unset
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersionMatch = 10;</code>
     * @return The bytes for resourceVersionMatch.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceVersionMatchBytes() {
      java.lang.Object ref = resourceVersionMatch_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resourceVersionMatch_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TIMEOUTSECONDS_FIELD_NUMBER = 5;
    private long timeoutSeconds_ = 0L;
    /**
     * <pre>
     * Timeout for the list/watch call.
     * This limits the duration of the call, regardless of any activity or inactivity.
     * +optional
     * </pre>
     *
     * <code>optional int64 timeoutSeconds = 5;</code>
     * @return Whether the timeoutSeconds field is set.
     */
    @java.lang.Override
    public boolean hasTimeoutSeconds() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Timeout for the list/watch call.
     * This limits the duration of the call, regardless of any activity or inactivity.
     * +optional
     * </pre>
     *
     * <code>optional int64 timeoutSeconds = 5;</code>
     * @return The timeoutSeconds.
     */
    @java.lang.Override
    public long getTimeoutSeconds() {
      return timeoutSeconds_;
    }

    public static final int LIMIT_FIELD_NUMBER = 7;
    private long limit_ = 0L;
    /**
     * <pre>
     * limit is a maximum number of responses to return for a list call. If more items exist, the
     * server will set the `continue` field on the list metadata to a value that can be used with the
     * same initial query to retrieve the next set of results. Setting a limit may return fewer than
     * the requested amount of items (up to zero items) in the event all requested objects are
     * filtered out and clients should only use the presence of the continue field to determine whether
     * more results are available. Servers may choose not to support the limit argument and will return
     * all of the available results. If limit is specified and the continue field is empty, clients may
     * assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing
     * a single list call without a limit - that is, no objects created, modified, or deleted after the
     * first request is issued will be included in any subsequent continued requests. This is sometimes
     * referred to as a consistent snapshot, and ensures that a client that is using limit to receive
     * smaller chunks of a very large result can ensure they see all possible objects. If objects are
     * updated during a chunked list the version of the object that was present at the time the first list
     * result was calculated is returned.
     * </pre>
     *
     * <code>optional int64 limit = 7;</code>
     * @return Whether the limit field is set.
     */
    @java.lang.Override
    public boolean hasLimit() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * limit is a maximum number of responses to return for a list call. If more items exist, the
     * server will set the `continue` field on the list metadata to a value that can be used with the
     * same initial query to retrieve the next set of results. Setting a limit may return fewer than
     * the requested amount of items (up to zero items) in the event all requested objects are
     * filtered out and clients should only use the presence of the continue field to determine whether
     * more results are available. Servers may choose not to support the limit argument and will return
     * all of the available results. If limit is specified and the continue field is empty, clients may
     * assume that no more results are available. This field is not supported if watch is true.
     *
     * The server guarantees that the objects returned when using continue will be identical to issuing
     * a single list call without a limit - that is, no objects created, modified, or deleted after the
     * first request is issued will be included in any subsequent continued requests. This is sometimes
     * referred to as a consistent snapshot, and ensures that a client that is using limit to receive
     * smaller chunks of a very large result can ensure they see all possible objects. If objects are
     * updated during a chunked list the version of the object that was present at the time the first list
     * result was calculated is returned.
     * </pre>
     *
     * <code>optional int64 limit = 7;</code>
     * @return The limit.
     */
    @java.lang.Override
    public long getLimit() {
      return limit_;
    }

    public static final int CONTINUE_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object continue_ = "";
    /**
     * <pre>
     * The continue option should be set when retrieving more results from the server. Since this value is
     * server defined, clients may only use the continue value from a previous query result with identical
     * query parameters (except for the value of continue) and the server may reject a continue value it
     * does not recognize. If the specified continue value is no longer valid whether due to expiration
     * (generally five to fifteen minutes) or a configuration change on the server, the server will
     * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
     * consistent list, it must restart their list without the continue field. Otherwise, the client may
     * send another list request with the token received with the 410 error, the server will respond with
     * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
     * previous list results - objects that are created, modified, or deleted after the first list request
     * will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last
     * resourceVersion value returned by the server and not miss any modifications.
     * </pre>
     *
     * <code>optional string continue = 8;</code>
     * @return Whether the continue field is set.
     */
    @java.lang.Override
    public boolean hasContinue() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * The continue option should be set when retrieving more results from the server. Since this value is
     * server defined, clients may only use the continue value from a previous query result with identical
     * query parameters (except for the value of continue) and the server may reject a continue value it
     * does not recognize. If the specified continue value is no longer valid whether due to expiration
     * (generally five to fifteen minutes) or a configuration change on the server, the server will
     * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
     * consistent list, it must restart their list without the continue field. Otherwise, the client may
     * send another list request with the token received with the 410 error, the server will respond with
     * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
     * previous list results - objects that are created, modified, or deleted after the first list request
     * will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last
     * resourceVersion value returned by the server and not miss any modifications.
     * </pre>
     *
     * <code>optional string continue = 8;</code>
     * @return The continue.
     */
    @java.lang.Override
    public java.lang.String getContinue() {
      java.lang.Object ref = continue_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          continue_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The continue option should be set when retrieving more results from the server. Since this value is
     * server defined, clients may only use the continue value from a previous query result with identical
     * query parameters (except for the value of continue) and the server may reject a continue value it
     * does not recognize. If the specified continue value is no longer valid whether due to expiration
     * (generally five to fifteen minutes) or a configuration change on the server, the server will
     * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
     * consistent list, it must restart their list without the continue field. Otherwise, the client may
     * send another list request with the token received with the 410 error, the server will respond with
     * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
     * previous list results - objects that are created, modified, or deleted after the first list request
     * will be included in the response, as long as their keys are after the "next key".
     *
     * This field is not supported when watch is true. Clients may start a watch from the last
     * resourceVersion value returned by the server and not miss any modifications.
     * </pre>
     *
     * <code>optional string continue = 8;</code>
     * @return The bytes for continue.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getContinueBytes() {
      java.lang.Object ref = continue_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        continue_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SENDINITIALEVENTS_FIELD_NUMBER = 11;
    private boolean sendInitialEvents_ = false;
    /**
     * <pre>
     * `sendInitialEvents=true` may be set together with `watch=true`.
     * In that case, the watch stream will begin with synthetic events to
     * produce the current state of objects in the collection. Once all such
     * events have been sent, a synthetic "Bookmark" event  will be sent.
     * The bookmark will report the ResourceVersion (RV) corresponding to the
     * set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation.
     * Afterwards, the watch stream will proceed as usual, sending watch events
     * corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch`
     * option to also be set. The semantic of the watch request is as following:
     * - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward
     * compatibility reasons) and to false otherwise.
     * +optional
     * </pre>
     *
     * <code>optional bool sendInitialEvents = 11;</code>
     * @return Whether the sendInitialEvents field is set.
     */
    @java.lang.Override
    public boolean hasSendInitialEvents() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * `sendInitialEvents=true` may be set together with `watch=true`.
     * In that case, the watch stream will begin with synthetic events to
     * produce the current state of objects in the collection. Once all such
     * events have been sent, a synthetic "Bookmark" event  will be sent.
     * The bookmark will report the ResourceVersion (RV) corresponding to the
     * set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation.
     * Afterwards, the watch stream will proceed as usual, sending watch events
     * corresponding to changes (subsequent to the RV) to objects watched.
     *
     * When `sendInitialEvents` option is set, we require `resourceVersionMatch`
     * option to also be set. The semantic of the watch request is as following:
     * - `resourceVersionMatch` = NotOlderThan
     * is interpreted as "data at least as new as the provided `resourceVersion`"
     * and the bookmark event is send when the state is synced
     * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
     * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
     * bookmark event is send when the state is synced at least to the moment
     * when request started being processed.
     * - `resourceVersionMatch` set to any other value or unset
     * Invalid error is returned.
     *
     * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward
     * compatibility reasons) and to false otherwise.
     * +optional
     * </pre>
     *
     * <code>optional bool sendInitialEvents = 11;</code>
     * @return The sendInitialEvents.
     */
    @java.lang.Override
    public boolean getSendInitialEvents() {
      return sendInitialEvents_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, labelSelector_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, fieldSelector_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(3, watch_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, resourceVersion_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeInt64(5, timeoutSeconds_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt64(7, limit_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, continue_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(9, allowWatchBookmarks_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 10, resourceVersionMatch_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeBool(11, sendInitialEvents_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, labelSelector_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, fieldSelector_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, watch_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, resourceVersion_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, timeoutSeconds_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(7, limit_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, continue_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, allowWatchBookmarks_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(10, resourceVersionMatch_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(11, sendInitialEvents_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.ListOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.ListOptions other = (io.kubernetes.client.proto.Meta.ListOptions) obj;

      if (hasLabelSelector() != other.hasLabelSelector()) return false;
      if (hasLabelSelector()) {
        if (!getLabelSelector()
            .equals(other.getLabelSelector())) return false;
      }
      if (hasFieldSelector() != other.hasFieldSelector()) return false;
      if (hasFieldSelector()) {
        if (!getFieldSelector()
            .equals(other.getFieldSelector())) return false;
      }
      if (hasWatch() != other.hasWatch()) return false;
      if (hasWatch()) {
        if (getWatch()
            != other.getWatch()) return false;
      }
      if (hasAllowWatchBookmarks() != other.hasAllowWatchBookmarks()) return false;
      if (hasAllowWatchBookmarks()) {
        if (getAllowWatchBookmarks()
            != other.getAllowWatchBookmarks()) return false;
      }
      if (hasResourceVersion() != other.hasResourceVersion()) return false;
      if (hasResourceVersion()) {
        if (!getResourceVersion()
            .equals(other.getResourceVersion())) return false;
      }
      if (hasResourceVersionMatch() != other.hasResourceVersionMatch()) return false;
      if (hasResourceVersionMatch()) {
        if (!getResourceVersionMatch()
            .equals(other.getResourceVersionMatch())) return false;
      }
      if (hasTimeoutSeconds() != other.hasTimeoutSeconds()) return false;
      if (hasTimeoutSeconds()) {
        if (getTimeoutSeconds()
            != other.getTimeoutSeconds()) return false;
      }
      if (hasLimit() != other.hasLimit()) return false;
      if (hasLimit()) {
        if (getLimit()
            != other.getLimit()) return false;
      }
      if (hasContinue() != other.hasContinue()) return false;
      if (hasContinue()) {
        if (!getContinue()
            .equals(other.getContinue())) return false;
      }
      if (hasSendInitialEvents() != other.hasSendInitialEvents()) return false;
      if (hasSendInitialEvents()) {
        if (getSendInitialEvents()
            != other.getSendInitialEvents()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasLabelSelector()) {
        hash = (37 * hash) + LABELSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getLabelSelector().hashCode();
      }
      if (hasFieldSelector()) {
        hash = (37 * hash) + FIELDSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getFieldSelector().hashCode();
      }
      if (hasWatch()) {
        hash = (37 * hash) + WATCH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getWatch());
      }
      if (hasAllowWatchBookmarks()) {
        hash = (37 * hash) + ALLOWWATCHBOOKMARKS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAllowWatchBookmarks());
      }
      if (hasResourceVersion()) {
        hash = (37 * hash) + RESOURCEVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getResourceVersion().hashCode();
      }
      if (hasResourceVersionMatch()) {
        hash = (37 * hash) + RESOURCEVERSIONMATCH_FIELD_NUMBER;
        hash = (53 * hash) + getResourceVersionMatch().hashCode();
      }
      if (hasTimeoutSeconds()) {
        hash = (37 * hash) + TIMEOUTSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getTimeoutSeconds());
      }
      if (hasLimit()) {
        hash = (37 * hash) + LIMIT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getLimit());
      }
      if (hasContinue()) {
        hash = (37 * hash) + CONTINUE_FIELD_NUMBER;
        hash = (53 * hash) + getContinue().hashCode();
      }
      if (hasSendInitialEvents()) {
        hash = (37 * hash) + SENDINITIALEVENTS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSendInitialEvents());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.ListOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.ListOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ListOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.ListOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ListOptions is the query options to a standard REST list call.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions)
        io.kubernetes.client.proto.Meta.ListOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.ListOptions.class, io.kubernetes.client.proto.Meta.ListOptions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.ListOptions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        labelSelector_ = "";
        fieldSelector_ = "";
        watch_ = false;
        allowWatchBookmarks_ = false;
        resourceVersion_ = "";
        resourceVersionMatch_ = "";
        timeoutSeconds_ = 0L;
        limit_ = 0L;
        continue_ = "";
        sendInitialEvents_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ListOptions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.ListOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ListOptions build() {
        io.kubernetes.client.proto.Meta.ListOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ListOptions buildPartial() {
        io.kubernetes.client.proto.Meta.ListOptions result = new io.kubernetes.client.proto.Meta.ListOptions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.ListOptions result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.labelSelector_ = labelSelector_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.fieldSelector_ = fieldSelector_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.watch_ = watch_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.allowWatchBookmarks_ = allowWatchBookmarks_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.resourceVersion_ = resourceVersion_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.resourceVersionMatch_ = resourceVersionMatch_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.timeoutSeconds_ = timeoutSeconds_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.limit_ = limit_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.continue_ = continue_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.sendInitialEvents_ = sendInitialEvents_;
          to_bitField0_ |= 0x00000200;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.ListOptions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.ListOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.ListOptions other) {
        if (other == io.kubernetes.client.proto.Meta.ListOptions.getDefaultInstance()) return this;
        if (other.hasLabelSelector()) {
          labelSelector_ = other.labelSelector_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasFieldSelector()) {
          fieldSelector_ = other.fieldSelector_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasWatch()) {
          setWatch(other.getWatch());
        }
        if (other.hasAllowWatchBookmarks()) {
          setAllowWatchBookmarks(other.getAllowWatchBookmarks());
        }
        if (other.hasResourceVersion()) {
          resourceVersion_ = other.resourceVersion_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasResourceVersionMatch()) {
          resourceVersionMatch_ = other.resourceVersionMatch_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (other.hasTimeoutSeconds()) {
          setTimeoutSeconds(other.getTimeoutSeconds());
        }
        if (other.hasLimit()) {
          setLimit(other.getLimit());
        }
        if (other.hasContinue()) {
          continue_ = other.continue_;
          bitField0_ |= 0x00000100;
          onChanged();
        }
        if (other.hasSendInitialEvents()) {
          setSendInitialEvents(other.getSendInitialEvents());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                labelSelector_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                fieldSelector_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                watch_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                resourceVersion_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 34
              case 40: {
                timeoutSeconds_ = input.readInt64();
                bitField0_ |= 0x00000040;
                break;
              } // case 40
              case 56: {
                limit_ = input.readInt64();
                bitField0_ |= 0x00000080;
                break;
              } // case 56
              case 66: {
                continue_ = input.readBytes();
                bitField0_ |= 0x00000100;
                break;
              } // case 66
              case 72: {
                allowWatchBookmarks_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 72
              case 82: {
                resourceVersionMatch_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 82
              case 88: {
                sendInitialEvents_ = input.readBool();
                bitField0_ |= 0x00000200;
                break;
              } // case 88
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object labelSelector_ = "";
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their labels.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string labelSelector = 1;</code>
       * @return Whether the labelSelector field is set.
       */
      public boolean hasLabelSelector() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their labels.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string labelSelector = 1;</code>
       * @return The labelSelector.
       */
      public java.lang.String getLabelSelector() {
        java.lang.Object ref = labelSelector_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            labelSelector_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their labels.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string labelSelector = 1;</code>
       * @return The bytes for labelSelector.
       */
      public com.google.protobuf.ByteString
          getLabelSelectorBytes() {
        java.lang.Object ref = labelSelector_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          labelSelector_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their labels.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string labelSelector = 1;</code>
       * @param value The labelSelector to set.
       * @return This builder for chaining.
       */
      public Builder setLabelSelector(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        labelSelector_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their labels.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string labelSelector = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabelSelector() {
        labelSelector_ = getDefaultInstance().getLabelSelector();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their labels.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string labelSelector = 1;</code>
       * @param value The bytes for labelSelector to set.
       * @return This builder for chaining.
       */
      public Builder setLabelSelectorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        labelSelector_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object fieldSelector_ = "";
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their fields.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string fieldSelector = 2;</code>
       * @return Whether the fieldSelector field is set.
       */
      public boolean hasFieldSelector() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their fields.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string fieldSelector = 2;</code>
       * @return The fieldSelector.
       */
      public java.lang.String getFieldSelector() {
        java.lang.Object ref = fieldSelector_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldSelector_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their fields.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string fieldSelector = 2;</code>
       * @return The bytes for fieldSelector.
       */
      public com.google.protobuf.ByteString
          getFieldSelectorBytes() {
        java.lang.Object ref = fieldSelector_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldSelector_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their fields.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string fieldSelector = 2;</code>
       * @param value The fieldSelector to set.
       * @return This builder for chaining.
       */
      public Builder setFieldSelector(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldSelector_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their fields.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string fieldSelector = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldSelector() {
        fieldSelector_ = getDefaultInstance().getFieldSelector();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A selector to restrict the list of returned objects by their fields.
       * Defaults to everything.
       * +optional
       * </pre>
       *
       * <code>optional string fieldSelector = 2;</code>
       * @param value The bytes for fieldSelector to set.
       * @return This builder for chaining.
       */
      public Builder setFieldSelectorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldSelector_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private boolean watch_ ;
      /**
       * <pre>
       * Watch for changes to the described resources and return them as a stream of
       * add, update, and remove notifications. Specify resourceVersion.
       * +optional
       * </pre>
       *
       * <code>optional bool watch = 3;</code>
       * @return Whether the watch field is set.
       */
      @java.lang.Override
      public boolean hasWatch() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Watch for changes to the described resources and return them as a stream of
       * add, update, and remove notifications. Specify resourceVersion.
       * +optional
       * </pre>
       *
       * <code>optional bool watch = 3;</code>
       * @return The watch.
       */
      @java.lang.Override
      public boolean getWatch() {
        return watch_;
      }
      /**
       * <pre>
       * Watch for changes to the described resources and return them as a stream of
       * add, update, and remove notifications. Specify resourceVersion.
       * +optional
       * </pre>
       *
       * <code>optional bool watch = 3;</code>
       * @param value The watch to set.
       * @return This builder for chaining.
       */
      public Builder setWatch(boolean value) {

        watch_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Watch for changes to the described resources and return them as a stream of
       * add, update, and remove notifications. Specify resourceVersion.
       * +optional
       * </pre>
       *
       * <code>optional bool watch = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearWatch() {
        bitField0_ = (bitField0_ & ~0x00000004);
        watch_ = false;
        onChanged();
        return this;
      }

      private boolean allowWatchBookmarks_ ;
      /**
       * <pre>
       * allowWatchBookmarks requests watch events with type "BOOKMARK".
       * Servers that do not implement bookmarks may ignore this flag and
       * bookmarks are sent at the server's discretion. Clients should not
       * assume bookmarks are returned at any specific interval, nor may they
       * assume the server will send any BOOKMARK event during a session.
       * If this is not a watch, this field is ignored.
       * +optional
       * </pre>
       *
       * <code>optional bool allowWatchBookmarks = 9;</code>
       * @return Whether the allowWatchBookmarks field is set.
       */
      @java.lang.Override
      public boolean hasAllowWatchBookmarks() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * allowWatchBookmarks requests watch events with type "BOOKMARK".
       * Servers that do not implement bookmarks may ignore this flag and
       * bookmarks are sent at the server's discretion. Clients should not
       * assume bookmarks are returned at any specific interval, nor may they
       * assume the server will send any BOOKMARK event during a session.
       * If this is not a watch, this field is ignored.
       * +optional
       * </pre>
       *
       * <code>optional bool allowWatchBookmarks = 9;</code>
       * @return The allowWatchBookmarks.
       */
      @java.lang.Override
      public boolean getAllowWatchBookmarks() {
        return allowWatchBookmarks_;
      }
      /**
       * <pre>
       * allowWatchBookmarks requests watch events with type "BOOKMARK".
       * Servers that do not implement bookmarks may ignore this flag and
       * bookmarks are sent at the server's discretion. Clients should not
       * assume bookmarks are returned at any specific interval, nor may they
       * assume the server will send any BOOKMARK event during a session.
       * If this is not a watch, this field is ignored.
       * +optional
       * </pre>
       *
       * <code>optional bool allowWatchBookmarks = 9;</code>
       * @param value The allowWatchBookmarks to set.
       * @return This builder for chaining.
       */
      public Builder setAllowWatchBookmarks(boolean value) {

        allowWatchBookmarks_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * allowWatchBookmarks requests watch events with type "BOOKMARK".
       * Servers that do not implement bookmarks may ignore this flag and
       * bookmarks are sent at the server's discretion. Clients should not
       * assume bookmarks are returned at any specific interval, nor may they
       * assume the server will send any BOOKMARK event during a session.
       * If this is not a watch, this field is ignored.
       * +optional
       * </pre>
       *
       * <code>optional bool allowWatchBookmarks = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearAllowWatchBookmarks() {
        bitField0_ = (bitField0_ & ~0x00000008);
        allowWatchBookmarks_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object resourceVersion_ = "";
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 4;</code>
       * @return Whether the resourceVersion field is set.
       */
      public boolean hasResourceVersion() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 4;</code>
       * @return The resourceVersion.
       */
      public java.lang.String getResourceVersion() {
        java.lang.Object ref = resourceVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            resourceVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 4;</code>
       * @return The bytes for resourceVersion.
       */
      public com.google.protobuf.ByteString
          getResourceVersionBytes() {
        java.lang.Object ref = resourceVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resourceVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 4;</code>
       * @param value The resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceVersion() {
        resourceVersion_ = getDefaultInstance().getResourceVersion();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * resourceVersion sets a constraint on what resource versions a request may be served from.
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 4;</code>
       * @param value The bytes for resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object resourceVersionMatch_ = "";
      /**
       * <pre>
       * resourceVersionMatch determines how resourceVersion is applied to list calls.
       * It is highly recommended that resourceVersionMatch be set for list calls where
       * resourceVersion is set
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersionMatch = 10;</code>
       * @return Whether the resourceVersionMatch field is set.
       */
      public boolean hasResourceVersionMatch() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * resourceVersionMatch determines how resourceVersion is applied to list calls.
       * It is highly recommended that resourceVersionMatch be set for list calls where
       * resourceVersion is set
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersionMatch = 10;</code>
       * @return The resourceVersionMatch.
       */
      public java.lang.String getResourceVersionMatch() {
        java.lang.Object ref = resourceVersionMatch_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            resourceVersionMatch_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * resourceVersionMatch determines how resourceVersion is applied to list calls.
       * It is highly recommended that resourceVersionMatch be set for list calls where
       * resourceVersion is set
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersionMatch = 10;</code>
       * @return The bytes for resourceVersionMatch.
       */
      public com.google.protobuf.ByteString
          getResourceVersionMatchBytes() {
        java.lang.Object ref = resourceVersionMatch_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resourceVersionMatch_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * resourceVersionMatch determines how resourceVersion is applied to list calls.
       * It is highly recommended that resourceVersionMatch be set for list calls where
       * resourceVersion is set
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersionMatch = 10;</code>
       * @param value The resourceVersionMatch to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersionMatch(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersionMatch_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * resourceVersionMatch determines how resourceVersion is applied to list calls.
       * It is highly recommended that resourceVersionMatch be set for list calls where
       * resourceVersion is set
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersionMatch = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceVersionMatch() {
        resourceVersionMatch_ = getDefaultInstance().getResourceVersionMatch();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * resourceVersionMatch determines how resourceVersion is applied to list calls.
       * It is highly recommended that resourceVersionMatch be set for list calls where
       * resourceVersion is set
       * See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
       * details.
       *
       * Defaults to unset
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersionMatch = 10;</code>
       * @param value The bytes for resourceVersionMatch to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersionMatchBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersionMatch_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private long timeoutSeconds_ ;
      /**
       * <pre>
       * Timeout for the list/watch call.
       * This limits the duration of the call, regardless of any activity or inactivity.
       * +optional
       * </pre>
       *
       * <code>optional int64 timeoutSeconds = 5;</code>
       * @return Whether the timeoutSeconds field is set.
       */
      @java.lang.Override
      public boolean hasTimeoutSeconds() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Timeout for the list/watch call.
       * This limits the duration of the call, regardless of any activity or inactivity.
       * +optional
       * </pre>
       *
       * <code>optional int64 timeoutSeconds = 5;</code>
       * @return The timeoutSeconds.
       */
      @java.lang.Override
      public long getTimeoutSeconds() {
        return timeoutSeconds_;
      }
      /**
       * <pre>
       * Timeout for the list/watch call.
       * This limits the duration of the call, regardless of any activity or inactivity.
       * +optional
       * </pre>
       *
       * <code>optional int64 timeoutSeconds = 5;</code>
       * @param value The timeoutSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setTimeoutSeconds(long value) {

        timeoutSeconds_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timeout for the list/watch call.
       * This limits the duration of the call, regardless of any activity or inactivity.
       * +optional
       * </pre>
       *
       * <code>optional int64 timeoutSeconds = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeoutSeconds() {
        bitField0_ = (bitField0_ & ~0x00000040);
        timeoutSeconds_ = 0L;
        onChanged();
        return this;
      }

      private long limit_ ;
      /**
       * <pre>
       * limit is a maximum number of responses to return for a list call. If more items exist, the
       * server will set the `continue` field on the list metadata to a value that can be used with the
       * same initial query to retrieve the next set of results. Setting a limit may return fewer than
       * the requested amount of items (up to zero items) in the event all requested objects are
       * filtered out and clients should only use the presence of the continue field to determine whether
       * more results are available. Servers may choose not to support the limit argument and will return
       * all of the available results. If limit is specified and the continue field is empty, clients may
       * assume that no more results are available. This field is not supported if watch is true.
       *
       * The server guarantees that the objects returned when using continue will be identical to issuing
       * a single list call without a limit - that is, no objects created, modified, or deleted after the
       * first request is issued will be included in any subsequent continued requests. This is sometimes
       * referred to as a consistent snapshot, and ensures that a client that is using limit to receive
       * smaller chunks of a very large result can ensure they see all possible objects. If objects are
       * updated during a chunked list the version of the object that was present at the time the first list
       * result was calculated is returned.
       * </pre>
       *
       * <code>optional int64 limit = 7;</code>
       * @return Whether the limit field is set.
       */
      @java.lang.Override
      public boolean hasLimit() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * limit is a maximum number of responses to return for a list call. If more items exist, the
       * server will set the `continue` field on the list metadata to a value that can be used with the
       * same initial query to retrieve the next set of results. Setting a limit may return fewer than
       * the requested amount of items (up to zero items) in the event all requested objects are
       * filtered out and clients should only use the presence of the continue field to determine whether
       * more results are available. Servers may choose not to support the limit argument and will return
       * all of the available results. If limit is specified and the continue field is empty, clients may
       * assume that no more results are available. This field is not supported if watch is true.
       *
       * The server guarantees that the objects returned when using continue will be identical to issuing
       * a single list call without a limit - that is, no objects created, modified, or deleted after the
       * first request is issued will be included in any subsequent continued requests. This is sometimes
       * referred to as a consistent snapshot, and ensures that a client that is using limit to receive
       * smaller chunks of a very large result can ensure they see all possible objects. If objects are
       * updated during a chunked list the version of the object that was present at the time the first list
       * result was calculated is returned.
       * </pre>
       *
       * <code>optional int64 limit = 7;</code>
       * @return The limit.
       */
      @java.lang.Override
      public long getLimit() {
        return limit_;
      }
      /**
       * <pre>
       * limit is a maximum number of responses to return for a list call. If more items exist, the
       * server will set the `continue` field on the list metadata to a value that can be used with the
       * same initial query to retrieve the next set of results. Setting a limit may return fewer than
       * the requested amount of items (up to zero items) in the event all requested objects are
       * filtered out and clients should only use the presence of the continue field to determine whether
       * more results are available. Servers may choose not to support the limit argument and will return
       * all of the available results. If limit is specified and the continue field is empty, clients may
       * assume that no more results are available. This field is not supported if watch is true.
       *
       * The server guarantees that the objects returned when using continue will be identical to issuing
       * a single list call without a limit - that is, no objects created, modified, or deleted after the
       * first request is issued will be included in any subsequent continued requests. This is sometimes
       * referred to as a consistent snapshot, and ensures that a client that is using limit to receive
       * smaller chunks of a very large result can ensure they see all possible objects. If objects are
       * updated during a chunked list the version of the object that was present at the time the first list
       * result was calculated is returned.
       * </pre>
       *
       * <code>optional int64 limit = 7;</code>
       * @param value The limit to set.
       * @return This builder for chaining.
       */
      public Builder setLimit(long value) {

        limit_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * limit is a maximum number of responses to return for a list call. If more items exist, the
       * server will set the `continue` field on the list metadata to a value that can be used with the
       * same initial query to retrieve the next set of results. Setting a limit may return fewer than
       * the requested amount of items (up to zero items) in the event all requested objects are
       * filtered out and clients should only use the presence of the continue field to determine whether
       * more results are available. Servers may choose not to support the limit argument and will return
       * all of the available results. If limit is specified and the continue field is empty, clients may
       * assume that no more results are available. This field is not supported if watch is true.
       *
       * The server guarantees that the objects returned when using continue will be identical to issuing
       * a single list call without a limit - that is, no objects created, modified, or deleted after the
       * first request is issued will be included in any subsequent continued requests. This is sometimes
       * referred to as a consistent snapshot, and ensures that a client that is using limit to receive
       * smaller chunks of a very large result can ensure they see all possible objects. If objects are
       * updated during a chunked list the version of the object that was present at the time the first list
       * result was calculated is returned.
       * </pre>
       *
       * <code>optional int64 limit = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearLimit() {
        bitField0_ = (bitField0_ & ~0x00000080);
        limit_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object continue_ = "";
      /**
       * <pre>
       * The continue option should be set when retrieving more results from the server. Since this value is
       * server defined, clients may only use the continue value from a previous query result with identical
       * query parameters (except for the value of continue) and the server may reject a continue value it
       * does not recognize. If the specified continue value is no longer valid whether due to expiration
       * (generally five to fifteen minutes) or a configuration change on the server, the server will
       * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
       * consistent list, it must restart their list without the continue field. Otherwise, the client may
       * send another list request with the token received with the 410 error, the server will respond with
       * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
       * previous list results - objects that are created, modified, or deleted after the first list request
       * will be included in the response, as long as their keys are after the "next key".
       *
       * This field is not supported when watch is true. Clients may start a watch from the last
       * resourceVersion value returned by the server and not miss any modifications.
       * </pre>
       *
       * <code>optional string continue = 8;</code>
       * @return Whether the continue field is set.
       */
      public boolean hasContinue() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * The continue option should be set when retrieving more results from the server. Since this value is
       * server defined, clients may only use the continue value from a previous query result with identical
       * query parameters (except for the value of continue) and the server may reject a continue value it
       * does not recognize. If the specified continue value is no longer valid whether due to expiration
       * (generally five to fifteen minutes) or a configuration change on the server, the server will
       * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
       * consistent list, it must restart their list without the continue field. Otherwise, the client may
       * send another list request with the token received with the 410 error, the server will respond with
       * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
       * previous list results - objects that are created, modified, or deleted after the first list request
       * will be included in the response, as long as their keys are after the "next key".
       *
       * This field is not supported when watch is true. Clients may start a watch from the last
       * resourceVersion value returned by the server and not miss any modifications.
       * </pre>
       *
       * <code>optional string continue = 8;</code>
       * @return The continue.
       */
      public java.lang.String getContinue() {
        java.lang.Object ref = continue_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            continue_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The continue option should be set when retrieving more results from the server. Since this value is
       * server defined, clients may only use the continue value from a previous query result with identical
       * query parameters (except for the value of continue) and the server may reject a continue value it
       * does not recognize. If the specified continue value is no longer valid whether due to expiration
       * (generally five to fifteen minutes) or a configuration change on the server, the server will
       * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
       * consistent list, it must restart their list without the continue field. Otherwise, the client may
       * send another list request with the token received with the 410 error, the server will respond with
       * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
       * previous list results - objects that are created, modified, or deleted after the first list request
       * will be included in the response, as long as their keys are after the "next key".
       *
       * This field is not supported when watch is true. Clients may start a watch from the last
       * resourceVersion value returned by the server and not miss any modifications.
       * </pre>
       *
       * <code>optional string continue = 8;</code>
       * @return The bytes for continue.
       */
      public com.google.protobuf.ByteString
          getContinueBytes() {
        java.lang.Object ref = continue_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          continue_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The continue option should be set when retrieving more results from the server. Since this value is
       * server defined, clients may only use the continue value from a previous query result with identical
       * query parameters (except for the value of continue) and the server may reject a continue value it
       * does not recognize. If the specified continue value is no longer valid whether due to expiration
       * (generally five to fifteen minutes) or a configuration change on the server, the server will
       * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
       * consistent list, it must restart their list without the continue field. Otherwise, the client may
       * send another list request with the token received with the 410 error, the server will respond with
       * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
       * previous list results - objects that are created, modified, or deleted after the first list request
       * will be included in the response, as long as their keys are after the "next key".
       *
       * This field is not supported when watch is true. Clients may start a watch from the last
       * resourceVersion value returned by the server and not miss any modifications.
       * </pre>
       *
       * <code>optional string continue = 8;</code>
       * @param value The continue to set.
       * @return This builder for chaining.
       */
      public Builder setContinue(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        continue_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The continue option should be set when retrieving more results from the server. Since this value is
       * server defined, clients may only use the continue value from a previous query result with identical
       * query parameters (except for the value of continue) and the server may reject a continue value it
       * does not recognize. If the specified continue value is no longer valid whether due to expiration
       * (generally five to fifteen minutes) or a configuration change on the server, the server will
       * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
       * consistent list, it must restart their list without the continue field. Otherwise, the client may
       * send another list request with the token received with the 410 error, the server will respond with
       * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
       * previous list results - objects that are created, modified, or deleted after the first list request
       * will be included in the response, as long as their keys are after the "next key".
       *
       * This field is not supported when watch is true. Clients may start a watch from the last
       * resourceVersion value returned by the server and not miss any modifications.
       * </pre>
       *
       * <code>optional string continue = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearContinue() {
        continue_ = getDefaultInstance().getContinue();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The continue option should be set when retrieving more results from the server. Since this value is
       * server defined, clients may only use the continue value from a previous query result with identical
       * query parameters (except for the value of continue) and the server may reject a continue value it
       * does not recognize. If the specified continue value is no longer valid whether due to expiration
       * (generally five to fifteen minutes) or a configuration change on the server, the server will
       * respond with a 410 ResourceExpired error together with a continue token. If the client needs a
       * consistent list, it must restart their list without the continue field. Otherwise, the client may
       * send another list request with the token received with the 410 error, the server will respond with
       * a list starting from the next key, but from the latest snapshot, which is inconsistent from the
       * previous list results - objects that are created, modified, or deleted after the first list request
       * will be included in the response, as long as their keys are after the "next key".
       *
       * This field is not supported when watch is true. Clients may start a watch from the last
       * resourceVersion value returned by the server and not miss any modifications.
       * </pre>
       *
       * <code>optional string continue = 8;</code>
       * @param value The bytes for continue to set.
       * @return This builder for chaining.
       */
      public Builder setContinueBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        continue_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      private boolean sendInitialEvents_ ;
      /**
       * <pre>
       * `sendInitialEvents=true` may be set together with `watch=true`.
       * In that case, the watch stream will begin with synthetic events to
       * produce the current state of objects in the collection. Once all such
       * events have been sent, a synthetic "Bookmark" event  will be sent.
       * The bookmark will report the ResourceVersion (RV) corresponding to the
       * set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation.
       * Afterwards, the watch stream will proceed as usual, sending watch events
       * corresponding to changes (subsequent to the RV) to objects watched.
       *
       * When `sendInitialEvents` option is set, we require `resourceVersionMatch`
       * option to also be set. The semantic of the watch request is as following:
       * - `resourceVersionMatch` = NotOlderThan
       * is interpreted as "data at least as new as the provided `resourceVersion`"
       * and the bookmark event is send when the state is synced
       * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
       * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
       * bookmark event is send when the state is synced at least to the moment
       * when request started being processed.
       * - `resourceVersionMatch` set to any other value or unset
       * Invalid error is returned.
       *
       * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward
       * compatibility reasons) and to false otherwise.
       * +optional
       * </pre>
       *
       * <code>optional bool sendInitialEvents = 11;</code>
       * @return Whether the sendInitialEvents field is set.
       */
      @java.lang.Override
      public boolean hasSendInitialEvents() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * `sendInitialEvents=true` may be set together with `watch=true`.
       * In that case, the watch stream will begin with synthetic events to
       * produce the current state of objects in the collection. Once all such
       * events have been sent, a synthetic "Bookmark" event  will be sent.
       * The bookmark will report the ResourceVersion (RV) corresponding to the
       * set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation.
       * Afterwards, the watch stream will proceed as usual, sending watch events
       * corresponding to changes (subsequent to the RV) to objects watched.
       *
       * When `sendInitialEvents` option is set, we require `resourceVersionMatch`
       * option to also be set. The semantic of the watch request is as following:
       * - `resourceVersionMatch` = NotOlderThan
       * is interpreted as "data at least as new as the provided `resourceVersion`"
       * and the bookmark event is send when the state is synced
       * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
       * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
       * bookmark event is send when the state is synced at least to the moment
       * when request started being processed.
       * - `resourceVersionMatch` set to any other value or unset
       * Invalid error is returned.
       *
       * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward
       * compatibility reasons) and to false otherwise.
       * +optional
       * </pre>
       *
       * <code>optional bool sendInitialEvents = 11;</code>
       * @return The sendInitialEvents.
       */
      @java.lang.Override
      public boolean getSendInitialEvents() {
        return sendInitialEvents_;
      }
      /**
       * <pre>
       * `sendInitialEvents=true` may be set together with `watch=true`.
       * In that case, the watch stream will begin with synthetic events to
       * produce the current state of objects in the collection. Once all such
       * events have been sent, a synthetic "Bookmark" event  will be sent.
       * The bookmark will report the ResourceVersion (RV) corresponding to the
       * set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation.
       * Afterwards, the watch stream will proceed as usual, sending watch events
       * corresponding to changes (subsequent to the RV) to objects watched.
       *
       * When `sendInitialEvents` option is set, we require `resourceVersionMatch`
       * option to also be set. The semantic of the watch request is as following:
       * - `resourceVersionMatch` = NotOlderThan
       * is interpreted as "data at least as new as the provided `resourceVersion`"
       * and the bookmark event is send when the state is synced
       * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
       * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
       * bookmark event is send when the state is synced at least to the moment
       * when request started being processed.
       * - `resourceVersionMatch` set to any other value or unset
       * Invalid error is returned.
       *
       * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward
       * compatibility reasons) and to false otherwise.
       * +optional
       * </pre>
       *
       * <code>optional bool sendInitialEvents = 11;</code>
       * @param value The sendInitialEvents to set.
       * @return This builder for chaining.
       */
      public Builder setSendInitialEvents(boolean value) {

        sendInitialEvents_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `sendInitialEvents=true` may be set together with `watch=true`.
       * In that case, the watch stream will begin with synthetic events to
       * produce the current state of objects in the collection. Once all such
       * events have been sent, a synthetic "Bookmark" event  will be sent.
       * The bookmark will report the ResourceVersion (RV) corresponding to the
       * set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation.
       * Afterwards, the watch stream will proceed as usual, sending watch events
       * corresponding to changes (subsequent to the RV) to objects watched.
       *
       * When `sendInitialEvents` option is set, we require `resourceVersionMatch`
       * option to also be set. The semantic of the watch request is as following:
       * - `resourceVersionMatch` = NotOlderThan
       * is interpreted as "data at least as new as the provided `resourceVersion`"
       * and the bookmark event is send when the state is synced
       * to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
       * If `resourceVersion` is unset, this is interpreted as "consistent read" and the
       * bookmark event is send when the state is synced at least to the moment
       * when request started being processed.
       * - `resourceVersionMatch` set to any other value or unset
       * Invalid error is returned.
       *
       * Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward
       * compatibility reasons) and to false otherwise.
       * +optional
       * </pre>
       *
       * <code>optional bool sendInitialEvents = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearSendInitialEvents() {
        bitField0_ = (bitField0_ & ~0x00000200);
        sendInitialEvents_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions)
    private static final io.kubernetes.client.proto.Meta.ListOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.ListOptions();
    }

    public static io.kubernetes.client.proto.Meta.ListOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListOptions>
        PARSER = new com.google.protobuf.AbstractParser<ListOptions>() {
      @java.lang.Override
      public ListOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ListOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ManagedFieldsEntryOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Manager is an identifier of the workflow managing these fields.
     * </pre>
     *
     * <code>optional string manager = 1;</code>
     * @return Whether the manager field is set.
     */
    boolean hasManager();
    /**
     * <pre>
     * Manager is an identifier of the workflow managing these fields.
     * </pre>
     *
     * <code>optional string manager = 1;</code>
     * @return The manager.
     */
    java.lang.String getManager();
    /**
     * <pre>
     * Manager is an identifier of the workflow managing these fields.
     * </pre>
     *
     * <code>optional string manager = 1;</code>
     * @return The bytes for manager.
     */
    com.google.protobuf.ByteString
        getManagerBytes();

    /**
     * <pre>
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
     * The only valid values for this field are 'Apply' and 'Update'.
     * </pre>
     *
     * <code>optional string operation = 2;</code>
     * @return Whether the operation field is set.
     */
    boolean hasOperation();
    /**
     * <pre>
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
     * The only valid values for this field are 'Apply' and 'Update'.
     * </pre>
     *
     * <code>optional string operation = 2;</code>
     * @return The operation.
     */
    java.lang.String getOperation();
    /**
     * <pre>
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
     * The only valid values for this field are 'Apply' and 'Update'.
     * </pre>
     *
     * <code>optional string operation = 2;</code>
     * @return The bytes for operation.
     */
    com.google.protobuf.ByteString
        getOperationBytes();

    /**
     * <pre>
     * APIVersion defines the version of this resource that this field set
     * applies to. The format is "group/version" just like the top-level
     * APIVersion field. It is necessary to track the version of a field
     * set because it cannot be automatically converted.
     * </pre>
     *
     * <code>optional string apiVersion = 3;</code>
     * @return Whether the apiVersion field is set.
     */
    boolean hasApiVersion();
    /**
     * <pre>
     * APIVersion defines the version of this resource that this field set
     * applies to. The format is "group/version" just like the top-level
     * APIVersion field. It is necessary to track the version of a field
     * set because it cannot be automatically converted.
     * </pre>
     *
     * <code>optional string apiVersion = 3;</code>
     * @return The apiVersion.
     */
    java.lang.String getApiVersion();
    /**
     * <pre>
     * APIVersion defines the version of this resource that this field set
     * applies to. The format is "group/version" just like the top-level
     * APIVersion field. It is necessary to track the version of a field
     * set because it cannot be automatically converted.
     * </pre>
     *
     * <code>optional string apiVersion = 3;</code>
     * @return The bytes for apiVersion.
     */
    com.google.protobuf.ByteString
        getApiVersionBytes();

    /**
     * <pre>
     * Time is the timestamp of when the ManagedFields entry was added. The
     * timestamp will also be updated if a field is added, the manager
     * changes any of the owned fields value or removes a field. The
     * timestamp does not update when a field is removed from the entry
     * because another manager took it over.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
     * @return Whether the time field is set.
     */
    boolean hasTime();
    /**
     * <pre>
     * Time is the timestamp of when the ManagedFields entry was added. The
     * timestamp will also be updated if a field is added, the manager
     * changes any of the owned fields value or removes a field. The
     * timestamp does not update when a field is removed from the entry
     * because another manager took it over.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
     * @return The time.
     */
    io.kubernetes.client.proto.Meta.Time getTime();
    /**
     * <pre>
     * Time is the timestamp of when the ManagedFields entry was added. The
     * timestamp will also be updated if a field is added, the manager
     * changes any of the owned fields value or removes a field. The
     * timestamp does not update when a field is removed from the entry
     * because another manager took it over.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getTimeOrBuilder();

    /**
     * <pre>
     * FieldsType is the discriminator for the different fields format and version.
     * There is currently only one possible value: "FieldsV1"
     * </pre>
     *
     * <code>optional string fieldsType = 6;</code>
     * @return Whether the fieldsType field is set.
     */
    boolean hasFieldsType();
    /**
     * <pre>
     * FieldsType is the discriminator for the different fields format and version.
     * There is currently only one possible value: "FieldsV1"
     * </pre>
     *
     * <code>optional string fieldsType = 6;</code>
     * @return The fieldsType.
     */
    java.lang.String getFieldsType();
    /**
     * <pre>
     * FieldsType is the discriminator for the different fields format and version.
     * There is currently only one possible value: "FieldsV1"
     * </pre>
     *
     * <code>optional string fieldsType = 6;</code>
     * @return The bytes for fieldsType.
     */
    com.google.protobuf.ByteString
        getFieldsTypeBytes();

    /**
     * <pre>
     * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
     * @return Whether the fieldsV1 field is set.
     */
    boolean hasFieldsV1();
    /**
     * <pre>
     * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
     * @return The fieldsV1.
     */
    io.kubernetes.client.proto.Meta.FieldsV1 getFieldsV1();
    /**
     * <pre>
     * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
     */
    io.kubernetes.client.proto.Meta.FieldsV1OrBuilder getFieldsV1OrBuilder();

    /**
     * <pre>
     * Subresource is the name of the subresource used to update that object, or
     * empty string if the object was updated through the main resource. The
     * value of this field is used to distinguish between managers, even if they
     * share the same name. For example, a status update will be distinct from a
     * regular update using the same manager name.
     * Note that the APIVersion field is not related to the Subresource field and
     * it always corresponds to the version of the main resource.
     * </pre>
     *
     * <code>optional string subresource = 8;</code>
     * @return Whether the subresource field is set.
     */
    boolean hasSubresource();
    /**
     * <pre>
     * Subresource is the name of the subresource used to update that object, or
     * empty string if the object was updated through the main resource. The
     * value of this field is used to distinguish between managers, even if they
     * share the same name. For example, a status update will be distinct from a
     * regular update using the same manager name.
     * Note that the APIVersion field is not related to the Subresource field and
     * it always corresponds to the version of the main resource.
     * </pre>
     *
     * <code>optional string subresource = 8;</code>
     * @return The subresource.
     */
    java.lang.String getSubresource();
    /**
     * <pre>
     * Subresource is the name of the subresource used to update that object, or
     * empty string if the object was updated through the main resource. The
     * value of this field is used to distinguish between managers, even if they
     * share the same name. For example, a status update will be distinct from a
     * regular update using the same manager name.
     * Note that the APIVersion field is not related to the Subresource field and
     * it always corresponds to the version of the main resource.
     * </pre>
     *
     * <code>optional string subresource = 8;</code>
     * @return The bytes for subresource.
     */
    com.google.protobuf.ByteString
        getSubresourceBytes();
  }
  /**
   * <pre>
   * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
   * that the fieldset applies to.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry}
   */
  public static final class ManagedFieldsEntry extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry)
      ManagedFieldsEntryOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ManagedFieldsEntry.class.getName());
    }
    // Use ManagedFieldsEntry.newBuilder() to construct.
    private ManagedFieldsEntry(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ManagedFieldsEntry() {
      manager_ = "";
      operation_ = "";
      apiVersion_ = "";
      fieldsType_ = "";
      subresource_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.ManagedFieldsEntry.class, io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder.class);
    }

    private int bitField0_;
    public static final int MANAGER_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object manager_ = "";
    /**
     * <pre>
     * Manager is an identifier of the workflow managing these fields.
     * </pre>
     *
     * <code>optional string manager = 1;</code>
     * @return Whether the manager field is set.
     */
    @java.lang.Override
    public boolean hasManager() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Manager is an identifier of the workflow managing these fields.
     * </pre>
     *
     * <code>optional string manager = 1;</code>
     * @return The manager.
     */
    @java.lang.Override
    public java.lang.String getManager() {
      java.lang.Object ref = manager_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          manager_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Manager is an identifier of the workflow managing these fields.
     * </pre>
     *
     * <code>optional string manager = 1;</code>
     * @return The bytes for manager.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getManagerBytes() {
      java.lang.Object ref = manager_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        manager_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OPERATION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object operation_ = "";
    /**
     * <pre>
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
     * The only valid values for this field are 'Apply' and 'Update'.
     * </pre>
     *
     * <code>optional string operation = 2;</code>
     * @return Whether the operation field is set.
     */
    @java.lang.Override
    public boolean hasOperation() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
     * The only valid values for this field are 'Apply' and 'Update'.
     * </pre>
     *
     * <code>optional string operation = 2;</code>
     * @return The operation.
     */
    @java.lang.Override
    public java.lang.String getOperation() {
      java.lang.Object ref = operation_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          operation_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
     * The only valid values for this field are 'Apply' and 'Update'.
     * </pre>
     *
     * <code>optional string operation = 2;</code>
     * @return The bytes for operation.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOperationBytes() {
      java.lang.Object ref = operation_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        operation_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int APIVERSION_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object apiVersion_ = "";
    /**
     * <pre>
     * APIVersion defines the version of this resource that this field set
     * applies to. The format is "group/version" just like the top-level
     * APIVersion field. It is necessary to track the version of a field
     * set because it cannot be automatically converted.
     * </pre>
     *
     * <code>optional string apiVersion = 3;</code>
     * @return Whether the apiVersion field is set.
     */
    @java.lang.Override
    public boolean hasApiVersion() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * APIVersion defines the version of this resource that this field set
     * applies to. The format is "group/version" just like the top-level
     * APIVersion field. It is necessary to track the version of a field
     * set because it cannot be automatically converted.
     * </pre>
     *
     * <code>optional string apiVersion = 3;</code>
     * @return The apiVersion.
     */
    @java.lang.Override
    public java.lang.String getApiVersion() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          apiVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * APIVersion defines the version of this resource that this field set
     * applies to. The format is "group/version" just like the top-level
     * APIVersion field. It is necessary to track the version of a field
     * set because it cannot be automatically converted.
     * </pre>
     *
     * <code>optional string apiVersion = 3;</code>
     * @return The bytes for apiVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getApiVersionBytes() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        apiVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TIME_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.Meta.Time time_;
    /**
     * <pre>
     * Time is the timestamp of when the ManagedFields entry was added. The
     * timestamp will also be updated if a field is added, the manager
     * changes any of the owned fields value or removes a field. The
     * timestamp does not update when a field is removed from the entry
     * because another manager took it over.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
     * @return Whether the time field is set.
     */
    @java.lang.Override
    public boolean hasTime() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Time is the timestamp of when the ManagedFields entry was added. The
     * timestamp will also be updated if a field is added, the manager
     * changes any of the owned fields value or removes a field. The
     * timestamp does not update when a field is removed from the entry
     * because another manager took it over.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
     * @return The time.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getTime() {
      return time_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : time_;
    }
    /**
     * <pre>
     * Time is the timestamp of when the ManagedFields entry was added. The
     * timestamp will also be updated if a field is added, the manager
     * changes any of the owned fields value or removes a field. The
     * timestamp does not update when a field is removed from the entry
     * because another manager took it over.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getTimeOrBuilder() {
      return time_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : time_;
    }

    public static final int FIELDSTYPE_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldsType_ = "";
    /**
     * <pre>
     * FieldsType is the discriminator for the different fields format and version.
     * There is currently only one possible value: "FieldsV1"
     * </pre>
     *
     * <code>optional string fieldsType = 6;</code>
     * @return Whether the fieldsType field is set.
     */
    @java.lang.Override
    public boolean hasFieldsType() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * FieldsType is the discriminator for the different fields format and version.
     * There is currently only one possible value: "FieldsV1"
     * </pre>
     *
     * <code>optional string fieldsType = 6;</code>
     * @return The fieldsType.
     */
    @java.lang.Override
    public java.lang.String getFieldsType() {
      java.lang.Object ref = fieldsType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldsType_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * FieldsType is the discriminator for the different fields format and version.
     * There is currently only one possible value: "FieldsV1"
     * </pre>
     *
     * <code>optional string fieldsType = 6;</code>
     * @return The bytes for fieldsType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldsTypeBytes() {
      java.lang.Object ref = fieldsType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldsType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FIELDSV1_FIELD_NUMBER = 7;
    private io.kubernetes.client.proto.Meta.FieldsV1 fieldsV1_;
    /**
     * <pre>
     * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
     * @return Whether the fieldsV1 field is set.
     */
    @java.lang.Override
    public boolean hasFieldsV1() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
     * @return The fieldsV1.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.FieldsV1 getFieldsV1() {
      return fieldsV1_ == null ? io.kubernetes.client.proto.Meta.FieldsV1.getDefaultInstance() : fieldsV1_;
    }
    /**
     * <pre>
     * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.FieldsV1OrBuilder getFieldsV1OrBuilder() {
      return fieldsV1_ == null ? io.kubernetes.client.proto.Meta.FieldsV1.getDefaultInstance() : fieldsV1_;
    }

    public static final int SUBRESOURCE_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object subresource_ = "";
    /**
     * <pre>
     * Subresource is the name of the subresource used to update that object, or
     * empty string if the object was updated through the main resource. The
     * value of this field is used to distinguish between managers, even if they
     * share the same name. For example, a status update will be distinct from a
     * regular update using the same manager name.
     * Note that the APIVersion field is not related to the Subresource field and
     * it always corresponds to the version of the main resource.
     * </pre>
     *
     * <code>optional string subresource = 8;</code>
     * @return Whether the subresource field is set.
     */
    @java.lang.Override
    public boolean hasSubresource() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Subresource is the name of the subresource used to update that object, or
     * empty string if the object was updated through the main resource. The
     * value of this field is used to distinguish between managers, even if they
     * share the same name. For example, a status update will be distinct from a
     * regular update using the same manager name.
     * Note that the APIVersion field is not related to the Subresource field and
     * it always corresponds to the version of the main resource.
     * </pre>
     *
     * <code>optional string subresource = 8;</code>
     * @return The subresource.
     */
    @java.lang.Override
    public java.lang.String getSubresource() {
      java.lang.Object ref = subresource_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          subresource_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Subresource is the name of the subresource used to update that object, or
     * empty string if the object was updated through the main resource. The
     * value of this field is used to distinguish between managers, even if they
     * share the same name. For example, a status update will be distinct from a
     * regular update using the same manager name.
     * Note that the APIVersion field is not related to the Subresource field and
     * it always corresponds to the version of the main resource.
     * </pre>
     *
     * <code>optional string subresource = 8;</code>
     * @return The bytes for subresource.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSubresourceBytes() {
      java.lang.Object ref = subresource_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        subresource_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, manager_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, operation_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, apiVersion_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getTime());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, fieldsType_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(7, getFieldsV1());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, subresource_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, manager_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, operation_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, apiVersion_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getTime());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, fieldsType_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getFieldsV1());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, subresource_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.ManagedFieldsEntry)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.ManagedFieldsEntry other = (io.kubernetes.client.proto.Meta.ManagedFieldsEntry) obj;

      if (hasManager() != other.hasManager()) return false;
      if (hasManager()) {
        if (!getManager()
            .equals(other.getManager())) return false;
      }
      if (hasOperation() != other.hasOperation()) return false;
      if (hasOperation()) {
        if (!getOperation()
            .equals(other.getOperation())) return false;
      }
      if (hasApiVersion() != other.hasApiVersion()) return false;
      if (hasApiVersion()) {
        if (!getApiVersion()
            .equals(other.getApiVersion())) return false;
      }
      if (hasTime() != other.hasTime()) return false;
      if (hasTime()) {
        if (!getTime()
            .equals(other.getTime())) return false;
      }
      if (hasFieldsType() != other.hasFieldsType()) return false;
      if (hasFieldsType()) {
        if (!getFieldsType()
            .equals(other.getFieldsType())) return false;
      }
      if (hasFieldsV1() != other.hasFieldsV1()) return false;
      if (hasFieldsV1()) {
        if (!getFieldsV1()
            .equals(other.getFieldsV1())) return false;
      }
      if (hasSubresource() != other.hasSubresource()) return false;
      if (hasSubresource()) {
        if (!getSubresource()
            .equals(other.getSubresource())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasManager()) {
        hash = (37 * hash) + MANAGER_FIELD_NUMBER;
        hash = (53 * hash) + getManager().hashCode();
      }
      if (hasOperation()) {
        hash = (37 * hash) + OPERATION_FIELD_NUMBER;
        hash = (53 * hash) + getOperation().hashCode();
      }
      if (hasApiVersion()) {
        hash = (37 * hash) + APIVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getApiVersion().hashCode();
      }
      if (hasTime()) {
        hash = (37 * hash) + TIME_FIELD_NUMBER;
        hash = (53 * hash) + getTime().hashCode();
      }
      if (hasFieldsType()) {
        hash = (37 * hash) + FIELDSTYPE_FIELD_NUMBER;
        hash = (53 * hash) + getFieldsType().hashCode();
      }
      if (hasFieldsV1()) {
        hash = (37 * hash) + FIELDSV1_FIELD_NUMBER;
        hash = (53 * hash) + getFieldsV1().hashCode();
      }
      if (hasSubresource()) {
        hash = (37 * hash) + SUBRESOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getSubresource().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.ManagedFieldsEntry prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
     * that the fieldset applies to.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry)
        io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.ManagedFieldsEntry.class, io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.ManagedFieldsEntry.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getTimeFieldBuilder();
          getFieldsV1FieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        manager_ = "";
        operation_ = "";
        apiVersion_ = "";
        time_ = null;
        if (timeBuilder_ != null) {
          timeBuilder_.dispose();
          timeBuilder_ = null;
        }
        fieldsType_ = "";
        fieldsV1_ = null;
        if (fieldsV1Builder_ != null) {
          fieldsV1Builder_.dispose();
          fieldsV1Builder_ = null;
        }
        subresource_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ManagedFieldsEntry getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.ManagedFieldsEntry.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ManagedFieldsEntry build() {
        io.kubernetes.client.proto.Meta.ManagedFieldsEntry result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ManagedFieldsEntry buildPartial() {
        io.kubernetes.client.proto.Meta.ManagedFieldsEntry result = new io.kubernetes.client.proto.Meta.ManagedFieldsEntry(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.ManagedFieldsEntry result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.manager_ = manager_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.operation_ = operation_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.apiVersion_ = apiVersion_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.time_ = timeBuilder_ == null
              ? time_
              : timeBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.fieldsType_ = fieldsType_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.fieldsV1_ = fieldsV1Builder_ == null
              ? fieldsV1_
              : fieldsV1Builder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.subresource_ = subresource_;
          to_bitField0_ |= 0x00000040;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.ManagedFieldsEntry) {
          return mergeFrom((io.kubernetes.client.proto.Meta.ManagedFieldsEntry)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.ManagedFieldsEntry other) {
        if (other == io.kubernetes.client.proto.Meta.ManagedFieldsEntry.getDefaultInstance()) return this;
        if (other.hasManager()) {
          manager_ = other.manager_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasOperation()) {
          operation_ = other.operation_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasApiVersion()) {
          apiVersion_ = other.apiVersion_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasTime()) {
          mergeTime(other.getTime());
        }
        if (other.hasFieldsType()) {
          fieldsType_ = other.fieldsType_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasFieldsV1()) {
          mergeFieldsV1(other.getFieldsV1());
        }
        if (other.hasSubresource()) {
          subresource_ = other.subresource_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                manager_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                operation_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                apiVersion_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getTimeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 50: {
                fieldsType_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    getFieldsV1FieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 58
              case 66: {
                subresource_ = input.readBytes();
                bitField0_ |= 0x00000040;
                break;
              } // case 66
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object manager_ = "";
      /**
       * <pre>
       * Manager is an identifier of the workflow managing these fields.
       * </pre>
       *
       * <code>optional string manager = 1;</code>
       * @return Whether the manager field is set.
       */
      public boolean hasManager() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Manager is an identifier of the workflow managing these fields.
       * </pre>
       *
       * <code>optional string manager = 1;</code>
       * @return The manager.
       */
      public java.lang.String getManager() {
        java.lang.Object ref = manager_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            manager_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Manager is an identifier of the workflow managing these fields.
       * </pre>
       *
       * <code>optional string manager = 1;</code>
       * @return The bytes for manager.
       */
      public com.google.protobuf.ByteString
          getManagerBytes() {
        java.lang.Object ref = manager_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          manager_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Manager is an identifier of the workflow managing these fields.
       * </pre>
       *
       * <code>optional string manager = 1;</code>
       * @param value The manager to set.
       * @return This builder for chaining.
       */
      public Builder setManager(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        manager_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Manager is an identifier of the workflow managing these fields.
       * </pre>
       *
       * <code>optional string manager = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearManager() {
        manager_ = getDefaultInstance().getManager();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Manager is an identifier of the workflow managing these fields.
       * </pre>
       *
       * <code>optional string manager = 1;</code>
       * @param value The bytes for manager to set.
       * @return This builder for chaining.
       */
      public Builder setManagerBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        manager_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object operation_ = "";
      /**
       * <pre>
       * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
       * The only valid values for this field are 'Apply' and 'Update'.
       * </pre>
       *
       * <code>optional string operation = 2;</code>
       * @return Whether the operation field is set.
       */
      public boolean hasOperation() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
       * The only valid values for this field are 'Apply' and 'Update'.
       * </pre>
       *
       * <code>optional string operation = 2;</code>
       * @return The operation.
       */
      public java.lang.String getOperation() {
        java.lang.Object ref = operation_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            operation_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
       * The only valid values for this field are 'Apply' and 'Update'.
       * </pre>
       *
       * <code>optional string operation = 2;</code>
       * @return The bytes for operation.
       */
      public com.google.protobuf.ByteString
          getOperationBytes() {
        java.lang.Object ref = operation_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          operation_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
       * The only valid values for this field are 'Apply' and 'Update'.
       * </pre>
       *
       * <code>optional string operation = 2;</code>
       * @param value The operation to set.
       * @return This builder for chaining.
       */
      public Builder setOperation(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        operation_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
       * The only valid values for this field are 'Apply' and 'Update'.
       * </pre>
       *
       * <code>optional string operation = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearOperation() {
        operation_ = getDefaultInstance().getOperation();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
       * The only valid values for this field are 'Apply' and 'Update'.
       * </pre>
       *
       * <code>optional string operation = 2;</code>
       * @param value The bytes for operation to set.
       * @return This builder for chaining.
       */
      public Builder setOperationBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        operation_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object apiVersion_ = "";
      /**
       * <pre>
       * APIVersion defines the version of this resource that this field set
       * applies to. The format is "group/version" just like the top-level
       * APIVersion field. It is necessary to track the version of a field
       * set because it cannot be automatically converted.
       * </pre>
       *
       * <code>optional string apiVersion = 3;</code>
       * @return Whether the apiVersion field is set.
       */
      public boolean hasApiVersion() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * APIVersion defines the version of this resource that this field set
       * applies to. The format is "group/version" just like the top-level
       * APIVersion field. It is necessary to track the version of a field
       * set because it cannot be automatically converted.
       * </pre>
       *
       * <code>optional string apiVersion = 3;</code>
       * @return The apiVersion.
       */
      public java.lang.String getApiVersion() {
        java.lang.Object ref = apiVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            apiVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * APIVersion defines the version of this resource that this field set
       * applies to. The format is "group/version" just like the top-level
       * APIVersion field. It is necessary to track the version of a field
       * set because it cannot be automatically converted.
       * </pre>
       *
       * <code>optional string apiVersion = 3;</code>
       * @return The bytes for apiVersion.
       */
      public com.google.protobuf.ByteString
          getApiVersionBytes() {
        java.lang.Object ref = apiVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          apiVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * APIVersion defines the version of this resource that this field set
       * applies to. The format is "group/version" just like the top-level
       * APIVersion field. It is necessary to track the version of a field
       * set because it cannot be automatically converted.
       * </pre>
       *
       * <code>optional string apiVersion = 3;</code>
       * @param value The apiVersion to set.
       * @return This builder for chaining.
       */
      public Builder setApiVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        apiVersion_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion defines the version of this resource that this field set
       * applies to. The format is "group/version" just like the top-level
       * APIVersion field. It is necessary to track the version of a field
       * set because it cannot be automatically converted.
       * </pre>
       *
       * <code>optional string apiVersion = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearApiVersion() {
        apiVersion_ = getDefaultInstance().getApiVersion();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion defines the version of this resource that this field set
       * applies to. The format is "group/version" just like the top-level
       * APIVersion field. It is necessary to track the version of a field
       * set because it cannot be automatically converted.
       * </pre>
       *
       * <code>optional string apiVersion = 3;</code>
       * @param value The bytes for apiVersion to set.
       * @return This builder for chaining.
       */
      public Builder setApiVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        apiVersion_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time time_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> timeBuilder_;
      /**
       * <pre>
       * Time is the timestamp of when the ManagedFields entry was added. The
       * timestamp will also be updated if a field is added, the manager
       * changes any of the owned fields value or removes a field. The
       * timestamp does not update when a field is removed from the entry
       * because another manager took it over.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
       * @return Whether the time field is set.
       */
      public boolean hasTime() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Time is the timestamp of when the ManagedFields entry was added. The
       * timestamp will also be updated if a field is added, the manager
       * changes any of the owned fields value or removes a field. The
       * timestamp does not update when a field is removed from the entry
       * because another manager took it over.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
       * @return The time.
       */
      public io.kubernetes.client.proto.Meta.Time getTime() {
        if (timeBuilder_ == null) {
          return time_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : time_;
        } else {
          return timeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Time is the timestamp of when the ManagedFields entry was added. The
       * timestamp will also be updated if a field is added, the manager
       * changes any of the owned fields value or removes a field. The
       * timestamp does not update when a field is removed from the entry
       * because another manager took it over.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
       */
      public Builder setTime(io.kubernetes.client.proto.Meta.Time value) {
        if (timeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          time_ = value;
        } else {
          timeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Time is the timestamp of when the ManagedFields entry was added. The
       * timestamp will also be updated if a field is added, the manager
       * changes any of the owned fields value or removes a field. The
       * timestamp does not update when a field is removed from the entry
       * because another manager took it over.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
       */
      public Builder setTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (timeBuilder_ == null) {
          time_ = builderForValue.build();
        } else {
          timeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Time is the timestamp of when the ManagedFields entry was added. The
       * timestamp will also be updated if a field is added, the manager
       * changes any of the owned fields value or removes a field. The
       * timestamp does not update when a field is removed from the entry
       * because another manager took it over.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
       */
      public Builder mergeTime(io.kubernetes.client.proto.Meta.Time value) {
        if (timeBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            time_ != null &&
            time_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getTimeBuilder().mergeFrom(value);
          } else {
            time_ = value;
          }
        } else {
          timeBuilder_.mergeFrom(value);
        }
        if (time_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Time is the timestamp of when the ManagedFields entry was added. The
       * timestamp will also be updated if a field is added, the manager
       * changes any of the owned fields value or removes a field. The
       * timestamp does not update when a field is removed from the entry
       * because another manager took it over.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
       */
      public Builder clearTime() {
        bitField0_ = (bitField0_ & ~0x00000008);
        time_ = null;
        if (timeBuilder_ != null) {
          timeBuilder_.dispose();
          timeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Time is the timestamp of when the ManagedFields entry was added. The
       * timestamp will also be updated if a field is added, the manager
       * changes any of the owned fields value or removes a field. The
       * timestamp does not update when a field is removed from the entry
       * because another manager took it over.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getTimeBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Time is the timestamp of when the ManagedFields entry was added. The
       * timestamp will also be updated if a field is added, the manager
       * changes any of the owned fields value or removes a field. The
       * timestamp does not update when a field is removed from the entry
       * because another manager took it over.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getTimeOrBuilder() {
        if (timeBuilder_ != null) {
          return timeBuilder_.getMessageOrBuilder();
        } else {
          return time_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : time_;
        }
      }
      /**
       * <pre>
       * Time is the timestamp of when the ManagedFields entry was added. The
       * timestamp will also be updated if a field is added, the manager
       * changes any of the owned fields value or removes a field. The
       * timestamp does not update when a field is removed from the entry
       * because another manager took it over.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getTimeFieldBuilder() {
        if (timeBuilder_ == null) {
          timeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getTime(),
                  getParentForChildren(),
                  isClean());
          time_ = null;
        }
        return timeBuilder_;
      }

      private java.lang.Object fieldsType_ = "";
      /**
       * <pre>
       * FieldsType is the discriminator for the different fields format and version.
       * There is currently only one possible value: "FieldsV1"
       * </pre>
       *
       * <code>optional string fieldsType = 6;</code>
       * @return Whether the fieldsType field is set.
       */
      public boolean hasFieldsType() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * FieldsType is the discriminator for the different fields format and version.
       * There is currently only one possible value: "FieldsV1"
       * </pre>
       *
       * <code>optional string fieldsType = 6;</code>
       * @return The fieldsType.
       */
      public java.lang.String getFieldsType() {
        java.lang.Object ref = fieldsType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldsType_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * FieldsType is the discriminator for the different fields format and version.
       * There is currently only one possible value: "FieldsV1"
       * </pre>
       *
       * <code>optional string fieldsType = 6;</code>
       * @return The bytes for fieldsType.
       */
      public com.google.protobuf.ByteString
          getFieldsTypeBytes() {
        java.lang.Object ref = fieldsType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldsType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * FieldsType is the discriminator for the different fields format and version.
       * There is currently only one possible value: "FieldsV1"
       * </pre>
       *
       * <code>optional string fieldsType = 6;</code>
       * @param value The fieldsType to set.
       * @return This builder for chaining.
       */
      public Builder setFieldsType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldsType_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FieldsType is the discriminator for the different fields format and version.
       * There is currently only one possible value: "FieldsV1"
       * </pre>
       *
       * <code>optional string fieldsType = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldsType() {
        fieldsType_ = getDefaultInstance().getFieldsType();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FieldsType is the discriminator for the different fields format and version.
       * There is currently only one possible value: "FieldsV1"
       * </pre>
       *
       * <code>optional string fieldsType = 6;</code>
       * @param value The bytes for fieldsType to set.
       * @return This builder for chaining.
       */
      public Builder setFieldsTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldsType_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.FieldsV1 fieldsV1_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.FieldsV1, io.kubernetes.client.proto.Meta.FieldsV1.Builder, io.kubernetes.client.proto.Meta.FieldsV1OrBuilder> fieldsV1Builder_;
      /**
       * <pre>
       * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
       * @return Whether the fieldsV1 field is set.
       */
      public boolean hasFieldsV1() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
       * @return The fieldsV1.
       */
      public io.kubernetes.client.proto.Meta.FieldsV1 getFieldsV1() {
        if (fieldsV1Builder_ == null) {
          return fieldsV1_ == null ? io.kubernetes.client.proto.Meta.FieldsV1.getDefaultInstance() : fieldsV1_;
        } else {
          return fieldsV1Builder_.getMessage();
        }
      }
      /**
       * <pre>
       * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
       */
      public Builder setFieldsV1(io.kubernetes.client.proto.Meta.FieldsV1 value) {
        if (fieldsV1Builder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          fieldsV1_ = value;
        } else {
          fieldsV1Builder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
       */
      public Builder setFieldsV1(
          io.kubernetes.client.proto.Meta.FieldsV1.Builder builderForValue) {
        if (fieldsV1Builder_ == null) {
          fieldsV1_ = builderForValue.build();
        } else {
          fieldsV1Builder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
       */
      public Builder mergeFieldsV1(io.kubernetes.client.proto.Meta.FieldsV1 value) {
        if (fieldsV1Builder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            fieldsV1_ != null &&
            fieldsV1_ != io.kubernetes.client.proto.Meta.FieldsV1.getDefaultInstance()) {
            getFieldsV1Builder().mergeFrom(value);
          } else {
            fieldsV1_ = value;
          }
        } else {
          fieldsV1Builder_.mergeFrom(value);
        }
        if (fieldsV1_ != null) {
          bitField0_ |= 0x00000020;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
       */
      public Builder clearFieldsV1() {
        bitField0_ = (bitField0_ & ~0x00000020);
        fieldsV1_ = null;
        if (fieldsV1Builder_ != null) {
          fieldsV1Builder_.dispose();
          fieldsV1Builder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
       */
      public io.kubernetes.client.proto.Meta.FieldsV1.Builder getFieldsV1Builder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getFieldsV1FieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
       */
      public io.kubernetes.client.proto.Meta.FieldsV1OrBuilder getFieldsV1OrBuilder() {
        if (fieldsV1Builder_ != null) {
          return fieldsV1Builder_.getMessageOrBuilder();
        } else {
          return fieldsV1_ == null ?
              io.kubernetes.client.proto.Meta.FieldsV1.getDefaultInstance() : fieldsV1_;
        }
      }
      /**
       * <pre>
       * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.FieldsV1, io.kubernetes.client.proto.Meta.FieldsV1.Builder, io.kubernetes.client.proto.Meta.FieldsV1OrBuilder> 
          getFieldsV1FieldBuilder() {
        if (fieldsV1Builder_ == null) {
          fieldsV1Builder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.FieldsV1, io.kubernetes.client.proto.Meta.FieldsV1.Builder, io.kubernetes.client.proto.Meta.FieldsV1OrBuilder>(
                  getFieldsV1(),
                  getParentForChildren(),
                  isClean());
          fieldsV1_ = null;
        }
        return fieldsV1Builder_;
      }

      private java.lang.Object subresource_ = "";
      /**
       * <pre>
       * Subresource is the name of the subresource used to update that object, or
       * empty string if the object was updated through the main resource. The
       * value of this field is used to distinguish between managers, even if they
       * share the same name. For example, a status update will be distinct from a
       * regular update using the same manager name.
       * Note that the APIVersion field is not related to the Subresource field and
       * it always corresponds to the version of the main resource.
       * </pre>
       *
       * <code>optional string subresource = 8;</code>
       * @return Whether the subresource field is set.
       */
      public boolean hasSubresource() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Subresource is the name of the subresource used to update that object, or
       * empty string if the object was updated through the main resource. The
       * value of this field is used to distinguish between managers, even if they
       * share the same name. For example, a status update will be distinct from a
       * regular update using the same manager name.
       * Note that the APIVersion field is not related to the Subresource field and
       * it always corresponds to the version of the main resource.
       * </pre>
       *
       * <code>optional string subresource = 8;</code>
       * @return The subresource.
       */
      public java.lang.String getSubresource() {
        java.lang.Object ref = subresource_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            subresource_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Subresource is the name of the subresource used to update that object, or
       * empty string if the object was updated through the main resource. The
       * value of this field is used to distinguish between managers, even if they
       * share the same name. For example, a status update will be distinct from a
       * regular update using the same manager name.
       * Note that the APIVersion field is not related to the Subresource field and
       * it always corresponds to the version of the main resource.
       * </pre>
       *
       * <code>optional string subresource = 8;</code>
       * @return The bytes for subresource.
       */
      public com.google.protobuf.ByteString
          getSubresourceBytes() {
        java.lang.Object ref = subresource_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          subresource_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Subresource is the name of the subresource used to update that object, or
       * empty string if the object was updated through the main resource. The
       * value of this field is used to distinguish between managers, even if they
       * share the same name. For example, a status update will be distinct from a
       * regular update using the same manager name.
       * Note that the APIVersion field is not related to the Subresource field and
       * it always corresponds to the version of the main resource.
       * </pre>
       *
       * <code>optional string subresource = 8;</code>
       * @param value The subresource to set.
       * @return This builder for chaining.
       */
      public Builder setSubresource(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        subresource_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Subresource is the name of the subresource used to update that object, or
       * empty string if the object was updated through the main resource. The
       * value of this field is used to distinguish between managers, even if they
       * share the same name. For example, a status update will be distinct from a
       * regular update using the same manager name.
       * Note that the APIVersion field is not related to the Subresource field and
       * it always corresponds to the version of the main resource.
       * </pre>
       *
       * <code>optional string subresource = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSubresource() {
        subresource_ = getDefaultInstance().getSubresource();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Subresource is the name of the subresource used to update that object, or
       * empty string if the object was updated through the main resource. The
       * value of this field is used to distinguish between managers, even if they
       * share the same name. For example, a status update will be distinct from a
       * regular update using the same manager name.
       * Note that the APIVersion field is not related to the Subresource field and
       * it always corresponds to the version of the main resource.
       * </pre>
       *
       * <code>optional string subresource = 8;</code>
       * @param value The bytes for subresource to set.
       * @return This builder for chaining.
       */
      public Builder setSubresourceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        subresource_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry)
    private static final io.kubernetes.client.proto.Meta.ManagedFieldsEntry DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.ManagedFieldsEntry();
    }

    public static io.kubernetes.client.proto.Meta.ManagedFieldsEntry getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ManagedFieldsEntry>
        PARSER = new com.google.protobuf.AbstractParser<ManagedFieldsEntry>() {
      @java.lang.Override
      public ManagedFieldsEntry parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ManagedFieldsEntry> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ManagedFieldsEntry> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ManagedFieldsEntry getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MicroTimeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return Whether the seconds field is set.
     */
    boolean hasSeconds();
    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return The seconds.
     */
    long getSeconds();

    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return Whether the nanos field is set.
     */
    boolean hasNanos();
    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return The nanos.
     */
    int getNanos();
  }
  /**
   * <pre>
   * MicroTime is version of Time with microsecond level precision.
   *
   * +protobuf.options.marshal=false
   * +protobuf.as=Timestamp
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime}
   */
  public static final class MicroTime extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime)
      MicroTimeOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        MicroTime.class.getName());
    }
    // Use MicroTime.newBuilder() to construct.
    private MicroTime(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private MicroTime() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.MicroTime.class, io.kubernetes.client.proto.Meta.MicroTime.Builder.class);
    }

    private int bitField0_;
    public static final int SECONDS_FIELD_NUMBER = 1;
    private long seconds_ = 0L;
    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return Whether the seconds field is set.
     */
    @java.lang.Override
    public boolean hasSeconds() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return The seconds.
     */
    @java.lang.Override
    public long getSeconds() {
      return seconds_;
    }

    public static final int NANOS_FIELD_NUMBER = 2;
    private int nanos_ = 0;
    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return Whether the nanos field is set.
     */
    @java.lang.Override
    public boolean hasNanos() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return The nanos.
     */
    @java.lang.Override
    public int getNanos() {
      return nanos_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, seconds_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, nanos_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, seconds_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, nanos_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.MicroTime)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.MicroTime other = (io.kubernetes.client.proto.Meta.MicroTime) obj;

      if (hasSeconds() != other.hasSeconds()) return false;
      if (hasSeconds()) {
        if (getSeconds()
            != other.getSeconds()) return false;
      }
      if (hasNanos() != other.hasNanos()) return false;
      if (hasNanos()) {
        if (getNanos()
            != other.getNanos()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSeconds()) {
        hash = (37 * hash) + SECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSeconds());
      }
      if (hasNanos()) {
        hash = (37 * hash) + NANOS_FIELD_NUMBER;
        hash = (53 * hash) + getNanos();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.MicroTime parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.MicroTime parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.MicroTime parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.MicroTime prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MicroTime is version of Time with microsecond level precision.
     *
     * +protobuf.options.marshal=false
     * +protobuf.as=Timestamp
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime)
        io.kubernetes.client.proto.Meta.MicroTimeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.MicroTime.class, io.kubernetes.client.proto.Meta.MicroTime.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.MicroTime.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        seconds_ = 0L;
        nanos_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.MicroTime getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.MicroTime.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.MicroTime build() {
        io.kubernetes.client.proto.Meta.MicroTime result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.MicroTime buildPartial() {
        io.kubernetes.client.proto.Meta.MicroTime result = new io.kubernetes.client.proto.Meta.MicroTime(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.MicroTime result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.seconds_ = seconds_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.nanos_ = nanos_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.MicroTime) {
          return mergeFrom((io.kubernetes.client.proto.Meta.MicroTime)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.MicroTime other) {
        if (other == io.kubernetes.client.proto.Meta.MicroTime.getDefaultInstance()) return this;
        if (other.hasSeconds()) {
          setSeconds(other.getSeconds());
        }
        if (other.hasNanos()) {
          setNanos(other.getNanos());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                seconds_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                nanos_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long seconds_ ;
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @return Whether the seconds field is set.
       */
      @java.lang.Override
      public boolean hasSeconds() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @return The seconds.
       */
      @java.lang.Override
      public long getSeconds() {
        return seconds_;
      }
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @param value The seconds to set.
       * @return This builder for chaining.
       */
      public Builder setSeconds(long value) {

        seconds_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSeconds() {
        bitField0_ = (bitField0_ & ~0x00000001);
        seconds_ = 0L;
        onChanged();
        return this;
      }

      private int nanos_ ;
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @return Whether the nanos field is set.
       */
      @java.lang.Override
      public boolean hasNanos() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @return The nanos.
       */
      @java.lang.Override
      public int getNanos() {
        return nanos_;
      }
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @param value The nanos to set.
       * @return This builder for chaining.
       */
      public Builder setNanos(int value) {

        nanos_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNanos() {
        bitField0_ = (bitField0_ & ~0x00000002);
        nanos_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime)
    private static final io.kubernetes.client.proto.Meta.MicroTime DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.MicroTime();
    }

    public static io.kubernetes.client.proto.Meta.MicroTime getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MicroTime>
        PARSER = new com.google.protobuf.AbstractParser<MicroTime>() {
      @java.lang.Override
      public MicroTime parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MicroTime> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MicroTime> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.MicroTime getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ObjectMetaOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * GenerateName is an optional prefix, used by the server, to generate a unique
     * name ONLY IF the Name field has not been provided.
     * If this field is used, the name returned to the client will be different
     * than the name passed. This value will also be combined with a unique suffix.
     * The provided value has the same validation rules as the Name field,
     * and may be truncated by the length of the suffix required to make the value
     * unique on the server.
     *
     * If this field is specified and the generated name exists, the server will return a 409.
     *
     * Applied only if Name is not specified.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
     * +optional
     * </pre>
     *
     * <code>optional string generateName = 2;</code>
     * @return Whether the generateName field is set.
     */
    boolean hasGenerateName();
    /**
     * <pre>
     * GenerateName is an optional prefix, used by the server, to generate a unique
     * name ONLY IF the Name field has not been provided.
     * If this field is used, the name returned to the client will be different
     * than the name passed. This value will also be combined with a unique suffix.
     * The provided value has the same validation rules as the Name field,
     * and may be truncated by the length of the suffix required to make the value
     * unique on the server.
     *
     * If this field is specified and the generated name exists, the server will return a 409.
     *
     * Applied only if Name is not specified.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
     * +optional
     * </pre>
     *
     * <code>optional string generateName = 2;</code>
     * @return The generateName.
     */
    java.lang.String getGenerateName();
    /**
     * <pre>
     * GenerateName is an optional prefix, used by the server, to generate a unique
     * name ONLY IF the Name field has not been provided.
     * If this field is used, the name returned to the client will be different
     * than the name passed. This value will also be combined with a unique suffix.
     * The provided value has the same validation rules as the Name field,
     * and may be truncated by the length of the suffix required to make the value
     * unique on the server.
     *
     * If this field is specified and the generated name exists, the server will return a 409.
     *
     * Applied only if Name is not specified.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
     * +optional
     * </pre>
     *
     * <code>optional string generateName = 2;</code>
     * @return The bytes for generateName.
     */
    com.google.protobuf.ByteString
        getGenerateNameBytes();

    /**
     * <pre>
     * Namespace defines the space within which each name must be unique. An empty namespace is
     * equivalent to the "default" namespace, but "default" is the canonical representation.
     * Not all objects are required to be scoped to a namespace - the value of this field for
     * those objects will be empty.
     *
     * Must be a DNS_LABEL.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 3;</code>
     * @return Whether the namespace field is set.
     */
    boolean hasNamespace();
    /**
     * <pre>
     * Namespace defines the space within which each name must be unique. An empty namespace is
     * equivalent to the "default" namespace, but "default" is the canonical representation.
     * Not all objects are required to be scoped to a namespace - the value of this field for
     * those objects will be empty.
     *
     * Must be a DNS_LABEL.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 3;</code>
     * @return The namespace.
     */
    java.lang.String getNamespace();
    /**
     * <pre>
     * Namespace defines the space within which each name must be unique. An empty namespace is
     * equivalent to the "default" namespace, but "default" is the canonical representation.
     * Not all objects are required to be scoped to a namespace - the value of this field for
     * those objects will be empty.
     *
     * Must be a DNS_LABEL.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 3;</code>
     * @return The bytes for namespace.
     */
    com.google.protobuf.ByteString
        getNamespaceBytes();

    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 4;</code>
     * @return Whether the selfLink field is set.
     */
    boolean hasSelfLink();
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 4;</code>
     * @return The selfLink.
     */
    java.lang.String getSelfLink();
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 4;</code>
     * @return The bytes for selfLink.
     */
    com.google.protobuf.ByteString
        getSelfLinkBytes();

    /**
     * <pre>
     * UID is the unique in time and space value for this object. It is typically generated by
     * the server on successful creation of a resource and is not allowed to change on PUT
     * operations.
     *
     * Populated by the system.
     * Read-only.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 5;</code>
     * @return Whether the uid field is set.
     */
    boolean hasUid();
    /**
     * <pre>
     * UID is the unique in time and space value for this object. It is typically generated by
     * the server on successful creation of a resource and is not allowed to change on PUT
     * operations.
     *
     * Populated by the system.
     * Read-only.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 5;</code>
     * @return The uid.
     */
    java.lang.String getUid();
    /**
     * <pre>
     * UID is the unique in time and space value for this object. It is typically generated by
     * the server on successful creation of a resource and is not allowed to change on PUT
     * operations.
     *
     * Populated by the system.
     * Read-only.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 5;</code>
     * @return The bytes for uid.
     */
    com.google.protobuf.ByteString
        getUidBytes();

    /**
     * <pre>
     * An opaque value that represents the internal version of this object that can
     * be used by clients to determine when objects have changed. May be used for optimistic
     * concurrency, change detection, and the watch operation on a resource or set of resources.
     * Clients must treat these values as opaque and passed unmodified back to the server.
     * They may only be valid for a particular resource or set of resources.
     *
     * Populated by the system.
     * Read-only.
     * Value must be treated as opaque by clients and .
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 6;</code>
     * @return Whether the resourceVersion field is set.
     */
    boolean hasResourceVersion();
    /**
     * <pre>
     * An opaque value that represents the internal version of this object that can
     * be used by clients to determine when objects have changed. May be used for optimistic
     * concurrency, change detection, and the watch operation on a resource or set of resources.
     * Clients must treat these values as opaque and passed unmodified back to the server.
     * They may only be valid for a particular resource or set of resources.
     *
     * Populated by the system.
     * Read-only.
     * Value must be treated as opaque by clients and .
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 6;</code>
     * @return The resourceVersion.
     */
    java.lang.String getResourceVersion();
    /**
     * <pre>
     * An opaque value that represents the internal version of this object that can
     * be used by clients to determine when objects have changed. May be used for optimistic
     * concurrency, change detection, and the watch operation on a resource or set of resources.
     * Clients must treat these values as opaque and passed unmodified back to the server.
     * They may only be valid for a particular resource or set of resources.
     *
     * Populated by the system.
     * Read-only.
     * Value must be treated as opaque by clients and .
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 6;</code>
     * @return The bytes for resourceVersion.
     */
    com.google.protobuf.ByteString
        getResourceVersionBytes();

    /**
     * <pre>
     * A sequence number representing a specific generation of the desired state.
     * Populated by the system. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional int64 generation = 7;</code>
     * @return Whether the generation field is set.
     */
    boolean hasGeneration();
    /**
     * <pre>
     * A sequence number representing a specific generation of the desired state.
     * Populated by the system. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional int64 generation = 7;</code>
     * @return The generation.
     */
    long getGeneration();

    /**
     * <pre>
     * CreationTimestamp is a timestamp representing the server time when this object was
     * created. It is not guaranteed to be set in happens-before order across separate operations.
     * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
     *
     * Populated by the system.
     * Read-only.
     * Null for lists.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
     * @return Whether the creationTimestamp field is set.
     */
    boolean hasCreationTimestamp();
    /**
     * <pre>
     * CreationTimestamp is a timestamp representing the server time when this object was
     * created. It is not guaranteed to be set in happens-before order across separate operations.
     * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
     *
     * Populated by the system.
     * Read-only.
     * Null for lists.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
     * @return The creationTimestamp.
     */
    io.kubernetes.client.proto.Meta.Time getCreationTimestamp();
    /**
     * <pre>
     * CreationTimestamp is a timestamp representing the server time when this object was
     * created. It is not guaranteed to be set in happens-before order across separate operations.
     * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
     *
     * Populated by the system.
     * Read-only.
     * Null for lists.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getCreationTimestampOrBuilder();

    /**
     * <pre>
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
     * field is set by the server when a graceful deletion is requested by the user, and is not
     * directly settable by a client. The resource is expected to be deleted (no longer visible
     * from resource lists, and not reachable by name) after the time in this field, once the
     * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
     * Once the deletionTimestamp is set, this value may not be unset or be set further into the
     * future, although it may be shortened or the resource may be deleted prior to this time.
     * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
     * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
     * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
     * remove the pod from the API. In the presence of network partitions, this object may still
     * exist after this timestamp, until an administrator or automated process can determine the
     * resource is fully terminated.
     * If not set, graceful deletion of the object has not been requested.
     *
     * Populated by the system when a graceful deletion is requested.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
     * @return Whether the deletionTimestamp field is set.
     */
    boolean hasDeletionTimestamp();
    /**
     * <pre>
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
     * field is set by the server when a graceful deletion is requested by the user, and is not
     * directly settable by a client. The resource is expected to be deleted (no longer visible
     * from resource lists, and not reachable by name) after the time in this field, once the
     * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
     * Once the deletionTimestamp is set, this value may not be unset or be set further into the
     * future, although it may be shortened or the resource may be deleted prior to this time.
     * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
     * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
     * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
     * remove the pod from the API. In the presence of network partitions, this object may still
     * exist after this timestamp, until an administrator or automated process can determine the
     * resource is fully terminated.
     * If not set, graceful deletion of the object has not been requested.
     *
     * Populated by the system when a graceful deletion is requested.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
     * @return The deletionTimestamp.
     */
    io.kubernetes.client.proto.Meta.Time getDeletionTimestamp();
    /**
     * <pre>
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
     * field is set by the server when a graceful deletion is requested by the user, and is not
     * directly settable by a client. The resource is expected to be deleted (no longer visible
     * from resource lists, and not reachable by name) after the time in this field, once the
     * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
     * Once the deletionTimestamp is set, this value may not be unset or be set further into the
     * future, although it may be shortened or the resource may be deleted prior to this time.
     * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
     * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
     * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
     * remove the pod from the API. In the presence of network partitions, this object may still
     * exist after this timestamp, until an administrator or automated process can determine the
     * resource is fully terminated.
     * If not set, graceful deletion of the object has not been requested.
     *
     * Populated by the system when a graceful deletion is requested.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getDeletionTimestampOrBuilder();

    /**
     * <pre>
     * Number of seconds allowed for this object to gracefully terminate before
     * it will be removed from the system. Only set when deletionTimestamp is also set.
     * May only be shortened.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional int64 deletionGracePeriodSeconds = 10;</code>
     * @return Whether the deletionGracePeriodSeconds field is set.
     */
    boolean hasDeletionGracePeriodSeconds();
    /**
     * <pre>
     * Number of seconds allowed for this object to gracefully terminate before
     * it will be removed from the system. Only set when deletionTimestamp is also set.
     * May only be shortened.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional int64 deletionGracePeriodSeconds = 10;</code>
     * @return The deletionGracePeriodSeconds.
     */
    long getDeletionGracePeriodSeconds();

    /**
     * <pre>
     * Map of string keys and values that can be used to organize and categorize
     * (scope and select) objects. May match selectors of replication controllers
     * and services.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 11;</code>
     */
    int getLabelsCount();
    /**
     * <pre>
     * Map of string keys and values that can be used to organize and categorize
     * (scope and select) objects. May match selectors of replication controllers
     * and services.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 11;</code>
     */
    boolean containsLabels(
        java.lang.String key);
    /**
     * Use {@link #getLabelsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getLabels();
    /**
     * <pre>
     * Map of string keys and values that can be used to organize and categorize
     * (scope and select) objects. May match selectors of replication controllers
     * and services.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 11;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getLabelsMap();
    /**
     * <pre>
     * Map of string keys and values that can be used to organize and categorize
     * (scope and select) objects. May match selectors of replication controllers
     * and services.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 11;</code>
     */
    /* nullable */
java.lang.String getLabelsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue);
    /**
     * <pre>
     * Map of string keys and values that can be used to organize and categorize
     * (scope and select) objects. May match selectors of replication controllers
     * and services.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 11;</code>
     */
    java.lang.String getLabelsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Annotations is an unstructured key value map stored with a resource that may be
     * set by external tools to store and retrieve arbitrary metadata. They are not
     * queryable and should be preserved when modifying objects.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 12;</code>
     */
    int getAnnotationsCount();
    /**
     * <pre>
     * Annotations is an unstructured key value map stored with a resource that may be
     * set by external tools to store and retrieve arbitrary metadata. They are not
     * queryable and should be preserved when modifying objects.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 12;</code>
     */
    boolean containsAnnotations(
        java.lang.String key);
    /**
     * Use {@link #getAnnotationsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getAnnotations();
    /**
     * <pre>
     * Annotations is an unstructured key value map stored with a resource that may be
     * set by external tools to store and retrieve arbitrary metadata. They are not
     * queryable and should be preserved when modifying objects.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 12;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getAnnotationsMap();
    /**
     * <pre>
     * Annotations is an unstructured key value map stored with a resource that may be
     * set by external tools to store and retrieve arbitrary metadata. They are not
     * queryable and should be preserved when modifying objects.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 12;</code>
     */
    /* nullable */
java.lang.String getAnnotationsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue);
    /**
     * <pre>
     * Annotations is an unstructured key value map stored with a resource that may be
     * set by external tools to store and retrieve arbitrary metadata. They are not
     * queryable and should be preserved when modifying objects.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 12;</code>
     */
    java.lang.String getAnnotationsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.OwnerReference> 
        getOwnerReferencesList();
    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    io.kubernetes.client.proto.Meta.OwnerReference getOwnerReferences(int index);
    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    int getOwnerReferencesCount();
    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder> 
        getOwnerReferencesOrBuilderList();
    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder getOwnerReferencesOrBuilder(
        int index);

    /**
     * <pre>
     * Must be empty before the object is deleted from the registry. Each entry
     * is an identifier for the responsible component that will remove the entry
     * from the list. If the deletionTimestamp of the object is non-nil, entries
     * in this list can only be removed.
     * Finalizers may be processed and removed in any order.  Order is NOT enforced
     * because it introduces significant risk of stuck finalizers.
     * finalizers is a shared field, any actor with permission can reorder it.
     * If the finalizer list is processed in order, then this can lead to a situation
     * in which the component responsible for the first finalizer in the list is
     * waiting for a signal (field value, external system, or other) produced by a
     * component responsible for a finalizer later in the list, resulting in a deadlock.
     * Without enforced ordering finalizers are free to order amongst themselves and
     * are not vulnerable to ordering changes in the list.
     * +optional
     * +patchStrategy=merge
     * +listType=set
     * </pre>
     *
     * <code>repeated string finalizers = 14;</code>
     * @return A list containing the finalizers.
     */
    java.util.List<java.lang.String>
        getFinalizersList();
    /**
     * <pre>
     * Must be empty before the object is deleted from the registry. Each entry
     * is an identifier for the responsible component that will remove the entry
     * from the list. If the deletionTimestamp of the object is non-nil, entries
     * in this list can only be removed.
     * Finalizers may be processed and removed in any order.  Order is NOT enforced
     * because it introduces significant risk of stuck finalizers.
     * finalizers is a shared field, any actor with permission can reorder it.
     * If the finalizer list is processed in order, then this can lead to a situation
     * in which the component responsible for the first finalizer in the list is
     * waiting for a signal (field value, external system, or other) produced by a
     * component responsible for a finalizer later in the list, resulting in a deadlock.
     * Without enforced ordering finalizers are free to order amongst themselves and
     * are not vulnerable to ordering changes in the list.
     * +optional
     * +patchStrategy=merge
     * +listType=set
     * </pre>
     *
     * <code>repeated string finalizers = 14;</code>
     * @return The count of finalizers.
     */
    int getFinalizersCount();
    /**
     * <pre>
     * Must be empty before the object is deleted from the registry. Each entry
     * is an identifier for the responsible component that will remove the entry
     * from the list. If the deletionTimestamp of the object is non-nil, entries
     * in this list can only be removed.
     * Finalizers may be processed and removed in any order.  Order is NOT enforced
     * because it introduces significant risk of stuck finalizers.
     * finalizers is a shared field, any actor with permission can reorder it.
     * If the finalizer list is processed in order, then this can lead to a situation
     * in which the component responsible for the first finalizer in the list is
     * waiting for a signal (field value, external system, or other) produced by a
     * component responsible for a finalizer later in the list, resulting in a deadlock.
     * Without enforced ordering finalizers are free to order amongst themselves and
     * are not vulnerable to ordering changes in the list.
     * +optional
     * +patchStrategy=merge
     * +listType=set
     * </pre>
     *
     * <code>repeated string finalizers = 14;</code>
     * @param index The index of the element to return.
     * @return The finalizers at the given index.
     */
    java.lang.String getFinalizers(int index);
    /**
     * <pre>
     * Must be empty before the object is deleted from the registry. Each entry
     * is an identifier for the responsible component that will remove the entry
     * from the list. If the deletionTimestamp of the object is non-nil, entries
     * in this list can only be removed.
     * Finalizers may be processed and removed in any order.  Order is NOT enforced
     * because it introduces significant risk of stuck finalizers.
     * finalizers is a shared field, any actor with permission can reorder it.
     * If the finalizer list is processed in order, then this can lead to a situation
     * in which the component responsible for the first finalizer in the list is
     * waiting for a signal (field value, external system, or other) produced by a
     * component responsible for a finalizer later in the list, resulting in a deadlock.
     * Without enforced ordering finalizers are free to order amongst themselves and
     * are not vulnerable to ordering changes in the list.
     * +optional
     * +patchStrategy=merge
     * +listType=set
     * </pre>
     *
     * <code>repeated string finalizers = 14;</code>
     * @param index The index of the value to return.
     * @return The bytes of the finalizers at the given index.
     */
    com.google.protobuf.ByteString
        getFinalizersBytes(int index);

    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.ManagedFieldsEntry> 
        getManagedFieldsList();
    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    io.kubernetes.client.proto.Meta.ManagedFieldsEntry getManagedFields(int index);
    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    int getManagedFieldsCount();
    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder> 
        getManagedFieldsOrBuilderList();
    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder getManagedFieldsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects
   * users must create.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta}
   */
  public static final class ObjectMeta extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta)
      ObjectMetaOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ObjectMeta.class.getName());
    }
    // Use ObjectMeta.newBuilder() to construct.
    private ObjectMeta(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ObjectMeta() {
      name_ = "";
      generateName_ = "";
      namespace_ = "";
      selfLink_ = "";
      uid_ = "";
      resourceVersion_ = "";
      ownerReferences_ = java.util.Collections.emptyList();
      finalizers_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      managedFields_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 11:
          return internalGetLabels();
        case 12:
          return internalGetAnnotations();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.ObjectMeta.class, io.kubernetes.client.proto.Meta.ObjectMeta.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name must be unique within a namespace. Is required when creating resources, although
     * some resources may allow a client to request the generation of an appropriate name
     * automatically. Name is primarily intended for creation idempotence and configuration
     * definition.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int GENERATENAME_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object generateName_ = "";
    /**
     * <pre>
     * GenerateName is an optional prefix, used by the server, to generate a unique
     * name ONLY IF the Name field has not been provided.
     * If this field is used, the name returned to the client will be different
     * than the name passed. This value will also be combined with a unique suffix.
     * The provided value has the same validation rules as the Name field,
     * and may be truncated by the length of the suffix required to make the value
     * unique on the server.
     *
     * If this field is specified and the generated name exists, the server will return a 409.
     *
     * Applied only if Name is not specified.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
     * +optional
     * </pre>
     *
     * <code>optional string generateName = 2;</code>
     * @return Whether the generateName field is set.
     */
    @java.lang.Override
    public boolean hasGenerateName() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * GenerateName is an optional prefix, used by the server, to generate a unique
     * name ONLY IF the Name field has not been provided.
     * If this field is used, the name returned to the client will be different
     * than the name passed. This value will also be combined with a unique suffix.
     * The provided value has the same validation rules as the Name field,
     * and may be truncated by the length of the suffix required to make the value
     * unique on the server.
     *
     * If this field is specified and the generated name exists, the server will return a 409.
     *
     * Applied only if Name is not specified.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
     * +optional
     * </pre>
     *
     * <code>optional string generateName = 2;</code>
     * @return The generateName.
     */
    @java.lang.Override
    public java.lang.String getGenerateName() {
      java.lang.Object ref = generateName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          generateName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * GenerateName is an optional prefix, used by the server, to generate a unique
     * name ONLY IF the Name field has not been provided.
     * If this field is used, the name returned to the client will be different
     * than the name passed. This value will also be combined with a unique suffix.
     * The provided value has the same validation rules as the Name field,
     * and may be truncated by the length of the suffix required to make the value
     * unique on the server.
     *
     * If this field is specified and the generated name exists, the server will return a 409.
     *
     * Applied only if Name is not specified.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
     * +optional
     * </pre>
     *
     * <code>optional string generateName = 2;</code>
     * @return The bytes for generateName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGenerateNameBytes() {
      java.lang.Object ref = generateName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        generateName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACE_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object namespace_ = "";
    /**
     * <pre>
     * Namespace defines the space within which each name must be unique. An empty namespace is
     * equivalent to the "default" namespace, but "default" is the canonical representation.
     * Not all objects are required to be scoped to a namespace - the value of this field for
     * those objects will be empty.
     *
     * Must be a DNS_LABEL.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 3;</code>
     * @return Whether the namespace field is set.
     */
    @java.lang.Override
    public boolean hasNamespace() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Namespace defines the space within which each name must be unique. An empty namespace is
     * equivalent to the "default" namespace, but "default" is the canonical representation.
     * Not all objects are required to be scoped to a namespace - the value of this field for
     * those objects will be empty.
     *
     * Must be a DNS_LABEL.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 3;</code>
     * @return The namespace.
     */
    @java.lang.Override
    public java.lang.String getNamespace() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          namespace_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Namespace defines the space within which each name must be unique. An empty namespace is
     * equivalent to the "default" namespace, but "default" is the canonical representation.
     * Not all objects are required to be scoped to a namespace - the value of this field for
     * those objects will be empty.
     *
     * Must be a DNS_LABEL.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 3;</code>
     * @return The bytes for namespace.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNamespaceBytes() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        namespace_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SELFLINK_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object selfLink_ = "";
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 4;</code>
     * @return Whether the selfLink field is set.
     */
    @java.lang.Override
    public boolean hasSelfLink() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 4;</code>
     * @return The selfLink.
     */
    @java.lang.Override
    public java.lang.String getSelfLink() {
      java.lang.Object ref = selfLink_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          selfLink_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
     * +optional
     * </pre>
     *
     * <code>optional string selfLink = 4;</code>
     * @return The bytes for selfLink.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSelfLinkBytes() {
      java.lang.Object ref = selfLink_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        selfLink_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UID_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object uid_ = "";
    /**
     * <pre>
     * UID is the unique in time and space value for this object. It is typically generated by
     * the server on successful creation of a resource and is not allowed to change on PUT
     * operations.
     *
     * Populated by the system.
     * Read-only.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 5;</code>
     * @return Whether the uid field is set.
     */
    @java.lang.Override
    public boolean hasUid() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * UID is the unique in time and space value for this object. It is typically generated by
     * the server on successful creation of a resource and is not allowed to change on PUT
     * operations.
     *
     * Populated by the system.
     * Read-only.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 5;</code>
     * @return The uid.
     */
    @java.lang.Override
    public java.lang.String getUid() {
      java.lang.Object ref = uid_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          uid_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * UID is the unique in time and space value for this object. It is typically generated by
     * the server on successful creation of a resource and is not allowed to change on PUT
     * operations.
     *
     * Populated by the system.
     * Read-only.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 5;</code>
     * @return The bytes for uid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUidBytes() {
      java.lang.Object ref = uid_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uid_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RESOURCEVERSION_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resourceVersion_ = "";
    /**
     * <pre>
     * An opaque value that represents the internal version of this object that can
     * be used by clients to determine when objects have changed. May be used for optimistic
     * concurrency, change detection, and the watch operation on a resource or set of resources.
     * Clients must treat these values as opaque and passed unmodified back to the server.
     * They may only be valid for a particular resource or set of resources.
     *
     * Populated by the system.
     * Read-only.
     * Value must be treated as opaque by clients and .
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 6;</code>
     * @return Whether the resourceVersion field is set.
     */
    @java.lang.Override
    public boolean hasResourceVersion() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * An opaque value that represents the internal version of this object that can
     * be used by clients to determine when objects have changed. May be used for optimistic
     * concurrency, change detection, and the watch operation on a resource or set of resources.
     * Clients must treat these values as opaque and passed unmodified back to the server.
     * They may only be valid for a particular resource or set of resources.
     *
     * Populated by the system.
     * Read-only.
     * Value must be treated as opaque by clients and .
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 6;</code>
     * @return The resourceVersion.
     */
    @java.lang.Override
    public java.lang.String getResourceVersion() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          resourceVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * An opaque value that represents the internal version of this object that can
     * be used by clients to determine when objects have changed. May be used for optimistic
     * concurrency, change detection, and the watch operation on a resource or set of resources.
     * Clients must treat these values as opaque and passed unmodified back to the server.
     * They may only be valid for a particular resource or set of resources.
     *
     * Populated by the system.
     * Read-only.
     * Value must be treated as opaque by clients and .
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 6;</code>
     * @return The bytes for resourceVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceVersionBytes() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resourceVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int GENERATION_FIELD_NUMBER = 7;
    private long generation_ = 0L;
    /**
     * <pre>
     * A sequence number representing a specific generation of the desired state.
     * Populated by the system. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional int64 generation = 7;</code>
     * @return Whether the generation field is set.
     */
    @java.lang.Override
    public boolean hasGeneration() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * A sequence number representing a specific generation of the desired state.
     * Populated by the system. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional int64 generation = 7;</code>
     * @return The generation.
     */
    @java.lang.Override
    public long getGeneration() {
      return generation_;
    }

    public static final int CREATIONTIMESTAMP_FIELD_NUMBER = 8;
    private io.kubernetes.client.proto.Meta.Time creationTimestamp_;
    /**
     * <pre>
     * CreationTimestamp is a timestamp representing the server time when this object was
     * created. It is not guaranteed to be set in happens-before order across separate operations.
     * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
     *
     * Populated by the system.
     * Read-only.
     * Null for lists.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
     * @return Whether the creationTimestamp field is set.
     */
    @java.lang.Override
    public boolean hasCreationTimestamp() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * CreationTimestamp is a timestamp representing the server time when this object was
     * created. It is not guaranteed to be set in happens-before order across separate operations.
     * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
     *
     * Populated by the system.
     * Read-only.
     * Null for lists.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
     * @return The creationTimestamp.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getCreationTimestamp() {
      return creationTimestamp_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : creationTimestamp_;
    }
    /**
     * <pre>
     * CreationTimestamp is a timestamp representing the server time when this object was
     * created. It is not guaranteed to be set in happens-before order across separate operations.
     * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
     *
     * Populated by the system.
     * Read-only.
     * Null for lists.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getCreationTimestampOrBuilder() {
      return creationTimestamp_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : creationTimestamp_;
    }

    public static final int DELETIONTIMESTAMP_FIELD_NUMBER = 9;
    private io.kubernetes.client.proto.Meta.Time deletionTimestamp_;
    /**
     * <pre>
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
     * field is set by the server when a graceful deletion is requested by the user, and is not
     * directly settable by a client. The resource is expected to be deleted (no longer visible
     * from resource lists, and not reachable by name) after the time in this field, once the
     * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
     * Once the deletionTimestamp is set, this value may not be unset or be set further into the
     * future, although it may be shortened or the resource may be deleted prior to this time.
     * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
     * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
     * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
     * remove the pod from the API. In the presence of network partitions, this object may still
     * exist after this timestamp, until an administrator or automated process can determine the
     * resource is fully terminated.
     * If not set, graceful deletion of the object has not been requested.
     *
     * Populated by the system when a graceful deletion is requested.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
     * @return Whether the deletionTimestamp field is set.
     */
    @java.lang.Override
    public boolean hasDeletionTimestamp() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
     * field is set by the server when a graceful deletion is requested by the user, and is not
     * directly settable by a client. The resource is expected to be deleted (no longer visible
     * from resource lists, and not reachable by name) after the time in this field, once the
     * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
     * Once the deletionTimestamp is set, this value may not be unset or be set further into the
     * future, although it may be shortened or the resource may be deleted prior to this time.
     * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
     * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
     * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
     * remove the pod from the API. In the presence of network partitions, this object may still
     * exist after this timestamp, until an administrator or automated process can determine the
     * resource is fully terminated.
     * If not set, graceful deletion of the object has not been requested.
     *
     * Populated by the system when a graceful deletion is requested.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
     * @return The deletionTimestamp.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getDeletionTimestamp() {
      return deletionTimestamp_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : deletionTimestamp_;
    }
    /**
     * <pre>
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
     * field is set by the server when a graceful deletion is requested by the user, and is not
     * directly settable by a client. The resource is expected to be deleted (no longer visible
     * from resource lists, and not reachable by name) after the time in this field, once the
     * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
     * Once the deletionTimestamp is set, this value may not be unset or be set further into the
     * future, although it may be shortened or the resource may be deleted prior to this time.
     * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
     * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
     * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
     * remove the pod from the API. In the presence of network partitions, this object may still
     * exist after this timestamp, until an administrator or automated process can determine the
     * resource is fully terminated.
     * If not set, graceful deletion of the object has not been requested.
     *
     * Populated by the system when a graceful deletion is requested.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getDeletionTimestampOrBuilder() {
      return deletionTimestamp_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : deletionTimestamp_;
    }

    public static final int DELETIONGRACEPERIODSECONDS_FIELD_NUMBER = 10;
    private long deletionGracePeriodSeconds_ = 0L;
    /**
     * <pre>
     * Number of seconds allowed for this object to gracefully terminate before
     * it will be removed from the system. Only set when deletionTimestamp is also set.
     * May only be shortened.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional int64 deletionGracePeriodSeconds = 10;</code>
     * @return Whether the deletionGracePeriodSeconds field is set.
     */
    @java.lang.Override
    public boolean hasDeletionGracePeriodSeconds() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Number of seconds allowed for this object to gracefully terminate before
     * it will be removed from the system. Only set when deletionTimestamp is also set.
     * May only be shortened.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional int64 deletionGracePeriodSeconds = 10;</code>
     * @return The deletionGracePeriodSeconds.
     */
    @java.lang.Override
    public long getDeletionGracePeriodSeconds() {
      return deletionGracePeriodSeconds_;
    }

    public static final int LABELS_FIELD_NUMBER = 11;
    private static final class LabelsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_LabelsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> labels_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetLabels() {
      if (labels_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            LabelsDefaultEntryHolder.defaultEntry);
      }
      return labels_;
    }
    public int getLabelsCount() {
      return internalGetLabels().getMap().size();
    }
    /**
     * <pre>
     * Map of string keys and values that can be used to organize and categorize
     * (scope and select) objects. May match selectors of replication controllers
     * and services.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 11;</code>
     */
    @java.lang.Override
    public boolean containsLabels(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetLabels().getMap().containsKey(key);
    }
    /**
     * Use {@link #getLabelsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getLabels() {
      return getLabelsMap();
    }
    /**
     * <pre>
     * Map of string keys and values that can be used to organize and categorize
     * (scope and select) objects. May match selectors of replication controllers
     * and services.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 11;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getLabelsMap() {
      return internalGetLabels().getMap();
    }
    /**
     * <pre>
     * Map of string keys and values that can be used to organize and categorize
     * (scope and select) objects. May match selectors of replication controllers
     * and services.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 11;</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getLabelsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetLabels().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Map of string keys and values that can be used to organize and categorize
     * (scope and select) objects. May match selectors of replication controllers
     * and services.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 11;</code>
     */
    @java.lang.Override
    public java.lang.String getLabelsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetLabels().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int ANNOTATIONS_FIELD_NUMBER = 12;
    private static final class AnnotationsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_AnnotationsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> annotations_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetAnnotations() {
      if (annotations_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            AnnotationsDefaultEntryHolder.defaultEntry);
      }
      return annotations_;
    }
    public int getAnnotationsCount() {
      return internalGetAnnotations().getMap().size();
    }
    /**
     * <pre>
     * Annotations is an unstructured key value map stored with a resource that may be
     * set by external tools to store and retrieve arbitrary metadata. They are not
     * queryable and should be preserved when modifying objects.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 12;</code>
     */
    @java.lang.Override
    public boolean containsAnnotations(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetAnnotations().getMap().containsKey(key);
    }
    /**
     * Use {@link #getAnnotationsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getAnnotations() {
      return getAnnotationsMap();
    }
    /**
     * <pre>
     * Annotations is an unstructured key value map stored with a resource that may be
     * set by external tools to store and retrieve arbitrary metadata. They are not
     * queryable and should be preserved when modifying objects.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 12;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getAnnotationsMap() {
      return internalGetAnnotations().getMap();
    }
    /**
     * <pre>
     * Annotations is an unstructured key value map stored with a resource that may be
     * set by external tools to store and retrieve arbitrary metadata. They are not
     * queryable and should be preserved when modifying objects.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 12;</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getAnnotationsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAnnotations().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Annotations is an unstructured key value map stored with a resource that may be
     * set by external tools to store and retrieve arbitrary metadata. They are not
     * queryable and should be preserved when modifying objects.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; annotations = 12;</code>
     */
    @java.lang.Override
    public java.lang.String getAnnotationsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAnnotations().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int OWNERREFERENCES_FIELD_NUMBER = 13;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.OwnerReference> ownerReferences_;
    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.OwnerReference> getOwnerReferencesList() {
      return ownerReferences_;
    }
    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder> 
        getOwnerReferencesOrBuilderList() {
      return ownerReferences_;
    }
    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    @java.lang.Override
    public int getOwnerReferencesCount() {
      return ownerReferences_.size();
    }
    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.OwnerReference getOwnerReferences(int index) {
      return ownerReferences_.get(index);
    }
    /**
     * <pre>
     * List of objects depended by this object. If ALL objects in the list have
     * been deleted, this object will be garbage collected. If this object is managed by a controller,
     * then an entry in this list will point to this controller, with the controller field set to true.
     * There cannot be more than one managing controller.
     * +optional
     * +patchMergeKey=uid
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=uid
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder getOwnerReferencesOrBuilder(
        int index) {
      return ownerReferences_.get(index);
    }

    public static final int FINALIZERS_FIELD_NUMBER = 14;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList finalizers_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Must be empty before the object is deleted from the registry. Each entry
     * is an identifier for the responsible component that will remove the entry
     * from the list. If the deletionTimestamp of the object is non-nil, entries
     * in this list can only be removed.
     * Finalizers may be processed and removed in any order.  Order is NOT enforced
     * because it introduces significant risk of stuck finalizers.
     * finalizers is a shared field, any actor with permission can reorder it.
     * If the finalizer list is processed in order, then this can lead to a situation
     * in which the component responsible for the first finalizer in the list is
     * waiting for a signal (field value, external system, or other) produced by a
     * component responsible for a finalizer later in the list, resulting in a deadlock.
     * Without enforced ordering finalizers are free to order amongst themselves and
     * are not vulnerable to ordering changes in the list.
     * +optional
     * +patchStrategy=merge
     * +listType=set
     * </pre>
     *
     * <code>repeated string finalizers = 14;</code>
     * @return A list containing the finalizers.
     */
    public com.google.protobuf.ProtocolStringList
        getFinalizersList() {
      return finalizers_;
    }
    /**
     * <pre>
     * Must be empty before the object is deleted from the registry. Each entry
     * is an identifier for the responsible component that will remove the entry
     * from the list. If the deletionTimestamp of the object is non-nil, entries
     * in this list can only be removed.
     * Finalizers may be processed and removed in any order.  Order is NOT enforced
     * because it introduces significant risk of stuck finalizers.
     * finalizers is a shared field, any actor with permission can reorder it.
     * If the finalizer list is processed in order, then this can lead to a situation
     * in which the component responsible for the first finalizer in the list is
     * waiting for a signal (field value, external system, or other) produced by a
     * component responsible for a finalizer later in the list, resulting in a deadlock.
     * Without enforced ordering finalizers are free to order amongst themselves and
     * are not vulnerable to ordering changes in the list.
     * +optional
     * +patchStrategy=merge
     * +listType=set
     * </pre>
     *
     * <code>repeated string finalizers = 14;</code>
     * @return The count of finalizers.
     */
    public int getFinalizersCount() {
      return finalizers_.size();
    }
    /**
     * <pre>
     * Must be empty before the object is deleted from the registry. Each entry
     * is an identifier for the responsible component that will remove the entry
     * from the list. If the deletionTimestamp of the object is non-nil, entries
     * in this list can only be removed.
     * Finalizers may be processed and removed in any order.  Order is NOT enforced
     * because it introduces significant risk of stuck finalizers.
     * finalizers is a shared field, any actor with permission can reorder it.
     * If the finalizer list is processed in order, then this can lead to a situation
     * in which the component responsible for the first finalizer in the list is
     * waiting for a signal (field value, external system, or other) produced by a
     * component responsible for a finalizer later in the list, resulting in a deadlock.
     * Without enforced ordering finalizers are free to order amongst themselves and
     * are not vulnerable to ordering changes in the list.
     * +optional
     * +patchStrategy=merge
     * +listType=set
     * </pre>
     *
     * <code>repeated string finalizers = 14;</code>
     * @param index The index of the element to return.
     * @return The finalizers at the given index.
     */
    public java.lang.String getFinalizers(int index) {
      return finalizers_.get(index);
    }
    /**
     * <pre>
     * Must be empty before the object is deleted from the registry. Each entry
     * is an identifier for the responsible component that will remove the entry
     * from the list. If the deletionTimestamp of the object is non-nil, entries
     * in this list can only be removed.
     * Finalizers may be processed and removed in any order.  Order is NOT enforced
     * because it introduces significant risk of stuck finalizers.
     * finalizers is a shared field, any actor with permission can reorder it.
     * If the finalizer list is processed in order, then this can lead to a situation
     * in which the component responsible for the first finalizer in the list is
     * waiting for a signal (field value, external system, or other) produced by a
     * component responsible for a finalizer later in the list, resulting in a deadlock.
     * Without enforced ordering finalizers are free to order amongst themselves and
     * are not vulnerable to ordering changes in the list.
     * +optional
     * +patchStrategy=merge
     * +listType=set
     * </pre>
     *
     * <code>repeated string finalizers = 14;</code>
     * @param index The index of the value to return.
     * @return The bytes of the finalizers at the given index.
     */
    public com.google.protobuf.ByteString
        getFinalizersBytes(int index) {
      return finalizers_.getByteString(index);
    }

    public static final int MANAGEDFIELDS_FIELD_NUMBER = 17;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.ManagedFieldsEntry> managedFields_;
    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.ManagedFieldsEntry> getManagedFieldsList() {
      return managedFields_;
    }
    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder> 
        getManagedFieldsOrBuilderList() {
      return managedFields_;
    }
    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    @java.lang.Override
    public int getManagedFieldsCount() {
      return managedFields_.size();
    }
    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ManagedFieldsEntry getManagedFields(int index) {
      return managedFields_.get(index);
    }
    /**
     * <pre>
     * ManagedFields maps workflow-id and version to the set of fields
     * that are managed by that workflow. This is mostly for internal
     * housekeeping, and users typically shouldn't need to set or
     * understand this field. A workflow can be the user's name, a
     * controller's name, or the name of a specific apply path like
     * "ci-cd". The set of fields is always in the version that the
     * workflow used when modifying the object.
     *
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder getManagedFieldsOrBuilder(
        int index) {
      return managedFields_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, generateName_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, namespace_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, selfLink_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, uid_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, resourceVersion_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeInt64(7, generation_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(8, getCreationTimestamp());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(9, getDeletionTimestamp());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeInt64(10, deletionGracePeriodSeconds_);
      }
      com.google.protobuf.GeneratedMessage
        .serializeStringMapTo(
          output,
          internalGetLabels(),
          LabelsDefaultEntryHolder.defaultEntry,
          11);
      com.google.protobuf.GeneratedMessage
        .serializeStringMapTo(
          output,
          internalGetAnnotations(),
          AnnotationsDefaultEntryHolder.defaultEntry,
          12);
      for (int i = 0; i < ownerReferences_.size(); i++) {
        output.writeMessage(13, ownerReferences_.get(i));
      }
      for (int i = 0; i < finalizers_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 14, finalizers_.getRaw(i));
      }
      for (int i = 0; i < managedFields_.size(); i++) {
        output.writeMessage(17, managedFields_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, generateName_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, namespace_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, selfLink_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, uid_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, resourceVersion_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(7, generation_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getCreationTimestamp());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getDeletionTimestamp());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(10, deletionGracePeriodSeconds_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetLabels().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        labels__ = LabelsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(11, labels__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetAnnotations().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        annotations__ = AnnotationsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(12, annotations__);
      }
      for (int i = 0; i < ownerReferences_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, ownerReferences_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < finalizers_.size(); i++) {
          dataSize += computeStringSizeNoTag(finalizers_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getFinalizersList().size();
      }
      for (int i = 0; i < managedFields_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(17, managedFields_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.ObjectMeta)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.ObjectMeta other = (io.kubernetes.client.proto.Meta.ObjectMeta) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasGenerateName() != other.hasGenerateName()) return false;
      if (hasGenerateName()) {
        if (!getGenerateName()
            .equals(other.getGenerateName())) return false;
      }
      if (hasNamespace() != other.hasNamespace()) return false;
      if (hasNamespace()) {
        if (!getNamespace()
            .equals(other.getNamespace())) return false;
      }
      if (hasSelfLink() != other.hasSelfLink()) return false;
      if (hasSelfLink()) {
        if (!getSelfLink()
            .equals(other.getSelfLink())) return false;
      }
      if (hasUid() != other.hasUid()) return false;
      if (hasUid()) {
        if (!getUid()
            .equals(other.getUid())) return false;
      }
      if (hasResourceVersion() != other.hasResourceVersion()) return false;
      if (hasResourceVersion()) {
        if (!getResourceVersion()
            .equals(other.getResourceVersion())) return false;
      }
      if (hasGeneration() != other.hasGeneration()) return false;
      if (hasGeneration()) {
        if (getGeneration()
            != other.getGeneration()) return false;
      }
      if (hasCreationTimestamp() != other.hasCreationTimestamp()) return false;
      if (hasCreationTimestamp()) {
        if (!getCreationTimestamp()
            .equals(other.getCreationTimestamp())) return false;
      }
      if (hasDeletionTimestamp() != other.hasDeletionTimestamp()) return false;
      if (hasDeletionTimestamp()) {
        if (!getDeletionTimestamp()
            .equals(other.getDeletionTimestamp())) return false;
      }
      if (hasDeletionGracePeriodSeconds() != other.hasDeletionGracePeriodSeconds()) return false;
      if (hasDeletionGracePeriodSeconds()) {
        if (getDeletionGracePeriodSeconds()
            != other.getDeletionGracePeriodSeconds()) return false;
      }
      if (!internalGetLabels().equals(
          other.internalGetLabels())) return false;
      if (!internalGetAnnotations().equals(
          other.internalGetAnnotations())) return false;
      if (!getOwnerReferencesList()
          .equals(other.getOwnerReferencesList())) return false;
      if (!getFinalizersList()
          .equals(other.getFinalizersList())) return false;
      if (!getManagedFieldsList()
          .equals(other.getManagedFieldsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasGenerateName()) {
        hash = (37 * hash) + GENERATENAME_FIELD_NUMBER;
        hash = (53 * hash) + getGenerateName().hashCode();
      }
      if (hasNamespace()) {
        hash = (37 * hash) + NAMESPACE_FIELD_NUMBER;
        hash = (53 * hash) + getNamespace().hashCode();
      }
      if (hasSelfLink()) {
        hash = (37 * hash) + SELFLINK_FIELD_NUMBER;
        hash = (53 * hash) + getSelfLink().hashCode();
      }
      if (hasUid()) {
        hash = (37 * hash) + UID_FIELD_NUMBER;
        hash = (53 * hash) + getUid().hashCode();
      }
      if (hasResourceVersion()) {
        hash = (37 * hash) + RESOURCEVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getResourceVersion().hashCode();
      }
      if (hasGeneration()) {
        hash = (37 * hash) + GENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getGeneration());
      }
      if (hasCreationTimestamp()) {
        hash = (37 * hash) + CREATIONTIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + getCreationTimestamp().hashCode();
      }
      if (hasDeletionTimestamp()) {
        hash = (37 * hash) + DELETIONTIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + getDeletionTimestamp().hashCode();
      }
      if (hasDeletionGracePeriodSeconds()) {
        hash = (37 * hash) + DELETIONGRACEPERIODSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDeletionGracePeriodSeconds());
      }
      if (!internalGetLabels().getMap().isEmpty()) {
        hash = (37 * hash) + LABELS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetLabels().hashCode();
      }
      if (!internalGetAnnotations().getMap().isEmpty()) {
        hash = (37 * hash) + ANNOTATIONS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetAnnotations().hashCode();
      }
      if (getOwnerReferencesCount() > 0) {
        hash = (37 * hash) + OWNERREFERENCES_FIELD_NUMBER;
        hash = (53 * hash) + getOwnerReferencesList().hashCode();
      }
      if (getFinalizersCount() > 0) {
        hash = (37 * hash) + FINALIZERS_FIELD_NUMBER;
        hash = (53 * hash) + getFinalizersList().hashCode();
      }
      if (getManagedFieldsCount() > 0) {
        hash = (37 * hash) + MANAGEDFIELDS_FIELD_NUMBER;
        hash = (53 * hash) + getManagedFieldsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.ObjectMeta parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.ObjectMeta parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ObjectMeta parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.ObjectMeta prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects
     * users must create.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta)
        io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 11:
            return internalGetLabels();
          case 12:
            return internalGetAnnotations();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 11:
            return internalGetMutableLabels();
          case 12:
            return internalGetMutableAnnotations();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.ObjectMeta.class, io.kubernetes.client.proto.Meta.ObjectMeta.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getCreationTimestampFieldBuilder();
          getDeletionTimestampFieldBuilder();
          getOwnerReferencesFieldBuilder();
          getManagedFieldsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        generateName_ = "";
        namespace_ = "";
        selfLink_ = "";
        uid_ = "";
        resourceVersion_ = "";
        generation_ = 0L;
        creationTimestamp_ = null;
        if (creationTimestampBuilder_ != null) {
          creationTimestampBuilder_.dispose();
          creationTimestampBuilder_ = null;
        }
        deletionTimestamp_ = null;
        if (deletionTimestampBuilder_ != null) {
          deletionTimestampBuilder_.dispose();
          deletionTimestampBuilder_ = null;
        }
        deletionGracePeriodSeconds_ = 0L;
        internalGetMutableLabels().clear();
        internalGetMutableAnnotations().clear();
        if (ownerReferencesBuilder_ == null) {
          ownerReferences_ = java.util.Collections.emptyList();
        } else {
          ownerReferences_ = null;
          ownerReferencesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00001000);
        finalizers_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        if (managedFieldsBuilder_ == null) {
          managedFields_ = java.util.Collections.emptyList();
        } else {
          managedFields_ = null;
          managedFieldsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ObjectMeta getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ObjectMeta build() {
        io.kubernetes.client.proto.Meta.ObjectMeta result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ObjectMeta buildPartial() {
        io.kubernetes.client.proto.Meta.ObjectMeta result = new io.kubernetes.client.proto.Meta.ObjectMeta(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.Meta.ObjectMeta result) {
        if (ownerReferencesBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0)) {
            ownerReferences_ = java.util.Collections.unmodifiableList(ownerReferences_);
            bitField0_ = (bitField0_ & ~0x00001000);
          }
          result.ownerReferences_ = ownerReferences_;
        } else {
          result.ownerReferences_ = ownerReferencesBuilder_.build();
        }
        if (managedFieldsBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0)) {
            managedFields_ = java.util.Collections.unmodifiableList(managedFields_);
            bitField0_ = (bitField0_ & ~0x00004000);
          }
          result.managedFields_ = managedFields_;
        } else {
          result.managedFields_ = managedFieldsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.ObjectMeta result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.generateName_ = generateName_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.namespace_ = namespace_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.selfLink_ = selfLink_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.uid_ = uid_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.resourceVersion_ = resourceVersion_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.generation_ = generation_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.creationTimestamp_ = creationTimestampBuilder_ == null
              ? creationTimestamp_
              : creationTimestampBuilder_.build();
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.deletionTimestamp_ = deletionTimestampBuilder_ == null
              ? deletionTimestamp_
              : deletionTimestampBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.deletionGracePeriodSeconds_ = deletionGracePeriodSeconds_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.labels_ = internalGetLabels();
          result.labels_.makeImmutable();
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.annotations_ = internalGetAnnotations();
          result.annotations_.makeImmutable();
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          finalizers_.makeImmutable();
          result.finalizers_ = finalizers_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.ObjectMeta) {
          return mergeFrom((io.kubernetes.client.proto.Meta.ObjectMeta)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.ObjectMeta other) {
        if (other == io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasGenerateName()) {
          generateName_ = other.generateName_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasNamespace()) {
          namespace_ = other.namespace_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasSelfLink()) {
          selfLink_ = other.selfLink_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasUid()) {
          uid_ = other.uid_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasResourceVersion()) {
          resourceVersion_ = other.resourceVersion_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (other.hasGeneration()) {
          setGeneration(other.getGeneration());
        }
        if (other.hasCreationTimestamp()) {
          mergeCreationTimestamp(other.getCreationTimestamp());
        }
        if (other.hasDeletionTimestamp()) {
          mergeDeletionTimestamp(other.getDeletionTimestamp());
        }
        if (other.hasDeletionGracePeriodSeconds()) {
          setDeletionGracePeriodSeconds(other.getDeletionGracePeriodSeconds());
        }
        internalGetMutableLabels().mergeFrom(
            other.internalGetLabels());
        bitField0_ |= 0x00000400;
        internalGetMutableAnnotations().mergeFrom(
            other.internalGetAnnotations());
        bitField0_ |= 0x00000800;
        if (ownerReferencesBuilder_ == null) {
          if (!other.ownerReferences_.isEmpty()) {
            if (ownerReferences_.isEmpty()) {
              ownerReferences_ = other.ownerReferences_;
              bitField0_ = (bitField0_ & ~0x00001000);
            } else {
              ensureOwnerReferencesIsMutable();
              ownerReferences_.addAll(other.ownerReferences_);
            }
            onChanged();
          }
        } else {
          if (!other.ownerReferences_.isEmpty()) {
            if (ownerReferencesBuilder_.isEmpty()) {
              ownerReferencesBuilder_.dispose();
              ownerReferencesBuilder_ = null;
              ownerReferences_ = other.ownerReferences_;
              bitField0_ = (bitField0_ & ~0x00001000);
              ownerReferencesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getOwnerReferencesFieldBuilder() : null;
            } else {
              ownerReferencesBuilder_.addAllMessages(other.ownerReferences_);
            }
          }
        }
        if (!other.finalizers_.isEmpty()) {
          if (finalizers_.isEmpty()) {
            finalizers_ = other.finalizers_;
            bitField0_ |= 0x00002000;
          } else {
            ensureFinalizersIsMutable();
            finalizers_.addAll(other.finalizers_);
          }
          onChanged();
        }
        if (managedFieldsBuilder_ == null) {
          if (!other.managedFields_.isEmpty()) {
            if (managedFields_.isEmpty()) {
              managedFields_ = other.managedFields_;
              bitField0_ = (bitField0_ & ~0x00004000);
            } else {
              ensureManagedFieldsIsMutable();
              managedFields_.addAll(other.managedFields_);
            }
            onChanged();
          }
        } else {
          if (!other.managedFields_.isEmpty()) {
            if (managedFieldsBuilder_.isEmpty()) {
              managedFieldsBuilder_.dispose();
              managedFieldsBuilder_ = null;
              managedFields_ = other.managedFields_;
              bitField0_ = (bitField0_ & ~0x00004000);
              managedFieldsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getManagedFieldsFieldBuilder() : null;
            } else {
              managedFieldsBuilder_.addAllMessages(other.managedFields_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                generateName_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                namespace_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                selfLink_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                uid_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                resourceVersion_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 56: {
                generation_ = input.readInt64();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 66: {
                input.readMessage(
                    getCreationTimestampFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              case 74: {
                input.readMessage(
                    getDeletionTimestampFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 74
              case 80: {
                deletionGracePeriodSeconds_ = input.readInt64();
                bitField0_ |= 0x00000200;
                break;
              } // case 80
              case 90: {
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                labels__ = input.readMessage(
                    LabelsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                internalGetMutableLabels().getMutableMap().put(
                    labels__.getKey(), labels__.getValue());
                bitField0_ |= 0x00000400;
                break;
              } // case 90
              case 98: {
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                annotations__ = input.readMessage(
                    AnnotationsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                internalGetMutableAnnotations().getMutableMap().put(
                    annotations__.getKey(), annotations__.getValue());
                bitField0_ |= 0x00000800;
                break;
              } // case 98
              case 106: {
                io.kubernetes.client.proto.Meta.OwnerReference m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.OwnerReference.parser(),
                        extensionRegistry);
                if (ownerReferencesBuilder_ == null) {
                  ensureOwnerReferencesIsMutable();
                  ownerReferences_.add(m);
                } else {
                  ownerReferencesBuilder_.addMessage(m);
                }
                break;
              } // case 106
              case 114: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureFinalizersIsMutable();
                finalizers_.add(bs);
                break;
              } // case 114
              case 138: {
                io.kubernetes.client.proto.Meta.ManagedFieldsEntry m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ManagedFieldsEntry.parser(),
                        extensionRegistry);
                if (managedFieldsBuilder_ == null) {
                  ensureManagedFieldsIsMutable();
                  managedFields_.add(m);
                } else {
                  managedFieldsBuilder_.addMessage(m);
                }
                break;
              } // case 138
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name must be unique within a namespace. Is required when creating resources, although
       * some resources may allow a client to request the generation of an appropriate name
       * automatically. Name is primarily intended for creation idempotence and configuration
       * definition.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Name must be unique within a namespace. Is required when creating resources, although
       * some resources may allow a client to request the generation of an appropriate name
       * automatically. Name is primarily intended for creation idempotence and configuration
       * definition.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name must be unique within a namespace. Is required when creating resources, although
       * some resources may allow a client to request the generation of an appropriate name
       * automatically. Name is primarily intended for creation idempotence and configuration
       * definition.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name must be unique within a namespace. Is required when creating resources, although
       * some resources may allow a client to request the generation of an appropriate name
       * automatically. Name is primarily intended for creation idempotence and configuration
       * definition.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name must be unique within a namespace. Is required when creating resources, although
       * some resources may allow a client to request the generation of an appropriate name
       * automatically. Name is primarily intended for creation idempotence and configuration
       * definition.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name must be unique within a namespace. Is required when creating resources, although
       * some resources may allow a client to request the generation of an appropriate name
       * automatically. Name is primarily intended for creation idempotence and configuration
       * definition.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object generateName_ = "";
      /**
       * <pre>
       * GenerateName is an optional prefix, used by the server, to generate a unique
       * name ONLY IF the Name field has not been provided.
       * If this field is used, the name returned to the client will be different
       * than the name passed. This value will also be combined with a unique suffix.
       * The provided value has the same validation rules as the Name field,
       * and may be truncated by the length of the suffix required to make the value
       * unique on the server.
       *
       * If this field is specified and the generated name exists, the server will return a 409.
       *
       * Applied only if Name is not specified.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
       * +optional
       * </pre>
       *
       * <code>optional string generateName = 2;</code>
       * @return Whether the generateName field is set.
       */
      public boolean hasGenerateName() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * GenerateName is an optional prefix, used by the server, to generate a unique
       * name ONLY IF the Name field has not been provided.
       * If this field is used, the name returned to the client will be different
       * than the name passed. This value will also be combined with a unique suffix.
       * The provided value has the same validation rules as the Name field,
       * and may be truncated by the length of the suffix required to make the value
       * unique on the server.
       *
       * If this field is specified and the generated name exists, the server will return a 409.
       *
       * Applied only if Name is not specified.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
       * +optional
       * </pre>
       *
       * <code>optional string generateName = 2;</code>
       * @return The generateName.
       */
      public java.lang.String getGenerateName() {
        java.lang.Object ref = generateName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            generateName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * GenerateName is an optional prefix, used by the server, to generate a unique
       * name ONLY IF the Name field has not been provided.
       * If this field is used, the name returned to the client will be different
       * than the name passed. This value will also be combined with a unique suffix.
       * The provided value has the same validation rules as the Name field,
       * and may be truncated by the length of the suffix required to make the value
       * unique on the server.
       *
       * If this field is specified and the generated name exists, the server will return a 409.
       *
       * Applied only if Name is not specified.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
       * +optional
       * </pre>
       *
       * <code>optional string generateName = 2;</code>
       * @return The bytes for generateName.
       */
      public com.google.protobuf.ByteString
          getGenerateNameBytes() {
        java.lang.Object ref = generateName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          generateName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * GenerateName is an optional prefix, used by the server, to generate a unique
       * name ONLY IF the Name field has not been provided.
       * If this field is used, the name returned to the client will be different
       * than the name passed. This value will also be combined with a unique suffix.
       * The provided value has the same validation rules as the Name field,
       * and may be truncated by the length of the suffix required to make the value
       * unique on the server.
       *
       * If this field is specified and the generated name exists, the server will return a 409.
       *
       * Applied only if Name is not specified.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
       * +optional
       * </pre>
       *
       * <code>optional string generateName = 2;</code>
       * @param value The generateName to set.
       * @return This builder for chaining.
       */
      public Builder setGenerateName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        generateName_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * GenerateName is an optional prefix, used by the server, to generate a unique
       * name ONLY IF the Name field has not been provided.
       * If this field is used, the name returned to the client will be different
       * than the name passed. This value will also be combined with a unique suffix.
       * The provided value has the same validation rules as the Name field,
       * and may be truncated by the length of the suffix required to make the value
       * unique on the server.
       *
       * If this field is specified and the generated name exists, the server will return a 409.
       *
       * Applied only if Name is not specified.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
       * +optional
       * </pre>
       *
       * <code>optional string generateName = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearGenerateName() {
        generateName_ = getDefaultInstance().getGenerateName();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * GenerateName is an optional prefix, used by the server, to generate a unique
       * name ONLY IF the Name field has not been provided.
       * If this field is used, the name returned to the client will be different
       * than the name passed. This value will also be combined with a unique suffix.
       * The provided value has the same validation rules as the Name field,
       * and may be truncated by the length of the suffix required to make the value
       * unique on the server.
       *
       * If this field is specified and the generated name exists, the server will return a 409.
       *
       * Applied only if Name is not specified.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
       * +optional
       * </pre>
       *
       * <code>optional string generateName = 2;</code>
       * @param value The bytes for generateName to set.
       * @return This builder for chaining.
       */
      public Builder setGenerateNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        generateName_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object namespace_ = "";
      /**
       * <pre>
       * Namespace defines the space within which each name must be unique. An empty namespace is
       * equivalent to the "default" namespace, but "default" is the canonical representation.
       * Not all objects are required to be scoped to a namespace - the value of this field for
       * those objects will be empty.
       *
       * Must be a DNS_LABEL.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 3;</code>
       * @return Whether the namespace field is set.
       */
      public boolean hasNamespace() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Namespace defines the space within which each name must be unique. An empty namespace is
       * equivalent to the "default" namespace, but "default" is the canonical representation.
       * Not all objects are required to be scoped to a namespace - the value of this field for
       * those objects will be empty.
       *
       * Must be a DNS_LABEL.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 3;</code>
       * @return The namespace.
       */
      public java.lang.String getNamespace() {
        java.lang.Object ref = namespace_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            namespace_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Namespace defines the space within which each name must be unique. An empty namespace is
       * equivalent to the "default" namespace, but "default" is the canonical representation.
       * Not all objects are required to be scoped to a namespace - the value of this field for
       * those objects will be empty.
       *
       * Must be a DNS_LABEL.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 3;</code>
       * @return The bytes for namespace.
       */
      public com.google.protobuf.ByteString
          getNamespaceBytes() {
        java.lang.Object ref = namespace_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          namespace_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Namespace defines the space within which each name must be unique. An empty namespace is
       * equivalent to the "default" namespace, but "default" is the canonical representation.
       * Not all objects are required to be scoped to a namespace - the value of this field for
       * those objects will be empty.
       *
       * Must be a DNS_LABEL.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 3;</code>
       * @param value The namespace to set.
       * @return This builder for chaining.
       */
      public Builder setNamespace(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        namespace_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Namespace defines the space within which each name must be unique. An empty namespace is
       * equivalent to the "default" namespace, but "default" is the canonical representation.
       * Not all objects are required to be scoped to a namespace - the value of this field for
       * those objects will be empty.
       *
       * Must be a DNS_LABEL.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNamespace() {
        namespace_ = getDefaultInstance().getNamespace();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Namespace defines the space within which each name must be unique. An empty namespace is
       * equivalent to the "default" namespace, but "default" is the canonical representation.
       * Not all objects are required to be scoped to a namespace - the value of this field for
       * those objects will be empty.
       *
       * Must be a DNS_LABEL.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 3;</code>
       * @param value The bytes for namespace to set.
       * @return This builder for chaining.
       */
      public Builder setNamespaceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        namespace_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object selfLink_ = "";
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 4;</code>
       * @return Whether the selfLink field is set.
       */
      public boolean hasSelfLink() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 4;</code>
       * @return The selfLink.
       */
      public java.lang.String getSelfLink() {
        java.lang.Object ref = selfLink_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            selfLink_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 4;</code>
       * @return The bytes for selfLink.
       */
      public com.google.protobuf.ByteString
          getSelfLinkBytes() {
        java.lang.Object ref = selfLink_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          selfLink_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 4;</code>
       * @param value The selfLink to set.
       * @return This builder for chaining.
       */
      public Builder setSelfLink(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        selfLink_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSelfLink() {
        selfLink_ = getDefaultInstance().getSelfLink();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       * +optional
       * </pre>
       *
       * <code>optional string selfLink = 4;</code>
       * @param value The bytes for selfLink to set.
       * @return This builder for chaining.
       */
      public Builder setSelfLinkBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        selfLink_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object uid_ = "";
      /**
       * <pre>
       * UID is the unique in time and space value for this object. It is typically generated by
       * the server on successful creation of a resource and is not allowed to change on PUT
       * operations.
       *
       * Populated by the system.
       * Read-only.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 5;</code>
       * @return Whether the uid field is set.
       */
      public boolean hasUid() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * UID is the unique in time and space value for this object. It is typically generated by
       * the server on successful creation of a resource and is not allowed to change on PUT
       * operations.
       *
       * Populated by the system.
       * Read-only.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 5;</code>
       * @return The uid.
       */
      public java.lang.String getUid() {
        java.lang.Object ref = uid_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            uid_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * UID is the unique in time and space value for this object. It is typically generated by
       * the server on successful creation of a resource and is not allowed to change on PUT
       * operations.
       *
       * Populated by the system.
       * Read-only.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 5;</code>
       * @return The bytes for uid.
       */
      public com.google.protobuf.ByteString
          getUidBytes() {
        java.lang.Object ref = uid_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          uid_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * UID is the unique in time and space value for this object. It is typically generated by
       * the server on successful creation of a resource and is not allowed to change on PUT
       * operations.
       *
       * Populated by the system.
       * Read-only.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 5;</code>
       * @param value The uid to set.
       * @return This builder for chaining.
       */
      public Builder setUid(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        uid_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UID is the unique in time and space value for this object. It is typically generated by
       * the server on successful creation of a resource and is not allowed to change on PUT
       * operations.
       *
       * Populated by the system.
       * Read-only.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearUid() {
        uid_ = getDefaultInstance().getUid();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UID is the unique in time and space value for this object. It is typically generated by
       * the server on successful creation of a resource and is not allowed to change on PUT
       * operations.
       *
       * Populated by the system.
       * Read-only.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 5;</code>
       * @param value The bytes for uid to set.
       * @return This builder for chaining.
       */
      public Builder setUidBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        uid_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object resourceVersion_ = "";
      /**
       * <pre>
       * An opaque value that represents the internal version of this object that can
       * be used by clients to determine when objects have changed. May be used for optimistic
       * concurrency, change detection, and the watch operation on a resource or set of resources.
       * Clients must treat these values as opaque and passed unmodified back to the server.
       * They may only be valid for a particular resource or set of resources.
       *
       * Populated by the system.
       * Read-only.
       * Value must be treated as opaque by clients and .
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 6;</code>
       * @return Whether the resourceVersion field is set.
       */
      public boolean hasResourceVersion() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * An opaque value that represents the internal version of this object that can
       * be used by clients to determine when objects have changed. May be used for optimistic
       * concurrency, change detection, and the watch operation on a resource or set of resources.
       * Clients must treat these values as opaque and passed unmodified back to the server.
       * They may only be valid for a particular resource or set of resources.
       *
       * Populated by the system.
       * Read-only.
       * Value must be treated as opaque by clients and .
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 6;</code>
       * @return The resourceVersion.
       */
      public java.lang.String getResourceVersion() {
        java.lang.Object ref = resourceVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            resourceVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * An opaque value that represents the internal version of this object that can
       * be used by clients to determine when objects have changed. May be used for optimistic
       * concurrency, change detection, and the watch operation on a resource or set of resources.
       * Clients must treat these values as opaque and passed unmodified back to the server.
       * They may only be valid for a particular resource or set of resources.
       *
       * Populated by the system.
       * Read-only.
       * Value must be treated as opaque by clients and .
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 6;</code>
       * @return The bytes for resourceVersion.
       */
      public com.google.protobuf.ByteString
          getResourceVersionBytes() {
        java.lang.Object ref = resourceVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resourceVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * An opaque value that represents the internal version of this object that can
       * be used by clients to determine when objects have changed. May be used for optimistic
       * concurrency, change detection, and the watch operation on a resource or set of resources.
       * Clients must treat these values as opaque and passed unmodified back to the server.
       * They may only be valid for a particular resource or set of resources.
       *
       * Populated by the system.
       * Read-only.
       * Value must be treated as opaque by clients and .
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 6;</code>
       * @param value The resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An opaque value that represents the internal version of this object that can
       * be used by clients to determine when objects have changed. May be used for optimistic
       * concurrency, change detection, and the watch operation on a resource or set of resources.
       * Clients must treat these values as opaque and passed unmodified back to the server.
       * They may only be valid for a particular resource or set of resources.
       *
       * Populated by the system.
       * Read-only.
       * Value must be treated as opaque by clients and .
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceVersion() {
        resourceVersion_ = getDefaultInstance().getResourceVersion();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An opaque value that represents the internal version of this object that can
       * be used by clients to determine when objects have changed. May be used for optimistic
       * concurrency, change detection, and the watch operation on a resource or set of resources.
       * Clients must treat these values as opaque and passed unmodified back to the server.
       * They may only be valid for a particular resource or set of resources.
       *
       * Populated by the system.
       * Read-only.
       * Value must be treated as opaque by clients and .
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 6;</code>
       * @param value The bytes for resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private long generation_ ;
      /**
       * <pre>
       * A sequence number representing a specific generation of the desired state.
       * Populated by the system. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional int64 generation = 7;</code>
       * @return Whether the generation field is set.
       */
      @java.lang.Override
      public boolean hasGeneration() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * A sequence number representing a specific generation of the desired state.
       * Populated by the system. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional int64 generation = 7;</code>
       * @return The generation.
       */
      @java.lang.Override
      public long getGeneration() {
        return generation_;
      }
      /**
       * <pre>
       * A sequence number representing a specific generation of the desired state.
       * Populated by the system. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional int64 generation = 7;</code>
       * @param value The generation to set.
       * @return This builder for chaining.
       */
      public Builder setGeneration(long value) {

        generation_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A sequence number representing a specific generation of the desired state.
       * Populated by the system. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional int64 generation = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearGeneration() {
        bitField0_ = (bitField0_ & ~0x00000040);
        generation_ = 0L;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time creationTimestamp_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> creationTimestampBuilder_;
      /**
       * <pre>
       * CreationTimestamp is a timestamp representing the server time when this object was
       * created. It is not guaranteed to be set in happens-before order across separate operations.
       * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       * Populated by the system.
       * Read-only.
       * Null for lists.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
       * @return Whether the creationTimestamp field is set.
       */
      public boolean hasCreationTimestamp() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * CreationTimestamp is a timestamp representing the server time when this object was
       * created. It is not guaranteed to be set in happens-before order across separate operations.
       * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       * Populated by the system.
       * Read-only.
       * Null for lists.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
       * @return The creationTimestamp.
       */
      public io.kubernetes.client.proto.Meta.Time getCreationTimestamp() {
        if (creationTimestampBuilder_ == null) {
          return creationTimestamp_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : creationTimestamp_;
        } else {
          return creationTimestampBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * CreationTimestamp is a timestamp representing the server time when this object was
       * created. It is not guaranteed to be set in happens-before order across separate operations.
       * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       * Populated by the system.
       * Read-only.
       * Null for lists.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
       */
      public Builder setCreationTimestamp(io.kubernetes.client.proto.Meta.Time value) {
        if (creationTimestampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          creationTimestamp_ = value;
        } else {
          creationTimestampBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * CreationTimestamp is a timestamp representing the server time when this object was
       * created. It is not guaranteed to be set in happens-before order across separate operations.
       * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       * Populated by the system.
       * Read-only.
       * Null for lists.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
       */
      public Builder setCreationTimestamp(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (creationTimestampBuilder_ == null) {
          creationTimestamp_ = builderForValue.build();
        } else {
          creationTimestampBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * CreationTimestamp is a timestamp representing the server time when this object was
       * created. It is not guaranteed to be set in happens-before order across separate operations.
       * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       * Populated by the system.
       * Read-only.
       * Null for lists.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
       */
      public Builder mergeCreationTimestamp(io.kubernetes.client.proto.Meta.Time value) {
        if (creationTimestampBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
            creationTimestamp_ != null &&
            creationTimestamp_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getCreationTimestampBuilder().mergeFrom(value);
          } else {
            creationTimestamp_ = value;
          }
        } else {
          creationTimestampBuilder_.mergeFrom(value);
        }
        if (creationTimestamp_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * CreationTimestamp is a timestamp representing the server time when this object was
       * created. It is not guaranteed to be set in happens-before order across separate operations.
       * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       * Populated by the system.
       * Read-only.
       * Null for lists.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
       */
      public Builder clearCreationTimestamp() {
        bitField0_ = (bitField0_ & ~0x00000080);
        creationTimestamp_ = null;
        if (creationTimestampBuilder_ != null) {
          creationTimestampBuilder_.dispose();
          creationTimestampBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * CreationTimestamp is a timestamp representing the server time when this object was
       * created. It is not guaranteed to be set in happens-before order across separate operations.
       * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       * Populated by the system.
       * Read-only.
       * Null for lists.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getCreationTimestampBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getCreationTimestampFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * CreationTimestamp is a timestamp representing the server time when this object was
       * created. It is not guaranteed to be set in happens-before order across separate operations.
       * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       * Populated by the system.
       * Read-only.
       * Null for lists.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getCreationTimestampOrBuilder() {
        if (creationTimestampBuilder_ != null) {
          return creationTimestampBuilder_.getMessageOrBuilder();
        } else {
          return creationTimestamp_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : creationTimestamp_;
        }
      }
      /**
       * <pre>
       * CreationTimestamp is a timestamp representing the server time when this object was
       * created. It is not guaranteed to be set in happens-before order across separate operations.
       * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       * Populated by the system.
       * Read-only.
       * Null for lists.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getCreationTimestampFieldBuilder() {
        if (creationTimestampBuilder_ == null) {
          creationTimestampBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getCreationTimestamp(),
                  getParentForChildren(),
                  isClean());
          creationTimestamp_ = null;
        }
        return creationTimestampBuilder_;
      }

      private io.kubernetes.client.proto.Meta.Time deletionTimestamp_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> deletionTimestampBuilder_;
      /**
       * <pre>
       * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       * field is set by the server when a graceful deletion is requested by the user, and is not
       * directly settable by a client. The resource is expected to be deleted (no longer visible
       * from resource lists, and not reachable by name) after the time in this field, once the
       * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       * Once the deletionTimestamp is set, this value may not be unset or be set further into the
       * future, although it may be shortened or the resource may be deleted prior to this time.
       * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       * remove the pod from the API. In the presence of network partitions, this object may still
       * exist after this timestamp, until an administrator or automated process can determine the
       * resource is fully terminated.
       * If not set, graceful deletion of the object has not been requested.
       *
       * Populated by the system when a graceful deletion is requested.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
       * @return Whether the deletionTimestamp field is set.
       */
      public boolean hasDeletionTimestamp() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       * field is set by the server when a graceful deletion is requested by the user, and is not
       * directly settable by a client. The resource is expected to be deleted (no longer visible
       * from resource lists, and not reachable by name) after the time in this field, once the
       * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       * Once the deletionTimestamp is set, this value may not be unset or be set further into the
       * future, although it may be shortened or the resource may be deleted prior to this time.
       * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       * remove the pod from the API. In the presence of network partitions, this object may still
       * exist after this timestamp, until an administrator or automated process can determine the
       * resource is fully terminated.
       * If not set, graceful deletion of the object has not been requested.
       *
       * Populated by the system when a graceful deletion is requested.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
       * @return The deletionTimestamp.
       */
      public io.kubernetes.client.proto.Meta.Time getDeletionTimestamp() {
        if (deletionTimestampBuilder_ == null) {
          return deletionTimestamp_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : deletionTimestamp_;
        } else {
          return deletionTimestampBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       * field is set by the server when a graceful deletion is requested by the user, and is not
       * directly settable by a client. The resource is expected to be deleted (no longer visible
       * from resource lists, and not reachable by name) after the time in this field, once the
       * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       * Once the deletionTimestamp is set, this value may not be unset or be set further into the
       * future, although it may be shortened or the resource may be deleted prior to this time.
       * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       * remove the pod from the API. In the presence of network partitions, this object may still
       * exist after this timestamp, until an administrator or automated process can determine the
       * resource is fully terminated.
       * If not set, graceful deletion of the object has not been requested.
       *
       * Populated by the system when a graceful deletion is requested.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
       */
      public Builder setDeletionTimestamp(io.kubernetes.client.proto.Meta.Time value) {
        if (deletionTimestampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          deletionTimestamp_ = value;
        } else {
          deletionTimestampBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       * field is set by the server when a graceful deletion is requested by the user, and is not
       * directly settable by a client. The resource is expected to be deleted (no longer visible
       * from resource lists, and not reachable by name) after the time in this field, once the
       * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       * Once the deletionTimestamp is set, this value may not be unset or be set further into the
       * future, although it may be shortened or the resource may be deleted prior to this time.
       * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       * remove the pod from the API. In the presence of network partitions, this object may still
       * exist after this timestamp, until an administrator or automated process can determine the
       * resource is fully terminated.
       * If not set, graceful deletion of the object has not been requested.
       *
       * Populated by the system when a graceful deletion is requested.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
       */
      public Builder setDeletionTimestamp(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (deletionTimestampBuilder_ == null) {
          deletionTimestamp_ = builderForValue.build();
        } else {
          deletionTimestampBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       * field is set by the server when a graceful deletion is requested by the user, and is not
       * directly settable by a client. The resource is expected to be deleted (no longer visible
       * from resource lists, and not reachable by name) after the time in this field, once the
       * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       * Once the deletionTimestamp is set, this value may not be unset or be set further into the
       * future, although it may be shortened or the resource may be deleted prior to this time.
       * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       * remove the pod from the API. In the presence of network partitions, this object may still
       * exist after this timestamp, until an administrator or automated process can determine the
       * resource is fully terminated.
       * If not set, graceful deletion of the object has not been requested.
       *
       * Populated by the system when a graceful deletion is requested.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
       */
      public Builder mergeDeletionTimestamp(io.kubernetes.client.proto.Meta.Time value) {
        if (deletionTimestampBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
            deletionTimestamp_ != null &&
            deletionTimestamp_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getDeletionTimestampBuilder().mergeFrom(value);
          } else {
            deletionTimestamp_ = value;
          }
        } else {
          deletionTimestampBuilder_.mergeFrom(value);
        }
        if (deletionTimestamp_ != null) {
          bitField0_ |= 0x00000100;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       * field is set by the server when a graceful deletion is requested by the user, and is not
       * directly settable by a client. The resource is expected to be deleted (no longer visible
       * from resource lists, and not reachable by name) after the time in this field, once the
       * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       * Once the deletionTimestamp is set, this value may not be unset or be set further into the
       * future, although it may be shortened or the resource may be deleted prior to this time.
       * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       * remove the pod from the API. In the presence of network partitions, this object may still
       * exist after this timestamp, until an administrator or automated process can determine the
       * resource is fully terminated.
       * If not set, graceful deletion of the object has not been requested.
       *
       * Populated by the system when a graceful deletion is requested.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
       */
      public Builder clearDeletionTimestamp() {
        bitField0_ = (bitField0_ & ~0x00000100);
        deletionTimestamp_ = null;
        if (deletionTimestampBuilder_ != null) {
          deletionTimestampBuilder_.dispose();
          deletionTimestampBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       * field is set by the server when a graceful deletion is requested by the user, and is not
       * directly settable by a client. The resource is expected to be deleted (no longer visible
       * from resource lists, and not reachable by name) after the time in this field, once the
       * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       * Once the deletionTimestamp is set, this value may not be unset or be set further into the
       * future, although it may be shortened or the resource may be deleted prior to this time.
       * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       * remove the pod from the API. In the presence of network partitions, this object may still
       * exist after this timestamp, until an administrator or automated process can determine the
       * resource is fully terminated.
       * If not set, graceful deletion of the object has not been requested.
       *
       * Populated by the system when a graceful deletion is requested.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getDeletionTimestampBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getDeletionTimestampFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       * field is set by the server when a graceful deletion is requested by the user, and is not
       * directly settable by a client. The resource is expected to be deleted (no longer visible
       * from resource lists, and not reachable by name) after the time in this field, once the
       * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       * Once the deletionTimestamp is set, this value may not be unset or be set further into the
       * future, although it may be shortened or the resource may be deleted prior to this time.
       * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       * remove the pod from the API. In the presence of network partitions, this object may still
       * exist after this timestamp, until an administrator or automated process can determine the
       * resource is fully terminated.
       * If not set, graceful deletion of the object has not been requested.
       *
       * Populated by the system when a graceful deletion is requested.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getDeletionTimestampOrBuilder() {
        if (deletionTimestampBuilder_ != null) {
          return deletionTimestampBuilder_.getMessageOrBuilder();
        } else {
          return deletionTimestamp_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : deletionTimestamp_;
        }
      }
      /**
       * <pre>
       * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       * field is set by the server when a graceful deletion is requested by the user, and is not
       * directly settable by a client. The resource is expected to be deleted (no longer visible
       * from resource lists, and not reachable by name) after the time in this field, once the
       * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       * Once the deletionTimestamp is set, this value may not be unset or be set further into the
       * future, although it may be shortened or the resource may be deleted prior to this time.
       * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       * remove the pod from the API. In the presence of network partitions, this object may still
       * exist after this timestamp, until an administrator or automated process can determine the
       * resource is fully terminated.
       * If not set, graceful deletion of the object has not been requested.
       *
       * Populated by the system when a graceful deletion is requested.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getDeletionTimestampFieldBuilder() {
        if (deletionTimestampBuilder_ == null) {
          deletionTimestampBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getDeletionTimestamp(),
                  getParentForChildren(),
                  isClean());
          deletionTimestamp_ = null;
        }
        return deletionTimestampBuilder_;
      }

      private long deletionGracePeriodSeconds_ ;
      /**
       * <pre>
       * Number of seconds allowed for this object to gracefully terminate before
       * it will be removed from the system. Only set when deletionTimestamp is also set.
       * May only be shortened.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional int64 deletionGracePeriodSeconds = 10;</code>
       * @return Whether the deletionGracePeriodSeconds field is set.
       */
      @java.lang.Override
      public boolean hasDeletionGracePeriodSeconds() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Number of seconds allowed for this object to gracefully terminate before
       * it will be removed from the system. Only set when deletionTimestamp is also set.
       * May only be shortened.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional int64 deletionGracePeriodSeconds = 10;</code>
       * @return The deletionGracePeriodSeconds.
       */
      @java.lang.Override
      public long getDeletionGracePeriodSeconds() {
        return deletionGracePeriodSeconds_;
      }
      /**
       * <pre>
       * Number of seconds allowed for this object to gracefully terminate before
       * it will be removed from the system. Only set when deletionTimestamp is also set.
       * May only be shortened.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional int64 deletionGracePeriodSeconds = 10;</code>
       * @param value The deletionGracePeriodSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setDeletionGracePeriodSeconds(long value) {

        deletionGracePeriodSeconds_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of seconds allowed for this object to gracefully terminate before
       * it will be removed from the system. Only set when deletionTimestamp is also set.
       * May only be shortened.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional int64 deletionGracePeriodSeconds = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeletionGracePeriodSeconds() {
        bitField0_ = (bitField0_ & ~0x00000200);
        deletionGracePeriodSeconds_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> labels_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetLabels() {
        if (labels_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              LabelsDefaultEntryHolder.defaultEntry);
        }
        return labels_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMutableLabels() {
        if (labels_ == null) {
          labels_ = com.google.protobuf.MapField.newMapField(
              LabelsDefaultEntryHolder.defaultEntry);
        }
        if (!labels_.isMutable()) {
          labels_ = labels_.copy();
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return labels_;
      }
      public int getLabelsCount() {
        return internalGetLabels().getMap().size();
      }
      /**
       * <pre>
       * Map of string keys and values that can be used to organize and categorize
       * (scope and select) objects. May match selectors of replication controllers
       * and services.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; labels = 11;</code>
       */
      @java.lang.Override
      public boolean containsLabels(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetLabels().getMap().containsKey(key);
      }
      /**
       * Use {@link #getLabelsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getLabels() {
        return getLabelsMap();
      }
      /**
       * <pre>
       * Map of string keys and values that can be used to organize and categorize
       * (scope and select) objects. May match selectors of replication controllers
       * and services.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; labels = 11;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.String> getLabelsMap() {
        return internalGetLabels().getMap();
      }
      /**
       * <pre>
       * Map of string keys and values that can be used to organize and categorize
       * (scope and select) objects. May match selectors of replication controllers
       * and services.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; labels = 11;</code>
       */
      @java.lang.Override
      public /* nullable */
java.lang.String getLabelsOrDefault(
          java.lang.String key,
          /* nullable */
java.lang.String defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetLabels().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Map of string keys and values that can be used to organize and categorize
       * (scope and select) objects. May match selectors of replication controllers
       * and services.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; labels = 11;</code>
       */
      @java.lang.Override
      public java.lang.String getLabelsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetLabels().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      public Builder clearLabels() {
        bitField0_ = (bitField0_ & ~0x00000400);
        internalGetMutableLabels().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Map of string keys and values that can be used to organize and categorize
       * (scope and select) objects. May match selectors of replication controllers
       * and services.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; labels = 11;</code>
       */
      public Builder removeLabels(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableLabels().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
          getMutableLabels() {
        bitField0_ |= 0x00000400;
        return internalGetMutableLabels().getMutableMap();
      }
      /**
       * <pre>
       * Map of string keys and values that can be used to organize and categorize
       * (scope and select) objects. May match selectors of replication controllers
       * and services.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; labels = 11;</code>
       */
      public Builder putLabels(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) { throw new NullPointerException("map value"); }
        internalGetMutableLabels().getMutableMap()
            .put(key, value);
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * Map of string keys and values that can be used to organize and categorize
       * (scope and select) objects. May match selectors of replication controllers
       * and services.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; labels = 11;</code>
       */
      public Builder putAllLabels(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableLabels().getMutableMap()
            .putAll(values);
        bitField0_ |= 0x00000400;
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> annotations_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetAnnotations() {
        if (annotations_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              AnnotationsDefaultEntryHolder.defaultEntry);
        }
        return annotations_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMutableAnnotations() {
        if (annotations_ == null) {
          annotations_ = com.google.protobuf.MapField.newMapField(
              AnnotationsDefaultEntryHolder.defaultEntry);
        }
        if (!annotations_.isMutable()) {
          annotations_ = annotations_.copy();
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return annotations_;
      }
      public int getAnnotationsCount() {
        return internalGetAnnotations().getMap().size();
      }
      /**
       * <pre>
       * Annotations is an unstructured key value map stored with a resource that may be
       * set by external tools to store and retrieve arbitrary metadata. They are not
       * queryable and should be preserved when modifying objects.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; annotations = 12;</code>
       */
      @java.lang.Override
      public boolean containsAnnotations(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetAnnotations().getMap().containsKey(key);
      }
      /**
       * Use {@link #getAnnotationsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getAnnotations() {
        return getAnnotationsMap();
      }
      /**
       * <pre>
       * Annotations is an unstructured key value map stored with a resource that may be
       * set by external tools to store and retrieve arbitrary metadata. They are not
       * queryable and should be preserved when modifying objects.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; annotations = 12;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.String> getAnnotationsMap() {
        return internalGetAnnotations().getMap();
      }
      /**
       * <pre>
       * Annotations is an unstructured key value map stored with a resource that may be
       * set by external tools to store and retrieve arbitrary metadata. They are not
       * queryable and should be preserved when modifying objects.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; annotations = 12;</code>
       */
      @java.lang.Override
      public /* nullable */
java.lang.String getAnnotationsOrDefault(
          java.lang.String key,
          /* nullable */
java.lang.String defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetAnnotations().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Annotations is an unstructured key value map stored with a resource that may be
       * set by external tools to store and retrieve arbitrary metadata. They are not
       * queryable and should be preserved when modifying objects.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; annotations = 12;</code>
       */
      @java.lang.Override
      public java.lang.String getAnnotationsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetAnnotations().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      public Builder clearAnnotations() {
        bitField0_ = (bitField0_ & ~0x00000800);
        internalGetMutableAnnotations().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Annotations is an unstructured key value map stored with a resource that may be
       * set by external tools to store and retrieve arbitrary metadata. They are not
       * queryable and should be preserved when modifying objects.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; annotations = 12;</code>
       */
      public Builder removeAnnotations(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableAnnotations().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
          getMutableAnnotations() {
        bitField0_ |= 0x00000800;
        return internalGetMutableAnnotations().getMutableMap();
      }
      /**
       * <pre>
       * Annotations is an unstructured key value map stored with a resource that may be
       * set by external tools to store and retrieve arbitrary metadata. They are not
       * queryable and should be preserved when modifying objects.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; annotations = 12;</code>
       */
      public Builder putAnnotations(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) { throw new NullPointerException("map value"); }
        internalGetMutableAnnotations().getMutableMap()
            .put(key, value);
        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       * <pre>
       * Annotations is an unstructured key value map stored with a resource that may be
       * set by external tools to store and retrieve arbitrary metadata. They are not
       * queryable and should be preserved when modifying objects.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; annotations = 12;</code>
       */
      public Builder putAllAnnotations(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableAnnotations().getMutableMap()
            .putAll(values);
        bitField0_ |= 0x00000800;
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.OwnerReference> ownerReferences_ =
        java.util.Collections.emptyList();
      private void ensureOwnerReferencesIsMutable() {
        if (!((bitField0_ & 0x00001000) != 0)) {
          ownerReferences_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.OwnerReference>(ownerReferences_);
          bitField0_ |= 0x00001000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.OwnerReference, io.kubernetes.client.proto.Meta.OwnerReference.Builder, io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder> ownerReferencesBuilder_;

      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.OwnerReference> getOwnerReferencesList() {
        if (ownerReferencesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ownerReferences_);
        } else {
          return ownerReferencesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public int getOwnerReferencesCount() {
        if (ownerReferencesBuilder_ == null) {
          return ownerReferences_.size();
        } else {
          return ownerReferencesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public io.kubernetes.client.proto.Meta.OwnerReference getOwnerReferences(int index) {
        if (ownerReferencesBuilder_ == null) {
          return ownerReferences_.get(index);
        } else {
          return ownerReferencesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public Builder setOwnerReferences(
          int index, io.kubernetes.client.proto.Meta.OwnerReference value) {
        if (ownerReferencesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOwnerReferencesIsMutable();
          ownerReferences_.set(index, value);
          onChanged();
        } else {
          ownerReferencesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public Builder setOwnerReferences(
          int index, io.kubernetes.client.proto.Meta.OwnerReference.Builder builderForValue) {
        if (ownerReferencesBuilder_ == null) {
          ensureOwnerReferencesIsMutable();
          ownerReferences_.set(index, builderForValue.build());
          onChanged();
        } else {
          ownerReferencesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public Builder addOwnerReferences(io.kubernetes.client.proto.Meta.OwnerReference value) {
        if (ownerReferencesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOwnerReferencesIsMutable();
          ownerReferences_.add(value);
          onChanged();
        } else {
          ownerReferencesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public Builder addOwnerReferences(
          int index, io.kubernetes.client.proto.Meta.OwnerReference value) {
        if (ownerReferencesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOwnerReferencesIsMutable();
          ownerReferences_.add(index, value);
          onChanged();
        } else {
          ownerReferencesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public Builder addOwnerReferences(
          io.kubernetes.client.proto.Meta.OwnerReference.Builder builderForValue) {
        if (ownerReferencesBuilder_ == null) {
          ensureOwnerReferencesIsMutable();
          ownerReferences_.add(builderForValue.build());
          onChanged();
        } else {
          ownerReferencesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public Builder addOwnerReferences(
          int index, io.kubernetes.client.proto.Meta.OwnerReference.Builder builderForValue) {
        if (ownerReferencesBuilder_ == null) {
          ensureOwnerReferencesIsMutable();
          ownerReferences_.add(index, builderForValue.build());
          onChanged();
        } else {
          ownerReferencesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public Builder addAllOwnerReferences(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.OwnerReference> values) {
        if (ownerReferencesBuilder_ == null) {
          ensureOwnerReferencesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, ownerReferences_);
          onChanged();
        } else {
          ownerReferencesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public Builder clearOwnerReferences() {
        if (ownerReferencesBuilder_ == null) {
          ownerReferences_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
          onChanged();
        } else {
          ownerReferencesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public Builder removeOwnerReferences(int index) {
        if (ownerReferencesBuilder_ == null) {
          ensureOwnerReferencesIsMutable();
          ownerReferences_.remove(index);
          onChanged();
        } else {
          ownerReferencesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public io.kubernetes.client.proto.Meta.OwnerReference.Builder getOwnerReferencesBuilder(
          int index) {
        return getOwnerReferencesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder getOwnerReferencesOrBuilder(
          int index) {
        if (ownerReferencesBuilder_ == null) {
          return ownerReferences_.get(index);  } else {
          return ownerReferencesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder> 
           getOwnerReferencesOrBuilderList() {
        if (ownerReferencesBuilder_ != null) {
          return ownerReferencesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ownerReferences_);
        }
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public io.kubernetes.client.proto.Meta.OwnerReference.Builder addOwnerReferencesBuilder() {
        return getOwnerReferencesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.OwnerReference.getDefaultInstance());
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public io.kubernetes.client.proto.Meta.OwnerReference.Builder addOwnerReferencesBuilder(
          int index) {
        return getOwnerReferencesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.OwnerReference.getDefaultInstance());
      }
      /**
       * <pre>
       * List of objects depended by this object. If ALL objects in the list have
       * been deleted, this object will be garbage collected. If this object is managed by a controller,
       * then an entry in this list will point to this controller, with the controller field set to true.
       * There cannot be more than one managing controller.
       * +optional
       * +patchMergeKey=uid
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=uid
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.OwnerReference.Builder> 
           getOwnerReferencesBuilderList() {
        return getOwnerReferencesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.OwnerReference, io.kubernetes.client.proto.Meta.OwnerReference.Builder, io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder> 
          getOwnerReferencesFieldBuilder() {
        if (ownerReferencesBuilder_ == null) {
          ownerReferencesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.OwnerReference, io.kubernetes.client.proto.Meta.OwnerReference.Builder, io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder>(
                  ownerReferences_,
                  ((bitField0_ & 0x00001000) != 0),
                  getParentForChildren(),
                  isClean());
          ownerReferences_ = null;
        }
        return ownerReferencesBuilder_;
      }

      private com.google.protobuf.LazyStringArrayList finalizers_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureFinalizersIsMutable() {
        if (!finalizers_.isModifiable()) {
          finalizers_ = new com.google.protobuf.LazyStringArrayList(finalizers_);
        }
        bitField0_ |= 0x00002000;
      }
      /**
       * <pre>
       * Must be empty before the object is deleted from the registry. Each entry
       * is an identifier for the responsible component that will remove the entry
       * from the list. If the deletionTimestamp of the object is non-nil, entries
       * in this list can only be removed.
       * Finalizers may be processed and removed in any order.  Order is NOT enforced
       * because it introduces significant risk of stuck finalizers.
       * finalizers is a shared field, any actor with permission can reorder it.
       * If the finalizer list is processed in order, then this can lead to a situation
       * in which the component responsible for the first finalizer in the list is
       * waiting for a signal (field value, external system, or other) produced by a
       * component responsible for a finalizer later in the list, resulting in a deadlock.
       * Without enforced ordering finalizers are free to order amongst themselves and
       * are not vulnerable to ordering changes in the list.
       * +optional
       * +patchStrategy=merge
       * +listType=set
       * </pre>
       *
       * <code>repeated string finalizers = 14;</code>
       * @return A list containing the finalizers.
       */
      public com.google.protobuf.ProtocolStringList
          getFinalizersList() {
        finalizers_.makeImmutable();
        return finalizers_;
      }
      /**
       * <pre>
       * Must be empty before the object is deleted from the registry. Each entry
       * is an identifier for the responsible component that will remove the entry
       * from the list. If the deletionTimestamp of the object is non-nil, entries
       * in this list can only be removed.
       * Finalizers may be processed and removed in any order.  Order is NOT enforced
       * because it introduces significant risk of stuck finalizers.
       * finalizers is a shared field, any actor with permission can reorder it.
       * If the finalizer list is processed in order, then this can lead to a situation
       * in which the component responsible for the first finalizer in the list is
       * waiting for a signal (field value, external system, or other) produced by a
       * component responsible for a finalizer later in the list, resulting in a deadlock.
       * Without enforced ordering finalizers are free to order amongst themselves and
       * are not vulnerable to ordering changes in the list.
       * +optional
       * +patchStrategy=merge
       * +listType=set
       * </pre>
       *
       * <code>repeated string finalizers = 14;</code>
       * @return The count of finalizers.
       */
      public int getFinalizersCount() {
        return finalizers_.size();
      }
      /**
       * <pre>
       * Must be empty before the object is deleted from the registry. Each entry
       * is an identifier for the responsible component that will remove the entry
       * from the list. If the deletionTimestamp of the object is non-nil, entries
       * in this list can only be removed.
       * Finalizers may be processed and removed in any order.  Order is NOT enforced
       * because it introduces significant risk of stuck finalizers.
       * finalizers is a shared field, any actor with permission can reorder it.
       * If the finalizer list is processed in order, then this can lead to a situation
       * in which the component responsible for the first finalizer in the list is
       * waiting for a signal (field value, external system, or other) produced by a
       * component responsible for a finalizer later in the list, resulting in a deadlock.
       * Without enforced ordering finalizers are free to order amongst themselves and
       * are not vulnerable to ordering changes in the list.
       * +optional
       * +patchStrategy=merge
       * +listType=set
       * </pre>
       *
       * <code>repeated string finalizers = 14;</code>
       * @param index The index of the element to return.
       * @return The finalizers at the given index.
       */
      public java.lang.String getFinalizers(int index) {
        return finalizers_.get(index);
      }
      /**
       * <pre>
       * Must be empty before the object is deleted from the registry. Each entry
       * is an identifier for the responsible component that will remove the entry
       * from the list. If the deletionTimestamp of the object is non-nil, entries
       * in this list can only be removed.
       * Finalizers may be processed and removed in any order.  Order is NOT enforced
       * because it introduces significant risk of stuck finalizers.
       * finalizers is a shared field, any actor with permission can reorder it.
       * If the finalizer list is processed in order, then this can lead to a situation
       * in which the component responsible for the first finalizer in the list is
       * waiting for a signal (field value, external system, or other) produced by a
       * component responsible for a finalizer later in the list, resulting in a deadlock.
       * Without enforced ordering finalizers are free to order amongst themselves and
       * are not vulnerable to ordering changes in the list.
       * +optional
       * +patchStrategy=merge
       * +listType=set
       * </pre>
       *
       * <code>repeated string finalizers = 14;</code>
       * @param index The index of the value to return.
       * @return The bytes of the finalizers at the given index.
       */
      public com.google.protobuf.ByteString
          getFinalizersBytes(int index) {
        return finalizers_.getByteString(index);
      }
      /**
       * <pre>
       * Must be empty before the object is deleted from the registry. Each entry
       * is an identifier for the responsible component that will remove the entry
       * from the list. If the deletionTimestamp of the object is non-nil, entries
       * in this list can only be removed.
       * Finalizers may be processed and removed in any order.  Order is NOT enforced
       * because it introduces significant risk of stuck finalizers.
       * finalizers is a shared field, any actor with permission can reorder it.
       * If the finalizer list is processed in order, then this can lead to a situation
       * in which the component responsible for the first finalizer in the list is
       * waiting for a signal (field value, external system, or other) produced by a
       * component responsible for a finalizer later in the list, resulting in a deadlock.
       * Without enforced ordering finalizers are free to order amongst themselves and
       * are not vulnerable to ordering changes in the list.
       * +optional
       * +patchStrategy=merge
       * +listType=set
       * </pre>
       *
       * <code>repeated string finalizers = 14;</code>
       * @param index The index to set the value at.
       * @param value The finalizers to set.
       * @return This builder for chaining.
       */
      public Builder setFinalizers(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFinalizersIsMutable();
        finalizers_.set(index, value);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be empty before the object is deleted from the registry. Each entry
       * is an identifier for the responsible component that will remove the entry
       * from the list. If the deletionTimestamp of the object is non-nil, entries
       * in this list can only be removed.
       * Finalizers may be processed and removed in any order.  Order is NOT enforced
       * because it introduces significant risk of stuck finalizers.
       * finalizers is a shared field, any actor with permission can reorder it.
       * If the finalizer list is processed in order, then this can lead to a situation
       * in which the component responsible for the first finalizer in the list is
       * waiting for a signal (field value, external system, or other) produced by a
       * component responsible for a finalizer later in the list, resulting in a deadlock.
       * Without enforced ordering finalizers are free to order amongst themselves and
       * are not vulnerable to ordering changes in the list.
       * +optional
       * +patchStrategy=merge
       * +listType=set
       * </pre>
       *
       * <code>repeated string finalizers = 14;</code>
       * @param value The finalizers to add.
       * @return This builder for chaining.
       */
      public Builder addFinalizers(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFinalizersIsMutable();
        finalizers_.add(value);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be empty before the object is deleted from the registry. Each entry
       * is an identifier for the responsible component that will remove the entry
       * from the list. If the deletionTimestamp of the object is non-nil, entries
       * in this list can only be removed.
       * Finalizers may be processed and removed in any order.  Order is NOT enforced
       * because it introduces significant risk of stuck finalizers.
       * finalizers is a shared field, any actor with permission can reorder it.
       * If the finalizer list is processed in order, then this can lead to a situation
       * in which the component responsible for the first finalizer in the list is
       * waiting for a signal (field value, external system, or other) produced by a
       * component responsible for a finalizer later in the list, resulting in a deadlock.
       * Without enforced ordering finalizers are free to order amongst themselves and
       * are not vulnerable to ordering changes in the list.
       * +optional
       * +patchStrategy=merge
       * +listType=set
       * </pre>
       *
       * <code>repeated string finalizers = 14;</code>
       * @param values The finalizers to add.
       * @return This builder for chaining.
       */
      public Builder addAllFinalizers(
          java.lang.Iterable<java.lang.String> values) {
        ensureFinalizersIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, finalizers_);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be empty before the object is deleted from the registry. Each entry
       * is an identifier for the responsible component that will remove the entry
       * from the list. If the deletionTimestamp of the object is non-nil, entries
       * in this list can only be removed.
       * Finalizers may be processed and removed in any order.  Order is NOT enforced
       * because it introduces significant risk of stuck finalizers.
       * finalizers is a shared field, any actor with permission can reorder it.
       * If the finalizer list is processed in order, then this can lead to a situation
       * in which the component responsible for the first finalizer in the list is
       * waiting for a signal (field value, external system, or other) produced by a
       * component responsible for a finalizer later in the list, resulting in a deadlock.
       * Without enforced ordering finalizers are free to order amongst themselves and
       * are not vulnerable to ordering changes in the list.
       * +optional
       * +patchStrategy=merge
       * +listType=set
       * </pre>
       *
       * <code>repeated string finalizers = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearFinalizers() {
        finalizers_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00002000);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must be empty before the object is deleted from the registry. Each entry
       * is an identifier for the responsible component that will remove the entry
       * from the list. If the deletionTimestamp of the object is non-nil, entries
       * in this list can only be removed.
       * Finalizers may be processed and removed in any order.  Order is NOT enforced
       * because it introduces significant risk of stuck finalizers.
       * finalizers is a shared field, any actor with permission can reorder it.
       * If the finalizer list is processed in order, then this can lead to a situation
       * in which the component responsible for the first finalizer in the list is
       * waiting for a signal (field value, external system, or other) produced by a
       * component responsible for a finalizer later in the list, resulting in a deadlock.
       * Without enforced ordering finalizers are free to order amongst themselves and
       * are not vulnerable to ordering changes in the list.
       * +optional
       * +patchStrategy=merge
       * +listType=set
       * </pre>
       *
       * <code>repeated string finalizers = 14;</code>
       * @param value The bytes of the finalizers to add.
       * @return This builder for chaining.
       */
      public Builder addFinalizersBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFinalizersIsMutable();
        finalizers_.add(value);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.ManagedFieldsEntry> managedFields_ =
        java.util.Collections.emptyList();
      private void ensureManagedFieldsIsMutable() {
        if (!((bitField0_ & 0x00004000) != 0)) {
          managedFields_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.ManagedFieldsEntry>(managedFields_);
          bitField0_ |= 0x00004000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.ManagedFieldsEntry, io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder, io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder> managedFieldsBuilder_;

      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.ManagedFieldsEntry> getManagedFieldsList() {
        if (managedFieldsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(managedFields_);
        } else {
          return managedFieldsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public int getManagedFieldsCount() {
        if (managedFieldsBuilder_ == null) {
          return managedFields_.size();
        } else {
          return managedFieldsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public io.kubernetes.client.proto.Meta.ManagedFieldsEntry getManagedFields(int index) {
        if (managedFieldsBuilder_ == null) {
          return managedFields_.get(index);
        } else {
          return managedFieldsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public Builder setManagedFields(
          int index, io.kubernetes.client.proto.Meta.ManagedFieldsEntry value) {
        if (managedFieldsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureManagedFieldsIsMutable();
          managedFields_.set(index, value);
          onChanged();
        } else {
          managedFieldsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public Builder setManagedFields(
          int index, io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder builderForValue) {
        if (managedFieldsBuilder_ == null) {
          ensureManagedFieldsIsMutable();
          managedFields_.set(index, builderForValue.build());
          onChanged();
        } else {
          managedFieldsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public Builder addManagedFields(io.kubernetes.client.proto.Meta.ManagedFieldsEntry value) {
        if (managedFieldsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureManagedFieldsIsMutable();
          managedFields_.add(value);
          onChanged();
        } else {
          managedFieldsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public Builder addManagedFields(
          int index, io.kubernetes.client.proto.Meta.ManagedFieldsEntry value) {
        if (managedFieldsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureManagedFieldsIsMutable();
          managedFields_.add(index, value);
          onChanged();
        } else {
          managedFieldsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public Builder addManagedFields(
          io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder builderForValue) {
        if (managedFieldsBuilder_ == null) {
          ensureManagedFieldsIsMutable();
          managedFields_.add(builderForValue.build());
          onChanged();
        } else {
          managedFieldsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public Builder addManagedFields(
          int index, io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder builderForValue) {
        if (managedFieldsBuilder_ == null) {
          ensureManagedFieldsIsMutable();
          managedFields_.add(index, builderForValue.build());
          onChanged();
        } else {
          managedFieldsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public Builder addAllManagedFields(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.ManagedFieldsEntry> values) {
        if (managedFieldsBuilder_ == null) {
          ensureManagedFieldsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, managedFields_);
          onChanged();
        } else {
          managedFieldsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public Builder clearManagedFields() {
        if (managedFieldsBuilder_ == null) {
          managedFields_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00004000);
          onChanged();
        } else {
          managedFieldsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public Builder removeManagedFields(int index) {
        if (managedFieldsBuilder_ == null) {
          ensureManagedFieldsIsMutable();
          managedFields_.remove(index);
          onChanged();
        } else {
          managedFieldsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder getManagedFieldsBuilder(
          int index) {
        return getManagedFieldsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder getManagedFieldsOrBuilder(
          int index) {
        if (managedFieldsBuilder_ == null) {
          return managedFields_.get(index);  } else {
          return managedFieldsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder> 
           getManagedFieldsOrBuilderList() {
        if (managedFieldsBuilder_ != null) {
          return managedFieldsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(managedFields_);
        }
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder addManagedFieldsBuilder() {
        return getManagedFieldsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.ManagedFieldsEntry.getDefaultInstance());
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder addManagedFieldsBuilder(
          int index) {
        return getManagedFieldsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.ManagedFieldsEntry.getDefaultInstance());
      }
      /**
       * <pre>
       * ManagedFields maps workflow-id and version to the set of fields
       * that are managed by that workflow. This is mostly for internal
       * housekeeping, and users typically shouldn't need to set or
       * understand this field. A workflow can be the user's name, a
       * controller's name, or the name of a specific apply path like
       * "ci-cd". The set of fields is always in the version that the
       * workflow used when modifying the object.
       *
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder> 
           getManagedFieldsBuilderList() {
        return getManagedFieldsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.ManagedFieldsEntry, io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder, io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder> 
          getManagedFieldsFieldBuilder() {
        if (managedFieldsBuilder_ == null) {
          managedFieldsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.ManagedFieldsEntry, io.kubernetes.client.proto.Meta.ManagedFieldsEntry.Builder, io.kubernetes.client.proto.Meta.ManagedFieldsEntryOrBuilder>(
                  managedFields_,
                  ((bitField0_ & 0x00004000) != 0),
                  getParentForChildren(),
                  isClean());
          managedFields_ = null;
        }
        return managedFieldsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta)
    private static final io.kubernetes.client.proto.Meta.ObjectMeta DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.ObjectMeta();
    }

    public static io.kubernetes.client.proto.Meta.ObjectMeta getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ObjectMeta>
        PARSER = new com.google.protobuf.AbstractParser<ObjectMeta>() {
      @java.lang.Override
      public ObjectMeta parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ObjectMeta> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ObjectMeta> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OwnerReferenceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * API version of the referent.
     * </pre>
     *
     * <code>optional string apiVersion = 5;</code>
     * @return Whether the apiVersion field is set.
     */
    boolean hasApiVersion();
    /**
     * <pre>
     * API version of the referent.
     * </pre>
     *
     * <code>optional string apiVersion = 5;</code>
     * @return The apiVersion.
     */
    java.lang.String getApiVersion();
    /**
     * <pre>
     * API version of the referent.
     * </pre>
     *
     * <code>optional string apiVersion = 5;</code>
     * @return The bytes for apiVersion.
     */
    com.google.protobuf.ByteString
        getApiVersionBytes();

    /**
     * <pre>
     * Kind of the referent.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return Whether the kind field is set.
     */
    boolean hasKind();
    /**
     * <pre>
     * Kind of the referent.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return The kind.
     */
    java.lang.String getKind();
    /**
     * <pre>
     * Kind of the referent.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return The bytes for kind.
     */
    com.google.protobuf.ByteString
        getKindBytes();

    /**
     * <pre>
     * Name of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Name of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * UID of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * </pre>
     *
     * <code>optional string uid = 4;</code>
     * @return Whether the uid field is set.
     */
    boolean hasUid();
    /**
     * <pre>
     * UID of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * </pre>
     *
     * <code>optional string uid = 4;</code>
     * @return The uid.
     */
    java.lang.String getUid();
    /**
     * <pre>
     * UID of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * </pre>
     *
     * <code>optional string uid = 4;</code>
     * @return The bytes for uid.
     */
    com.google.protobuf.ByteString
        getUidBytes();

    /**
     * <pre>
     * If true, this reference points to the managing controller.
     * +optional
     * </pre>
     *
     * <code>optional bool controller = 6;</code>
     * @return Whether the controller field is set.
     */
    boolean hasController();
    /**
     * <pre>
     * If true, this reference points to the managing controller.
     * +optional
     * </pre>
     *
     * <code>optional bool controller = 6;</code>
     * @return The controller.
     */
    boolean getController();

    /**
     * <pre>
     * If true, AND if the owner has the "foregroundDeletion" finalizer, then
     * the owner cannot be deleted from the key-value store until this
     * reference is removed.
     * See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
     * for how the garbage collector interacts with this field and enforces the foreground deletion.
     * Defaults to false.
     * To set this field, a user needs "delete" permission of the owner,
     * otherwise 422 (Unprocessable Entity) will be returned.
     * +optional
     * </pre>
     *
     * <code>optional bool blockOwnerDeletion = 7;</code>
     * @return Whether the blockOwnerDeletion field is set.
     */
    boolean hasBlockOwnerDeletion();
    /**
     * <pre>
     * If true, AND if the owner has the "foregroundDeletion" finalizer, then
     * the owner cannot be deleted from the key-value store until this
     * reference is removed.
     * See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
     * for how the garbage collector interacts with this field and enforces the foreground deletion.
     * Defaults to false.
     * To set this field, a user needs "delete" permission of the owner,
     * otherwise 422 (Unprocessable Entity) will be returned.
     * +optional
     * </pre>
     *
     * <code>optional bool blockOwnerDeletion = 7;</code>
     * @return The blockOwnerDeletion.
     */
    boolean getBlockOwnerDeletion();
  }
  /**
   * <pre>
   * OwnerReference contains enough information to let you identify an owning
   * object. An owning object must be in the same namespace as the dependent, or
   * be cluster-scoped, so there is no namespace field.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference}
   */
  public static final class OwnerReference extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference)
      OwnerReferenceOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        OwnerReference.class.getName());
    }
    // Use OwnerReference.newBuilder() to construct.
    private OwnerReference(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private OwnerReference() {
      apiVersion_ = "";
      kind_ = "";
      name_ = "";
      uid_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.OwnerReference.class, io.kubernetes.client.proto.Meta.OwnerReference.Builder.class);
    }

    private int bitField0_;
    public static final int APIVERSION_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object apiVersion_ = "";
    /**
     * <pre>
     * API version of the referent.
     * </pre>
     *
     * <code>optional string apiVersion = 5;</code>
     * @return Whether the apiVersion field is set.
     */
    @java.lang.Override
    public boolean hasApiVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * API version of the referent.
     * </pre>
     *
     * <code>optional string apiVersion = 5;</code>
     * @return The apiVersion.
     */
    @java.lang.Override
    public java.lang.String getApiVersion() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          apiVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * API version of the referent.
     * </pre>
     *
     * <code>optional string apiVersion = 5;</code>
     * @return The bytes for apiVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getApiVersionBytes() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        apiVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KIND_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object kind_ = "";
    /**
     * <pre>
     * Kind of the referent.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return Whether the kind field is set.
     */
    @java.lang.Override
    public boolean hasKind() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Kind of the referent.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return The kind.
     */
    @java.lang.Override
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          kind_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Kind of the referent.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return The bytes for kind.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAME_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Name of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Name of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UID_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object uid_ = "";
    /**
     * <pre>
     * UID of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * </pre>
     *
     * <code>optional string uid = 4;</code>
     * @return Whether the uid field is set.
     */
    @java.lang.Override
    public boolean hasUid() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * UID of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * </pre>
     *
     * <code>optional string uid = 4;</code>
     * @return The uid.
     */
    @java.lang.Override
    public java.lang.String getUid() {
      java.lang.Object ref = uid_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          uid_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * UID of the referent.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * </pre>
     *
     * <code>optional string uid = 4;</code>
     * @return The bytes for uid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUidBytes() {
      java.lang.Object ref = uid_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uid_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CONTROLLER_FIELD_NUMBER = 6;
    private boolean controller_ = false;
    /**
     * <pre>
     * If true, this reference points to the managing controller.
     * +optional
     * </pre>
     *
     * <code>optional bool controller = 6;</code>
     * @return Whether the controller field is set.
     */
    @java.lang.Override
    public boolean hasController() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * If true, this reference points to the managing controller.
     * +optional
     * </pre>
     *
     * <code>optional bool controller = 6;</code>
     * @return The controller.
     */
    @java.lang.Override
    public boolean getController() {
      return controller_;
    }

    public static final int BLOCKOWNERDELETION_FIELD_NUMBER = 7;
    private boolean blockOwnerDeletion_ = false;
    /**
     * <pre>
     * If true, AND if the owner has the "foregroundDeletion" finalizer, then
     * the owner cannot be deleted from the key-value store until this
     * reference is removed.
     * See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
     * for how the garbage collector interacts with this field and enforces the foreground deletion.
     * Defaults to false.
     * To set this field, a user needs "delete" permission of the owner,
     * otherwise 422 (Unprocessable Entity) will be returned.
     * +optional
     * </pre>
     *
     * <code>optional bool blockOwnerDeletion = 7;</code>
     * @return Whether the blockOwnerDeletion field is set.
     */
    @java.lang.Override
    public boolean hasBlockOwnerDeletion() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * If true, AND if the owner has the "foregroundDeletion" finalizer, then
     * the owner cannot be deleted from the key-value store until this
     * reference is removed.
     * See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
     * for how the garbage collector interacts with this field and enforces the foreground deletion.
     * Defaults to false.
     * To set this field, a user needs "delete" permission of the owner,
     * otherwise 422 (Unprocessable Entity) will be returned.
     * +optional
     * </pre>
     *
     * <code>optional bool blockOwnerDeletion = 7;</code>
     * @return The blockOwnerDeletion.
     */
    @java.lang.Override
    public boolean getBlockOwnerDeletion() {
      return blockOwnerDeletion_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, kind_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, name_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, uid_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, apiVersion_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(6, controller_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(7, blockOwnerDeletion_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, kind_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, name_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, uid_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, apiVersion_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, controller_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, blockOwnerDeletion_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.OwnerReference)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.OwnerReference other = (io.kubernetes.client.proto.Meta.OwnerReference) obj;

      if (hasApiVersion() != other.hasApiVersion()) return false;
      if (hasApiVersion()) {
        if (!getApiVersion()
            .equals(other.getApiVersion())) return false;
      }
      if (hasKind() != other.hasKind()) return false;
      if (hasKind()) {
        if (!getKind()
            .equals(other.getKind())) return false;
      }
      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasUid() != other.hasUid()) return false;
      if (hasUid()) {
        if (!getUid()
            .equals(other.getUid())) return false;
      }
      if (hasController() != other.hasController()) return false;
      if (hasController()) {
        if (getController()
            != other.getController()) return false;
      }
      if (hasBlockOwnerDeletion() != other.hasBlockOwnerDeletion()) return false;
      if (hasBlockOwnerDeletion()) {
        if (getBlockOwnerDeletion()
            != other.getBlockOwnerDeletion()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasApiVersion()) {
        hash = (37 * hash) + APIVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getApiVersion().hashCode();
      }
      if (hasKind()) {
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + getKind().hashCode();
      }
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasUid()) {
        hash = (37 * hash) + UID_FIELD_NUMBER;
        hash = (53 * hash) + getUid().hashCode();
      }
      if (hasController()) {
        hash = (37 * hash) + CONTROLLER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getController());
      }
      if (hasBlockOwnerDeletion()) {
        hash = (37 * hash) + BLOCKOWNERDELETION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getBlockOwnerDeletion());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.OwnerReference parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.OwnerReference parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.OwnerReference parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.OwnerReference prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * OwnerReference contains enough information to let you identify an owning
     * object. An owning object must be in the same namespace as the dependent, or
     * be cluster-scoped, so there is no namespace field.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference)
        io.kubernetes.client.proto.Meta.OwnerReferenceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.OwnerReference.class, io.kubernetes.client.proto.Meta.OwnerReference.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.OwnerReference.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        apiVersion_ = "";
        kind_ = "";
        name_ = "";
        uid_ = "";
        controller_ = false;
        blockOwnerDeletion_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.OwnerReference getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.OwnerReference.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.OwnerReference build() {
        io.kubernetes.client.proto.Meta.OwnerReference result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.OwnerReference buildPartial() {
        io.kubernetes.client.proto.Meta.OwnerReference result = new io.kubernetes.client.proto.Meta.OwnerReference(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.OwnerReference result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.apiVersion_ = apiVersion_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.kind_ = kind_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.uid_ = uid_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.controller_ = controller_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.blockOwnerDeletion_ = blockOwnerDeletion_;
          to_bitField0_ |= 0x00000020;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.OwnerReference) {
          return mergeFrom((io.kubernetes.client.proto.Meta.OwnerReference)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.OwnerReference other) {
        if (other == io.kubernetes.client.proto.Meta.OwnerReference.getDefaultInstance()) return this;
        if (other.hasApiVersion()) {
          apiVersion_ = other.apiVersion_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasKind()) {
          kind_ = other.kind_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasUid()) {
          uid_ = other.uid_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasController()) {
          setController(other.getController());
        }
        if (other.hasBlockOwnerDeletion()) {
          setBlockOwnerDeletion(other.getBlockOwnerDeletion());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                kind_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 10
              case 26: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                uid_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                apiVersion_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 42
              case 48: {
                controller_ = input.readBool();
                bitField0_ |= 0x00000010;
                break;
              } // case 48
              case 56: {
                blockOwnerDeletion_ = input.readBool();
                bitField0_ |= 0x00000020;
                break;
              } // case 56
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object apiVersion_ = "";
      /**
       * <pre>
       * API version of the referent.
       * </pre>
       *
       * <code>optional string apiVersion = 5;</code>
       * @return Whether the apiVersion field is set.
       */
      public boolean hasApiVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * API version of the referent.
       * </pre>
       *
       * <code>optional string apiVersion = 5;</code>
       * @return The apiVersion.
       */
      public java.lang.String getApiVersion() {
        java.lang.Object ref = apiVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            apiVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * API version of the referent.
       * </pre>
       *
       * <code>optional string apiVersion = 5;</code>
       * @return The bytes for apiVersion.
       */
      public com.google.protobuf.ByteString
          getApiVersionBytes() {
        java.lang.Object ref = apiVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          apiVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * API version of the referent.
       * </pre>
       *
       * <code>optional string apiVersion = 5;</code>
       * @param value The apiVersion to set.
       * @return This builder for chaining.
       */
      public Builder setApiVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        apiVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * API version of the referent.
       * </pre>
       *
       * <code>optional string apiVersion = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearApiVersion() {
        apiVersion_ = getDefaultInstance().getApiVersion();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * API version of the referent.
       * </pre>
       *
       * <code>optional string apiVersion = 5;</code>
       * @param value The bytes for apiVersion to set.
       * @return This builder for chaining.
       */
      public Builder setApiVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        apiVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object kind_ = "";
      /**
       * <pre>
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @return Whether the kind field is set.
       */
      public boolean hasKind() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @return The kind.
       */
      public java.lang.String getKind() {
        java.lang.Object ref = kind_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            kind_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @return The bytes for kind.
       */
      public com.google.protobuf.ByteString
          getKindBytes() {
        java.lang.Object ref = kind_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          kind_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @param value The kind to set.
       * @return This builder for chaining.
       */
      public Builder setKind(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKind() {
        kind_ = getDefaultInstance().getKind();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @param value The bytes for kind to set.
       * @return This builder for chaining.
       */
      public Builder setKindBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object uid_ = "";
      /**
       * <pre>
       * UID of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * </pre>
       *
       * <code>optional string uid = 4;</code>
       * @return Whether the uid field is set.
       */
      public boolean hasUid() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * UID of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * </pre>
       *
       * <code>optional string uid = 4;</code>
       * @return The uid.
       */
      public java.lang.String getUid() {
        java.lang.Object ref = uid_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            uid_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * UID of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * </pre>
       *
       * <code>optional string uid = 4;</code>
       * @return The bytes for uid.
       */
      public com.google.protobuf.ByteString
          getUidBytes() {
        java.lang.Object ref = uid_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          uid_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * UID of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * </pre>
       *
       * <code>optional string uid = 4;</code>
       * @param value The uid to set.
       * @return This builder for chaining.
       */
      public Builder setUid(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        uid_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UID of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * </pre>
       *
       * <code>optional string uid = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearUid() {
        uid_ = getDefaultInstance().getUid();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UID of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * </pre>
       *
       * <code>optional string uid = 4;</code>
       * @param value The bytes for uid to set.
       * @return This builder for chaining.
       */
      public Builder setUidBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        uid_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private boolean controller_ ;
      /**
       * <pre>
       * If true, this reference points to the managing controller.
       * +optional
       * </pre>
       *
       * <code>optional bool controller = 6;</code>
       * @return Whether the controller field is set.
       */
      @java.lang.Override
      public boolean hasController() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * If true, this reference points to the managing controller.
       * +optional
       * </pre>
       *
       * <code>optional bool controller = 6;</code>
       * @return The controller.
       */
      @java.lang.Override
      public boolean getController() {
        return controller_;
      }
      /**
       * <pre>
       * If true, this reference points to the managing controller.
       * +optional
       * </pre>
       *
       * <code>optional bool controller = 6;</code>
       * @param value The controller to set.
       * @return This builder for chaining.
       */
      public Builder setController(boolean value) {

        controller_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, this reference points to the managing controller.
       * +optional
       * </pre>
       *
       * <code>optional bool controller = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearController() {
        bitField0_ = (bitField0_ & ~0x00000010);
        controller_ = false;
        onChanged();
        return this;
      }

      private boolean blockOwnerDeletion_ ;
      /**
       * <pre>
       * If true, AND if the owner has the "foregroundDeletion" finalizer, then
       * the owner cannot be deleted from the key-value store until this
       * reference is removed.
       * See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
       * for how the garbage collector interacts with this field and enforces the foreground deletion.
       * Defaults to false.
       * To set this field, a user needs "delete" permission of the owner,
       * otherwise 422 (Unprocessable Entity) will be returned.
       * +optional
       * </pre>
       *
       * <code>optional bool blockOwnerDeletion = 7;</code>
       * @return Whether the blockOwnerDeletion field is set.
       */
      @java.lang.Override
      public boolean hasBlockOwnerDeletion() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * If true, AND if the owner has the "foregroundDeletion" finalizer, then
       * the owner cannot be deleted from the key-value store until this
       * reference is removed.
       * See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
       * for how the garbage collector interacts with this field and enforces the foreground deletion.
       * Defaults to false.
       * To set this field, a user needs "delete" permission of the owner,
       * otherwise 422 (Unprocessable Entity) will be returned.
       * +optional
       * </pre>
       *
       * <code>optional bool blockOwnerDeletion = 7;</code>
       * @return The blockOwnerDeletion.
       */
      @java.lang.Override
      public boolean getBlockOwnerDeletion() {
        return blockOwnerDeletion_;
      }
      /**
       * <pre>
       * If true, AND if the owner has the "foregroundDeletion" finalizer, then
       * the owner cannot be deleted from the key-value store until this
       * reference is removed.
       * See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
       * for how the garbage collector interacts with this field and enforces the foreground deletion.
       * Defaults to false.
       * To set this field, a user needs "delete" permission of the owner,
       * otherwise 422 (Unprocessable Entity) will be returned.
       * +optional
       * </pre>
       *
       * <code>optional bool blockOwnerDeletion = 7;</code>
       * @param value The blockOwnerDeletion to set.
       * @return This builder for chaining.
       */
      public Builder setBlockOwnerDeletion(boolean value) {

        blockOwnerDeletion_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, AND if the owner has the "foregroundDeletion" finalizer, then
       * the owner cannot be deleted from the key-value store until this
       * reference is removed.
       * See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
       * for how the garbage collector interacts with this field and enforces the foreground deletion.
       * Defaults to false.
       * To set this field, a user needs "delete" permission of the owner,
       * otherwise 422 (Unprocessable Entity) will be returned.
       * +optional
       * </pre>
       *
       * <code>optional bool blockOwnerDeletion = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockOwnerDeletion() {
        bitField0_ = (bitField0_ & ~0x00000020);
        blockOwnerDeletion_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference)
    private static final io.kubernetes.client.proto.Meta.OwnerReference DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.OwnerReference();
    }

    public static io.kubernetes.client.proto.Meta.OwnerReference getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OwnerReference>
        PARSER = new com.google.protobuf.AbstractParser<OwnerReference>() {
      @java.lang.Override
      public OwnerReference parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<OwnerReference> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OwnerReference> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.OwnerReference getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PartialObjectMetadataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();
  }
  /**
   * <pre>
   * PartialObjectMetadata is a generic representation of any object with ObjectMeta. It allows clients
   * to get access to a particular ObjectMeta schema without knowing the details of the version.
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata}
   */
  public static final class PartialObjectMetadata extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata)
      PartialObjectMetadataOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        PartialObjectMetadata.class.getName());
    }
    // Use PartialObjectMetadata.newBuilder() to construct.
    private PartialObjectMetadata(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private PartialObjectMetadata() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.PartialObjectMetadata.class, io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.PartialObjectMetadata)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.PartialObjectMetadata other = (io.kubernetes.client.proto.Meta.PartialObjectMetadata) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.PartialObjectMetadata prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PartialObjectMetadata is a generic representation of any object with ObjectMeta. It allows clients
     * to get access to a particular ObjectMeta schema without knowing the details of the version.
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata)
        io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.PartialObjectMetadata.class, io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.PartialObjectMetadata.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.PartialObjectMetadata getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.PartialObjectMetadata.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.PartialObjectMetadata build() {
        io.kubernetes.client.proto.Meta.PartialObjectMetadata result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.PartialObjectMetadata buildPartial() {
        io.kubernetes.client.proto.Meta.PartialObjectMetadata result = new io.kubernetes.client.proto.Meta.PartialObjectMetadata(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.PartialObjectMetadata result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.PartialObjectMetadata) {
          return mergeFrom((io.kubernetes.client.proto.Meta.PartialObjectMetadata)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.PartialObjectMetadata other) {
        if (other == io.kubernetes.client.proto.Meta.PartialObjectMetadata.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata)
    private static final io.kubernetes.client.proto.Meta.PartialObjectMetadata DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.PartialObjectMetadata();
    }

    public static io.kubernetes.client.proto.Meta.PartialObjectMetadata getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PartialObjectMetadata>
        PARSER = new com.google.protobuf.AbstractParser<PartialObjectMetadata>() {
      @java.lang.Override
      public PartialObjectMetadata parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PartialObjectMetadata> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PartialObjectMetadata> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.PartialObjectMetadata getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PartialObjectMetadataListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.PartialObjectMetadata> 
        getItemsList();
    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    io.kubernetes.client.proto.Meta.PartialObjectMetadata getItems(int index);
    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * PartialObjectMetadataList contains a list of objects containing only their metadata
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList}
   */
  public static final class PartialObjectMetadataList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList)
      PartialObjectMetadataListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        PartialObjectMetadataList.class.getName());
    }
    // Use PartialObjectMetadataList.newBuilder() to construct.
    private PartialObjectMetadataList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private PartialObjectMetadataList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.PartialObjectMetadataList.class, io.kubernetes.client.proto.Meta.PartialObjectMetadataList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.PartialObjectMetadata> items_;
    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.PartialObjectMetadata> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.PartialObjectMetadata getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * items contains each of the included items.
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.PartialObjectMetadataList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.PartialObjectMetadataList other = (io.kubernetes.client.proto.Meta.PartialObjectMetadataList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.PartialObjectMetadataList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PartialObjectMetadataList contains a list of objects containing only their metadata
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList)
        io.kubernetes.client.proto.Meta.PartialObjectMetadataListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.PartialObjectMetadataList.class, io.kubernetes.client.proto.Meta.PartialObjectMetadataList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.PartialObjectMetadataList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.PartialObjectMetadataList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.PartialObjectMetadataList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.PartialObjectMetadataList build() {
        io.kubernetes.client.proto.Meta.PartialObjectMetadataList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.PartialObjectMetadataList buildPartial() {
        io.kubernetes.client.proto.Meta.PartialObjectMetadataList result = new io.kubernetes.client.proto.Meta.PartialObjectMetadataList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.Meta.PartialObjectMetadataList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.PartialObjectMetadataList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.PartialObjectMetadataList) {
          return mergeFrom((io.kubernetes.client.proto.Meta.PartialObjectMetadataList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.PartialObjectMetadataList other) {
        if (other == io.kubernetes.client.proto.Meta.PartialObjectMetadataList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.Meta.PartialObjectMetadata m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.PartialObjectMetadata.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.PartialObjectMetadata> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.PartialObjectMetadata>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.PartialObjectMetadata, io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder, io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.PartialObjectMetadata> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.PartialObjectMetadata getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.Meta.PartialObjectMetadata value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.Meta.PartialObjectMetadata value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.Meta.PartialObjectMetadata value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.PartialObjectMetadata> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.PartialObjectMetadata.getDefaultInstance());
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.PartialObjectMetadata.getDefaultInstance());
      }
      /**
       * <pre>
       * items contains each of the included items.
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.PartialObjectMetadata, io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder, io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.PartialObjectMetadata, io.kubernetes.client.proto.Meta.PartialObjectMetadata.Builder, io.kubernetes.client.proto.Meta.PartialObjectMetadataOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList)
    private static final io.kubernetes.client.proto.Meta.PartialObjectMetadataList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.PartialObjectMetadataList();
    }

    public static io.kubernetes.client.proto.Meta.PartialObjectMetadataList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PartialObjectMetadataList>
        PARSER = new com.google.protobuf.AbstractParser<PartialObjectMetadataList>() {
      @java.lang.Override
      public PartialObjectMetadataList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PartialObjectMetadataList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PartialObjectMetadataList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.PartialObjectMetadataList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PatchOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.Patch)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Patch}
   */
  public static final class Patch extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Patch)
      PatchOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Patch.class.getName());
    }
    // Use Patch.newBuilder() to construct.
    private Patch(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Patch() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.Patch.class, io.kubernetes.client.proto.Meta.Patch.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.Patch)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.Patch other = (io.kubernetes.client.proto.Meta.Patch) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.Patch parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Patch parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Patch parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Patch parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Patch parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Patch parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Patch parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Patch parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.Patch parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.Patch parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Patch parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Patch parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.Patch prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Patch}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Patch)
        io.kubernetes.client.proto.Meta.PatchOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.Patch.class, io.kubernetes.client.proto.Meta.Patch.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.Patch.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Patch getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.Patch.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Patch build() {
        io.kubernetes.client.proto.Meta.Patch result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Patch buildPartial() {
        io.kubernetes.client.proto.Meta.Patch result = new io.kubernetes.client.proto.Meta.Patch(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.Patch) {
          return mergeFrom((io.kubernetes.client.proto.Meta.Patch)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.Patch other) {
        if (other == io.kubernetes.client.proto.Meta.Patch.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Patch)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Patch)
    private static final io.kubernetes.client.proto.Meta.Patch DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.Patch();
    }

    public static io.kubernetes.client.proto.Meta.Patch getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Patch>
        PARSER = new com.google.protobuf.AbstractParser<Patch>() {
      @java.lang.Override
      public Patch parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Patch> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Patch> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Patch getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PatchOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return A list containing the dryRun.
     */
    java.util.List<java.lang.String>
        getDryRunList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return The count of dryRun.
     */
    int getDryRunCount();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    java.lang.String getDryRun(int index);
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    com.google.protobuf.ByteString
        getDryRunBytes(int index);

    /**
     * <pre>
     * Force is going to "force" Apply requests. It means user will
     * re-acquire conflicting fields owned by other people. Force
     * flag must be unset for non-apply patch requests.
     * +optional
     * </pre>
     *
     * <code>optional bool force = 2;</code>
     * @return Whether the force field is set.
     */
    boolean hasForce();
    /**
     * <pre>
     * Force is going to "force" Apply requests. It means user will
     * re-acquire conflicting fields owned by other people. Force
     * flag must be unset for non-apply patch requests.
     * +optional
     * </pre>
     *
     * <code>optional bool force = 2;</code>
     * @return The force.
     */
    boolean getForce();

    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required for apply requests
     * (application/apply-patch) but optional for non-apply patch
     * types (JsonPatch, MergePatch, StrategicMergePatch).
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return Whether the fieldManager field is set.
     */
    boolean hasFieldManager();
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required for apply requests
     * (application/apply-patch) but optional for non-apply patch
     * types (JsonPatch, MergePatch, StrategicMergePatch).
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The fieldManager.
     */
    java.lang.String getFieldManager();
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required for apply requests
     * (application/apply-patch) but optional for non-apply patch
     * types (JsonPatch, MergePatch, StrategicMergePatch).
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The bytes for fieldManager.
     */
    com.google.protobuf.ByteString
        getFieldManagerBytes();

    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return Whether the fieldValidation field is set.
     */
    boolean hasFieldValidation();
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return The fieldValidation.
     */
    java.lang.String getFieldValidation();
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return The bytes for fieldValidation.
     */
    com.google.protobuf.ByteString
        getFieldValidationBytes();
  }
  /**
   * <pre>
   * PatchOptions may be provided when patching an API object.
   * PatchOptions is meant to be a superset of UpdateOptions.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions}
   */
  public static final class PatchOptions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions)
      PatchOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        PatchOptions.class.getName());
    }
    // Use PatchOptions.newBuilder() to construct.
    private PatchOptions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private PatchOptions() {
      dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      fieldManager_ = "";
      fieldValidation_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.PatchOptions.class, io.kubernetes.client.proto.Meta.PatchOptions.Builder.class);
    }

    private int bitField0_;
    public static final int DRYRUN_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList dryRun_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return A list containing the dryRun.
     */
    public com.google.protobuf.ProtocolStringList
        getDryRunList() {
      return dryRun_;
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return The count of dryRun.
     */
    public int getDryRunCount() {
      return dryRun_.size();
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    public java.lang.String getDryRun(int index) {
      return dryRun_.get(index);
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    public com.google.protobuf.ByteString
        getDryRunBytes(int index) {
      return dryRun_.getByteString(index);
    }

    public static final int FORCE_FIELD_NUMBER = 2;
    private boolean force_ = false;
    /**
     * <pre>
     * Force is going to "force" Apply requests. It means user will
     * re-acquire conflicting fields owned by other people. Force
     * flag must be unset for non-apply patch requests.
     * +optional
     * </pre>
     *
     * <code>optional bool force = 2;</code>
     * @return Whether the force field is set.
     */
    @java.lang.Override
    public boolean hasForce() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Force is going to "force" Apply requests. It means user will
     * re-acquire conflicting fields owned by other people. Force
     * flag must be unset for non-apply patch requests.
     * +optional
     * </pre>
     *
     * <code>optional bool force = 2;</code>
     * @return The force.
     */
    @java.lang.Override
    public boolean getForce() {
      return force_;
    }

    public static final int FIELDMANAGER_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldManager_ = "";
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required for apply requests
     * (application/apply-patch) but optional for non-apply patch
     * types (JsonPatch, MergePatch, StrategicMergePatch).
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return Whether the fieldManager field is set.
     */
    @java.lang.Override
    public boolean hasFieldManager() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required for apply requests
     * (application/apply-patch) but optional for non-apply patch
     * types (JsonPatch, MergePatch, StrategicMergePatch).
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The fieldManager.
     */
    @java.lang.Override
    public java.lang.String getFieldManager() {
      java.lang.Object ref = fieldManager_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldManager_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint. This
     * field is required for apply requests
     * (application/apply-patch) but optional for non-apply patch
     * types (JsonPatch, MergePatch, StrategicMergePatch).
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 3;</code>
     * @return The bytes for fieldManager.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldManagerBytes() {
      java.lang.Object ref = fieldManager_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldManager_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FIELDVALIDATION_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldValidation_ = "";
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return Whether the fieldValidation field is set.
     */
    @java.lang.Override
    public boolean hasFieldValidation() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return The fieldValidation.
     */
    @java.lang.Override
    public java.lang.String getFieldValidation() {
      java.lang.Object ref = fieldValidation_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldValidation_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 4;</code>
     * @return The bytes for fieldValidation.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldValidationBytes() {
      java.lang.Object ref = fieldValidation_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldValidation_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < dryRun_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, dryRun_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(2, force_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, fieldManager_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, fieldValidation_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < dryRun_.size(); i++) {
          dataSize += computeStringSizeNoTag(dryRun_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getDryRunList().size();
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, force_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, fieldManager_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, fieldValidation_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.PatchOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.PatchOptions other = (io.kubernetes.client.proto.Meta.PatchOptions) obj;

      if (!getDryRunList()
          .equals(other.getDryRunList())) return false;
      if (hasForce() != other.hasForce()) return false;
      if (hasForce()) {
        if (getForce()
            != other.getForce()) return false;
      }
      if (hasFieldManager() != other.hasFieldManager()) return false;
      if (hasFieldManager()) {
        if (!getFieldManager()
            .equals(other.getFieldManager())) return false;
      }
      if (hasFieldValidation() != other.hasFieldValidation()) return false;
      if (hasFieldValidation()) {
        if (!getFieldValidation()
            .equals(other.getFieldValidation())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getDryRunCount() > 0) {
        hash = (37 * hash) + DRYRUN_FIELD_NUMBER;
        hash = (53 * hash) + getDryRunList().hashCode();
      }
      if (hasForce()) {
        hash = (37 * hash) + FORCE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getForce());
      }
      if (hasFieldManager()) {
        hash = (37 * hash) + FIELDMANAGER_FIELD_NUMBER;
        hash = (53 * hash) + getFieldManager().hashCode();
      }
      if (hasFieldValidation()) {
        hash = (37 * hash) + FIELDVALIDATION_FIELD_NUMBER;
        hash = (53 * hash) + getFieldValidation().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.PatchOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.PatchOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.PatchOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.PatchOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PatchOptions may be provided when patching an API object.
     * PatchOptions is meant to be a superset of UpdateOptions.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions)
        io.kubernetes.client.proto.Meta.PatchOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.PatchOptions.class, io.kubernetes.client.proto.Meta.PatchOptions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.PatchOptions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        dryRun_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        force_ = false;
        fieldManager_ = "";
        fieldValidation_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.PatchOptions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.PatchOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.PatchOptions build() {
        io.kubernetes.client.proto.Meta.PatchOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.PatchOptions buildPartial() {
        io.kubernetes.client.proto.Meta.PatchOptions result = new io.kubernetes.client.proto.Meta.PatchOptions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.PatchOptions result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          dryRun_.makeImmutable();
          result.dryRun_ = dryRun_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.force_ = force_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.fieldManager_ = fieldManager_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.fieldValidation_ = fieldValidation_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.PatchOptions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.PatchOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.PatchOptions other) {
        if (other == io.kubernetes.client.proto.Meta.PatchOptions.getDefaultInstance()) return this;
        if (!other.dryRun_.isEmpty()) {
          if (dryRun_.isEmpty()) {
            dryRun_ = other.dryRun_;
            bitField0_ |= 0x00000001;
          } else {
            ensureDryRunIsMutable();
            dryRun_.addAll(other.dryRun_);
          }
          onChanged();
        }
        if (other.hasForce()) {
          setForce(other.getForce());
        }
        if (other.hasFieldManager()) {
          fieldManager_ = other.fieldManager_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasFieldValidation()) {
          fieldValidation_ = other.fieldValidation_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureDryRunIsMutable();
                dryRun_.add(bs);
                break;
              } // case 10
              case 16: {
                force_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                fieldManager_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                fieldValidation_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureDryRunIsMutable() {
        if (!dryRun_.isModifiable()) {
          dryRun_ = new com.google.protobuf.LazyStringArrayList(dryRun_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return A list containing the dryRun.
       */
      public com.google.protobuf.ProtocolStringList
          getDryRunList() {
        dryRun_.makeImmutable();
        return dryRun_;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return The count of dryRun.
       */
      public int getDryRunCount() {
        return dryRun_.size();
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index of the element to return.
       * @return The dryRun at the given index.
       */
      public java.lang.String getDryRun(int index) {
        return dryRun_.get(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the dryRun at the given index.
       */
      public com.google.protobuf.ByteString
          getDryRunBytes(int index) {
        return dryRun_.getByteString(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index to set the value at.
       * @param value The dryRun to set.
       * @return This builder for chaining.
       */
      public Builder setDryRun(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param value The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRun(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param values The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addAllDryRun(
          java.lang.Iterable<java.lang.String> values) {
        ensureDryRunIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, dryRun_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDryRun() {
        dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param value The bytes of the dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRunBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private boolean force_ ;
      /**
       * <pre>
       * Force is going to "force" Apply requests. It means user will
       * re-acquire conflicting fields owned by other people. Force
       * flag must be unset for non-apply patch requests.
       * +optional
       * </pre>
       *
       * <code>optional bool force = 2;</code>
       * @return Whether the force field is set.
       */
      @java.lang.Override
      public boolean hasForce() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Force is going to "force" Apply requests. It means user will
       * re-acquire conflicting fields owned by other people. Force
       * flag must be unset for non-apply patch requests.
       * +optional
       * </pre>
       *
       * <code>optional bool force = 2;</code>
       * @return The force.
       */
      @java.lang.Override
      public boolean getForce() {
        return force_;
      }
      /**
       * <pre>
       * Force is going to "force" Apply requests. It means user will
       * re-acquire conflicting fields owned by other people. Force
       * flag must be unset for non-apply patch requests.
       * +optional
       * </pre>
       *
       * <code>optional bool force = 2;</code>
       * @param value The force to set.
       * @return This builder for chaining.
       */
      public Builder setForce(boolean value) {

        force_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Force is going to "force" Apply requests. It means user will
       * re-acquire conflicting fields owned by other people. Force
       * flag must be unset for non-apply patch requests.
       * +optional
       * </pre>
       *
       * <code>optional bool force = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearForce() {
        bitField0_ = (bitField0_ & ~0x00000002);
        force_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object fieldManager_ = "";
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required for apply requests
       * (application/apply-patch) but optional for non-apply patch
       * types (JsonPatch, MergePatch, StrategicMergePatch).
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return Whether the fieldManager field is set.
       */
      public boolean hasFieldManager() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required for apply requests
       * (application/apply-patch) but optional for non-apply patch
       * types (JsonPatch, MergePatch, StrategicMergePatch).
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return The fieldManager.
       */
      public java.lang.String getFieldManager() {
        java.lang.Object ref = fieldManager_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldManager_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required for apply requests
       * (application/apply-patch) but optional for non-apply patch
       * types (JsonPatch, MergePatch, StrategicMergePatch).
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return The bytes for fieldManager.
       */
      public com.google.protobuf.ByteString
          getFieldManagerBytes() {
        java.lang.Object ref = fieldManager_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldManager_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required for apply requests
       * (application/apply-patch) but optional for non-apply patch
       * types (JsonPatch, MergePatch, StrategicMergePatch).
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @param value The fieldManager to set.
       * @return This builder for chaining.
       */
      public Builder setFieldManager(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldManager_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required for apply requests
       * (application/apply-patch) but optional for non-apply patch
       * types (JsonPatch, MergePatch, StrategicMergePatch).
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldManager() {
        fieldManager_ = getDefaultInstance().getFieldManager();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint. This
       * field is required for apply requests
       * (application/apply-patch) but optional for non-apply patch
       * types (JsonPatch, MergePatch, StrategicMergePatch).
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 3;</code>
       * @param value The bytes for fieldManager to set.
       * @return This builder for chaining.
       */
      public Builder setFieldManagerBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldManager_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object fieldValidation_ = "";
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @return Whether the fieldValidation field is set.
       */
      public boolean hasFieldValidation() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @return The fieldValidation.
       */
      public java.lang.String getFieldValidation() {
        java.lang.Object ref = fieldValidation_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldValidation_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @return The bytes for fieldValidation.
       */
      public com.google.protobuf.ByteString
          getFieldValidationBytes() {
        java.lang.Object ref = fieldValidation_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldValidation_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @param value The fieldValidation to set.
       * @return This builder for chaining.
       */
      public Builder setFieldValidation(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldValidation_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldValidation() {
        fieldValidation_ = getDefaultInstance().getFieldValidation();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 4;</code>
       * @param value The bytes for fieldValidation to set.
       * @return This builder for chaining.
       */
      public Builder setFieldValidationBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldValidation_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions)
    private static final io.kubernetes.client.proto.Meta.PatchOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.PatchOptions();
    }

    public static io.kubernetes.client.proto.Meta.PatchOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PatchOptions>
        PARSER = new com.google.protobuf.AbstractParser<PatchOptions>() {
      @java.lang.Override
      public PatchOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PatchOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PatchOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.PatchOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PreconditionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Specifies the target UID.
     * +optional
     * </pre>
     *
     * <code>optional string uid = 1;</code>
     * @return Whether the uid field is set.
     */
    boolean hasUid();
    /**
     * <pre>
     * Specifies the target UID.
     * +optional
     * </pre>
     *
     * <code>optional string uid = 1;</code>
     * @return The uid.
     */
    java.lang.String getUid();
    /**
     * <pre>
     * Specifies the target UID.
     * +optional
     * </pre>
     *
     * <code>optional string uid = 1;</code>
     * @return The bytes for uid.
     */
    com.google.protobuf.ByteString
        getUidBytes();

    /**
     * <pre>
     * Specifies the target ResourceVersion
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return Whether the resourceVersion field is set.
     */
    boolean hasResourceVersion();
    /**
     * <pre>
     * Specifies the target ResourceVersion
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return The resourceVersion.
     */
    java.lang.String getResourceVersion();
    /**
     * <pre>
     * Specifies the target ResourceVersion
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return The bytes for resourceVersion.
     */
    com.google.protobuf.ByteString
        getResourceVersionBytes();
  }
  /**
   * <pre>
   * Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions}
   */
  public static final class Preconditions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions)
      PreconditionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Preconditions.class.getName());
    }
    // Use Preconditions.newBuilder() to construct.
    private Preconditions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Preconditions() {
      uid_ = "";
      resourceVersion_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.Preconditions.class, io.kubernetes.client.proto.Meta.Preconditions.Builder.class);
    }

    private int bitField0_;
    public static final int UID_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object uid_ = "";
    /**
     * <pre>
     * Specifies the target UID.
     * +optional
     * </pre>
     *
     * <code>optional string uid = 1;</code>
     * @return Whether the uid field is set.
     */
    @java.lang.Override
    public boolean hasUid() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Specifies the target UID.
     * +optional
     * </pre>
     *
     * <code>optional string uid = 1;</code>
     * @return The uid.
     */
    @java.lang.Override
    public java.lang.String getUid() {
      java.lang.Object ref = uid_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          uid_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Specifies the target UID.
     * +optional
     * </pre>
     *
     * <code>optional string uid = 1;</code>
     * @return The bytes for uid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUidBytes() {
      java.lang.Object ref = uid_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uid_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RESOURCEVERSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object resourceVersion_ = "";
    /**
     * <pre>
     * Specifies the target ResourceVersion
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return Whether the resourceVersion field is set.
     */
    @java.lang.Override
    public boolean hasResourceVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Specifies the target ResourceVersion
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return The resourceVersion.
     */
    @java.lang.Override
    public java.lang.String getResourceVersion() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          resourceVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Specifies the target ResourceVersion
     * +optional
     * </pre>
     *
     * <code>optional string resourceVersion = 2;</code>
     * @return The bytes for resourceVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getResourceVersionBytes() {
      java.lang.Object ref = resourceVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        resourceVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, uid_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, resourceVersion_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, uid_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, resourceVersion_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.Preconditions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.Preconditions other = (io.kubernetes.client.proto.Meta.Preconditions) obj;

      if (hasUid() != other.hasUid()) return false;
      if (hasUid()) {
        if (!getUid()
            .equals(other.getUid())) return false;
      }
      if (hasResourceVersion() != other.hasResourceVersion()) return false;
      if (hasResourceVersion()) {
        if (!getResourceVersion()
            .equals(other.getResourceVersion())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasUid()) {
        hash = (37 * hash) + UID_FIELD_NUMBER;
        hash = (53 * hash) + getUid().hashCode();
      }
      if (hasResourceVersion()) {
        hash = (37 * hash) + RESOURCEVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getResourceVersion().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.Preconditions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.Preconditions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Preconditions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.Preconditions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions)
        io.kubernetes.client.proto.Meta.PreconditionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.Preconditions.class, io.kubernetes.client.proto.Meta.Preconditions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.Preconditions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        uid_ = "";
        resourceVersion_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Preconditions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.Preconditions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Preconditions build() {
        io.kubernetes.client.proto.Meta.Preconditions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Preconditions buildPartial() {
        io.kubernetes.client.proto.Meta.Preconditions result = new io.kubernetes.client.proto.Meta.Preconditions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.Preconditions result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.uid_ = uid_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.resourceVersion_ = resourceVersion_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.Preconditions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.Preconditions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.Preconditions other) {
        if (other == io.kubernetes.client.proto.Meta.Preconditions.getDefaultInstance()) return this;
        if (other.hasUid()) {
          uid_ = other.uid_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasResourceVersion()) {
          resourceVersion_ = other.resourceVersion_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                uid_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                resourceVersion_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object uid_ = "";
      /**
       * <pre>
       * Specifies the target UID.
       * +optional
       * </pre>
       *
       * <code>optional string uid = 1;</code>
       * @return Whether the uid field is set.
       */
      public boolean hasUid() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Specifies the target UID.
       * +optional
       * </pre>
       *
       * <code>optional string uid = 1;</code>
       * @return The uid.
       */
      public java.lang.String getUid() {
        java.lang.Object ref = uid_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            uid_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Specifies the target UID.
       * +optional
       * </pre>
       *
       * <code>optional string uid = 1;</code>
       * @return The bytes for uid.
       */
      public com.google.protobuf.ByteString
          getUidBytes() {
        java.lang.Object ref = uid_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          uid_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Specifies the target UID.
       * +optional
       * </pre>
       *
       * <code>optional string uid = 1;</code>
       * @param value The uid to set.
       * @return This builder for chaining.
       */
      public Builder setUid(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        uid_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the target UID.
       * +optional
       * </pre>
       *
       * <code>optional string uid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearUid() {
        uid_ = getDefaultInstance().getUid();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the target UID.
       * +optional
       * </pre>
       *
       * <code>optional string uid = 1;</code>
       * @param value The bytes for uid to set.
       * @return This builder for chaining.
       */
      public Builder setUidBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        uid_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object resourceVersion_ = "";
      /**
       * <pre>
       * Specifies the target ResourceVersion
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @return Whether the resourceVersion field is set.
       */
      public boolean hasResourceVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Specifies the target ResourceVersion
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @return The resourceVersion.
       */
      public java.lang.String getResourceVersion() {
        java.lang.Object ref = resourceVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            resourceVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Specifies the target ResourceVersion
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @return The bytes for resourceVersion.
       */
      public com.google.protobuf.ByteString
          getResourceVersionBytes() {
        java.lang.Object ref = resourceVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          resourceVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Specifies the target ResourceVersion
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @param value The resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the target ResourceVersion
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceVersion() {
        resourceVersion_ = getDefaultInstance().getResourceVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the target ResourceVersion
       * +optional
       * </pre>
       *
       * <code>optional string resourceVersion = 2;</code>
       * @param value The bytes for resourceVersion to set.
       * @return This builder for chaining.
       */
      public Builder setResourceVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        resourceVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions)
    private static final io.kubernetes.client.proto.Meta.Preconditions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.Preconditions();
    }

    public static io.kubernetes.client.proto.Meta.Preconditions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Preconditions>
        PARSER = new com.google.protobuf.AbstractParser<Preconditions>() {
      @java.lang.Override
      public Preconditions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Preconditions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Preconditions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Preconditions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RootPathsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * paths are the paths available at root.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string paths = 1;</code>
     * @return A list containing the paths.
     */
    java.util.List<java.lang.String>
        getPathsList();
    /**
     * <pre>
     * paths are the paths available at root.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string paths = 1;</code>
     * @return The count of paths.
     */
    int getPathsCount();
    /**
     * <pre>
     * paths are the paths available at root.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string paths = 1;</code>
     * @param index The index of the element to return.
     * @return The paths at the given index.
     */
    java.lang.String getPaths(int index);
    /**
     * <pre>
     * paths are the paths available at root.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string paths = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the paths at the given index.
     */
    com.google.protobuf.ByteString
        getPathsBytes(int index);
  }
  /**
   * <pre>
   * RootPaths lists the paths available at root.
   * For example: "/healthz", "/apis".
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths}
   */
  public static final class RootPaths extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths)
      RootPathsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        RootPaths.class.getName());
    }
    // Use RootPaths.newBuilder() to construct.
    private RootPaths(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private RootPaths() {
      paths_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.RootPaths.class, io.kubernetes.client.proto.Meta.RootPaths.Builder.class);
    }

    public static final int PATHS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList paths_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * paths are the paths available at root.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string paths = 1;</code>
     * @return A list containing the paths.
     */
    public com.google.protobuf.ProtocolStringList
        getPathsList() {
      return paths_;
    }
    /**
     * <pre>
     * paths are the paths available at root.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string paths = 1;</code>
     * @return The count of paths.
     */
    public int getPathsCount() {
      return paths_.size();
    }
    /**
     * <pre>
     * paths are the paths available at root.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string paths = 1;</code>
     * @param index The index of the element to return.
     * @return The paths at the given index.
     */
    public java.lang.String getPaths(int index) {
      return paths_.get(index);
    }
    /**
     * <pre>
     * paths are the paths available at root.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string paths = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the paths at the given index.
     */
    public com.google.protobuf.ByteString
        getPathsBytes(int index) {
      return paths_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < paths_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, paths_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < paths_.size(); i++) {
          dataSize += computeStringSizeNoTag(paths_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getPathsList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.RootPaths)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.RootPaths other = (io.kubernetes.client.proto.Meta.RootPaths) obj;

      if (!getPathsList()
          .equals(other.getPathsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getPathsCount() > 0) {
        hash = (37 * hash) + PATHS_FIELD_NUMBER;
        hash = (53 * hash) + getPathsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.RootPaths parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.RootPaths parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.RootPaths parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.RootPaths prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * RootPaths lists the paths available at root.
     * For example: "/healthz", "/apis".
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths)
        io.kubernetes.client.proto.Meta.RootPathsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.RootPaths.class, io.kubernetes.client.proto.Meta.RootPaths.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.RootPaths.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        paths_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.RootPaths getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.RootPaths.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.RootPaths build() {
        io.kubernetes.client.proto.Meta.RootPaths result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.RootPaths buildPartial() {
        io.kubernetes.client.proto.Meta.RootPaths result = new io.kubernetes.client.proto.Meta.RootPaths(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.RootPaths result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          paths_.makeImmutable();
          result.paths_ = paths_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.RootPaths) {
          return mergeFrom((io.kubernetes.client.proto.Meta.RootPaths)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.RootPaths other) {
        if (other == io.kubernetes.client.proto.Meta.RootPaths.getDefaultInstance()) return this;
        if (!other.paths_.isEmpty()) {
          if (paths_.isEmpty()) {
            paths_ = other.paths_;
            bitField0_ |= 0x00000001;
          } else {
            ensurePathsIsMutable();
            paths_.addAll(other.paths_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensurePathsIsMutable();
                paths_.add(bs);
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList paths_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensurePathsIsMutable() {
        if (!paths_.isModifiable()) {
          paths_ = new com.google.protobuf.LazyStringArrayList(paths_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * paths are the paths available at root.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string paths = 1;</code>
       * @return A list containing the paths.
       */
      public com.google.protobuf.ProtocolStringList
          getPathsList() {
        paths_.makeImmutable();
        return paths_;
      }
      /**
       * <pre>
       * paths are the paths available at root.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string paths = 1;</code>
       * @return The count of paths.
       */
      public int getPathsCount() {
        return paths_.size();
      }
      /**
       * <pre>
       * paths are the paths available at root.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string paths = 1;</code>
       * @param index The index of the element to return.
       * @return The paths at the given index.
       */
      public java.lang.String getPaths(int index) {
        return paths_.get(index);
      }
      /**
       * <pre>
       * paths are the paths available at root.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string paths = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the paths at the given index.
       */
      public com.google.protobuf.ByteString
          getPathsBytes(int index) {
        return paths_.getByteString(index);
      }
      /**
       * <pre>
       * paths are the paths available at root.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string paths = 1;</code>
       * @param index The index to set the value at.
       * @param value The paths to set.
       * @return This builder for chaining.
       */
      public Builder setPaths(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensurePathsIsMutable();
        paths_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * paths are the paths available at root.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string paths = 1;</code>
       * @param value The paths to add.
       * @return This builder for chaining.
       */
      public Builder addPaths(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensurePathsIsMutable();
        paths_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * paths are the paths available at root.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string paths = 1;</code>
       * @param values The paths to add.
       * @return This builder for chaining.
       */
      public Builder addAllPaths(
          java.lang.Iterable<java.lang.String> values) {
        ensurePathsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, paths_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * paths are the paths available at root.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string paths = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaths() {
        paths_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * paths are the paths available at root.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string paths = 1;</code>
       * @param value The bytes of the paths to add.
       * @return This builder for chaining.
       */
      public Builder addPathsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensurePathsIsMutable();
        paths_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths)
    private static final io.kubernetes.client.proto.Meta.RootPaths DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.RootPaths();
    }

    public static io.kubernetes.client.proto.Meta.RootPaths getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RootPaths>
        PARSER = new com.google.protobuf.AbstractParser<RootPaths>() {
      @java.lang.Override
      public RootPaths parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<RootPaths> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RootPaths> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.RootPaths getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ServerAddressByClientCIDROrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The CIDR with which clients can match their IP to figure out the server address that they should use.
     * </pre>
     *
     * <code>optional string clientCIDR = 1;</code>
     * @return Whether the clientCIDR field is set.
     */
    boolean hasClientCIDR();
    /**
     * <pre>
     * The CIDR with which clients can match their IP to figure out the server address that they should use.
     * </pre>
     *
     * <code>optional string clientCIDR = 1;</code>
     * @return The clientCIDR.
     */
    java.lang.String getClientCIDR();
    /**
     * <pre>
     * The CIDR with which clients can match their IP to figure out the server address that they should use.
     * </pre>
     *
     * <code>optional string clientCIDR = 1;</code>
     * @return The bytes for clientCIDR.
     */
    com.google.protobuf.ByteString
        getClientCIDRBytes();

    /**
     * <pre>
     * Address of this server, suitable for a client that matches the above CIDR.
     * This can be a hostname, hostname:port, IP or IP:port.
     * </pre>
     *
     * <code>optional string serverAddress = 2;</code>
     * @return Whether the serverAddress field is set.
     */
    boolean hasServerAddress();
    /**
     * <pre>
     * Address of this server, suitable for a client that matches the above CIDR.
     * This can be a hostname, hostname:port, IP or IP:port.
     * </pre>
     *
     * <code>optional string serverAddress = 2;</code>
     * @return The serverAddress.
     */
    java.lang.String getServerAddress();
    /**
     * <pre>
     * Address of this server, suitable for a client that matches the above CIDR.
     * This can be a hostname, hostname:port, IP or IP:port.
     * </pre>
     *
     * <code>optional string serverAddress = 2;</code>
     * @return The bytes for serverAddress.
     */
    com.google.protobuf.ByteString
        getServerAddressBytes();
  }
  /**
   * <pre>
   * ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR}
   */
  public static final class ServerAddressByClientCIDR extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR)
      ServerAddressByClientCIDROrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ServerAddressByClientCIDR.class.getName());
    }
    // Use ServerAddressByClientCIDR.newBuilder() to construct.
    private ServerAddressByClientCIDR(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ServerAddressByClientCIDR() {
      clientCIDR_ = "";
      serverAddress_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.class, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder.class);
    }

    private int bitField0_;
    public static final int CLIENTCIDR_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object clientCIDR_ = "";
    /**
     * <pre>
     * The CIDR with which clients can match their IP to figure out the server address that they should use.
     * </pre>
     *
     * <code>optional string clientCIDR = 1;</code>
     * @return Whether the clientCIDR field is set.
     */
    @java.lang.Override
    public boolean hasClientCIDR() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The CIDR with which clients can match their IP to figure out the server address that they should use.
     * </pre>
     *
     * <code>optional string clientCIDR = 1;</code>
     * @return The clientCIDR.
     */
    @java.lang.Override
    public java.lang.String getClientCIDR() {
      java.lang.Object ref = clientCIDR_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          clientCIDR_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The CIDR with which clients can match their IP to figure out the server address that they should use.
     * </pre>
     *
     * <code>optional string clientCIDR = 1;</code>
     * @return The bytes for clientCIDR.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getClientCIDRBytes() {
      java.lang.Object ref = clientCIDR_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        clientCIDR_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVERADDRESS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object serverAddress_ = "";
    /**
     * <pre>
     * Address of this server, suitable for a client that matches the above CIDR.
     * This can be a hostname, hostname:port, IP or IP:port.
     * </pre>
     *
     * <code>optional string serverAddress = 2;</code>
     * @return Whether the serverAddress field is set.
     */
    @java.lang.Override
    public boolean hasServerAddress() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Address of this server, suitable for a client that matches the above CIDR.
     * This can be a hostname, hostname:port, IP or IP:port.
     * </pre>
     *
     * <code>optional string serverAddress = 2;</code>
     * @return The serverAddress.
     */
    @java.lang.Override
    public java.lang.String getServerAddress() {
      java.lang.Object ref = serverAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          serverAddress_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Address of this server, suitable for a client that matches the above CIDR.
     * This can be a hostname, hostname:port, IP or IP:port.
     * </pre>
     *
     * <code>optional string serverAddress = 2;</code>
     * @return The bytes for serverAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServerAddressBytes() {
      java.lang.Object ref = serverAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serverAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, clientCIDR_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, serverAddress_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, clientCIDR_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, serverAddress_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR other = (io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR) obj;

      if (hasClientCIDR() != other.hasClientCIDR()) return false;
      if (hasClientCIDR()) {
        if (!getClientCIDR()
            .equals(other.getClientCIDR())) return false;
      }
      if (hasServerAddress() != other.hasServerAddress()) return false;
      if (hasServerAddress()) {
        if (!getServerAddress()
            .equals(other.getServerAddress())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasClientCIDR()) {
        hash = (37 * hash) + CLIENTCIDR_FIELD_NUMBER;
        hash = (53 * hash) + getClientCIDR().hashCode();
      }
      if (hasServerAddress()) {
        hash = (37 * hash) + SERVERADDRESS_FIELD_NUMBER;
        hash = (53 * hash) + getServerAddress().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR)
        io.kubernetes.client.proto.Meta.ServerAddressByClientCIDROrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.class, io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        clientCIDR_ = "";
        serverAddress_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR build() {
        io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR buildPartial() {
        io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR result = new io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.clientCIDR_ = clientCIDR_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.serverAddress_ = serverAddress_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR) {
          return mergeFrom((io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR other) {
        if (other == io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR.getDefaultInstance()) return this;
        if (other.hasClientCIDR()) {
          clientCIDR_ = other.clientCIDR_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasServerAddress()) {
          serverAddress_ = other.serverAddress_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                clientCIDR_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                serverAddress_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object clientCIDR_ = "";
      /**
       * <pre>
       * The CIDR with which clients can match their IP to figure out the server address that they should use.
       * </pre>
       *
       * <code>optional string clientCIDR = 1;</code>
       * @return Whether the clientCIDR field is set.
       */
      public boolean hasClientCIDR() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The CIDR with which clients can match their IP to figure out the server address that they should use.
       * </pre>
       *
       * <code>optional string clientCIDR = 1;</code>
       * @return The clientCIDR.
       */
      public java.lang.String getClientCIDR() {
        java.lang.Object ref = clientCIDR_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            clientCIDR_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The CIDR with which clients can match their IP to figure out the server address that they should use.
       * </pre>
       *
       * <code>optional string clientCIDR = 1;</code>
       * @return The bytes for clientCIDR.
       */
      public com.google.protobuf.ByteString
          getClientCIDRBytes() {
        java.lang.Object ref = clientCIDR_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          clientCIDR_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The CIDR with which clients can match their IP to figure out the server address that they should use.
       * </pre>
       *
       * <code>optional string clientCIDR = 1;</code>
       * @param value The clientCIDR to set.
       * @return This builder for chaining.
       */
      public Builder setClientCIDR(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        clientCIDR_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The CIDR with which clients can match their IP to figure out the server address that they should use.
       * </pre>
       *
       * <code>optional string clientCIDR = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearClientCIDR() {
        clientCIDR_ = getDefaultInstance().getClientCIDR();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The CIDR with which clients can match their IP to figure out the server address that they should use.
       * </pre>
       *
       * <code>optional string clientCIDR = 1;</code>
       * @param value The bytes for clientCIDR to set.
       * @return This builder for chaining.
       */
      public Builder setClientCIDRBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        clientCIDR_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object serverAddress_ = "";
      /**
       * <pre>
       * Address of this server, suitable for a client that matches the above CIDR.
       * This can be a hostname, hostname:port, IP or IP:port.
       * </pre>
       *
       * <code>optional string serverAddress = 2;</code>
       * @return Whether the serverAddress field is set.
       */
      public boolean hasServerAddress() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Address of this server, suitable for a client that matches the above CIDR.
       * This can be a hostname, hostname:port, IP or IP:port.
       * </pre>
       *
       * <code>optional string serverAddress = 2;</code>
       * @return The serverAddress.
       */
      public java.lang.String getServerAddress() {
        java.lang.Object ref = serverAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            serverAddress_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Address of this server, suitable for a client that matches the above CIDR.
       * This can be a hostname, hostname:port, IP or IP:port.
       * </pre>
       *
       * <code>optional string serverAddress = 2;</code>
       * @return The bytes for serverAddress.
       */
      public com.google.protobuf.ByteString
          getServerAddressBytes() {
        java.lang.Object ref = serverAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serverAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Address of this server, suitable for a client that matches the above CIDR.
       * This can be a hostname, hostname:port, IP or IP:port.
       * </pre>
       *
       * <code>optional string serverAddress = 2;</code>
       * @param value The serverAddress to set.
       * @return This builder for chaining.
       */
      public Builder setServerAddress(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        serverAddress_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Address of this server, suitable for a client that matches the above CIDR.
       * This can be a hostname, hostname:port, IP or IP:port.
       * </pre>
       *
       * <code>optional string serverAddress = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearServerAddress() {
        serverAddress_ = getDefaultInstance().getServerAddress();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Address of this server, suitable for a client that matches the above CIDR.
       * This can be a hostname, hostname:port, IP or IP:port.
       * </pre>
       *
       * <code>optional string serverAddress = 2;</code>
       * @param value The bytes for serverAddress to set.
       * @return This builder for chaining.
       */
      public Builder setServerAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        serverAddress_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR)
    private static final io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR();
    }

    public static io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ServerAddressByClientCIDR>
        PARSER = new com.google.protobuf.AbstractParser<ServerAddressByClientCIDR>() {
      @java.lang.Override
      public ServerAddressByClientCIDR parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ServerAddressByClientCIDR> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ServerAddressByClientCIDR> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ServerAddressByClientCIDR getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.Status)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Status of the operation.
     * One of: "Success" or "Failure".
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * Status of the operation.
     * One of: "Success" or "Failure".
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    java.lang.String getStatus();
    /**
     * <pre>
     * Status of the operation.
     * One of: "Success" or "Failure".
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    com.google.protobuf.ByteString
        getStatusBytes();

    /**
     * <pre>
     * A human-readable description of the status of this operation.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * A human-readable description of the status of this operation.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * A human-readable description of the status of this operation.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    /**
     * <pre>
     * A machine-readable description of why this operation is in the
     * "Failure" status. If this value is empty there
     * is no information available. A Reason clarifies an HTTP status
     * code but does not override it.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * A machine-readable description of why this operation is in the
     * "Failure" status. If this value is empty there
     * is no information available. A Reason clarifies an HTTP status
     * code but does not override it.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * A machine-readable description of why this operation is in the
     * "Failure" status. If this value is empty there
     * is no information available. A Reason clarifies an HTTP status
     * code but does not override it.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * Extended data associated with the reason.  Each reason may define its
     * own extended details. This field is optional and the data returned
     * is not guaranteed to conform to any schema except that defined by
     * the reason type.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
     * @return Whether the details field is set.
     */
    boolean hasDetails();
    /**
     * <pre>
     * Extended data associated with the reason.  Each reason may define its
     * own extended details. This field is optional and the data returned
     * is not guaranteed to conform to any schema except that defined by
     * the reason type.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
     * @return The details.
     */
    io.kubernetes.client.proto.Meta.StatusDetails getDetails();
    /**
     * <pre>
     * Extended data associated with the reason.  Each reason may define its
     * own extended details. This field is optional and the data returned
     * is not guaranteed to conform to any schema except that defined by
     * the reason type.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
     */
    io.kubernetes.client.proto.Meta.StatusDetailsOrBuilder getDetailsOrBuilder();

    /**
     * <pre>
     * Suggested HTTP return code for this status, 0 if not set.
     * +optional
     * </pre>
     *
     * <code>optional int32 code = 6;</code>
     * @return Whether the code field is set.
     */
    boolean hasCode();
    /**
     * <pre>
     * Suggested HTTP return code for this status, 0 if not set.
     * +optional
     * </pre>
     *
     * <code>optional int32 code = 6;</code>
     * @return The code.
     */
    int getCode();
  }
  /**
   * <pre>
   * Status is a return value for calls that don't return other objects.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Status}
   */
  public static final class Status extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Status)
      StatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Status.class.getName());
    }
    // Use Status.newBuilder() to construct.
    private Status(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Status() {
      status_ = "";
      message_ = "";
      reason_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.Status.class, io.kubernetes.client.proto.Meta.Status.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object status_ = "";
    /**
     * <pre>
     * Status of the operation.
     * One of: "Success" or "Failure".
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Status of the operation.
     * One of: "Success" or "Failure".
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    @java.lang.Override
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Status of the operation.
     * One of: "Success" or "Failure".
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * A human-readable description of the status of this operation.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * A human-readable description of the status of this operation.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable description of the status of this operation.
     * +optional
     * </pre>
     *
     * <code>optional string message = 3;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REASON_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * A machine-readable description of why this operation is in the
     * "Failure" status. If this value is empty there
     * is no information available. A Reason clarifies an HTTP status
     * code but does not override it.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * A machine-readable description of why this operation is in the
     * "Failure" status. If this value is empty there
     * is no information available. A Reason clarifies an HTTP status
     * code but does not override it.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A machine-readable description of why this operation is in the
     * "Failure" status. If this value is empty there
     * is no information available. A Reason clarifies an HTTP status
     * code but does not override it.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DETAILS_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.Meta.StatusDetails details_;
    /**
     * <pre>
     * Extended data associated with the reason.  Each reason may define its
     * own extended details. This field is optional and the data returned
     * is not guaranteed to conform to any schema except that defined by
     * the reason type.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
     * @return Whether the details field is set.
     */
    @java.lang.Override
    public boolean hasDetails() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Extended data associated with the reason.  Each reason may define its
     * own extended details. This field is optional and the data returned
     * is not guaranteed to conform to any schema except that defined by
     * the reason type.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
     * @return The details.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.StatusDetails getDetails() {
      return details_ == null ? io.kubernetes.client.proto.Meta.StatusDetails.getDefaultInstance() : details_;
    }
    /**
     * <pre>
     * Extended data associated with the reason.  Each reason may define its
     * own extended details. This field is optional and the data returned
     * is not guaranteed to conform to any schema except that defined by
     * the reason type.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.StatusDetailsOrBuilder getDetailsOrBuilder() {
      return details_ == null ? io.kubernetes.client.proto.Meta.StatusDetails.getDefaultInstance() : details_;
    }

    public static final int CODE_FIELD_NUMBER = 6;
    private int code_ = 0;
    /**
     * <pre>
     * Suggested HTTP return code for this status, 0 if not set.
     * +optional
     * </pre>
     *
     * <code>optional int32 code = 6;</code>
     * @return Whether the code field is set.
     */
    @java.lang.Override
    public boolean hasCode() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Suggested HTTP return code for this status, 0 if not set.
     * +optional
     * </pre>
     *
     * <code>optional int32 code = 6;</code>
     * @return The code.
     */
    @java.lang.Override
    public int getCode() {
      return code_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, message_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(5, getDetails());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeInt32(6, code_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, message_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getDetails());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, code_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.Status)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.Status other = (io.kubernetes.client.proto.Meta.Status) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasDetails() != other.hasDetails()) return false;
      if (hasDetails()) {
        if (!getDetails()
            .equals(other.getDetails())) return false;
      }
      if (hasCode() != other.hasCode()) return false;
      if (hasCode()) {
        if (getCode()
            != other.getCode()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasDetails()) {
        hash = (37 * hash) + DETAILS_FIELD_NUMBER;
        hash = (53 * hash) + getDetails().hashCode();
      }
      if (hasCode()) {
        hash = (37 * hash) + CODE_FIELD_NUMBER;
        hash = (53 * hash) + getCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.Status parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Status parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Status parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Status parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Status parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Status parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Status parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Status parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.Status parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.Status parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Status parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Status parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.Status prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Status is a return value for calls that don't return other objects.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Status}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Status)
        io.kubernetes.client.proto.Meta.StatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.Status.class, io.kubernetes.client.proto.Meta.Status.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.Status.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getDetailsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        status_ = "";
        message_ = "";
        reason_ = "";
        details_ = null;
        if (detailsBuilder_ != null) {
          detailsBuilder_.dispose();
          detailsBuilder_ = null;
        }
        code_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Status getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.Status.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Status build() {
        io.kubernetes.client.proto.Meta.Status result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Status buildPartial() {
        io.kubernetes.client.proto.Meta.Status result = new io.kubernetes.client.proto.Meta.Status(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.Status result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.details_ = detailsBuilder_ == null
              ? details_
              : detailsBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.code_ = code_;
          to_bitField0_ |= 0x00000020;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.Status) {
          return mergeFrom((io.kubernetes.client.proto.Meta.Status)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.Status other) {
        if (other == io.kubernetes.client.proto.Meta.Status.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasStatus()) {
          status_ = other.status_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasDetails()) {
          mergeDetails(other.getDetails());
        }
        if (other.hasCode()) {
          setCode(other.getCode());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                status_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                message_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                reason_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getDetailsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 48: {
                code_ = input.readInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.lang.Object status_ = "";
      /**
       * <pre>
       * Status of the operation.
       * One of: "Success" or "Failure".
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Status of the operation.
       * One of: "Success" or "Failure".
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The status.
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Status of the operation.
       * One of: "Success" or "Failure".
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The bytes for status.
       */
      public com.google.protobuf.ByteString
          getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Status of the operation.
       * One of: "Success" or "Failure".
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the operation.
       * One of: "Success" or "Failure".
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        status_ = getDefaultInstance().getStatus();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the operation.
       * One of: "Success" or "Failure".
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The bytes for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * A human-readable description of the status of this operation.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3;</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * A human-readable description of the status of this operation.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable description of the status of this operation.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable description of the status of this operation.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable description of the status of this operation.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable description of the status of this operation.
       * +optional
       * </pre>
       *
       * <code>optional string message = 3;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * A machine-readable description of why this operation is in the
       * "Failure" status. If this value is empty there
       * is no information available. A Reason clarifies an HTTP status
       * code but does not override it.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * A machine-readable description of why this operation is in the
       * "Failure" status. If this value is empty there
       * is no information available. A Reason clarifies an HTTP status
       * code but does not override it.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A machine-readable description of why this operation is in the
       * "Failure" status. If this value is empty there
       * is no information available. A Reason clarifies an HTTP status
       * code but does not override it.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A machine-readable description of why this operation is in the
       * "Failure" status. If this value is empty there
       * is no information available. A Reason clarifies an HTTP status
       * code but does not override it.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A machine-readable description of why this operation is in the
       * "Failure" status. If this value is empty there
       * is no information available. A Reason clarifies an HTTP status
       * code but does not override it.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A machine-readable description of why this operation is in the
       * "Failure" status. If this value is empty there
       * is no information available. A Reason clarifies an HTTP status
       * code but does not override it.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.StatusDetails details_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.StatusDetails, io.kubernetes.client.proto.Meta.StatusDetails.Builder, io.kubernetes.client.proto.Meta.StatusDetailsOrBuilder> detailsBuilder_;
      /**
       * <pre>
       * Extended data associated with the reason.  Each reason may define its
       * own extended details. This field is optional and the data returned
       * is not guaranteed to conform to any schema except that defined by
       * the reason type.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
       * @return Whether the details field is set.
       */
      public boolean hasDetails() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Extended data associated with the reason.  Each reason may define its
       * own extended details. This field is optional and the data returned
       * is not guaranteed to conform to any schema except that defined by
       * the reason type.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
       * @return The details.
       */
      public io.kubernetes.client.proto.Meta.StatusDetails getDetails() {
        if (detailsBuilder_ == null) {
          return details_ == null ? io.kubernetes.client.proto.Meta.StatusDetails.getDefaultInstance() : details_;
        } else {
          return detailsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Extended data associated with the reason.  Each reason may define its
       * own extended details. This field is optional and the data returned
       * is not guaranteed to conform to any schema except that defined by
       * the reason type.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
       */
      public Builder setDetails(io.kubernetes.client.proto.Meta.StatusDetails value) {
        if (detailsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          details_ = value;
        } else {
          detailsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Extended data associated with the reason.  Each reason may define its
       * own extended details. This field is optional and the data returned
       * is not guaranteed to conform to any schema except that defined by
       * the reason type.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
       */
      public Builder setDetails(
          io.kubernetes.client.proto.Meta.StatusDetails.Builder builderForValue) {
        if (detailsBuilder_ == null) {
          details_ = builderForValue.build();
        } else {
          detailsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Extended data associated with the reason.  Each reason may define its
       * own extended details. This field is optional and the data returned
       * is not guaranteed to conform to any schema except that defined by
       * the reason type.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
       */
      public Builder mergeDetails(io.kubernetes.client.proto.Meta.StatusDetails value) {
        if (detailsBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            details_ != null &&
            details_ != io.kubernetes.client.proto.Meta.StatusDetails.getDefaultInstance()) {
            getDetailsBuilder().mergeFrom(value);
          } else {
            details_ = value;
          }
        } else {
          detailsBuilder_.mergeFrom(value);
        }
        if (details_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Extended data associated with the reason.  Each reason may define its
       * own extended details. This field is optional and the data returned
       * is not guaranteed to conform to any schema except that defined by
       * the reason type.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
       */
      public Builder clearDetails() {
        bitField0_ = (bitField0_ & ~0x00000010);
        details_ = null;
        if (detailsBuilder_ != null) {
          detailsBuilder_.dispose();
          detailsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Extended data associated with the reason.  Each reason may define its
       * own extended details. This field is optional and the data returned
       * is not guaranteed to conform to any schema except that defined by
       * the reason type.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.StatusDetails.Builder getDetailsBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getDetailsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Extended data associated with the reason.  Each reason may define its
       * own extended details. This field is optional and the data returned
       * is not guaranteed to conform to any schema except that defined by
       * the reason type.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.StatusDetailsOrBuilder getDetailsOrBuilder() {
        if (detailsBuilder_ != null) {
          return detailsBuilder_.getMessageOrBuilder();
        } else {
          return details_ == null ?
              io.kubernetes.client.proto.Meta.StatusDetails.getDefaultInstance() : details_;
        }
      }
      /**
       * <pre>
       * Extended data associated with the reason.  Each reason may define its
       * own extended details. This field is optional and the data returned
       * is not guaranteed to conform to any schema except that defined by
       * the reason type.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.StatusDetails, io.kubernetes.client.proto.Meta.StatusDetails.Builder, io.kubernetes.client.proto.Meta.StatusDetailsOrBuilder> 
          getDetailsFieldBuilder() {
        if (detailsBuilder_ == null) {
          detailsBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.StatusDetails, io.kubernetes.client.proto.Meta.StatusDetails.Builder, io.kubernetes.client.proto.Meta.StatusDetailsOrBuilder>(
                  getDetails(),
                  getParentForChildren(),
                  isClean());
          details_ = null;
        }
        return detailsBuilder_;
      }

      private int code_ ;
      /**
       * <pre>
       * Suggested HTTP return code for this status, 0 if not set.
       * +optional
       * </pre>
       *
       * <code>optional int32 code = 6;</code>
       * @return Whether the code field is set.
       */
      @java.lang.Override
      public boolean hasCode() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Suggested HTTP return code for this status, 0 if not set.
       * +optional
       * </pre>
       *
       * <code>optional int32 code = 6;</code>
       * @return The code.
       */
      @java.lang.Override
      public int getCode() {
        return code_;
      }
      /**
       * <pre>
       * Suggested HTTP return code for this status, 0 if not set.
       * +optional
       * </pre>
       *
       * <code>optional int32 code = 6;</code>
       * @param value The code to set.
       * @return This builder for chaining.
       */
      public Builder setCode(int value) {

        code_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Suggested HTTP return code for this status, 0 if not set.
       * +optional
       * </pre>
       *
       * <code>optional int32 code = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearCode() {
        bitField0_ = (bitField0_ & ~0x00000020);
        code_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Status)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Status)
    private static final io.kubernetes.client.proto.Meta.Status DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.Status();
    }

    public static io.kubernetes.client.proto.Meta.Status getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Status>
        PARSER = new com.google.protobuf.AbstractParser<Status>() {
      @java.lang.Override
      public Status parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Status> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Status> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Status getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatusCauseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A machine-readable description of the cause of the error. If this value is
     * empty there is no information available.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1;</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * A machine-readable description of the cause of the error. If this value is
     * empty there is no information available.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1;</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * A machine-readable description of the cause of the error. If this value is
     * empty there is no information available.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1;</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * A human-readable description of the cause of the error.  This field may be
     * presented as-is to a reader.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * A human-readable description of the cause of the error.  This field may be
     * presented as-is to a reader.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * A human-readable description of the cause of the error.  This field may be
     * presented as-is to a reader.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    /**
     * <pre>
     * The field of the resource that has caused this error, as named by its JSON
     * serialization. May include dot and postfix notation for nested attributes.
     * Arrays are zero-indexed.  Fields may appear more than once in an array of
     * causes due to fields having multiple errors.
     * Optional.
     *
     * Examples:
     * "name" - the field "name" on the current resource
     * "items[0].name" - the field "name" on the first array entry in "items"
     * +optional
     * </pre>
     *
     * <code>optional string field = 3;</code>
     * @return Whether the field field is set.
     */
    boolean hasField();
    /**
     * <pre>
     * The field of the resource that has caused this error, as named by its JSON
     * serialization. May include dot and postfix notation for nested attributes.
     * Arrays are zero-indexed.  Fields may appear more than once in an array of
     * causes due to fields having multiple errors.
     * Optional.
     *
     * Examples:
     * "name" - the field "name" on the current resource
     * "items[0].name" - the field "name" on the first array entry in "items"
     * +optional
     * </pre>
     *
     * <code>optional string field = 3;</code>
     * @return The field.
     */
    java.lang.String getField();
    /**
     * <pre>
     * The field of the resource that has caused this error, as named by its JSON
     * serialization. May include dot and postfix notation for nested attributes.
     * Arrays are zero-indexed.  Fields may appear more than once in an array of
     * causes due to fields having multiple errors.
     * Optional.
     *
     * Examples:
     * "name" - the field "name" on the current resource
     * "items[0].name" - the field "name" on the first array entry in "items"
     * +optional
     * </pre>
     *
     * <code>optional string field = 3;</code>
     * @return The bytes for field.
     */
    com.google.protobuf.ByteString
        getFieldBytes();
  }
  /**
   * <pre>
   * StatusCause provides more information about an api.Status failure, including
   * cases when multiple errors are encountered.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause}
   */
  public static final class StatusCause extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause)
      StatusCauseOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatusCause.class.getName());
    }
    // Use StatusCause.newBuilder() to construct.
    private StatusCause(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatusCause() {
      reason_ = "";
      message_ = "";
      field_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.StatusCause.class, io.kubernetes.client.proto.Meta.StatusCause.Builder.class);
    }

    private int bitField0_;
    public static final int REASON_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * A machine-readable description of the cause of the error. If this value is
     * empty there is no information available.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1;</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A machine-readable description of the cause of the error. If this value is
     * empty there is no information available.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1;</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A machine-readable description of the cause of the error. If this value is
     * empty there is no information available.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 1;</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * A human-readable description of the cause of the error.  This field may be
     * presented as-is to a reader.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * A human-readable description of the cause of the error.  This field may be
     * presented as-is to a reader.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable description of the cause of the error.  This field may be
     * presented as-is to a reader.
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FIELD_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object field_ = "";
    /**
     * <pre>
     * The field of the resource that has caused this error, as named by its JSON
     * serialization. May include dot and postfix notation for nested attributes.
     * Arrays are zero-indexed.  Fields may appear more than once in an array of
     * causes due to fields having multiple errors.
     * Optional.
     *
     * Examples:
     * "name" - the field "name" on the current resource
     * "items[0].name" - the field "name" on the first array entry in "items"
     * +optional
     * </pre>
     *
     * <code>optional string field = 3;</code>
     * @return Whether the field field is set.
     */
    @java.lang.Override
    public boolean hasField() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The field of the resource that has caused this error, as named by its JSON
     * serialization. May include dot and postfix notation for nested attributes.
     * Arrays are zero-indexed.  Fields may appear more than once in an array of
     * causes due to fields having multiple errors.
     * Optional.
     *
     * Examples:
     * "name" - the field "name" on the current resource
     * "items[0].name" - the field "name" on the first array entry in "items"
     * +optional
     * </pre>
     *
     * <code>optional string field = 3;</code>
     * @return The field.
     */
    @java.lang.Override
    public java.lang.String getField() {
      java.lang.Object ref = field_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          field_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The field of the resource that has caused this error, as named by its JSON
     * serialization. May include dot and postfix notation for nested attributes.
     * Arrays are zero-indexed.  Fields may appear more than once in an array of
     * causes due to fields having multiple errors.
     * Optional.
     *
     * Examples:
     * "name" - the field "name" on the current resource
     * "items[0].name" - the field "name" on the first array entry in "items"
     * +optional
     * </pre>
     *
     * <code>optional string field = 3;</code>
     * @return The bytes for field.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldBytes() {
      java.lang.Object ref = field_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        field_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, reason_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, message_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, field_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, reason_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, message_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, field_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.StatusCause)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.StatusCause other = (io.kubernetes.client.proto.Meta.StatusCause) obj;

      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (hasField() != other.hasField()) return false;
      if (hasField()) {
        if (!getField()
            .equals(other.getField())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      if (hasField()) {
        hash = (37 * hash) + FIELD_FIELD_NUMBER;
        hash = (53 * hash) + getField().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.StatusCause parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.StatusCause parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.StatusCause parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.StatusCause prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StatusCause provides more information about an api.Status failure, including
     * cases when multiple errors are encountered.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause)
        io.kubernetes.client.proto.Meta.StatusCauseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.StatusCause.class, io.kubernetes.client.proto.Meta.StatusCause.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.StatusCause.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        reason_ = "";
        message_ = "";
        field_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.StatusCause getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.StatusCause.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.StatusCause build() {
        io.kubernetes.client.proto.Meta.StatusCause result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.StatusCause buildPartial() {
        io.kubernetes.client.proto.Meta.StatusCause result = new io.kubernetes.client.proto.Meta.StatusCause(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.StatusCause result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.field_ = field_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.StatusCause) {
          return mergeFrom((io.kubernetes.client.proto.Meta.StatusCause)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.StatusCause other) {
        if (other == io.kubernetes.client.proto.Meta.StatusCause.getDefaultInstance()) return this;
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasField()) {
          field_ = other.field_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                reason_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                message_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                field_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * A machine-readable description of the cause of the error. If this value is
       * empty there is no information available.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1;</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A machine-readable description of the cause of the error. If this value is
       * empty there is no information available.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1;</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A machine-readable description of the cause of the error. If this value is
       * empty there is no information available.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1;</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A machine-readable description of the cause of the error. If this value is
       * empty there is no information available.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1;</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A machine-readable description of the cause of the error. If this value is
       * empty there is no information available.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A machine-readable description of the cause of the error. If this value is
       * empty there is no information available.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 1;</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * A human-readable description of the cause of the error.  This field may be
       * presented as-is to a reader.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * A human-readable description of the cause of the error.  This field may be
       * presented as-is to a reader.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable description of the cause of the error.  This field may be
       * presented as-is to a reader.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable description of the cause of the error.  This field may be
       * presented as-is to a reader.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable description of the cause of the error.  This field may be
       * presented as-is to a reader.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable description of the cause of the error.  This field may be
       * presented as-is to a reader.
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object field_ = "";
      /**
       * <pre>
       * The field of the resource that has caused this error, as named by its JSON
       * serialization. May include dot and postfix notation for nested attributes.
       * Arrays are zero-indexed.  Fields may appear more than once in an array of
       * causes due to fields having multiple errors.
       * Optional.
       *
       * Examples:
       * "name" - the field "name" on the current resource
       * "items[0].name" - the field "name" on the first array entry in "items"
       * +optional
       * </pre>
       *
       * <code>optional string field = 3;</code>
       * @return Whether the field field is set.
       */
      public boolean hasField() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The field of the resource that has caused this error, as named by its JSON
       * serialization. May include dot and postfix notation for nested attributes.
       * Arrays are zero-indexed.  Fields may appear more than once in an array of
       * causes due to fields having multiple errors.
       * Optional.
       *
       * Examples:
       * "name" - the field "name" on the current resource
       * "items[0].name" - the field "name" on the first array entry in "items"
       * +optional
       * </pre>
       *
       * <code>optional string field = 3;</code>
       * @return The field.
       */
      public java.lang.String getField() {
        java.lang.Object ref = field_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            field_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The field of the resource that has caused this error, as named by its JSON
       * serialization. May include dot and postfix notation for nested attributes.
       * Arrays are zero-indexed.  Fields may appear more than once in an array of
       * causes due to fields having multiple errors.
       * Optional.
       *
       * Examples:
       * "name" - the field "name" on the current resource
       * "items[0].name" - the field "name" on the first array entry in "items"
       * +optional
       * </pre>
       *
       * <code>optional string field = 3;</code>
       * @return The bytes for field.
       */
      public com.google.protobuf.ByteString
          getFieldBytes() {
        java.lang.Object ref = field_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          field_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The field of the resource that has caused this error, as named by its JSON
       * serialization. May include dot and postfix notation for nested attributes.
       * Arrays are zero-indexed.  Fields may appear more than once in an array of
       * causes due to fields having multiple errors.
       * Optional.
       *
       * Examples:
       * "name" - the field "name" on the current resource
       * "items[0].name" - the field "name" on the first array entry in "items"
       * +optional
       * </pre>
       *
       * <code>optional string field = 3;</code>
       * @param value The field to set.
       * @return This builder for chaining.
       */
      public Builder setField(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        field_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The field of the resource that has caused this error, as named by its JSON
       * serialization. May include dot and postfix notation for nested attributes.
       * Arrays are zero-indexed.  Fields may appear more than once in an array of
       * causes due to fields having multiple errors.
       * Optional.
       *
       * Examples:
       * "name" - the field "name" on the current resource
       * "items[0].name" - the field "name" on the first array entry in "items"
       * +optional
       * </pre>
       *
       * <code>optional string field = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearField() {
        field_ = getDefaultInstance().getField();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The field of the resource that has caused this error, as named by its JSON
       * serialization. May include dot and postfix notation for nested attributes.
       * Arrays are zero-indexed.  Fields may appear more than once in an array of
       * causes due to fields having multiple errors.
       * Optional.
       *
       * Examples:
       * "name" - the field "name" on the current resource
       * "items[0].name" - the field "name" on the first array entry in "items"
       * +optional
       * </pre>
       *
       * <code>optional string field = 3;</code>
       * @param value The bytes for field to set.
       * @return This builder for chaining.
       */
      public Builder setFieldBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        field_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause)
    private static final io.kubernetes.client.proto.Meta.StatusCause DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.StatusCause();
    }

    public static io.kubernetes.client.proto.Meta.StatusCause getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatusCause>
        PARSER = new com.google.protobuf.AbstractParser<StatusCause>() {
      @java.lang.Override
      public StatusCause parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatusCause> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatusCause> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.StatusCause getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatusDetailsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name attribute of the resource associated with the status StatusReason
     * (when there is a single name which can be described).
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * The name attribute of the resource associated with the status StatusReason
     * (when there is a single name which can be described).
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name attribute of the resource associated with the status StatusReason
     * (when there is a single name which can be described).
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * The group attribute of the resource associated with the status StatusReason.
     * +optional
     * </pre>
     *
     * <code>optional string group = 2;</code>
     * @return Whether the group field is set.
     */
    boolean hasGroup();
    /**
     * <pre>
     * The group attribute of the resource associated with the status StatusReason.
     * +optional
     * </pre>
     *
     * <code>optional string group = 2;</code>
     * @return The group.
     */
    java.lang.String getGroup();
    /**
     * <pre>
     * The group attribute of the resource associated with the status StatusReason.
     * +optional
     * </pre>
     *
     * <code>optional string group = 2;</code>
     * @return The bytes for group.
     */
    com.google.protobuf.ByteString
        getGroupBytes();

    /**
     * <pre>
     * The kind attribute of the resource associated with the status StatusReason.
     * On some operations may differ from the requested resource Kind.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return Whether the kind field is set.
     */
    boolean hasKind();
    /**
     * <pre>
     * The kind attribute of the resource associated with the status StatusReason.
     * On some operations may differ from the requested resource Kind.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return The kind.
     */
    java.lang.String getKind();
    /**
     * <pre>
     * The kind attribute of the resource associated with the status StatusReason.
     * On some operations may differ from the requested resource Kind.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return The bytes for kind.
     */
    com.google.protobuf.ByteString
        getKindBytes();

    /**
     * <pre>
     * UID of the resource.
     * (when there is a single resource which can be described).
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 6;</code>
     * @return Whether the uid field is set.
     */
    boolean hasUid();
    /**
     * <pre>
     * UID of the resource.
     * (when there is a single resource which can be described).
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 6;</code>
     * @return The uid.
     */
    java.lang.String getUid();
    /**
     * <pre>
     * UID of the resource.
     * (when there is a single resource which can be described).
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 6;</code>
     * @return The bytes for uid.
     */
    com.google.protobuf.ByteString
        getUidBytes();

    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.StatusCause> 
        getCausesList();
    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    io.kubernetes.client.proto.Meta.StatusCause getCauses(int index);
    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    int getCausesCount();
    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.StatusCauseOrBuilder> 
        getCausesOrBuilderList();
    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    io.kubernetes.client.proto.Meta.StatusCauseOrBuilder getCausesOrBuilder(
        int index);

    /**
     * <pre>
     * If specified, the time in seconds before the operation should be retried. Some errors may indicate
     * the client must take an alternate action - for those errors this field may indicate how long to wait
     * before taking the alternate action.
     * +optional
     * </pre>
     *
     * <code>optional int32 retryAfterSeconds = 5;</code>
     * @return Whether the retryAfterSeconds field is set.
     */
    boolean hasRetryAfterSeconds();
    /**
     * <pre>
     * If specified, the time in seconds before the operation should be retried. Some errors may indicate
     * the client must take an alternate action - for those errors this field may indicate how long to wait
     * before taking the alternate action.
     * +optional
     * </pre>
     *
     * <code>optional int32 retryAfterSeconds = 5;</code>
     * @return The retryAfterSeconds.
     */
    int getRetryAfterSeconds();
  }
  /**
   * <pre>
   * StatusDetails is a set of additional properties that MAY be set by the
   * server to provide additional information about a response. The Reason
   * field of a Status object defines what attributes will be set. Clients
   * must ignore fields that do not match the defined type of each attribute,
   * and should assume that any attribute may be empty, invalid, or under
   * defined.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails}
   */
  public static final class StatusDetails extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails)
      StatusDetailsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatusDetails.class.getName());
    }
    // Use StatusDetails.newBuilder() to construct.
    private StatusDetails(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatusDetails() {
      name_ = "";
      group_ = "";
      kind_ = "";
      uid_ = "";
      causes_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.StatusDetails.class, io.kubernetes.client.proto.Meta.StatusDetails.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * The name attribute of the resource associated with the status StatusReason
     * (when there is a single name which can be described).
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The name attribute of the resource associated with the status StatusReason
     * (when there is a single name which can be described).
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name attribute of the resource associated with the status StatusReason
     * (when there is a single name which can be described).
     * +optional
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int GROUP_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object group_ = "";
    /**
     * <pre>
     * The group attribute of the resource associated with the status StatusReason.
     * +optional
     * </pre>
     *
     * <code>optional string group = 2;</code>
     * @return Whether the group field is set.
     */
    @java.lang.Override
    public boolean hasGroup() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The group attribute of the resource associated with the status StatusReason.
     * +optional
     * </pre>
     *
     * <code>optional string group = 2;</code>
     * @return The group.
     */
    @java.lang.Override
    public java.lang.String getGroup() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          group_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The group attribute of the resource associated with the status StatusReason.
     * +optional
     * </pre>
     *
     * <code>optional string group = 2;</code>
     * @return The bytes for group.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroupBytes() {
      java.lang.Object ref = group_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        group_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KIND_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object kind_ = "";
    /**
     * <pre>
     * The kind attribute of the resource associated with the status StatusReason.
     * On some operations may differ from the requested resource Kind.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return Whether the kind field is set.
     */
    @java.lang.Override
    public boolean hasKind() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The kind attribute of the resource associated with the status StatusReason.
     * On some operations may differ from the requested resource Kind.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return The kind.
     */
    @java.lang.Override
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          kind_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The kind attribute of the resource associated with the status StatusReason.
     * On some operations may differ from the requested resource Kind.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 3;</code>
     * @return The bytes for kind.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UID_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object uid_ = "";
    /**
     * <pre>
     * UID of the resource.
     * (when there is a single resource which can be described).
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 6;</code>
     * @return Whether the uid field is set.
     */
    @java.lang.Override
    public boolean hasUid() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * UID of the resource.
     * (when there is a single resource which can be described).
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 6;</code>
     * @return The uid.
     */
    @java.lang.Override
    public java.lang.String getUid() {
      java.lang.Object ref = uid_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          uid_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * UID of the resource.
     * (when there is a single resource which can be described).
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * +optional
     * </pre>
     *
     * <code>optional string uid = 6;</code>
     * @return The bytes for uid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUidBytes() {
      java.lang.Object ref = uid_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uid_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CAUSES_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.StatusCause> causes_;
    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.StatusCause> getCausesList() {
      return causes_;
    }
    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.StatusCauseOrBuilder> 
        getCausesOrBuilderList() {
      return causes_;
    }
    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    @java.lang.Override
    public int getCausesCount() {
      return causes_.size();
    }
    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.StatusCause getCauses(int index) {
      return causes_.get(index);
    }
    /**
     * <pre>
     * The Causes array includes more details associated with the StatusReason
     * failure. Not all StatusReasons may provide detailed causes.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.StatusCauseOrBuilder getCausesOrBuilder(
        int index) {
      return causes_.get(index);
    }

    public static final int RETRYAFTERSECONDS_FIELD_NUMBER = 5;
    private int retryAfterSeconds_ = 0;
    /**
     * <pre>
     * If specified, the time in seconds before the operation should be retried. Some errors may indicate
     * the client must take an alternate action - for those errors this field may indicate how long to wait
     * before taking the alternate action.
     * +optional
     * </pre>
     *
     * <code>optional int32 retryAfterSeconds = 5;</code>
     * @return Whether the retryAfterSeconds field is set.
     */
    @java.lang.Override
    public boolean hasRetryAfterSeconds() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * If specified, the time in seconds before the operation should be retried. Some errors may indicate
     * the client must take an alternate action - for those errors this field may indicate how long to wait
     * before taking the alternate action.
     * +optional
     * </pre>
     *
     * <code>optional int32 retryAfterSeconds = 5;</code>
     * @return The retryAfterSeconds.
     */
    @java.lang.Override
    public int getRetryAfterSeconds() {
      return retryAfterSeconds_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, group_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, kind_);
      }
      for (int i = 0; i < causes_.size(); i++) {
        output.writeMessage(4, causes_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt32(5, retryAfterSeconds_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, uid_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, group_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, kind_);
      }
      for (int i = 0; i < causes_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, causes_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, retryAfterSeconds_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, uid_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.StatusDetails)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.StatusDetails other = (io.kubernetes.client.proto.Meta.StatusDetails) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasGroup() != other.hasGroup()) return false;
      if (hasGroup()) {
        if (!getGroup()
            .equals(other.getGroup())) return false;
      }
      if (hasKind() != other.hasKind()) return false;
      if (hasKind()) {
        if (!getKind()
            .equals(other.getKind())) return false;
      }
      if (hasUid() != other.hasUid()) return false;
      if (hasUid()) {
        if (!getUid()
            .equals(other.getUid())) return false;
      }
      if (!getCausesList()
          .equals(other.getCausesList())) return false;
      if (hasRetryAfterSeconds() != other.hasRetryAfterSeconds()) return false;
      if (hasRetryAfterSeconds()) {
        if (getRetryAfterSeconds()
            != other.getRetryAfterSeconds()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasGroup()) {
        hash = (37 * hash) + GROUP_FIELD_NUMBER;
        hash = (53 * hash) + getGroup().hashCode();
      }
      if (hasKind()) {
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + getKind().hashCode();
      }
      if (hasUid()) {
        hash = (37 * hash) + UID_FIELD_NUMBER;
        hash = (53 * hash) + getUid().hashCode();
      }
      if (getCausesCount() > 0) {
        hash = (37 * hash) + CAUSES_FIELD_NUMBER;
        hash = (53 * hash) + getCausesList().hashCode();
      }
      if (hasRetryAfterSeconds()) {
        hash = (37 * hash) + RETRYAFTERSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getRetryAfterSeconds();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.StatusDetails parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.StatusDetails parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.StatusDetails parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.StatusDetails prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StatusDetails is a set of additional properties that MAY be set by the
     * server to provide additional information about a response. The Reason
     * field of a Status object defines what attributes will be set. Clients
     * must ignore fields that do not match the defined type of each attribute,
     * and should assume that any attribute may be empty, invalid, or under
     * defined.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails)
        io.kubernetes.client.proto.Meta.StatusDetailsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.StatusDetails.class, io.kubernetes.client.proto.Meta.StatusDetails.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.StatusDetails.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        group_ = "";
        kind_ = "";
        uid_ = "";
        if (causesBuilder_ == null) {
          causes_ = java.util.Collections.emptyList();
        } else {
          causes_ = null;
          causesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        retryAfterSeconds_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.StatusDetails getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.StatusDetails.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.StatusDetails build() {
        io.kubernetes.client.proto.Meta.StatusDetails result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.StatusDetails buildPartial() {
        io.kubernetes.client.proto.Meta.StatusDetails result = new io.kubernetes.client.proto.Meta.StatusDetails(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.Meta.StatusDetails result) {
        if (causesBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            causes_ = java.util.Collections.unmodifiableList(causes_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.causes_ = causes_;
        } else {
          result.causes_ = causesBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.StatusDetails result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.group_ = group_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.kind_ = kind_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.uid_ = uid_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.retryAfterSeconds_ = retryAfterSeconds_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.StatusDetails) {
          return mergeFrom((io.kubernetes.client.proto.Meta.StatusDetails)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.StatusDetails other) {
        if (other == io.kubernetes.client.proto.Meta.StatusDetails.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasGroup()) {
          group_ = other.group_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasKind()) {
          kind_ = other.kind_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasUid()) {
          uid_ = other.uid_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (causesBuilder_ == null) {
          if (!other.causes_.isEmpty()) {
            if (causes_.isEmpty()) {
              causes_ = other.causes_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureCausesIsMutable();
              causes_.addAll(other.causes_);
            }
            onChanged();
          }
        } else {
          if (!other.causes_.isEmpty()) {
            if (causesBuilder_.isEmpty()) {
              causesBuilder_.dispose();
              causesBuilder_ = null;
              causes_ = other.causes_;
              bitField0_ = (bitField0_ & ~0x00000010);
              causesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getCausesFieldBuilder() : null;
            } else {
              causesBuilder_.addAllMessages(other.causes_);
            }
          }
        }
        if (other.hasRetryAfterSeconds()) {
          setRetryAfterSeconds(other.getRetryAfterSeconds());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                group_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                kind_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                io.kubernetes.client.proto.Meta.StatusCause m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.StatusCause.parser(),
                        extensionRegistry);
                if (causesBuilder_ == null) {
                  ensureCausesIsMutable();
                  causes_.add(m);
                } else {
                  causesBuilder_.addMessage(m);
                }
                break;
              } // case 34
              case 40: {
                retryAfterSeconds_ = input.readInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 40
              case 50: {
                uid_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name attribute of the resource associated with the status StatusReason
       * (when there is a single name which can be described).
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The name attribute of the resource associated with the status StatusReason
       * (when there is a single name which can be described).
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name attribute of the resource associated with the status StatusReason
       * (when there is a single name which can be described).
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name attribute of the resource associated with the status StatusReason
       * (when there is a single name which can be described).
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name attribute of the resource associated with the status StatusReason
       * (when there is a single name which can be described).
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name attribute of the resource associated with the status StatusReason
       * (when there is a single name which can be described).
       * +optional
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object group_ = "";
      /**
       * <pre>
       * The group attribute of the resource associated with the status StatusReason.
       * +optional
       * </pre>
       *
       * <code>optional string group = 2;</code>
       * @return Whether the group field is set.
       */
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The group attribute of the resource associated with the status StatusReason.
       * +optional
       * </pre>
       *
       * <code>optional string group = 2;</code>
       * @return The group.
       */
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The group attribute of the resource associated with the status StatusReason.
       * +optional
       * </pre>
       *
       * <code>optional string group = 2;</code>
       * @return The bytes for group.
       */
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The group attribute of the resource associated with the status StatusReason.
       * +optional
       * </pre>
       *
       * <code>optional string group = 2;</code>
       * @param value The group to set.
       * @return This builder for chaining.
       */
      public Builder setGroup(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The group attribute of the resource associated with the status StatusReason.
       * +optional
       * </pre>
       *
       * <code>optional string group = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearGroup() {
        group_ = getDefaultInstance().getGroup();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The group attribute of the resource associated with the status StatusReason.
       * +optional
       * </pre>
       *
       * <code>optional string group = 2;</code>
       * @param value The bytes for group to set.
       * @return This builder for chaining.
       */
      public Builder setGroupBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        group_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object kind_ = "";
      /**
       * <pre>
       * The kind attribute of the resource associated with the status StatusReason.
       * On some operations may differ from the requested resource Kind.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @return Whether the kind field is set.
       */
      public boolean hasKind() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The kind attribute of the resource associated with the status StatusReason.
       * On some operations may differ from the requested resource Kind.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @return The kind.
       */
      public java.lang.String getKind() {
        java.lang.Object ref = kind_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            kind_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The kind attribute of the resource associated with the status StatusReason.
       * On some operations may differ from the requested resource Kind.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @return The bytes for kind.
       */
      public com.google.protobuf.ByteString
          getKindBytes() {
        java.lang.Object ref = kind_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          kind_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The kind attribute of the resource associated with the status StatusReason.
       * On some operations may differ from the requested resource Kind.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @param value The kind to set.
       * @return This builder for chaining.
       */
      public Builder setKind(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The kind attribute of the resource associated with the status StatusReason.
       * On some operations may differ from the requested resource Kind.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearKind() {
        kind_ = getDefaultInstance().getKind();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The kind attribute of the resource associated with the status StatusReason.
       * On some operations may differ from the requested resource Kind.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 3;</code>
       * @param value The bytes for kind to set.
       * @return This builder for chaining.
       */
      public Builder setKindBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object uid_ = "";
      /**
       * <pre>
       * UID of the resource.
       * (when there is a single resource which can be described).
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 6;</code>
       * @return Whether the uid field is set.
       */
      public boolean hasUid() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * UID of the resource.
       * (when there is a single resource which can be described).
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 6;</code>
       * @return The uid.
       */
      public java.lang.String getUid() {
        java.lang.Object ref = uid_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            uid_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * UID of the resource.
       * (when there is a single resource which can be described).
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 6;</code>
       * @return The bytes for uid.
       */
      public com.google.protobuf.ByteString
          getUidBytes() {
        java.lang.Object ref = uid_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          uid_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * UID of the resource.
       * (when there is a single resource which can be described).
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 6;</code>
       * @param value The uid to set.
       * @return This builder for chaining.
       */
      public Builder setUid(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        uid_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UID of the resource.
       * (when there is a single resource which can be described).
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearUid() {
        uid_ = getDefaultInstance().getUid();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UID of the resource.
       * (when there is a single resource which can be described).
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       * +optional
       * </pre>
       *
       * <code>optional string uid = 6;</code>
       * @param value The bytes for uid to set.
       * @return This builder for chaining.
       */
      public Builder setUidBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        uid_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.StatusCause> causes_ =
        java.util.Collections.emptyList();
      private void ensureCausesIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          causes_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.StatusCause>(causes_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.StatusCause, io.kubernetes.client.proto.Meta.StatusCause.Builder, io.kubernetes.client.proto.Meta.StatusCauseOrBuilder> causesBuilder_;

      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.StatusCause> getCausesList() {
        if (causesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(causes_);
        } else {
          return causesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public int getCausesCount() {
        if (causesBuilder_ == null) {
          return causes_.size();
        } else {
          return causesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.StatusCause getCauses(int index) {
        if (causesBuilder_ == null) {
          return causes_.get(index);
        } else {
          return causesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public Builder setCauses(
          int index, io.kubernetes.client.proto.Meta.StatusCause value) {
        if (causesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCausesIsMutable();
          causes_.set(index, value);
          onChanged();
        } else {
          causesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public Builder setCauses(
          int index, io.kubernetes.client.proto.Meta.StatusCause.Builder builderForValue) {
        if (causesBuilder_ == null) {
          ensureCausesIsMutable();
          causes_.set(index, builderForValue.build());
          onChanged();
        } else {
          causesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public Builder addCauses(io.kubernetes.client.proto.Meta.StatusCause value) {
        if (causesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCausesIsMutable();
          causes_.add(value);
          onChanged();
        } else {
          causesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public Builder addCauses(
          int index, io.kubernetes.client.proto.Meta.StatusCause value) {
        if (causesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCausesIsMutable();
          causes_.add(index, value);
          onChanged();
        } else {
          causesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public Builder addCauses(
          io.kubernetes.client.proto.Meta.StatusCause.Builder builderForValue) {
        if (causesBuilder_ == null) {
          ensureCausesIsMutable();
          causes_.add(builderForValue.build());
          onChanged();
        } else {
          causesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public Builder addCauses(
          int index, io.kubernetes.client.proto.Meta.StatusCause.Builder builderForValue) {
        if (causesBuilder_ == null) {
          ensureCausesIsMutable();
          causes_.add(index, builderForValue.build());
          onChanged();
        } else {
          causesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public Builder addAllCauses(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.StatusCause> values) {
        if (causesBuilder_ == null) {
          ensureCausesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, causes_);
          onChanged();
        } else {
          causesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public Builder clearCauses() {
        if (causesBuilder_ == null) {
          causes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          causesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public Builder removeCauses(int index) {
        if (causesBuilder_ == null) {
          ensureCausesIsMutable();
          causes_.remove(index);
          onChanged();
        } else {
          causesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.StatusCause.Builder getCausesBuilder(
          int index) {
        return getCausesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.StatusCauseOrBuilder getCausesOrBuilder(
          int index) {
        if (causesBuilder_ == null) {
          return causes_.get(index);  } else {
          return causesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.StatusCauseOrBuilder> 
           getCausesOrBuilderList() {
        if (causesBuilder_ != null) {
          return causesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(causes_);
        }
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.StatusCause.Builder addCausesBuilder() {
        return getCausesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.StatusCause.getDefaultInstance());
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.StatusCause.Builder addCausesBuilder(
          int index) {
        return getCausesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.StatusCause.getDefaultInstance());
      }
      /**
       * <pre>
       * The Causes array includes more details associated with the StatusReason
       * failure. Not all StatusReasons may provide detailed causes.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.StatusCause.Builder> 
           getCausesBuilderList() {
        return getCausesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.StatusCause, io.kubernetes.client.proto.Meta.StatusCause.Builder, io.kubernetes.client.proto.Meta.StatusCauseOrBuilder> 
          getCausesFieldBuilder() {
        if (causesBuilder_ == null) {
          causesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.StatusCause, io.kubernetes.client.proto.Meta.StatusCause.Builder, io.kubernetes.client.proto.Meta.StatusCauseOrBuilder>(
                  causes_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          causes_ = null;
        }
        return causesBuilder_;
      }

      private int retryAfterSeconds_ ;
      /**
       * <pre>
       * If specified, the time in seconds before the operation should be retried. Some errors may indicate
       * the client must take an alternate action - for those errors this field may indicate how long to wait
       * before taking the alternate action.
       * +optional
       * </pre>
       *
       * <code>optional int32 retryAfterSeconds = 5;</code>
       * @return Whether the retryAfterSeconds field is set.
       */
      @java.lang.Override
      public boolean hasRetryAfterSeconds() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * If specified, the time in seconds before the operation should be retried. Some errors may indicate
       * the client must take an alternate action - for those errors this field may indicate how long to wait
       * before taking the alternate action.
       * +optional
       * </pre>
       *
       * <code>optional int32 retryAfterSeconds = 5;</code>
       * @return The retryAfterSeconds.
       */
      @java.lang.Override
      public int getRetryAfterSeconds() {
        return retryAfterSeconds_;
      }
      /**
       * <pre>
       * If specified, the time in seconds before the operation should be retried. Some errors may indicate
       * the client must take an alternate action - for those errors this field may indicate how long to wait
       * before taking the alternate action.
       * +optional
       * </pre>
       *
       * <code>optional int32 retryAfterSeconds = 5;</code>
       * @param value The retryAfterSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setRetryAfterSeconds(int value) {

        retryAfterSeconds_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the time in seconds before the operation should be retried. Some errors may indicate
       * the client must take an alternate action - for those errors this field may indicate how long to wait
       * before taking the alternate action.
       * +optional
       * </pre>
       *
       * <code>optional int32 retryAfterSeconds = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearRetryAfterSeconds() {
        bitField0_ = (bitField0_ & ~0x00000020);
        retryAfterSeconds_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails)
    private static final io.kubernetes.client.proto.Meta.StatusDetails DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.StatusDetails();
    }

    public static io.kubernetes.client.proto.Meta.StatusDetails getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatusDetails>
        PARSER = new com.google.protobuf.AbstractParser<StatusDetails>() {
      @java.lang.Override
      public StatusDetails parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatusDetails> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatusDetails> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.StatusDetails getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TableOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * includeObject decides whether to include each object along with its columnar information.
     * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
     * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
     * in version v1beta1 of the meta.k8s.io API group.
     * </pre>
     *
     * <code>optional string includeObject = 1;</code>
     * @return Whether the includeObject field is set.
     */
    boolean hasIncludeObject();
    /**
     * <pre>
     * includeObject decides whether to include each object along with its columnar information.
     * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
     * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
     * in version v1beta1 of the meta.k8s.io API group.
     * </pre>
     *
     * <code>optional string includeObject = 1;</code>
     * @return The includeObject.
     */
    java.lang.String getIncludeObject();
    /**
     * <pre>
     * includeObject decides whether to include each object along with its columnar information.
     * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
     * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
     * in version v1beta1 of the meta.k8s.io API group.
     * </pre>
     *
     * <code>optional string includeObject = 1;</code>
     * @return The bytes for includeObject.
     */
    com.google.protobuf.ByteString
        getIncludeObjectBytes();
  }
  /**
   * <pre>
   * TableOptions are used when a Table is requested by the caller.
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions}
   */
  public static final class TableOptions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions)
      TableOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        TableOptions.class.getName());
    }
    // Use TableOptions.newBuilder() to construct.
    private TableOptions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private TableOptions() {
      includeObject_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.TableOptions.class, io.kubernetes.client.proto.Meta.TableOptions.Builder.class);
    }

    private int bitField0_;
    public static final int INCLUDEOBJECT_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object includeObject_ = "";
    /**
     * <pre>
     * includeObject decides whether to include each object along with its columnar information.
     * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
     * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
     * in version v1beta1 of the meta.k8s.io API group.
     * </pre>
     *
     * <code>optional string includeObject = 1;</code>
     * @return Whether the includeObject field is set.
     */
    @java.lang.Override
    public boolean hasIncludeObject() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * includeObject decides whether to include each object along with its columnar information.
     * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
     * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
     * in version v1beta1 of the meta.k8s.io API group.
     * </pre>
     *
     * <code>optional string includeObject = 1;</code>
     * @return The includeObject.
     */
    @java.lang.Override
    public java.lang.String getIncludeObject() {
      java.lang.Object ref = includeObject_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          includeObject_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * includeObject decides whether to include each object along with its columnar information.
     * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
     * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
     * in version v1beta1 of the meta.k8s.io API group.
     * </pre>
     *
     * <code>optional string includeObject = 1;</code>
     * @return The bytes for includeObject.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIncludeObjectBytes() {
      java.lang.Object ref = includeObject_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        includeObject_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, includeObject_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, includeObject_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.TableOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.TableOptions other = (io.kubernetes.client.proto.Meta.TableOptions) obj;

      if (hasIncludeObject() != other.hasIncludeObject()) return false;
      if (hasIncludeObject()) {
        if (!getIncludeObject()
            .equals(other.getIncludeObject())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasIncludeObject()) {
        hash = (37 * hash) + INCLUDEOBJECT_FIELD_NUMBER;
        hash = (53 * hash) + getIncludeObject().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.TableOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.TableOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.TableOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.TableOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TableOptions are used when a Table is requested by the caller.
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions)
        io.kubernetes.client.proto.Meta.TableOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.TableOptions.class, io.kubernetes.client.proto.Meta.TableOptions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.TableOptions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        includeObject_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.TableOptions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.TableOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.TableOptions build() {
        io.kubernetes.client.proto.Meta.TableOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.TableOptions buildPartial() {
        io.kubernetes.client.proto.Meta.TableOptions result = new io.kubernetes.client.proto.Meta.TableOptions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.TableOptions result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.includeObject_ = includeObject_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.TableOptions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.TableOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.TableOptions other) {
        if (other == io.kubernetes.client.proto.Meta.TableOptions.getDefaultInstance()) return this;
        if (other.hasIncludeObject()) {
          includeObject_ = other.includeObject_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                includeObject_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object includeObject_ = "";
      /**
       * <pre>
       * includeObject decides whether to include each object along with its columnar information.
       * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
       * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
       * in version v1beta1 of the meta.k8s.io API group.
       * </pre>
       *
       * <code>optional string includeObject = 1;</code>
       * @return Whether the includeObject field is set.
       */
      public boolean hasIncludeObject() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * includeObject decides whether to include each object along with its columnar information.
       * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
       * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
       * in version v1beta1 of the meta.k8s.io API group.
       * </pre>
       *
       * <code>optional string includeObject = 1;</code>
       * @return The includeObject.
       */
      public java.lang.String getIncludeObject() {
        java.lang.Object ref = includeObject_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            includeObject_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * includeObject decides whether to include each object along with its columnar information.
       * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
       * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
       * in version v1beta1 of the meta.k8s.io API group.
       * </pre>
       *
       * <code>optional string includeObject = 1;</code>
       * @return The bytes for includeObject.
       */
      public com.google.protobuf.ByteString
          getIncludeObjectBytes() {
        java.lang.Object ref = includeObject_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          includeObject_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * includeObject decides whether to include each object along with its columnar information.
       * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
       * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
       * in version v1beta1 of the meta.k8s.io API group.
       * </pre>
       *
       * <code>optional string includeObject = 1;</code>
       * @param value The includeObject to set.
       * @return This builder for chaining.
       */
      public Builder setIncludeObject(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        includeObject_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * includeObject decides whether to include each object along with its columnar information.
       * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
       * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
       * in version v1beta1 of the meta.k8s.io API group.
       * </pre>
       *
       * <code>optional string includeObject = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIncludeObject() {
        includeObject_ = getDefaultInstance().getIncludeObject();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * includeObject decides whether to include each object along with its columnar information.
       * Specifying "None" will return no object, specifying "Object" will return the full object contents, and
       * specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
       * in version v1beta1 of the meta.k8s.io API group.
       * </pre>
       *
       * <code>optional string includeObject = 1;</code>
       * @param value The bytes for includeObject to set.
       * @return This builder for chaining.
       */
      public Builder setIncludeObjectBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        includeObject_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions)
    private static final io.kubernetes.client.proto.Meta.TableOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.TableOptions();
    }

    public static io.kubernetes.client.proto.Meta.TableOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TableOptions>
        PARSER = new com.google.protobuf.AbstractParser<TableOptions>() {
      @java.lang.Override
      public TableOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TableOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TableOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TableOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TimeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.Time)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return Whether the seconds field is set.
     */
    boolean hasSeconds();
    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return The seconds.
     */
    long getSeconds();

    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return Whether the nanos field is set.
     */
    boolean hasNanos();
    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return The nanos.
     */
    int getNanos();
  }
  /**
   * <pre>
   * Time is a wrapper around time.Time which supports correct
   * marshaling to YAML and JSON.  Wrappers are provided for many
   * of the factory methods that the time package offers.
   *
   * +protobuf.options.marshal=false
   * +protobuf.as=Timestamp
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Time}
   */
  public static final class Time extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Time)
      TimeOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Time.class.getName());
    }
    // Use Time.newBuilder() to construct.
    private Time(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Time() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.Time.class, io.kubernetes.client.proto.Meta.Time.Builder.class);
    }

    private int bitField0_;
    public static final int SECONDS_FIELD_NUMBER = 1;
    private long seconds_ = 0L;
    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return Whether the seconds field is set.
     */
    @java.lang.Override
    public boolean hasSeconds() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return The seconds.
     */
    @java.lang.Override
    public long getSeconds() {
      return seconds_;
    }

    public static final int NANOS_FIELD_NUMBER = 2;
    private int nanos_ = 0;
    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return Whether the nanos field is set.
     */
    @java.lang.Override
    public boolean hasNanos() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return The nanos.
     */
    @java.lang.Override
    public int getNanos() {
      return nanos_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, seconds_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, nanos_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, seconds_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, nanos_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.Time)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.Time other = (io.kubernetes.client.proto.Meta.Time) obj;

      if (hasSeconds() != other.hasSeconds()) return false;
      if (hasSeconds()) {
        if (getSeconds()
            != other.getSeconds()) return false;
      }
      if (hasNanos() != other.hasNanos()) return false;
      if (hasNanos()) {
        if (getNanos()
            != other.getNanos()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSeconds()) {
        hash = (37 * hash) + SECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSeconds());
      }
      if (hasNanos()) {
        hash = (37 * hash) + NANOS_FIELD_NUMBER;
        hash = (53 * hash) + getNanos();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.Time parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Time parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Time parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Time parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Time parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Time parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Time parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Time parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.Time parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.Time parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Time parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Time parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.Time prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Time is a wrapper around time.Time which supports correct
     * marshaling to YAML and JSON.  Wrappers are provided for many
     * of the factory methods that the time package offers.
     *
     * +protobuf.options.marshal=false
     * +protobuf.as=Timestamp
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Time}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Time)
        io.kubernetes.client.proto.Meta.TimeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.Time.class, io.kubernetes.client.proto.Meta.Time.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.Time.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        seconds_ = 0L;
        nanos_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Time getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.Time.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Time build() {
        io.kubernetes.client.proto.Meta.Time result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Time buildPartial() {
        io.kubernetes.client.proto.Meta.Time result = new io.kubernetes.client.proto.Meta.Time(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.Time result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.seconds_ = seconds_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.nanos_ = nanos_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.Time) {
          return mergeFrom((io.kubernetes.client.proto.Meta.Time)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.Time other) {
        if (other == io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) return this;
        if (other.hasSeconds()) {
          setSeconds(other.getSeconds());
        }
        if (other.hasNanos()) {
          setNanos(other.getNanos());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                seconds_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                nanos_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long seconds_ ;
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @return Whether the seconds field is set.
       */
      @java.lang.Override
      public boolean hasSeconds() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @return The seconds.
       */
      @java.lang.Override
      public long getSeconds() {
        return seconds_;
      }
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @param value The seconds to set.
       * @return This builder for chaining.
       */
      public Builder setSeconds(long value) {

        seconds_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSeconds() {
        bitField0_ = (bitField0_ & ~0x00000001);
        seconds_ = 0L;
        onChanged();
        return this;
      }

      private int nanos_ ;
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @return Whether the nanos field is set.
       */
      @java.lang.Override
      public boolean hasNanos() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @return The nanos.
       */
      @java.lang.Override
      public int getNanos() {
        return nanos_;
      }
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @param value The nanos to set.
       * @return This builder for chaining.
       */
      public Builder setNanos(int value) {

        nanos_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNanos() {
        bitField0_ = (bitField0_ & ~0x00000002);
        nanos_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Time)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Time)
    private static final io.kubernetes.client.proto.Meta.Time DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.Time();
    }

    public static io.kubernetes.client.proto.Meta.Time getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Time>
        PARSER = new com.google.protobuf.AbstractParser<Time>() {
      @java.lang.Override
      public Time parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Time> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Time> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TimestampOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return Whether the seconds field is set.
     */
    boolean hasSeconds();
    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return The seconds.
     */
    long getSeconds();

    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return Whether the nanos field is set.
     */
    boolean hasNanos();
    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return The nanos.
     */
    int getNanos();
  }
  /**
   * <pre>
   * Timestamp is a struct that is equivalent to Time, but intended for
   * protobuf marshalling/unmarshalling. It is generated into a serialization
   * that matches Time. Do not use in Go structs.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp}
   */
  public static final class Timestamp extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp)
      TimestampOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Timestamp.class.getName());
    }
    // Use Timestamp.newBuilder() to construct.
    private Timestamp(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Timestamp() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.Timestamp.class, io.kubernetes.client.proto.Meta.Timestamp.Builder.class);
    }

    private int bitField0_;
    public static final int SECONDS_FIELD_NUMBER = 1;
    private long seconds_ = 0L;
    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return Whether the seconds field is set.
     */
    @java.lang.Override
    public boolean hasSeconds() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Represents seconds of UTC time since Unix epoch
     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     * 9999-12-31T23:59:59Z inclusive.
     * </pre>
     *
     * <code>optional int64 seconds = 1;</code>
     * @return The seconds.
     */
    @java.lang.Override
    public long getSeconds() {
      return seconds_;
    }

    public static final int NANOS_FIELD_NUMBER = 2;
    private int nanos_ = 0;
    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return Whether the nanos field is set.
     */
    @java.lang.Override
    public boolean hasNanos() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Non-negative fractions of a second at nanosecond resolution. Negative
     * second values with fractions must still have non-negative nanos values
     * that count forward in time. Must be from 0 to 999,999,999
     * inclusive. This field may be limited in precision depending on context.
     * </pre>
     *
     * <code>optional int32 nanos = 2;</code>
     * @return The nanos.
     */
    @java.lang.Override
    public int getNanos() {
      return nanos_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, seconds_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, nanos_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, seconds_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, nanos_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.Timestamp)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.Timestamp other = (io.kubernetes.client.proto.Meta.Timestamp) obj;

      if (hasSeconds() != other.hasSeconds()) return false;
      if (hasSeconds()) {
        if (getSeconds()
            != other.getSeconds()) return false;
      }
      if (hasNanos() != other.hasNanos()) return false;
      if (hasNanos()) {
        if (getNanos()
            != other.getNanos()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSeconds()) {
        hash = (37 * hash) + SECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSeconds());
      }
      if (hasNanos()) {
        hash = (37 * hash) + NANOS_FIELD_NUMBER;
        hash = (53 * hash) + getNanos();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.Timestamp parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.Timestamp parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Timestamp parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.Timestamp prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Timestamp is a struct that is equivalent to Time, but intended for
     * protobuf marshalling/unmarshalling. It is generated into a serialization
     * that matches Time. Do not use in Go structs.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp)
        io.kubernetes.client.proto.Meta.TimestampOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.Timestamp.class, io.kubernetes.client.proto.Meta.Timestamp.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.Timestamp.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        seconds_ = 0L;
        nanos_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Timestamp getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.Timestamp.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Timestamp build() {
        io.kubernetes.client.proto.Meta.Timestamp result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Timestamp buildPartial() {
        io.kubernetes.client.proto.Meta.Timestamp result = new io.kubernetes.client.proto.Meta.Timestamp(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.Timestamp result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.seconds_ = seconds_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.nanos_ = nanos_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.Timestamp) {
          return mergeFrom((io.kubernetes.client.proto.Meta.Timestamp)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.Timestamp other) {
        if (other == io.kubernetes.client.proto.Meta.Timestamp.getDefaultInstance()) return this;
        if (other.hasSeconds()) {
          setSeconds(other.getSeconds());
        }
        if (other.hasNanos()) {
          setNanos(other.getNanos());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                seconds_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                nanos_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long seconds_ ;
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @return Whether the seconds field is set.
       */
      @java.lang.Override
      public boolean hasSeconds() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @return The seconds.
       */
      @java.lang.Override
      public long getSeconds() {
        return seconds_;
      }
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @param value The seconds to set.
       * @return This builder for chaining.
       */
      public Builder setSeconds(long value) {

        seconds_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       * </pre>
       *
       * <code>optional int64 seconds = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSeconds() {
        bitField0_ = (bitField0_ & ~0x00000001);
        seconds_ = 0L;
        onChanged();
        return this;
      }

      private int nanos_ ;
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @return Whether the nanos field is set.
       */
      @java.lang.Override
      public boolean hasNanos() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @return The nanos.
       */
      @java.lang.Override
      public int getNanos() {
        return nanos_;
      }
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @param value The nanos to set.
       * @return This builder for chaining.
       */
      public Builder setNanos(int value) {

        nanos_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive. This field may be limited in precision depending on context.
       * </pre>
       *
       * <code>optional int32 nanos = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNanos() {
        bitField0_ = (bitField0_ & ~0x00000002);
        nanos_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp)
    private static final io.kubernetes.client.proto.Meta.Timestamp DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.Timestamp();
    }

    public static io.kubernetes.client.proto.Meta.Timestamp getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Timestamp>
        PARSER = new com.google.protobuf.AbstractParser<Timestamp>() {
      @java.lang.Override
      public Timestamp parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Timestamp> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Timestamp> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Timestamp getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TypeMetaOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Kind is a string value representing the REST resource this object represents.
     * Servers may infer this from the endpoint the client submits requests to.
     * Cannot be updated.
     * In CamelCase.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return Whether the kind field is set.
     */
    boolean hasKind();
    /**
     * <pre>
     * Kind is a string value representing the REST resource this object represents.
     * Servers may infer this from the endpoint the client submits requests to.
     * Cannot be updated.
     * In CamelCase.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return The kind.
     */
    java.lang.String getKind();
    /**
     * <pre>
     * Kind is a string value representing the REST resource this object represents.
     * Servers may infer this from the endpoint the client submits requests to.
     * Cannot be updated.
     * In CamelCase.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return The bytes for kind.
     */
    com.google.protobuf.ByteString
        getKindBytes();

    /**
     * <pre>
     * APIVersion defines the versioned schema of this representation of an object.
     * Servers should convert recognized schemas to the latest internal value, and
     * may reject unrecognized values.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     * +optional
     * </pre>
     *
     * <code>optional string apiVersion = 2;</code>
     * @return Whether the apiVersion field is set.
     */
    boolean hasApiVersion();
    /**
     * <pre>
     * APIVersion defines the versioned schema of this representation of an object.
     * Servers should convert recognized schemas to the latest internal value, and
     * may reject unrecognized values.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     * +optional
     * </pre>
     *
     * <code>optional string apiVersion = 2;</code>
     * @return The apiVersion.
     */
    java.lang.String getApiVersion();
    /**
     * <pre>
     * APIVersion defines the versioned schema of this representation of an object.
     * Servers should convert recognized schemas to the latest internal value, and
     * may reject unrecognized values.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     * +optional
     * </pre>
     *
     * <code>optional string apiVersion = 2;</code>
     * @return The bytes for apiVersion.
     */
    com.google.protobuf.ByteString
        getApiVersionBytes();
  }
  /**
   * <pre>
   * TypeMeta describes an individual object in an API response or request
   * with strings representing the type of the object and its API schema version.
   * Structures that are versioned or persisted should inline TypeMeta.
   *
   * +k8s:deepcopy-gen=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta}
   */
  public static final class TypeMeta extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta)
      TypeMetaOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        TypeMeta.class.getName());
    }
    // Use TypeMeta.newBuilder() to construct.
    private TypeMeta(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private TypeMeta() {
      kind_ = "";
      apiVersion_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.TypeMeta.class, io.kubernetes.client.proto.Meta.TypeMeta.Builder.class);
    }

    private int bitField0_;
    public static final int KIND_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object kind_ = "";
    /**
     * <pre>
     * Kind is a string value representing the REST resource this object represents.
     * Servers may infer this from the endpoint the client submits requests to.
     * Cannot be updated.
     * In CamelCase.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return Whether the kind field is set.
     */
    @java.lang.Override
    public boolean hasKind() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Kind is a string value representing the REST resource this object represents.
     * Servers may infer this from the endpoint the client submits requests to.
     * Cannot be updated.
     * In CamelCase.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return The kind.
     */
    @java.lang.Override
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          kind_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Kind is a string value representing the REST resource this object represents.
     * Servers may infer this from the endpoint the client submits requests to.
     * Cannot be updated.
     * In CamelCase.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional string kind = 1;</code>
     * @return The bytes for kind.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int APIVERSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object apiVersion_ = "";
    /**
     * <pre>
     * APIVersion defines the versioned schema of this representation of an object.
     * Servers should convert recognized schemas to the latest internal value, and
     * may reject unrecognized values.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     * +optional
     * </pre>
     *
     * <code>optional string apiVersion = 2;</code>
     * @return Whether the apiVersion field is set.
     */
    @java.lang.Override
    public boolean hasApiVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * APIVersion defines the versioned schema of this representation of an object.
     * Servers should convert recognized schemas to the latest internal value, and
     * may reject unrecognized values.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     * +optional
     * </pre>
     *
     * <code>optional string apiVersion = 2;</code>
     * @return The apiVersion.
     */
    @java.lang.Override
    public java.lang.String getApiVersion() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          apiVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * APIVersion defines the versioned schema of this representation of an object.
     * Servers should convert recognized schemas to the latest internal value, and
     * may reject unrecognized values.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     * +optional
     * </pre>
     *
     * <code>optional string apiVersion = 2;</code>
     * @return The bytes for apiVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getApiVersionBytes() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        apiVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, kind_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, apiVersion_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, kind_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, apiVersion_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.TypeMeta)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.TypeMeta other = (io.kubernetes.client.proto.Meta.TypeMeta) obj;

      if (hasKind() != other.hasKind()) return false;
      if (hasKind()) {
        if (!getKind()
            .equals(other.getKind())) return false;
      }
      if (hasApiVersion() != other.hasApiVersion()) return false;
      if (hasApiVersion()) {
        if (!getApiVersion()
            .equals(other.getApiVersion())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKind()) {
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + getKind().hashCode();
      }
      if (hasApiVersion()) {
        hash = (37 * hash) + APIVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getApiVersion().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.TypeMeta parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.TypeMeta parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.TypeMeta parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.TypeMeta prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TypeMeta describes an individual object in an API response or request
     * with strings representing the type of the object and its API schema version.
     * Structures that are versioned or persisted should inline TypeMeta.
     *
     * +k8s:deepcopy-gen=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta)
        io.kubernetes.client.proto.Meta.TypeMetaOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.TypeMeta.class, io.kubernetes.client.proto.Meta.TypeMeta.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.TypeMeta.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        kind_ = "";
        apiVersion_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.TypeMeta getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.TypeMeta.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.TypeMeta build() {
        io.kubernetes.client.proto.Meta.TypeMeta result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.TypeMeta buildPartial() {
        io.kubernetes.client.proto.Meta.TypeMeta result = new io.kubernetes.client.proto.Meta.TypeMeta(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.TypeMeta result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.kind_ = kind_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.apiVersion_ = apiVersion_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.TypeMeta) {
          return mergeFrom((io.kubernetes.client.proto.Meta.TypeMeta)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.TypeMeta other) {
        if (other == io.kubernetes.client.proto.Meta.TypeMeta.getDefaultInstance()) return this;
        if (other.hasKind()) {
          kind_ = other.kind_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasApiVersion()) {
          apiVersion_ = other.apiVersion_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                kind_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                apiVersion_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object kind_ = "";
      /**
       * <pre>
       * Kind is a string value representing the REST resource this object represents.
       * Servers may infer this from the endpoint the client submits requests to.
       * Cannot be updated.
       * In CamelCase.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @return Whether the kind field is set.
       */
      public boolean hasKind() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Kind is a string value representing the REST resource this object represents.
       * Servers may infer this from the endpoint the client submits requests to.
       * Cannot be updated.
       * In CamelCase.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @return The kind.
       */
      public java.lang.String getKind() {
        java.lang.Object ref = kind_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            kind_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Kind is a string value representing the REST resource this object represents.
       * Servers may infer this from the endpoint the client submits requests to.
       * Cannot be updated.
       * In CamelCase.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @return The bytes for kind.
       */
      public com.google.protobuf.ByteString
          getKindBytes() {
        java.lang.Object ref = kind_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          kind_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Kind is a string value representing the REST resource this object represents.
       * Servers may infer this from the endpoint the client submits requests to.
       * Cannot be updated.
       * In CamelCase.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @param value The kind to set.
       * @return This builder for chaining.
       */
      public Builder setKind(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind is a string value representing the REST resource this object represents.
       * Servers may infer this from the endpoint the client submits requests to.
       * Cannot be updated.
       * In CamelCase.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKind() {
        kind_ = getDefaultInstance().getKind();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind is a string value representing the REST resource this object represents.
       * Servers may infer this from the endpoint the client submits requests to.
       * Cannot be updated.
       * In CamelCase.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional string kind = 1;</code>
       * @param value The bytes for kind to set.
       * @return This builder for chaining.
       */
      public Builder setKindBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object apiVersion_ = "";
      /**
       * <pre>
       * APIVersion defines the versioned schema of this representation of an object.
       * Servers should convert recognized schemas to the latest internal value, and
       * may reject unrecognized values.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       * +optional
       * </pre>
       *
       * <code>optional string apiVersion = 2;</code>
       * @return Whether the apiVersion field is set.
       */
      public boolean hasApiVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * APIVersion defines the versioned schema of this representation of an object.
       * Servers should convert recognized schemas to the latest internal value, and
       * may reject unrecognized values.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       * +optional
       * </pre>
       *
       * <code>optional string apiVersion = 2;</code>
       * @return The apiVersion.
       */
      public java.lang.String getApiVersion() {
        java.lang.Object ref = apiVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            apiVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * APIVersion defines the versioned schema of this representation of an object.
       * Servers should convert recognized schemas to the latest internal value, and
       * may reject unrecognized values.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       * +optional
       * </pre>
       *
       * <code>optional string apiVersion = 2;</code>
       * @return The bytes for apiVersion.
       */
      public com.google.protobuf.ByteString
          getApiVersionBytes() {
        java.lang.Object ref = apiVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          apiVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * APIVersion defines the versioned schema of this representation of an object.
       * Servers should convert recognized schemas to the latest internal value, and
       * may reject unrecognized values.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       * +optional
       * </pre>
       *
       * <code>optional string apiVersion = 2;</code>
       * @param value The apiVersion to set.
       * @return This builder for chaining.
       */
      public Builder setApiVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        apiVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion defines the versioned schema of this representation of an object.
       * Servers should convert recognized schemas to the latest internal value, and
       * may reject unrecognized values.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       * +optional
       * </pre>
       *
       * <code>optional string apiVersion = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearApiVersion() {
        apiVersion_ = getDefaultInstance().getApiVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion defines the versioned schema of this representation of an object.
       * Servers should convert recognized schemas to the latest internal value, and
       * may reject unrecognized values.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       * +optional
       * </pre>
       *
       * <code>optional string apiVersion = 2;</code>
       * @param value The bytes for apiVersion to set.
       * @return This builder for chaining.
       */
      public Builder setApiVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        apiVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta)
    private static final io.kubernetes.client.proto.Meta.TypeMeta DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.TypeMeta();
    }

    public static io.kubernetes.client.proto.Meta.TypeMeta getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TypeMeta>
        PARSER = new com.google.protobuf.AbstractParser<TypeMeta>() {
      @java.lang.Override
      public TypeMeta parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TypeMeta> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TypeMeta> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TypeMeta getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface UpdateOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return A list containing the dryRun.
     */
    java.util.List<java.lang.String>
        getDryRunList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return The count of dryRun.
     */
    int getDryRunCount();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    java.lang.String getDryRun(int index);
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    com.google.protobuf.ByteString
        getDryRunBytes(int index);

    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 2;</code>
     * @return Whether the fieldManager field is set.
     */
    boolean hasFieldManager();
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 2;</code>
     * @return The fieldManager.
     */
    java.lang.String getFieldManager();
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 2;</code>
     * @return The bytes for fieldManager.
     */
    com.google.protobuf.ByteString
        getFieldManagerBytes();

    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 3;</code>
     * @return Whether the fieldValidation field is set.
     */
    boolean hasFieldValidation();
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 3;</code>
     * @return The fieldValidation.
     */
    java.lang.String getFieldValidation();
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 3;</code>
     * @return The bytes for fieldValidation.
     */
    com.google.protobuf.ByteString
        getFieldValidationBytes();
  }
  /**
   * <pre>
   * UpdateOptions may be provided when updating an API object.
   * All fields in UpdateOptions should also be present in PatchOptions.
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions}
   */
  public static final class UpdateOptions extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions)
      UpdateOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        UpdateOptions.class.getName());
    }
    // Use UpdateOptions.newBuilder() to construct.
    private UpdateOptions(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private UpdateOptions() {
      dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      fieldManager_ = "";
      fieldValidation_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.UpdateOptions.class, io.kubernetes.client.proto.Meta.UpdateOptions.Builder.class);
    }

    private int bitField0_;
    public static final int DRYRUN_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList dryRun_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return A list containing the dryRun.
     */
    public com.google.protobuf.ProtocolStringList
        getDryRunList() {
      return dryRun_;
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @return The count of dryRun.
     */
    public int getDryRunCount() {
      return dryRun_.size();
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the element to return.
     * @return The dryRun at the given index.
     */
    public java.lang.String getDryRun(int index) {
      return dryRun_.get(index);
    }
    /**
     * <pre>
     * When present, indicates that modifications should not be
     * persisted. An invalid or unrecognized dryRun directive will
     * result in an error response and no further processing of the
     * request. Valid values are:
     * - All: all dry run stages will be processed
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string dryRun = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dryRun at the given index.
     */
    public com.google.protobuf.ByteString
        getDryRunBytes(int index) {
      return dryRun_.getByteString(index);
    }

    public static final int FIELDMANAGER_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldManager_ = "";
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 2;</code>
     * @return Whether the fieldManager field is set.
     */
    @java.lang.Override
    public boolean hasFieldManager() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 2;</code>
     * @return The fieldManager.
     */
    @java.lang.Override
    public java.lang.String getFieldManager() {
      java.lang.Object ref = fieldManager_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldManager_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * fieldManager is a name associated with the actor or entity
     * that is making these changes. The value must be less than or
     * 128 characters long, and only contain printable characters,
     * as defined by https://golang.org/pkg/unicode/#IsPrint.
     * +optional
     * </pre>
     *
     * <code>optional string fieldManager = 2;</code>
     * @return The bytes for fieldManager.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldManagerBytes() {
      java.lang.Object ref = fieldManager_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldManager_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FIELDVALIDATION_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldValidation_ = "";
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 3;</code>
     * @return Whether the fieldValidation field is set.
     */
    @java.lang.Override
    public boolean hasFieldValidation() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 3;</code>
     * @return The fieldValidation.
     */
    @java.lang.Override
    public java.lang.String getFieldValidation() {
      java.lang.Object ref = fieldValidation_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldValidation_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * fieldValidation instructs the server on how to handle
     * objects in the request (POST/PUT/PATCH) containing unknown
     * or duplicate fields. Valid values are:
     * - Ignore: This will ignore any unknown fields that are silently
     * dropped from the object, and will ignore all but the last duplicate
     * field that the decoder encounters. This is the default behavior
     * prior to v1.23.
     * - Warn: This will send a warning via the standard warning response
     * header for each unknown field that is dropped from the object, and
     * for each duplicate field that is encountered. The request will
     * still succeed if there are no other errors, and will only persist
     * the last of any duplicate fields. This is the default in v1.23+
     * - Strict: This will fail the request with a BadRequest error if
     * any unknown fields would be dropped from the object, or if any
     * duplicate fields are present. The error returned from the server
     * will contain all unknown and duplicate fields encountered.
     * +optional
     * </pre>
     *
     * <code>optional string fieldValidation = 3;</code>
     * @return The bytes for fieldValidation.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldValidationBytes() {
      java.lang.Object ref = fieldValidation_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldValidation_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < dryRun_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, dryRun_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, fieldManager_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, fieldValidation_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < dryRun_.size(); i++) {
          dataSize += computeStringSizeNoTag(dryRun_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getDryRunList().size();
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, fieldManager_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, fieldValidation_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.UpdateOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.UpdateOptions other = (io.kubernetes.client.proto.Meta.UpdateOptions) obj;

      if (!getDryRunList()
          .equals(other.getDryRunList())) return false;
      if (hasFieldManager() != other.hasFieldManager()) return false;
      if (hasFieldManager()) {
        if (!getFieldManager()
            .equals(other.getFieldManager())) return false;
      }
      if (hasFieldValidation() != other.hasFieldValidation()) return false;
      if (hasFieldValidation()) {
        if (!getFieldValidation()
            .equals(other.getFieldValidation())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getDryRunCount() > 0) {
        hash = (37 * hash) + DRYRUN_FIELD_NUMBER;
        hash = (53 * hash) + getDryRunList().hashCode();
      }
      if (hasFieldManager()) {
        hash = (37 * hash) + FIELDMANAGER_FIELD_NUMBER;
        hash = (53 * hash) + getFieldManager().hashCode();
      }
      if (hasFieldValidation()) {
        hash = (37 * hash) + FIELDVALIDATION_FIELD_NUMBER;
        hash = (53 * hash) + getFieldValidation().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.UpdateOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.UpdateOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.UpdateOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.UpdateOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * UpdateOptions may be provided when updating an API object.
     * All fields in UpdateOptions should also be present in PatchOptions.
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions)
        io.kubernetes.client.proto.Meta.UpdateOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.UpdateOptions.class, io.kubernetes.client.proto.Meta.UpdateOptions.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.UpdateOptions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        dryRun_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        fieldManager_ = "";
        fieldValidation_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.UpdateOptions getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.UpdateOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.UpdateOptions build() {
        io.kubernetes.client.proto.Meta.UpdateOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.UpdateOptions buildPartial() {
        io.kubernetes.client.proto.Meta.UpdateOptions result = new io.kubernetes.client.proto.Meta.UpdateOptions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.UpdateOptions result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          dryRun_.makeImmutable();
          result.dryRun_ = dryRun_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.fieldManager_ = fieldManager_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.fieldValidation_ = fieldValidation_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.UpdateOptions) {
          return mergeFrom((io.kubernetes.client.proto.Meta.UpdateOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.UpdateOptions other) {
        if (other == io.kubernetes.client.proto.Meta.UpdateOptions.getDefaultInstance()) return this;
        if (!other.dryRun_.isEmpty()) {
          if (dryRun_.isEmpty()) {
            dryRun_ = other.dryRun_;
            bitField0_ |= 0x00000001;
          } else {
            ensureDryRunIsMutable();
            dryRun_.addAll(other.dryRun_);
          }
          onChanged();
        }
        if (other.hasFieldManager()) {
          fieldManager_ = other.fieldManager_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasFieldValidation()) {
          fieldValidation_ = other.fieldValidation_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureDryRunIsMutable();
                dryRun_.add(bs);
                break;
              } // case 10
              case 18: {
                fieldManager_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                fieldValidation_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureDryRunIsMutable() {
        if (!dryRun_.isModifiable()) {
          dryRun_ = new com.google.protobuf.LazyStringArrayList(dryRun_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return A list containing the dryRun.
       */
      public com.google.protobuf.ProtocolStringList
          getDryRunList() {
        dryRun_.makeImmutable();
        return dryRun_;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return The count of dryRun.
       */
      public int getDryRunCount() {
        return dryRun_.size();
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index of the element to return.
       * @return The dryRun at the given index.
       */
      public java.lang.String getDryRun(int index) {
        return dryRun_.get(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the dryRun at the given index.
       */
      public com.google.protobuf.ByteString
          getDryRunBytes(int index) {
        return dryRun_.getByteString(index);
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param index The index to set the value at.
       * @param value The dryRun to set.
       * @return This builder for chaining.
       */
      public Builder setDryRun(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param value The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRun(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param values The dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addAllDryRun(
          java.lang.Iterable<java.lang.String> values) {
        ensureDryRunIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, dryRun_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDryRun() {
        dryRun_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When present, indicates that modifications should not be
       * persisted. An invalid or unrecognized dryRun directive will
       * result in an error response and no further processing of the
       * request. Valid values are:
       * - All: all dry run stages will be processed
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string dryRun = 1;</code>
       * @param value The bytes of the dryRun to add.
       * @return This builder for chaining.
       */
      public Builder addDryRunBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDryRunIsMutable();
        dryRun_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object fieldManager_ = "";
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 2;</code>
       * @return Whether the fieldManager field is set.
       */
      public boolean hasFieldManager() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 2;</code>
       * @return The fieldManager.
       */
      public java.lang.String getFieldManager() {
        java.lang.Object ref = fieldManager_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldManager_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 2;</code>
       * @return The bytes for fieldManager.
       */
      public com.google.protobuf.ByteString
          getFieldManagerBytes() {
        java.lang.Object ref = fieldManager_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldManager_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 2;</code>
       * @param value The fieldManager to set.
       * @return This builder for chaining.
       */
      public Builder setFieldManager(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldManager_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldManager() {
        fieldManager_ = getDefaultInstance().getFieldManager();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldManager is a name associated with the actor or entity
       * that is making these changes. The value must be less than or
       * 128 characters long, and only contain printable characters,
       * as defined by https://golang.org/pkg/unicode/#IsPrint.
       * +optional
       * </pre>
       *
       * <code>optional string fieldManager = 2;</code>
       * @param value The bytes for fieldManager to set.
       * @return This builder for chaining.
       */
      public Builder setFieldManagerBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldManager_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object fieldValidation_ = "";
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 3;</code>
       * @return Whether the fieldValidation field is set.
       */
      public boolean hasFieldValidation() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 3;</code>
       * @return The fieldValidation.
       */
      public java.lang.String getFieldValidation() {
        java.lang.Object ref = fieldValidation_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldValidation_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 3;</code>
       * @return The bytes for fieldValidation.
       */
      public com.google.protobuf.ByteString
          getFieldValidationBytes() {
        java.lang.Object ref = fieldValidation_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldValidation_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 3;</code>
       * @param value The fieldValidation to set.
       * @return This builder for chaining.
       */
      public Builder setFieldValidation(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldValidation_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldValidation() {
        fieldValidation_ = getDefaultInstance().getFieldValidation();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * fieldValidation instructs the server on how to handle
       * objects in the request (POST/PUT/PATCH) containing unknown
       * or duplicate fields. Valid values are:
       * - Ignore: This will ignore any unknown fields that are silently
       * dropped from the object, and will ignore all but the last duplicate
       * field that the decoder encounters. This is the default behavior
       * prior to v1.23.
       * - Warn: This will send a warning via the standard warning response
       * header for each unknown field that is dropped from the object, and
       * for each duplicate field that is encountered. The request will
       * still succeed if there are no other errors, and will only persist
       * the last of any duplicate fields. This is the default in v1.23+
       * - Strict: This will fail the request with a BadRequest error if
       * any unknown fields would be dropped from the object, or if any
       * duplicate fields are present. The error returned from the server
       * will contain all unknown and duplicate fields encountered.
       * +optional
       * </pre>
       *
       * <code>optional string fieldValidation = 3;</code>
       * @param value The bytes for fieldValidation to set.
       * @return This builder for chaining.
       */
      public Builder setFieldValidationBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldValidation_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions)
    private static final io.kubernetes.client.proto.Meta.UpdateOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.UpdateOptions();
    }

    public static io.kubernetes.client.proto.Meta.UpdateOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<UpdateOptions>
        PARSER = new com.google.protobuf.AbstractParser<UpdateOptions>() {
      @java.lang.Override
      public UpdateOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<UpdateOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<UpdateOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.UpdateOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VerbsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated string items = 1;</code>
     * @return A list containing the items.
     */
    java.util.List<java.lang.String>
        getItemsList();
    /**
     * <code>repeated string items = 1;</code>
     * @return The count of items.
     */
    int getItemsCount();
    /**
     * <code>repeated string items = 1;</code>
     * @param index The index of the element to return.
     * @return The items at the given index.
     */
    java.lang.String getItems(int index);
    /**
     * <code>repeated string items = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the items at the given index.
     */
    com.google.protobuf.ByteString
        getItemsBytes(int index);
  }
  /**
   * <pre>
   * Verbs masks the value so protobuf can generate
   *
   * +protobuf.nullable=true
   * +protobuf.options.(gogoproto.goproto_stringer)=false
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Verbs}
   */
  public static final class Verbs extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs)
      VerbsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Verbs.class.getName());
    }
    // Use Verbs.newBuilder() to construct.
    private Verbs(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Verbs() {
      items_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.Verbs.class, io.kubernetes.client.proto.Meta.Verbs.Builder.class);
    }

    public static final int ITEMS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList items_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <code>repeated string items = 1;</code>
     * @return A list containing the items.
     */
    public com.google.protobuf.ProtocolStringList
        getItemsList() {
      return items_;
    }
    /**
     * <code>repeated string items = 1;</code>
     * @return The count of items.
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <code>repeated string items = 1;</code>
     * @param index The index of the element to return.
     * @return The items at the given index.
     */
    public java.lang.String getItems(int index) {
      return items_.get(index);
    }
    /**
     * <code>repeated string items = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the items at the given index.
     */
    public com.google.protobuf.ByteString
        getItemsBytes(int index) {
      return items_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < items_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, items_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < items_.size(); i++) {
          dataSize += computeStringSizeNoTag(items_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getItemsList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.Verbs)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.Verbs other = (io.kubernetes.client.proto.Meta.Verbs) obj;

      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.Verbs parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.Verbs parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.Verbs parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.Verbs prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Verbs masks the value so protobuf can generate
     *
     * +protobuf.nullable=true
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.Verbs}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs)
        io.kubernetes.client.proto.Meta.VerbsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.Verbs.class, io.kubernetes.client.proto.Meta.Verbs.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.Verbs.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        items_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Verbs getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.Verbs.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Verbs build() {
        io.kubernetes.client.proto.Meta.Verbs result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.Verbs buildPartial() {
        io.kubernetes.client.proto.Meta.Verbs result = new io.kubernetes.client.proto.Meta.Verbs(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.Verbs result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          items_.makeImmutable();
          result.items_ = items_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.Verbs) {
          return mergeFrom((io.kubernetes.client.proto.Meta.Verbs)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.Verbs other) {
        if (other == io.kubernetes.client.proto.Meta.Verbs.getDefaultInstance()) return this;
        if (!other.items_.isEmpty()) {
          if (items_.isEmpty()) {
            items_ = other.items_;
            bitField0_ |= 0x00000001;
          } else {
            ensureItemsIsMutable();
            items_.addAll(other.items_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureItemsIsMutable();
                items_.add(bs);
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList items_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureItemsIsMutable() {
        if (!items_.isModifiable()) {
          items_ = new com.google.protobuf.LazyStringArrayList(items_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <code>repeated string items = 1;</code>
       * @return A list containing the items.
       */
      public com.google.protobuf.ProtocolStringList
          getItemsList() {
        items_.makeImmutable();
        return items_;
      }
      /**
       * <code>repeated string items = 1;</code>
       * @return The count of items.
       */
      public int getItemsCount() {
        return items_.size();
      }
      /**
       * <code>repeated string items = 1;</code>
       * @param index The index of the element to return.
       * @return The items at the given index.
       */
      public java.lang.String getItems(int index) {
        return items_.get(index);
      }
      /**
       * <code>repeated string items = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the items at the given index.
       */
      public com.google.protobuf.ByteString
          getItemsBytes(int index) {
        return items_.getByteString(index);
      }
      /**
       * <code>repeated string items = 1;</code>
       * @param index The index to set the value at.
       * @param value The items to set.
       * @return This builder for chaining.
       */
      public Builder setItems(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureItemsIsMutable();
        items_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string items = 1;</code>
       * @param value The items to add.
       * @return This builder for chaining.
       */
      public Builder addItems(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureItemsIsMutable();
        items_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string items = 1;</code>
       * @param values The items to add.
       * @return This builder for chaining.
       */
      public Builder addAllItems(
          java.lang.Iterable<java.lang.String> values) {
        ensureItemsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, items_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string items = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearItems() {
        items_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string items = 1;</code>
       * @param value The bytes of the items to add.
       * @return This builder for chaining.
       */
      public Builder addItemsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureItemsIsMutable();
        items_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs)
    private static final io.kubernetes.client.proto.Meta.Verbs DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.Verbs();
    }

    public static io.kubernetes.client.proto.Meta.Verbs getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Verbs>
        PARSER = new com.google.protobuf.AbstractParser<Verbs>() {
      @java.lang.Override
      public Verbs parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Verbs> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Verbs> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Verbs getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface WatchEventOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Object is:
     * * If Type is Added or Modified: the new state of the object.
     * * If Type is Deleted: the state of the object immediately before deletion.
     * * If Type is Error: *Status is recommended; other types may make sense
     * depending on context.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
     * @return Whether the object field is set.
     */
    boolean hasObject();
    /**
     * <pre>
     * Object is:
     * * If Type is Added or Modified: the new state of the object.
     * * If Type is Deleted: the state of the object immediately before deletion.
     * * If Type is Error: *Status is recommended; other types may make sense
     * depending on context.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
     * @return The object.
     */
    io.kubernetes.client.proto.Runtime.RawExtension getObject();
    /**
     * <pre>
     * Object is:
     * * If Type is Added or Modified: the new state of the object.
     * * If Type is Deleted: the state of the object immediately before deletion.
     * * If Type is Error: *Status is recommended; other types may make sense
     * depending on context.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
     */
    io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder getObjectOrBuilder();
  }
  /**
   * <pre>
   * Event represents a single event to a watched resource.
   *
   * +protobuf=true
   * +k8s:deepcopy-gen=true
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * </pre>
   *
   * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent}
   */
  public static final class WatchEvent extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent)
      WatchEventOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        WatchEvent.class.getName());
    }
    // Use WatchEvent.newBuilder() to construct.
    private WatchEvent(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private WatchEvent() {
      type_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.Meta.WatchEvent.class, io.kubernetes.client.proto.Meta.WatchEvent.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OBJECT_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Runtime.RawExtension object_;
    /**
     * <pre>
     * Object is:
     * * If Type is Added or Modified: the new state of the object.
     * * If Type is Deleted: the state of the object immediately before deletion.
     * * If Type is Error: *Status is recommended; other types may make sense
     * depending on context.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
     * @return Whether the object field is set.
     */
    @java.lang.Override
    public boolean hasObject() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Object is:
     * * If Type is Added or Modified: the new state of the object.
     * * If Type is Deleted: the state of the object immediately before deletion.
     * * If Type is Error: *Status is recommended; other types may make sense
     * depending on context.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
     * @return The object.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Runtime.RawExtension getObject() {
      return object_ == null ? io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance() : object_;
    }
    /**
     * <pre>
     * Object is:
     * * If Type is Added or Modified: the new state of the object.
     * * If Type is Deleted: the state of the object immediately before deletion.
     * * If Type is Error: *Status is recommended; other types may make sense
     * depending on context.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder getObjectOrBuilder() {
      return object_ == null ? io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance() : object_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getObject());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getObject());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.Meta.WatchEvent)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.Meta.WatchEvent other = (io.kubernetes.client.proto.Meta.WatchEvent) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasObject() != other.hasObject()) return false;
      if (hasObject()) {
        if (!getObject()
            .equals(other.getObject())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasObject()) {
        hash = (37 * hash) + OBJECT_FIELD_NUMBER;
        hash = (53 * hash) + getObject().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.Meta.WatchEvent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.Meta.WatchEvent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.Meta.WatchEvent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.Meta.WatchEvent prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Event represents a single event to a watched resource.
     *
     * +protobuf=true
     * +k8s:deepcopy-gen=true
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * </pre>
     *
     * Protobuf type {@code k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent)
        io.kubernetes.client.proto.Meta.WatchEventOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.Meta.WatchEvent.class, io.kubernetes.client.proto.Meta.WatchEvent.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.Meta.WatchEvent.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getObjectFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        object_ = null;
        if (objectBuilder_ != null) {
          objectBuilder_.dispose();
          objectBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.Meta.internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.WatchEvent getDefaultInstanceForType() {
        return io.kubernetes.client.proto.Meta.WatchEvent.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.WatchEvent build() {
        io.kubernetes.client.proto.Meta.WatchEvent result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.Meta.WatchEvent buildPartial() {
        io.kubernetes.client.proto.Meta.WatchEvent result = new io.kubernetes.client.proto.Meta.WatchEvent(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.Meta.WatchEvent result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.object_ = objectBuilder_ == null
              ? object_
              : objectBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.Meta.WatchEvent) {
          return mergeFrom((io.kubernetes.client.proto.Meta.WatchEvent)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.Meta.WatchEvent other) {
        if (other == io.kubernetes.client.proto.Meta.WatchEvent.getDefaultInstance()) return this;
        if (other.hasType()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasObject()) {
          mergeObject(other.getObject());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getObjectFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Runtime.RawExtension object_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Runtime.RawExtension, io.kubernetes.client.proto.Runtime.RawExtension.Builder, io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder> objectBuilder_;
      /**
       * <pre>
       * Object is:
       * * If Type is Added or Modified: the new state of the object.
       * * If Type is Deleted: the state of the object immediately before deletion.
       * * If Type is Error: *Status is recommended; other types may make sense
       * depending on context.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
       * @return Whether the object field is set.
       */
      public boolean hasObject() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Object is:
       * * If Type is Added or Modified: the new state of the object.
       * * If Type is Deleted: the state of the object immediately before deletion.
       * * If Type is Error: *Status is recommended; other types may make sense
       * depending on context.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
       * @return The object.
       */
      public io.kubernetes.client.proto.Runtime.RawExtension getObject() {
        if (objectBuilder_ == null) {
          return object_ == null ? io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance() : object_;
        } else {
          return objectBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Object is:
       * * If Type is Added or Modified: the new state of the object.
       * * If Type is Deleted: the state of the object immediately before deletion.
       * * If Type is Error: *Status is recommended; other types may make sense
       * depending on context.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
       */
      public Builder setObject(io.kubernetes.client.proto.Runtime.RawExtension value) {
        if (objectBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          object_ = value;
        } else {
          objectBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Object is:
       * * If Type is Added or Modified: the new state of the object.
       * * If Type is Deleted: the state of the object immediately before deletion.
       * * If Type is Error: *Status is recommended; other types may make sense
       * depending on context.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
       */
      public Builder setObject(
          io.kubernetes.client.proto.Runtime.RawExtension.Builder builderForValue) {
        if (objectBuilder_ == null) {
          object_ = builderForValue.build();
        } else {
          objectBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Object is:
       * * If Type is Added or Modified: the new state of the object.
       * * If Type is Deleted: the state of the object immediately before deletion.
       * * If Type is Error: *Status is recommended; other types may make sense
       * depending on context.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
       */
      public Builder mergeObject(io.kubernetes.client.proto.Runtime.RawExtension value) {
        if (objectBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            object_ != null &&
            object_ != io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance()) {
            getObjectBuilder().mergeFrom(value);
          } else {
            object_ = value;
          }
        } else {
          objectBuilder_.mergeFrom(value);
        }
        if (object_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Object is:
       * * If Type is Added or Modified: the new state of the object.
       * * If Type is Deleted: the state of the object immediately before deletion.
       * * If Type is Error: *Status is recommended; other types may make sense
       * depending on context.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
       */
      public Builder clearObject() {
        bitField0_ = (bitField0_ & ~0x00000002);
        object_ = null;
        if (objectBuilder_ != null) {
          objectBuilder_.dispose();
          objectBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Object is:
       * * If Type is Added or Modified: the new state of the object.
       * * If Type is Deleted: the state of the object immediately before deletion.
       * * If Type is Error: *Status is recommended; other types may make sense
       * depending on context.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
       */
      public io.kubernetes.client.proto.Runtime.RawExtension.Builder getObjectBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getObjectFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Object is:
       * * If Type is Added or Modified: the new state of the object.
       * * If Type is Deleted: the state of the object immediately before deletion.
       * * If Type is Error: *Status is recommended; other types may make sense
       * depending on context.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
       */
      public io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder getObjectOrBuilder() {
        if (objectBuilder_ != null) {
          return objectBuilder_.getMessageOrBuilder();
        } else {
          return object_ == null ?
              io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance() : object_;
        }
      }
      /**
       * <pre>
       * Object is:
       * * If Type is Added or Modified: the new state of the object.
       * * If Type is Deleted: the state of the object immediately before deletion.
       * * If Type is Error: *Status is recommended; other types may make sense
       * depending on context.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Runtime.RawExtension, io.kubernetes.client.proto.Runtime.RawExtension.Builder, io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder> 
          getObjectFieldBuilder() {
        if (objectBuilder_ == null) {
          objectBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Runtime.RawExtension, io.kubernetes.client.proto.Runtime.RawExtension.Builder, io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder>(
                  getObject(),
                  getParentForChildren(),
                  isClean());
          object_ = null;
        }
        return objectBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent)
    private static final io.kubernetes.client.proto.Meta.WatchEvent DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.Meta.WatchEvent();
    }

    public static io.kubernetes.client.proto.Meta.WatchEvent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<WatchEvent>
        PARSER = new com.google.protobuf.AbstractParser<WatchEvent>() {
      @java.lang.Override
      public WatchEvent parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<WatchEvent> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<WatchEvent> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.Meta.WatchEvent getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_MatchLabelsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_MatchLabelsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_LabelsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_LabelsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_AnnotationsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_AnnotationsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n4k8s.io/apimachinery/pkg/apis/meta/v1/g" +
      "enerated.proto\022$k8s.io.apimachinery.pkg." +
      "apis.meta.v1\032/k8s.io/apimachinery/pkg/ru" +
      "ntime/generated.proto\0326k8s.io/apimachine" +
      "ry/pkg/runtime/schema/generated.proto\"\251\002" +
      "\n\010APIGroup\022\014\n\004name\030\001 \001(\t\022P\n\010versions\030\002 \003" +
      "(\0132>.k8s.io.apimachinery.pkg.apis.meta.v" +
      "1.GroupVersionForDiscovery\022X\n\020preferredV" +
      "ersion\030\003 \001(\0132>.k8s.io.apimachinery.pkg.a" +
      "pis.meta.v1.GroupVersionForDiscovery\022c\n\032" +
      "serverAddressByClientCIDRs\030\004 \003(\0132?.k8s.i" +
      "o.apimachinery.pkg.apis.meta.v1.ServerAd" +
      "dressByClientCIDR\"N\n\014APIGroupList\022>\n\006gro" +
      "ups\030\001 \003(\0132..k8s.io.apimachinery.pkg.apis" +
      ".meta.v1.APIGroup\"\363\001\n\013APIResource\022\014\n\004nam" +
      "e\030\001 \001(\t\022\024\n\014singularName\030\006 \001(\t\022\022\n\nnamespa" +
      "ced\030\002 \001(\010\022\r\n\005group\030\010 \001(\t\022\017\n\007version\030\t \001(" +
      "\t\022\014\n\004kind\030\003 \001(\t\022:\n\005verbs\030\004 \001(\0132+.k8s.io." +
      "apimachinery.pkg.apis.meta.v1.Verbs\022\022\n\ns" +
      "hortNames\030\005 \003(\t\022\022\n\ncategories\030\007 \003(\t\022\032\n\022s" +
      "torageVersionHash\030\n \001(\t\"m\n\017APIResourceLi" +
      "st\022\024\n\014groupVersion\030\001 \001(\t\022D\n\tresources\030\002 " +
      "\003(\01321.k8s.io.apimachinery.pkg.apis.meta." +
      "v1.APIResource\"\204\001\n\013APIVersions\022\020\n\010versio" +
      "ns\030\001 \003(\t\022c\n\032serverAddressByClientCIDRs\030\002" +
      " \003(\0132?.k8s.io.apimachinery.pkg.apis.meta" +
      ".v1.ServerAddressByClientCIDR\"C\n\014ApplyOp" +
      "tions\022\016\n\006dryRun\030\001 \003(\t\022\r\n\005force\030\002 \001(\010\022\024\n\014" +
      "fieldManager\030\003 \001(\t\"\256\001\n\tCondition\022\014\n\004type" +
      "\030\001 \001(\t\022\016\n\006status\030\002 \001(\t\022\032\n\022observedGenera" +
      "tion\030\003 \001(\003\022F\n\022lastTransitionTime\030\004 \001(\0132*" +
      ".k8s.io.apimachinery.pkg.apis.meta.v1.Ti" +
      "me\022\016\n\006reason\030\005 \001(\t\022\017\n\007message\030\006 \001(\t\"N\n\rC" +
      "reateOptions\022\016\n\006dryRun\030\001 \003(\t\022\024\n\014fieldMan" +
      "ager\030\003 \001(\t\022\027\n\017fieldValidation\030\004 \001(\t\"\274\001\n\r" +
      "DeleteOptions\022\032\n\022gracePeriodSeconds\030\001 \001(" +
      "\003\022J\n\rpreconditions\030\002 \001(\01323.k8s.io.apimac" +
      "hinery.pkg.apis.meta.v1.Preconditions\022\030\n" +
      "\020orphanDependents\030\003 \001(\010\022\031\n\021propagationPo" +
      "licy\030\004 \001(\t\022\016\n\006dryRun\030\005 \003(\t\"\034\n\010Duration\022\020" +
      "\n\010duration\030\001 \001(\003\"\027\n\010FieldsV1\022\013\n\003Raw\030\001 \001(" +
      "\014\"%\n\nGetOptions\022\027\n\017resourceVersion\030\001 \001(\t" +
      "\"(\n\tGroupKind\022\r\n\005group\030\001 \001(\t\022\014\n\004kind\030\002 \001" +
      "(\t\"0\n\rGroupResource\022\r\n\005group\030\001 \001(\t\022\020\n\010re" +
      "source\030\002 \001(\t\".\n\014GroupVersion\022\r\n\005group\030\001 " +
      "\001(\t\022\017\n\007version\030\002 \001(\t\"A\n\030GroupVersionForD" +
      "iscovery\022\024\n\014groupVersion\030\001 \001(\t\022\017\n\007versio" +
      "n\030\002 \001(\t\"@\n\020GroupVersionKind\022\r\n\005group\030\001 \001" +
      "(\t\022\017\n\007version\030\002 \001(\t\022\014\n\004kind\030\003 \001(\t\"H\n\024Gro" +
      "upVersionResource\022\r\n\005group\030\001 \001(\t\022\017\n\007vers" +
      "ion\030\002 \001(\t\022\020\n\010resource\030\003 \001(\t\"\370\001\n\rLabelSel" +
      "ector\022Y\n\013matchLabels\030\001 \003(\0132D.k8s.io.apim" +
      "achinery.pkg.apis.meta.v1.LabelSelector." +
      "MatchLabelsEntry\022X\n\020matchExpressions\030\002 \003" +
      "(\0132>.k8s.io.apimachinery.pkg.apis.meta.v" +
      "1.LabelSelectorRequirement\0322\n\020MatchLabel" +
      "sEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"I" +
      "\n\030LabelSelectorRequirement\022\013\n\003key\030\001 \001(\t\022" +
      "\020\n\010operator\030\002 \001(\t\022\016\n\006values\030\003 \003(\t\"\206\001\n\004Li" +
      "st\022@\n\010metadata\030\001 \001(\0132..k8s.io.apimachine" +
      "ry.pkg.apis.meta.v1.ListMeta\022<\n\005items\030\002 " +
      "\003(\0132-.k8s.io.apimachinery.pkg.runtime.Ra" +
      "wExtension\"c\n\010ListMeta\022\020\n\010selfLink\030\001 \001(\t" +
      "\022\027\n\017resourceVersion\030\002 \001(\t\022\020\n\010continue\030\003 " +
      "\001(\t\022\032\n\022remainingItemCount\030\004 \001(\003\"\362\001\n\013List" +
      "Options\022\025\n\rlabelSelector\030\001 \001(\t\022\025\n\rfieldS" +
      "elector\030\002 \001(\t\022\r\n\005watch\030\003 \001(\010\022\033\n\023allowWat" +
      "chBookmarks\030\t \001(\010\022\027\n\017resourceVersion\030\004 \001" +
      "(\t\022\034\n\024resourceVersionMatch\030\n \001(\t\022\026\n\016time" +
      "outSeconds\030\005 \001(\003\022\r\n\005limit\030\007 \001(\003\022\020\n\010conti" +
      "nue\030\010 \001(\t\022\031\n\021sendInitialEvents\030\013 \001(\010\"\361\001\n" +
      "\022ManagedFieldsEntry\022\017\n\007manager\030\001 \001(\t\022\021\n\t" +
      "operation\030\002 \001(\t\022\022\n\napiVersion\030\003 \001(\t\0228\n\004t" +
      "ime\030\004 \001(\0132*.k8s.io.apimachinery.pkg.apis" +
      ".meta.v1.Time\022\022\n\nfieldsType\030\006 \001(\t\022@\n\010fie" +
      "ldsV1\030\007 \001(\0132..k8s.io.apimachinery.pkg.ap" +
      "is.meta.v1.FieldsV1\022\023\n\013subresource\030\010 \001(\t" +
      "\"+\n\tMicroTime\022\017\n\007seconds\030\001 \001(\003\022\r\n\005nanos\030" +
      "\002 \001(\005\"\376\005\n\nObjectMeta\022\014\n\004name\030\001 \001(\t\022\024\n\014ge" +
      "nerateName\030\002 \001(\t\022\021\n\tnamespace\030\003 \001(\t\022\020\n\010s" +
      "elfLink\030\004 \001(\t\022\013\n\003uid\030\005 \001(\t\022\027\n\017resourceVe" +
      "rsion\030\006 \001(\t\022\022\n\ngeneration\030\007 \001(\003\022E\n\021creat" +
      "ionTimestamp\030\010 \001(\0132*.k8s.io.apimachinery" +
      ".pkg.apis.meta.v1.Time\022E\n\021deletionTimest" +
      "amp\030\t \001(\0132*.k8s.io.apimachinery.pkg.apis" +
      ".meta.v1.Time\022\"\n\032deletionGracePeriodSeco" +
      "nds\030\n \001(\003\022L\n\006labels\030\013 \003(\0132<.k8s.io.apima" +
      "chinery.pkg.apis.meta.v1.ObjectMeta.Labe" +
      "lsEntry\022V\n\013annotations\030\014 \003(\0132A.k8s.io.ap" +
      "imachinery.pkg.apis.meta.v1.ObjectMeta.A" +
      "nnotationsEntry\022M\n\017ownerReferences\030\r \003(\013" +
      "24.k8s.io.apimachinery.pkg.apis.meta.v1." +
      "OwnerReference\022\022\n\nfinalizers\030\016 \003(\t\022O\n\rma" +
      "nagedFields\030\021 \003(\01328.k8s.io.apimachinery." +
      "pkg.apis.meta.v1.ManagedFieldsEntry\032-\n\013L" +
      "abelsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\002" +
      "8\001\0322\n\020AnnotationsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005v" +
      "alue\030\002 \001(\t:\0028\001\"}\n\016OwnerReference\022\022\n\napiV" +
      "ersion\030\005 \001(\t\022\014\n\004kind\030\001 \001(\t\022\014\n\004name\030\003 \001(\t" +
      "\022\013\n\003uid\030\004 \001(\t\022\022\n\ncontroller\030\006 \001(\010\022\032\n\022blo" +
      "ckOwnerDeletion\030\007 \001(\010\"[\n\025PartialObjectMe" +
      "tadata\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimac" +
      "hinery.pkg.apis.meta.v1.ObjectMeta\"\251\001\n\031P" +
      "artialObjectMetadataList\022@\n\010metadata\030\001 \001" +
      "(\0132..k8s.io.apimachinery.pkg.apis.meta.v" +
      "1.ListMeta\022J\n\005items\030\002 \003(\0132;.k8s.io.apima" +
      "chinery.pkg.apis.meta.v1.PartialObjectMe" +
      "tadata\"\007\n\005Patch\"\\\n\014PatchOptions\022\016\n\006dryRu" +
      "n\030\001 \003(\t\022\r\n\005force\030\002 \001(\010\022\024\n\014fieldManager\030\003" +
      " \001(\t\022\027\n\017fieldValidation\030\004 \001(\t\"5\n\rPrecond" +
      "itions\022\013\n\003uid\030\001 \001(\t\022\027\n\017resourceVersion\030\002" +
      " \001(\t\"\032\n\tRootPaths\022\r\n\005paths\030\001 \003(\t\"F\n\031Serv" +
      "erAddressByClientCIDR\022\022\n\nclientCIDR\030\001 \001(" +
      "\t\022\025\n\rserverAddress\030\002 \001(\t\"\317\001\n\006Status\022@\n\010m" +
      "etadata\030\001 \001(\0132..k8s.io.apimachinery.pkg." +
      "apis.meta.v1.ListMeta\022\016\n\006status\030\002 \001(\t\022\017\n" +
      "\007message\030\003 \001(\t\022\016\n\006reason\030\004 \001(\t\022D\n\007detail" +
      "s\030\005 \001(\01323.k8s.io.apimachinery.pkg.apis.m" +
      "eta.v1.StatusDetails\022\014\n\004code\030\006 \001(\005\"=\n\013St" +
      "atusCause\022\016\n\006reason\030\001 \001(\t\022\017\n\007message\030\002 \001" +
      "(\t\022\r\n\005field\030\003 \001(\t\"\245\001\n\rStatusDetails\022\014\n\004n" +
      "ame\030\001 \001(\t\022\r\n\005group\030\002 \001(\t\022\014\n\004kind\030\003 \001(\t\022\013" +
      "\n\003uid\030\006 \001(\t\022A\n\006causes\030\004 \003(\01321.k8s.io.api" +
      "machinery.pkg.apis.meta.v1.StatusCause\022\031" +
      "\n\021retryAfterSeconds\030\005 \001(\005\"%\n\014TableOption" +
      "s\022\025\n\rincludeObject\030\001 \001(\t\"&\n\004Time\022\017\n\007seco" +
      "nds\030\001 \001(\003\022\r\n\005nanos\030\002 \001(\005\"+\n\tTimestamp\022\017\n" +
      "\007seconds\030\001 \001(\003\022\r\n\005nanos\030\002 \001(\005\",\n\010TypeMet" +
      "a\022\014\n\004kind\030\001 \001(\t\022\022\n\napiVersion\030\002 \001(\t\"N\n\rU" +
      "pdateOptions\022\016\n\006dryRun\030\001 \003(\t\022\024\n\014fieldMan" +
      "ager\030\002 \001(\t\022\027\n\017fieldValidation\030\003 \001(\t\"\026\n\005V" +
      "erbs\022\r\n\005items\030\001 \003(\t\"Y\n\nWatchEvent\022\014\n\004typ" +
      "e\030\001 \001(\t\022=\n\006object\030\002 \001(\0132-.k8s.io.apimach" +
      "inery.pkg.runtime.RawExtensionBH\n\032io.kub" +
      "ernetes.client.protoB\004MetaZ$k8s.io/apima" +
      "chinery/pkg/apis/meta/v1"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.kubernetes.client.proto.Runtime.getDescriptor(),
          io.kubernetes.client.proto.RuntimeSchema.getDescriptor(),
        });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroup_descriptor,
        new java.lang.String[] { "Name", "Versions", "PreferredVersion", "ServerAddressByClientCIDRs", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIGroupList_descriptor,
        new java.lang.String[] { "Groups", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResource_descriptor,
        new java.lang.String[] { "Name", "SingularName", "Namespaced", "Group", "Version", "Kind", "Verbs", "ShortNames", "Categories", "StorageVersionHash", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIResourceList_descriptor,
        new java.lang.String[] { "GroupVersion", "Resources", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_APIVersions_descriptor,
        new java.lang.String[] { "Versions", "ServerAddressByClientCIDRs", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ApplyOptions_descriptor,
        new java.lang.String[] { "DryRun", "Force", "FieldManager", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Condition_descriptor,
        new java.lang.String[] { "Type", "Status", "ObservedGeneration", "LastTransitionTime", "Reason", "Message", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_CreateOptions_descriptor,
        new java.lang.String[] { "DryRun", "FieldManager", "FieldValidation", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_DeleteOptions_descriptor,
        new java.lang.String[] { "GracePeriodSeconds", "Preconditions", "OrphanDependents", "PropagationPolicy", "DryRun", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Duration_descriptor,
        new java.lang.String[] { "Duration", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_FieldsV1_descriptor,
        new java.lang.String[] { "Raw", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GetOptions_descriptor,
        new java.lang.String[] { "ResourceVersion", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupKind_descriptor,
        new java.lang.String[] { "Group", "Kind", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupResource_descriptor,
        new java.lang.String[] { "Group", "Resource", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersion_descriptor,
        new java.lang.String[] { "Group", "Version", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionForDiscovery_descriptor,
        new java.lang.String[] { "GroupVersion", "Version", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionKind_descriptor,
        new java.lang.String[] { "Group", "Version", "Kind", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_GroupVersionResource_descriptor,
        new java.lang.String[] { "Group", "Version", "Resource", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_descriptor,
        new java.lang.String[] { "MatchLabels", "MatchExpressions", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_MatchLabelsEntry_descriptor =
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_descriptor.getNestedTypes().get(0);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_MatchLabelsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelector_MatchLabelsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_LabelSelectorRequirement_descriptor,
        new java.lang.String[] { "Key", "Operator", "Values", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_List_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListMeta_descriptor,
        new java.lang.String[] { "SelfLink", "ResourceVersion", "Continue", "RemainingItemCount", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ListOptions_descriptor,
        new java.lang.String[] { "LabelSelector", "FieldSelector", "Watch", "AllowWatchBookmarks", "ResourceVersion", "ResourceVersionMatch", "TimeoutSeconds", "Limit", "Continue", "SendInitialEvents", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ManagedFieldsEntry_descriptor,
        new java.lang.String[] { "Manager", "Operation", "ApiVersion", "Time", "FieldsType", "FieldsV1", "Subresource", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_MicroTime_descriptor,
        new java.lang.String[] { "Seconds", "Nanos", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_descriptor =
      getDescriptor().getMessageTypes().get(25);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_descriptor,
        new java.lang.String[] { "Name", "GenerateName", "Namespace", "SelfLink", "Uid", "ResourceVersion", "Generation", "CreationTimestamp", "DeletionTimestamp", "DeletionGracePeriodSeconds", "Labels", "Annotations", "OwnerReferences", "Finalizers", "ManagedFields", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_LabelsEntry_descriptor =
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_descriptor.getNestedTypes().get(0);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_LabelsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_LabelsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_AnnotationsEntry_descriptor =
      internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_descriptor.getNestedTypes().get(1);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_AnnotationsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ObjectMeta_AnnotationsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_descriptor =
      getDescriptor().getMessageTypes().get(26);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_OwnerReference_descriptor,
        new java.lang.String[] { "ApiVersion", "Kind", "Name", "Uid", "Controller", "BlockOwnerDeletion", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_descriptor =
      getDescriptor().getMessageTypes().get(27);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadata_descriptor,
        new java.lang.String[] { "Metadata", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_descriptor =
      getDescriptor().getMessageTypes().get(28);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PartialObjectMetadataList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_descriptor =
      getDescriptor().getMessageTypes().get(29);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Patch_descriptor,
        new java.lang.String[] { });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_descriptor =
      getDescriptor().getMessageTypes().get(30);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_PatchOptions_descriptor,
        new java.lang.String[] { "DryRun", "Force", "FieldManager", "FieldValidation", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_descriptor =
      getDescriptor().getMessageTypes().get(31);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Preconditions_descriptor,
        new java.lang.String[] { "Uid", "ResourceVersion", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_descriptor =
      getDescriptor().getMessageTypes().get(32);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_RootPaths_descriptor,
        new java.lang.String[] { "Paths", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_descriptor =
      getDescriptor().getMessageTypes().get(33);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_ServerAddressByClientCIDR_descriptor,
        new java.lang.String[] { "ClientCIDR", "ServerAddress", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_descriptor =
      getDescriptor().getMessageTypes().get(34);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Status_descriptor,
        new java.lang.String[] { "Metadata", "Status", "Message", "Reason", "Details", "Code", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_descriptor =
      getDescriptor().getMessageTypes().get(35);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusCause_descriptor,
        new java.lang.String[] { "Reason", "Message", "Field", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_descriptor =
      getDescriptor().getMessageTypes().get(36);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_StatusDetails_descriptor,
        new java.lang.String[] { "Name", "Group", "Kind", "Uid", "Causes", "RetryAfterSeconds", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_descriptor =
      getDescriptor().getMessageTypes().get(37);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TableOptions_descriptor,
        new java.lang.String[] { "IncludeObject", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_descriptor =
      getDescriptor().getMessageTypes().get(38);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Time_descriptor,
        new java.lang.String[] { "Seconds", "Nanos", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_descriptor =
      getDescriptor().getMessageTypes().get(39);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Timestamp_descriptor,
        new java.lang.String[] { "Seconds", "Nanos", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_descriptor =
      getDescriptor().getMessageTypes().get(40);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_TypeMeta_descriptor,
        new java.lang.String[] { "Kind", "ApiVersion", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_descriptor =
      getDescriptor().getMessageTypes().get(41);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_UpdateOptions_descriptor,
        new java.lang.String[] { "DryRun", "FieldManager", "FieldValidation", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_descriptor =
      getDescriptor().getMessageTypes().get(42);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_Verbs_descriptor,
        new java.lang.String[] { "Items", });
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_descriptor =
      getDescriptor().getMessageTypes().get(43);
    internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_apimachinery_pkg_apis_meta_v1_WatchEvent_descriptor,
        new java.lang.String[] { "Type", "Object", });
    descriptor.resolveAllFeaturesImmutable();
    io.kubernetes.client.proto.Runtime.getDescriptor();
    io.kubernetes.client.proto.RuntimeSchema.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
