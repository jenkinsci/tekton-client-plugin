// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: k8s.io/api/apps/v1/generated.proto
// Protobuf Java Version: 4.26.1

package io.kubernetes.client.proto;

public final class V1Apps {
  private V1Apps() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 26,
      /* patch= */ 1,
      /* suffix= */ "",
      V1Apps.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ControllerRevisionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.ControllerRevision)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Data is the serialized representation of the state.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
     * @return Whether the data field is set.
     */
    boolean hasData();
    /**
     * <pre>
     * Data is the serialized representation of the state.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
     * @return The data.
     */
    io.kubernetes.client.proto.Runtime.RawExtension getData();
    /**
     * <pre>
     * Data is the serialized representation of the state.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
     */
    io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder getDataOrBuilder();

    /**
     * <pre>
     * Revision indicates the revision of the state represented by Data.
     * </pre>
     *
     * <code>optional int64 revision = 3;</code>
     * @return Whether the revision field is set.
     */
    boolean hasRevision();
    /**
     * <pre>
     * Revision indicates the revision of the state represented by Data.
     * </pre>
     *
     * <code>optional int64 revision = 3;</code>
     * @return The revision.
     */
    long getRevision();
  }
  /**
   * <pre>
   * ControllerRevision implements an immutable snapshot of state data. Clients
   * are responsible for serializing and deserializing the objects that contain
   * their internal state.
   * Once a ControllerRevision has been successfully created, it can not be updated.
   * The API Server will fail validation of all requests that attempt to mutate
   * the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both
   * the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However,
   * it may be subject to name and representation changes in future releases, and clients should not
   * depend on its stability. It is primarily for internal use by controllers.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.ControllerRevision}
   */
  public static final class ControllerRevision extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.ControllerRevision)
      ControllerRevisionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ControllerRevision.class.getName());
    }
    // Use ControllerRevision.newBuilder() to construct.
    private ControllerRevision(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ControllerRevision() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevision_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevision_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.ControllerRevision.class, io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int DATA_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Runtime.RawExtension data_;
    /**
     * <pre>
     * Data is the serialized representation of the state.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
     * @return Whether the data field is set.
     */
    @java.lang.Override
    public boolean hasData() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Data is the serialized representation of the state.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
     * @return The data.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Runtime.RawExtension getData() {
      return data_ == null ? io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance() : data_;
    }
    /**
     * <pre>
     * Data is the serialized representation of the state.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder getDataOrBuilder() {
      return data_ == null ? io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance() : data_;
    }

    public static final int REVISION_FIELD_NUMBER = 3;
    private long revision_ = 0L;
    /**
     * <pre>
     * Revision indicates the revision of the state represented by Data.
     * </pre>
     *
     * <code>optional int64 revision = 3;</code>
     * @return Whether the revision field is set.
     */
    @java.lang.Override
    public boolean hasRevision() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Revision indicates the revision of the state represented by Data.
     * </pre>
     *
     * <code>optional int64 revision = 3;</code>
     * @return The revision.
     */
    @java.lang.Override
    public long getRevision() {
      return revision_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getData());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt64(3, revision_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getData());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, revision_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.ControllerRevision)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.ControllerRevision other = (io.kubernetes.client.proto.V1Apps.ControllerRevision) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasData() != other.hasData()) return false;
      if (hasData()) {
        if (!getData()
            .equals(other.getData())) return false;
      }
      if (hasRevision() != other.hasRevision()) return false;
      if (hasRevision()) {
        if (getRevision()
            != other.getRevision()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasData()) {
        hash = (37 * hash) + DATA_FIELD_NUMBER;
        hash = (53 * hash) + getData().hashCode();
      }
      if (hasRevision()) {
        hash = (37 * hash) + REVISION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getRevision());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevision parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.ControllerRevision prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ControllerRevision implements an immutable snapshot of state data. Clients
     * are responsible for serializing and deserializing the objects that contain
     * their internal state.
     * Once a ControllerRevision has been successfully created, it can not be updated.
     * The API Server will fail validation of all requests that attempt to mutate
     * the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both
     * the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However,
     * it may be subject to name and representation changes in future releases, and clients should not
     * depend on its stability. It is primarily for internal use by controllers.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.ControllerRevision}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.ControllerRevision)
        io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevision_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevision_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.ControllerRevision.class, io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.ControllerRevision.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getDataFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        data_ = null;
        if (dataBuilder_ != null) {
          dataBuilder_.dispose();
          dataBuilder_ = null;
        }
        revision_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevision_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ControllerRevision getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.ControllerRevision.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ControllerRevision build() {
        io.kubernetes.client.proto.V1Apps.ControllerRevision result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ControllerRevision buildPartial() {
        io.kubernetes.client.proto.V1Apps.ControllerRevision result = new io.kubernetes.client.proto.V1Apps.ControllerRevision(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.ControllerRevision result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.data_ = dataBuilder_ == null
              ? data_
              : dataBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.revision_ = revision_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.ControllerRevision) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.ControllerRevision)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.ControllerRevision other) {
        if (other == io.kubernetes.client.proto.V1Apps.ControllerRevision.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasData()) {
          mergeData(other.getData());
        }
        if (other.hasRevision()) {
          setRevision(other.getRevision());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getDataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                revision_ = input.readInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.Runtime.RawExtension data_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Runtime.RawExtension, io.kubernetes.client.proto.Runtime.RawExtension.Builder, io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder> dataBuilder_;
      /**
       * <pre>
       * Data is the serialized representation of the state.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
       * @return Whether the data field is set.
       */
      public boolean hasData() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Data is the serialized representation of the state.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
       * @return The data.
       */
      public io.kubernetes.client.proto.Runtime.RawExtension getData() {
        if (dataBuilder_ == null) {
          return data_ == null ? io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance() : data_;
        } else {
          return dataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Data is the serialized representation of the state.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
       */
      public Builder setData(io.kubernetes.client.proto.Runtime.RawExtension value) {
        if (dataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          data_ = value;
        } else {
          dataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data is the serialized representation of the state.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
       */
      public Builder setData(
          io.kubernetes.client.proto.Runtime.RawExtension.Builder builderForValue) {
        if (dataBuilder_ == null) {
          data_ = builderForValue.build();
        } else {
          dataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data is the serialized representation of the state.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
       */
      public Builder mergeData(io.kubernetes.client.proto.Runtime.RawExtension value) {
        if (dataBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            data_ != null &&
            data_ != io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance()) {
            getDataBuilder().mergeFrom(value);
          } else {
            data_ = value;
          }
        } else {
          dataBuilder_.mergeFrom(value);
        }
        if (data_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Data is the serialized representation of the state.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
       */
      public Builder clearData() {
        bitField0_ = (bitField0_ & ~0x00000002);
        data_ = null;
        if (dataBuilder_ != null) {
          dataBuilder_.dispose();
          dataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data is the serialized representation of the state.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
       */
      public io.kubernetes.client.proto.Runtime.RawExtension.Builder getDataBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getDataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Data is the serialized representation of the state.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
       */
      public io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder getDataOrBuilder() {
        if (dataBuilder_ != null) {
          return dataBuilder_.getMessageOrBuilder();
        } else {
          return data_ == null ?
              io.kubernetes.client.proto.Runtime.RawExtension.getDefaultInstance() : data_;
        }
      }
      /**
       * <pre>
       * Data is the serialized representation of the state.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.runtime.RawExtension data = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Runtime.RawExtension, io.kubernetes.client.proto.Runtime.RawExtension.Builder, io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder> 
          getDataFieldBuilder() {
        if (dataBuilder_ == null) {
          dataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Runtime.RawExtension, io.kubernetes.client.proto.Runtime.RawExtension.Builder, io.kubernetes.client.proto.Runtime.RawExtensionOrBuilder>(
                  getData(),
                  getParentForChildren(),
                  isClean());
          data_ = null;
        }
        return dataBuilder_;
      }

      private long revision_ ;
      /**
       * <pre>
       * Revision indicates the revision of the state represented by Data.
       * </pre>
       *
       * <code>optional int64 revision = 3;</code>
       * @return Whether the revision field is set.
       */
      @java.lang.Override
      public boolean hasRevision() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Revision indicates the revision of the state represented by Data.
       * </pre>
       *
       * <code>optional int64 revision = 3;</code>
       * @return The revision.
       */
      @java.lang.Override
      public long getRevision() {
        return revision_;
      }
      /**
       * <pre>
       * Revision indicates the revision of the state represented by Data.
       * </pre>
       *
       * <code>optional int64 revision = 3;</code>
       * @param value The revision to set.
       * @return This builder for chaining.
       */
      public Builder setRevision(long value) {

        revision_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Revision indicates the revision of the state represented by Data.
       * </pre>
       *
       * <code>optional int64 revision = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRevision() {
        bitField0_ = (bitField0_ & ~0x00000004);
        revision_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.ControllerRevision)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.ControllerRevision)
    private static final io.kubernetes.client.proto.V1Apps.ControllerRevision DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.ControllerRevision();
    }

    public static io.kubernetes.client.proto.V1Apps.ControllerRevision getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerRevision>
        PARSER = new com.google.protobuf.AbstractParser<ControllerRevision>() {
      @java.lang.Override
      public ControllerRevision parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ControllerRevision> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerRevision> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ControllerRevision getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerRevisionListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.ControllerRevisionList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.ControllerRevision> 
        getItemsList();
    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.ControllerRevision getItems(int index);
    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ControllerRevisionList is a resource containing a list of ControllerRevision objects.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.ControllerRevisionList}
   */
  public static final class ControllerRevisionList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.ControllerRevisionList)
      ControllerRevisionListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ControllerRevisionList.class.getName());
    }
    // Use ControllerRevisionList.newBuilder() to construct.
    private ControllerRevisionList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ControllerRevisionList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevisionList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevisionList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.ControllerRevisionList.class, io.kubernetes.client.proto.V1Apps.ControllerRevisionList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Apps.ControllerRevision> items_;
    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Apps.ControllerRevision> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ControllerRevision getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * Items is the list of ControllerRevisions
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.ControllerRevisionList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.ControllerRevisionList other = (io.kubernetes.client.proto.V1Apps.ControllerRevisionList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.ControllerRevisionList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ControllerRevisionList is a resource containing a list of ControllerRevision objects.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.ControllerRevisionList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.ControllerRevisionList)
        io.kubernetes.client.proto.V1Apps.ControllerRevisionListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevisionList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevisionList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.ControllerRevisionList.class, io.kubernetes.client.proto.V1Apps.ControllerRevisionList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.ControllerRevisionList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ControllerRevisionList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ControllerRevisionList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.ControllerRevisionList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ControllerRevisionList build() {
        io.kubernetes.client.proto.V1Apps.ControllerRevisionList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ControllerRevisionList buildPartial() {
        io.kubernetes.client.proto.V1Apps.ControllerRevisionList result = new io.kubernetes.client.proto.V1Apps.ControllerRevisionList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.ControllerRevisionList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.ControllerRevisionList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.ControllerRevisionList) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.ControllerRevisionList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.ControllerRevisionList other) {
        if (other == io.kubernetes.client.proto.V1Apps.ControllerRevisionList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Apps.ControllerRevision m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Apps.ControllerRevision.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.ControllerRevision> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.ControllerRevision>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ControllerRevision, io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder, io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.ControllerRevision> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ControllerRevision getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.ControllerRevision value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Apps.ControllerRevision value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.ControllerRevision value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.ControllerRevision> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.ControllerRevision.getDefaultInstance());
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.ControllerRevision.getDefaultInstance());
      }
      /**
       * <pre>
       * Items is the list of ControllerRevisions
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ControllerRevision items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ControllerRevision, io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder, io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Apps.ControllerRevision, io.kubernetes.client.proto.V1Apps.ControllerRevision.Builder, io.kubernetes.client.proto.V1Apps.ControllerRevisionOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.ControllerRevisionList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.ControllerRevisionList)
    private static final io.kubernetes.client.proto.V1Apps.ControllerRevisionList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.ControllerRevisionList();
    }

    public static io.kubernetes.client.proto.V1Apps.ControllerRevisionList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerRevisionList>
        PARSER = new com.google.protobuf.AbstractParser<ControllerRevisionList>() {
      @java.lang.Override
      public ControllerRevisionList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ControllerRevisionList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerRevisionList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ControllerRevisionList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    boolean hasSpec();
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     * @return The spec.
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetSpec getSpec();
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     * @return The status.
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetStatus getStatus();
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * DaemonSet represents the configuration of a daemon set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSet}
   */
  public static final class DaemonSet extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSet)
      DaemonSetOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DaemonSet.class.getName());
    }
    // Use DaemonSet.newBuilder() to construct.
    private DaemonSet(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DaemonSet() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSet.class, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Apps.DaemonSetSpec spec_;
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    @java.lang.Override
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     * @return The spec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Apps.DaemonSetStatus status_;
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     * @return The status.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getStatus());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSet)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSet other = (io.kubernetes.client.proto.V1Apps.DaemonSet) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasSpec() != other.hasSpec()) return false;
      if (hasSpec()) {
        if (!getSpec()
            .equals(other.getSpec())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSet represents the configuration of a daemon set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSet)
        io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSet.class, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSet getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSet.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSet build() {
        io.kubernetes.client.proto.V1Apps.DaemonSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSet buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSet result = new io.kubernetes.client.proto.V1Apps.DaemonSet(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DaemonSet result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.spec_ = specBuilder_ == null
              ? spec_
              : specBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.status_ = statusBuilder_ == null
              ? status_
              : statusBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSet) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSet)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSet other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSet.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getStatusFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.DaemonSetSpec spec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSetSpec, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       * @return Whether the spec field is set.
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       * @return The spec.
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Apps.DaemonSetSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Apps.DaemonSetSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            spec_ != null &&
            spec_ != io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance()) {
            getSpecBuilder().mergeFrom(value);
          } else {
            spec_ = value;
          }
        } else {
          specBuilder_.mergeFrom(value);
        }
        if (spec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSetSpec, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.DaemonSetSpec, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.DaemonSetStatus status_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSetStatus, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       * @return The status.
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1Apps.DaemonSetStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1Apps.DaemonSetStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            status_ != null &&
            status_ != io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance()) {
            getStatusBuilder().mergeFrom(value);
          } else {
            status_ = value;
          }
        } else {
          statusBuilder_.mergeFrom(value);
        }
        if (status_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000004);
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSetStatus, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.DaemonSetStatus, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSet)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSet)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSet DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSet();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DaemonSet>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSet>() {
      @java.lang.Override
      public DaemonSet parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DaemonSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSet> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSetCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    java.lang.String getStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    com.google.protobuf.ByteString
        getStatusBytes();

    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    boolean hasLastTransitionTime();
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return The lastTransitionTime.
     */
    io.kubernetes.client.proto.Meta.Time getLastTransitionTime();
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder();

    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * <pre>
   * DaemonSetCondition describes the state of a DaemonSet at a certain point.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetCondition}
   */
  public static final class DaemonSetCondition extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSetCondition)
      DaemonSetConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DaemonSetCondition.class.getName());
    }
    // Use DaemonSetCondition.newBuilder() to construct.
    private DaemonSetCondition(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DaemonSetCondition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSetCondition.class, io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object status_ = "";
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    @java.lang.Override
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LASTTRANSITIONTIME_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    @java.lang.Override
    public boolean hasLastTransitionTime() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return The lastTransitionTime.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, message_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, message_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSetCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSetCondition other = (io.kubernetes.client.proto.V1Apps.DaemonSetCondition) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (hasLastTransitionTime() != other.hasLastTransitionTime()) return false;
      if (hasLastTransitionTime()) {
        if (!getLastTransitionTime()
            .equals(other.getLastTransitionTime())) return false;
      }
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasLastTransitionTime()) {
        hash = (37 * hash) + LASTTRANSITIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastTransitionTime().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSetCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSetCondition describes the state of a DaemonSet at a certain point.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetCondition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSetCondition)
        io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSetCondition.class, io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSetCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getLastTransitionTimeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        status_ = "";
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        reason_ = "";
        message_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetCondition getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSetCondition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetCondition build() {
        io.kubernetes.client.proto.V1Apps.DaemonSetCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetCondition buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSetCondition result = new io.kubernetes.client.proto.V1Apps.DaemonSetCondition(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DaemonSetCondition result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.lastTransitionTime_ = lastTransitionTimeBuilder_ == null
              ? lastTransitionTime_
              : lastTransitionTimeBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSetCondition) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSetCondition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSetCondition other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSetCondition.getDefaultInstance()) return this;
        if (other.hasType()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasStatus()) {
          status_ = other.status_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasLastTransitionTime()) {
          mergeLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                status_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getLastTransitionTimeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                reason_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                message_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The status.
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The bytes for status.
       */
      public com.google.protobuf.ByteString
          getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        status_ = getDefaultInstance().getStatus();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The bytes for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastTransitionTimeBuilder_;
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       * @return Whether the lastTransitionTime field is set.
       */
      public boolean hasLastTransitionTime() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       * @return The lastTransitionTime.
       */
      public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        } else {
          return lastTransitionTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastTransitionTime_ = value;
        } else {
          lastTransitionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = builderForValue.build();
        } else {
          lastTransitionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder mergeLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            lastTransitionTime_ != null &&
            lastTransitionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getLastTransitionTimeBuilder().mergeFrom(value);
          } else {
            lastTransitionTime_ = value;
          }
        } else {
          lastTransitionTimeBuilder_.mergeFrom(value);
        }
        if (lastTransitionTime_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder clearLastTransitionTime() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastTransitionTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastTransitionTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
        if (lastTransitionTimeBuilder_ != null) {
          return lastTransitionTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastTransitionTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        }
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastTransitionTimeFieldBuilder() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTimeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastTransitionTime(),
                  getParentForChildren(),
                  isClean());
          lastTransitionTime_ = null;
        }
        return lastTransitionTimeBuilder_;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSetCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSetCondition)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSetCondition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSetCondition();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetCondition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DaemonSetCondition>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSetCondition>() {
      @java.lang.Override
      public DaemonSetCondition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DaemonSetCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetCondition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSetList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> 
        getItemsList();
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSet getItems(int index);
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * DaemonSetList is a collection of daemon sets.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetList}
   */
  public static final class DaemonSetList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSetList)
      DaemonSetListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DaemonSetList.class.getName());
    }
    // Use DaemonSetList.newBuilder() to construct.
    private DaemonSetList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DaemonSetList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSetList.class, io.kubernetes.client.proto.V1Apps.DaemonSetList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> items_;
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSet getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSetList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSetList other = (io.kubernetes.client.proto.V1Apps.DaemonSetList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSetList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSetList is a collection of daemon sets.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSetList)
        io.kubernetes.client.proto.V1Apps.DaemonSetListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSetList.class, io.kubernetes.client.proto.V1Apps.DaemonSetList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSetList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSetList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetList build() {
        io.kubernetes.client.proto.V1Apps.DaemonSetList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetList buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSetList result = new io.kubernetes.client.proto.V1Apps.DaemonSetList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.DaemonSetList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DaemonSetList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSetList) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSetList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSetList other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSetList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Apps.DaemonSet m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Apps.DaemonSet.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.DaemonSet>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSet, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSet getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Apps.DaemonSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Apps.DaemonSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.DaemonSet> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSet.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSet.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.DaemonSet.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSet.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.DaemonSet.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSet, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Apps.DaemonSet, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSetList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSetList)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSetList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSetList();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DaemonSetList>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSetList>() {
      @java.lang.Override
      public DaemonSetList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DaemonSetList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSetSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     * @return Whether the selector field is set.
     */
    boolean hasSelector();
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     * @return The selector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * The only allowed template.spec.restartPolicy value is "Always".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     * @return Whether the template field is set.
     */
    boolean hasTemplate();
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * The only allowed template.spec.restartPolicy value is "Always".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     * @return The template.
     */
    io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate();
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * The only allowed template.spec.restartPolicy value is "Always".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder();

    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     * @return Whether the updateStrategy field is set.
     */
    boolean hasUpdateStrategy();
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     * @return The updateStrategy.
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getUpdateStrategy();
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder getUpdateStrategyOrBuilder();

    /**
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     * @return Whether the minReadySeconds field is set.
     */
    boolean hasMinReadySeconds();
    /**
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     * @return The minReadySeconds.
     */
    int getMinReadySeconds();

    /**
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     * @return Whether the revisionHistoryLimit field is set.
     */
    boolean hasRevisionHistoryLimit();
    /**
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     * @return The revisionHistoryLimit.
     */
    int getRevisionHistoryLimit();
  }
  /**
   * <pre>
   * DaemonSetSpec is the specification of a daemon set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetSpec}
   */
  public static final class DaemonSetSpec extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSetSpec)
      DaemonSetSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DaemonSetSpec.class.getName());
    }
    // Use DaemonSetSpec.newBuilder() to construct.
    private DaemonSetSpec(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DaemonSetSpec() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSetSpec.class, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder.class);
    }

    private int bitField0_;
    public static final int SELECTOR_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     * @return Whether the selector field is set.
     */
    @java.lang.Override
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     * @return The selector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }

    public static final int TEMPLATE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * The only allowed template.spec.restartPolicy value is "Always".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     * @return Whether the template field is set.
     */
    @java.lang.Override
    public boolean hasTemplate() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * The only allowed template.spec.restartPolicy value is "Always".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     * @return The template.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * The only allowed template.spec.restartPolicy value is "Always".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }

    public static final int UPDATESTRATEGY_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy updateStrategy_;
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     * @return Whether the updateStrategy field is set.
     */
    @java.lang.Override
    public boolean hasUpdateStrategy() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     * @return The updateStrategy.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getUpdateStrategy() {
      return updateStrategy_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
    }
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder getUpdateStrategyOrBuilder() {
      return updateStrategy_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
    }

    public static final int MINREADYSECONDS_FIELD_NUMBER = 4;
    private int minReadySeconds_ = 0;
    /**
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     * @return Whether the minReadySeconds field is set.
     */
    @java.lang.Override
    public boolean hasMinReadySeconds() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     * @return The minReadySeconds.
     */
    @java.lang.Override
    public int getMinReadySeconds() {
      return minReadySeconds_;
    }

    public static final int REVISIONHISTORYLIMIT_FIELD_NUMBER = 6;
    private int revisionHistoryLimit_ = 0;
    /**
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     * @return Whether the revisionHistoryLimit field is set.
     */
    @java.lang.Override
    public boolean hasRevisionHistoryLimit() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     * @return The revisionHistoryLimit.
     */
    @java.lang.Override
    public int getRevisionHistoryLimit() {
      return revisionHistoryLimit_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getSelector());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getTemplate());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getUpdateStrategy());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(4, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt32(6, revisionHistoryLimit_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getSelector());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getTemplate());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getUpdateStrategy());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, revisionHistoryLimit_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSetSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSetSpec other = (io.kubernetes.client.proto.V1Apps.DaemonSetSpec) obj;

      if (hasSelector() != other.hasSelector()) return false;
      if (hasSelector()) {
        if (!getSelector()
            .equals(other.getSelector())) return false;
      }
      if (hasTemplate() != other.hasTemplate()) return false;
      if (hasTemplate()) {
        if (!getTemplate()
            .equals(other.getTemplate())) return false;
      }
      if (hasUpdateStrategy() != other.hasUpdateStrategy()) return false;
      if (hasUpdateStrategy()) {
        if (!getUpdateStrategy()
            .equals(other.getUpdateStrategy())) return false;
      }
      if (hasMinReadySeconds() != other.hasMinReadySeconds()) return false;
      if (hasMinReadySeconds()) {
        if (getMinReadySeconds()
            != other.getMinReadySeconds()) return false;
      }
      if (hasRevisionHistoryLimit() != other.hasRevisionHistoryLimit()) return false;
      if (hasRevisionHistoryLimit()) {
        if (getRevisionHistoryLimit()
            != other.getRevisionHistoryLimit()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasTemplate()) {
        hash = (37 * hash) + TEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplate().hashCode();
      }
      if (hasUpdateStrategy()) {
        hash = (37 * hash) + UPDATESTRATEGY_FIELD_NUMBER;
        hash = (53 * hash) + getUpdateStrategy().hashCode();
      }
      if (hasMinReadySeconds()) {
        hash = (37 * hash) + MINREADYSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getMinReadySeconds();
      }
      if (hasRevisionHistoryLimit()) {
        hash = (37 * hash) + REVISIONHISTORYLIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getRevisionHistoryLimit();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSetSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSetSpec is the specification of a daemon set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSetSpec)
        io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSetSpec.class, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSetSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
          getTemplateFieldBuilder();
          getUpdateStrategyFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        template_ = null;
        if (templateBuilder_ != null) {
          templateBuilder_.dispose();
          templateBuilder_ = null;
        }
        updateStrategy_ = null;
        if (updateStrategyBuilder_ != null) {
          updateStrategyBuilder_.dispose();
          updateStrategyBuilder_ = null;
        }
        minReadySeconds_ = 0;
        revisionHistoryLimit_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec build() {
        io.kubernetes.client.proto.V1Apps.DaemonSetSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSetSpec result = new io.kubernetes.client.proto.V1Apps.DaemonSetSpec(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DaemonSetSpec result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.selector_ = selectorBuilder_ == null
              ? selector_
              : selectorBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.template_ = templateBuilder_ == null
              ? template_
              : templateBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.updateStrategy_ = updateStrategyBuilder_ == null
              ? updateStrategy_
              : updateStrategyBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.minReadySeconds_ = minReadySeconds_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.revisionHistoryLimit_ = revisionHistoryLimit_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSetSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSetSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSetSpec other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance()) return this;
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasTemplate()) {
          mergeTemplate(other.getTemplate());
        }
        if (other.hasUpdateStrategy()) {
          mergeUpdateStrategy(other.getUpdateStrategy());
        }
        if (other.hasMinReadySeconds()) {
          setMinReadySeconds(other.getMinReadySeconds());
        }
        if (other.hasRevisionHistoryLimit()) {
          setRevisionHistoryLimit(other.getRevisionHistoryLimit());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getTemplateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getUpdateStrategyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                minReadySeconds_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 48: {
                revisionHistoryLimit_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.LabelSelector selector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> selectorBuilder_;
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       * @return Whether the selector field is set.
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       * @return The selector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            selector_ != null &&
            selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getSelectorBuilder().mergeFrom(value);
          } else {
            selector_ = value;
          }
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        if (selector_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder clearSelector() {
        bitField0_ = (bitField0_ & ~0x00000001);
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        }
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(),
                  getParentForChildren(),
                  isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> templateBuilder_;
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * The only allowed template.spec.restartPolicy value is "Always".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       * @return Whether the template field is set.
       */
      public boolean hasTemplate() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * The only allowed template.spec.restartPolicy value is "Always".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       * @return The template.
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
        if (templateBuilder_ == null) {
          return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        } else {
          return templateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * The only allowed template.spec.restartPolicy value is "Always".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder setTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          template_ = value;
        } else {
          templateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * The only allowed template.spec.restartPolicy value is "Always".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder setTemplate(
          io.kubernetes.client.proto.V1.PodTemplateSpec.Builder builderForValue) {
        if (templateBuilder_ == null) {
          template_ = builderForValue.build();
        } else {
          templateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * The only allowed template.spec.restartPolicy value is "Always".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder mergeTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            template_ != null &&
            template_ != io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()) {
            getTemplateBuilder().mergeFrom(value);
          } else {
            template_ = value;
          }
        } else {
          templateBuilder_.mergeFrom(value);
        }
        if (template_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * The only allowed template.spec.restartPolicy value is "Always".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder clearTemplate() {
        bitField0_ = (bitField0_ & ~0x00000002);
        template_ = null;
        if (templateBuilder_ != null) {
          templateBuilder_.dispose();
          templateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * The only allowed template.spec.restartPolicy value is "Always".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec.Builder getTemplateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getTemplateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * The only allowed template.spec.restartPolicy value is "Always".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
        if (templateBuilder_ != null) {
          return templateBuilder_.getMessageOrBuilder();
        } else {
          return template_ == null ?
              io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        }
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * The only allowed template.spec.restartPolicy value is "Always".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> 
          getTemplateFieldBuilder() {
        if (templateBuilder_ == null) {
          templateBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>(
                  getTemplate(),
                  getParentForChildren(),
                  isClean());
          template_ = null;
        }
        return templateBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy updateStrategy_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder> updateStrategyBuilder_;
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       * @return Whether the updateStrategy field is set.
       */
      public boolean hasUpdateStrategy() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       * @return The updateStrategy.
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getUpdateStrategy() {
        if (updateStrategyBuilder_ == null) {
          return updateStrategy_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
        } else {
          return updateStrategyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public Builder setUpdateStrategy(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy value) {
        if (updateStrategyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          updateStrategy_ = value;
        } else {
          updateStrategyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public Builder setUpdateStrategy(
          io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder builderForValue) {
        if (updateStrategyBuilder_ == null) {
          updateStrategy_ = builderForValue.build();
        } else {
          updateStrategyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public Builder mergeUpdateStrategy(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy value) {
        if (updateStrategyBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            updateStrategy_ != null &&
            updateStrategy_ != io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance()) {
            getUpdateStrategyBuilder().mergeFrom(value);
          } else {
            updateStrategy_ = value;
          }
        } else {
          updateStrategyBuilder_.mergeFrom(value);
        }
        if (updateStrategy_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public Builder clearUpdateStrategy() {
        bitField0_ = (bitField0_ & ~0x00000004);
        updateStrategy_ = null;
        if (updateStrategyBuilder_ != null) {
          updateStrategyBuilder_.dispose();
          updateStrategyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder getUpdateStrategyBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getUpdateStrategyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder getUpdateStrategyOrBuilder() {
        if (updateStrategyBuilder_ != null) {
          return updateStrategyBuilder_.getMessageOrBuilder();
        } else {
          return updateStrategy_ == null ?
              io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
        }
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder> 
          getUpdateStrategyFieldBuilder() {
        if (updateStrategyBuilder_ == null) {
          updateStrategyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder>(
                  getUpdateStrategy(),
                  getParentForChildren(),
                  isClean());
          updateStrategy_ = null;
        }
        return updateStrategyBuilder_;
      }

      private int minReadySeconds_ ;
      /**
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       * @return Whether the minReadySeconds field is set.
       */
      @java.lang.Override
      public boolean hasMinReadySeconds() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       * @return The minReadySeconds.
       */
      @java.lang.Override
      public int getMinReadySeconds() {
        return minReadySeconds_;
      }
      /**
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       * @param value The minReadySeconds to set.
       * @return This builder for chaining.
       */
      public Builder setMinReadySeconds(int value) {

        minReadySeconds_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinReadySeconds() {
        bitField0_ = (bitField0_ & ~0x00000008);
        minReadySeconds_ = 0;
        onChanged();
        return this;
      }

      private int revisionHistoryLimit_ ;
      /**
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       * @return Whether the revisionHistoryLimit field is set.
       */
      @java.lang.Override
      public boolean hasRevisionHistoryLimit() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       * @return The revisionHistoryLimit.
       */
      @java.lang.Override
      public int getRevisionHistoryLimit() {
        return revisionHistoryLimit_;
      }
      /**
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       * @param value The revisionHistoryLimit to set.
       * @return This builder for chaining.
       */
      public Builder setRevisionHistoryLimit(int value) {

        revisionHistoryLimit_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearRevisionHistoryLimit() {
        bitField0_ = (bitField0_ & ~0x00000010);
        revisionHistoryLimit_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSetSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSetSpec)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSetSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSetSpec();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DaemonSetSpec>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSetSpec>() {
      @java.lang.Override
      public DaemonSetSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DaemonSetSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSetStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     * @return Whether the currentNumberScheduled field is set.
     */
    boolean hasCurrentNumberScheduled();
    /**
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     * @return The currentNumberScheduled.
     */
    int getCurrentNumberScheduled();

    /**
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     * @return Whether the numberMisscheduled field is set.
     */
    boolean hasNumberMisscheduled();
    /**
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     * @return The numberMisscheduled.
     */
    int getNumberMisscheduled();

    /**
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     * @return Whether the desiredNumberScheduled field is set.
     */
    boolean hasDesiredNumberScheduled();
    /**
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     * @return The desiredNumberScheduled.
     */
    int getDesiredNumberScheduled();

    /**
     * <pre>
     * numberReady is the number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running with a Ready Condition.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     * @return Whether the numberReady field is set.
     */
    boolean hasNumberReady();
    /**
     * <pre>
     * numberReady is the number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running with a Ready Condition.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     * @return The numberReady.
     */
    int getNumberReady();

    /**
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     * @return Whether the observedGeneration field is set.
     */
    boolean hasObservedGeneration();
    /**
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     * @return The observedGeneration.
     */
    long getObservedGeneration();

    /**
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     * @return Whether the updatedNumberScheduled field is set.
     */
    boolean hasUpdatedNumberScheduled();
    /**
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     * @return The updatedNumberScheduled.
     */
    int getUpdatedNumberScheduled();

    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     * @return Whether the numberAvailable field is set.
     */
    boolean hasNumberAvailable();
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     * @return The numberAvailable.
     */
    int getNumberAvailable();

    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     * @return Whether the numberUnavailable field is set.
     */
    boolean hasNumberUnavailable();
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     * @return The numberUnavailable.
     */
    int getNumberUnavailable();

    /**
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     * @return Whether the collisionCount field is set.
     */
    boolean hasCollisionCount();
    /**
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     * @return The collisionCount.
     */
    int getCollisionCount();

    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSetCondition> 
        getConditionsList();
    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetCondition getConditions(int index);
    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    int getConditionsCount();
    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder> 
        getConditionsOrBuilderList();
    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder getConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * DaemonSetStatus represents the current status of a daemon set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetStatus}
   */
  public static final class DaemonSetStatus extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSetStatus)
      DaemonSetStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DaemonSetStatus.class.getName());
    }
    // Use DaemonSetStatus.newBuilder() to construct.
    private DaemonSetStatus(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DaemonSetStatus() {
      conditions_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSetStatus.class, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder.class);
    }

    private int bitField0_;
    public static final int CURRENTNUMBERSCHEDULED_FIELD_NUMBER = 1;
    private int currentNumberScheduled_ = 0;
    /**
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     * @return Whether the currentNumberScheduled field is set.
     */
    @java.lang.Override
    public boolean hasCurrentNumberScheduled() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     * @return The currentNumberScheduled.
     */
    @java.lang.Override
    public int getCurrentNumberScheduled() {
      return currentNumberScheduled_;
    }

    public static final int NUMBERMISSCHEDULED_FIELD_NUMBER = 2;
    private int numberMisscheduled_ = 0;
    /**
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     * @return Whether the numberMisscheduled field is set.
     */
    @java.lang.Override
    public boolean hasNumberMisscheduled() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     * @return The numberMisscheduled.
     */
    @java.lang.Override
    public int getNumberMisscheduled() {
      return numberMisscheduled_;
    }

    public static final int DESIREDNUMBERSCHEDULED_FIELD_NUMBER = 3;
    private int desiredNumberScheduled_ = 0;
    /**
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     * @return Whether the desiredNumberScheduled field is set.
     */
    @java.lang.Override
    public boolean hasDesiredNumberScheduled() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     * @return The desiredNumberScheduled.
     */
    @java.lang.Override
    public int getDesiredNumberScheduled() {
      return desiredNumberScheduled_;
    }

    public static final int NUMBERREADY_FIELD_NUMBER = 4;
    private int numberReady_ = 0;
    /**
     * <pre>
     * numberReady is the number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running with a Ready Condition.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     * @return Whether the numberReady field is set.
     */
    @java.lang.Override
    public boolean hasNumberReady() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * numberReady is the number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running with a Ready Condition.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     * @return The numberReady.
     */
    @java.lang.Override
    public int getNumberReady() {
      return numberReady_;
    }

    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 5;
    private long observedGeneration_ = 0L;
    /**
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     * @return Whether the observedGeneration field is set.
     */
    @java.lang.Override
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     * @return The observedGeneration.
     */
    @java.lang.Override
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int UPDATEDNUMBERSCHEDULED_FIELD_NUMBER = 6;
    private int updatedNumberScheduled_ = 0;
    /**
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     * @return Whether the updatedNumberScheduled field is set.
     */
    @java.lang.Override
    public boolean hasUpdatedNumberScheduled() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     * @return The updatedNumberScheduled.
     */
    @java.lang.Override
    public int getUpdatedNumberScheduled() {
      return updatedNumberScheduled_;
    }

    public static final int NUMBERAVAILABLE_FIELD_NUMBER = 7;
    private int numberAvailable_ = 0;
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     * @return Whether the numberAvailable field is set.
     */
    @java.lang.Override
    public boolean hasNumberAvailable() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     * @return The numberAvailable.
     */
    @java.lang.Override
    public int getNumberAvailable() {
      return numberAvailable_;
    }

    public static final int NUMBERUNAVAILABLE_FIELD_NUMBER = 8;
    private int numberUnavailable_ = 0;
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     * @return Whether the numberUnavailable field is set.
     */
    @java.lang.Override
    public boolean hasNumberUnavailable() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     * @return The numberUnavailable.
     */
    @java.lang.Override
    public int getNumberUnavailable() {
      return numberUnavailable_;
    }

    public static final int COLLISIONCOUNT_FIELD_NUMBER = 9;
    private int collisionCount_ = 0;
    /**
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     * @return Whether the collisionCount field is set.
     */
    @java.lang.Override
    public boolean hasCollisionCount() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     * @return The collisionCount.
     */
    @java.lang.Override
    public int getCollisionCount() {
      return collisionCount_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSetCondition> conditions_;
    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSetCondition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetCondition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, currentNumberScheduled_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, numberMisscheduled_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt32(3, desiredNumberScheduled_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(4, numberReady_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt64(5, observedGeneration_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeInt32(6, updatedNumberScheduled_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeInt32(7, numberAvailable_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt32(8, numberUnavailable_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeInt32(9, collisionCount_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(10, conditions_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, currentNumberScheduled_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, numberMisscheduled_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, desiredNumberScheduled_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, numberReady_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, observedGeneration_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, updatedNumberScheduled_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, numberAvailable_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, numberUnavailable_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, collisionCount_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, conditions_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSetStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSetStatus other = (io.kubernetes.client.proto.V1Apps.DaemonSetStatus) obj;

      if (hasCurrentNumberScheduled() != other.hasCurrentNumberScheduled()) return false;
      if (hasCurrentNumberScheduled()) {
        if (getCurrentNumberScheduled()
            != other.getCurrentNumberScheduled()) return false;
      }
      if (hasNumberMisscheduled() != other.hasNumberMisscheduled()) return false;
      if (hasNumberMisscheduled()) {
        if (getNumberMisscheduled()
            != other.getNumberMisscheduled()) return false;
      }
      if (hasDesiredNumberScheduled() != other.hasDesiredNumberScheduled()) return false;
      if (hasDesiredNumberScheduled()) {
        if (getDesiredNumberScheduled()
            != other.getDesiredNumberScheduled()) return false;
      }
      if (hasNumberReady() != other.hasNumberReady()) return false;
      if (hasNumberReady()) {
        if (getNumberReady()
            != other.getNumberReady()) return false;
      }
      if (hasObservedGeneration() != other.hasObservedGeneration()) return false;
      if (hasObservedGeneration()) {
        if (getObservedGeneration()
            != other.getObservedGeneration()) return false;
      }
      if (hasUpdatedNumberScheduled() != other.hasUpdatedNumberScheduled()) return false;
      if (hasUpdatedNumberScheduled()) {
        if (getUpdatedNumberScheduled()
            != other.getUpdatedNumberScheduled()) return false;
      }
      if (hasNumberAvailable() != other.hasNumberAvailable()) return false;
      if (hasNumberAvailable()) {
        if (getNumberAvailable()
            != other.getNumberAvailable()) return false;
      }
      if (hasNumberUnavailable() != other.hasNumberUnavailable()) return false;
      if (hasNumberUnavailable()) {
        if (getNumberUnavailable()
            != other.getNumberUnavailable()) return false;
      }
      if (hasCollisionCount() != other.hasCollisionCount()) return false;
      if (hasCollisionCount()) {
        if (getCollisionCount()
            != other.getCollisionCount()) return false;
      }
      if (!getConditionsList()
          .equals(other.getConditionsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCurrentNumberScheduled()) {
        hash = (37 * hash) + CURRENTNUMBERSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getCurrentNumberScheduled();
      }
      if (hasNumberMisscheduled()) {
        hash = (37 * hash) + NUMBERMISSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getNumberMisscheduled();
      }
      if (hasDesiredNumberScheduled()) {
        hash = (37 * hash) + DESIREDNUMBERSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getDesiredNumberScheduled();
      }
      if (hasNumberReady()) {
        hash = (37 * hash) + NUMBERREADY_FIELD_NUMBER;
        hash = (53 * hash) + getNumberReady();
      }
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getObservedGeneration());
      }
      if (hasUpdatedNumberScheduled()) {
        hash = (37 * hash) + UPDATEDNUMBERSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getUpdatedNumberScheduled();
      }
      if (hasNumberAvailable()) {
        hash = (37 * hash) + NUMBERAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getNumberAvailable();
      }
      if (hasNumberUnavailable()) {
        hash = (37 * hash) + NUMBERUNAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getNumberUnavailable();
      }
      if (hasCollisionCount()) {
        hash = (37 * hash) + COLLISIONCOUNT_FIELD_NUMBER;
        hash = (53 * hash) + getCollisionCount();
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSetStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSetStatus represents the current status of a daemon set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSetStatus)
        io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSetStatus.class, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSetStatus.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        currentNumberScheduled_ = 0;
        numberMisscheduled_ = 0;
        desiredNumberScheduled_ = 0;
        numberReady_ = 0;
        observedGeneration_ = 0L;
        updatedNumberScheduled_ = 0;
        numberAvailable_ = 0;
        numberUnavailable_ = 0;
        collisionCount_ = 0;
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
        } else {
          conditions_ = null;
          conditionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus build() {
        io.kubernetes.client.proto.V1Apps.DaemonSetStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSetStatus result = new io.kubernetes.client.proto.V1Apps.DaemonSetStatus(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.DaemonSetStatus result) {
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000200);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DaemonSetStatus result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.currentNumberScheduled_ = currentNumberScheduled_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.numberMisscheduled_ = numberMisscheduled_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.desiredNumberScheduled_ = desiredNumberScheduled_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.numberReady_ = numberReady_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.observedGeneration_ = observedGeneration_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.updatedNumberScheduled_ = updatedNumberScheduled_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.numberAvailable_ = numberAvailable_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.numberUnavailable_ = numberUnavailable_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.collisionCount_ = collisionCount_;
          to_bitField0_ |= 0x00000100;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSetStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSetStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSetStatus other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance()) return this;
        if (other.hasCurrentNumberScheduled()) {
          setCurrentNumberScheduled(other.getCurrentNumberScheduled());
        }
        if (other.hasNumberMisscheduled()) {
          setNumberMisscheduled(other.getNumberMisscheduled());
        }
        if (other.hasDesiredNumberScheduled()) {
          setDesiredNumberScheduled(other.getDesiredNumberScheduled());
        }
        if (other.hasNumberReady()) {
          setNumberReady(other.getNumberReady());
        }
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasUpdatedNumberScheduled()) {
          setUpdatedNumberScheduled(other.getUpdatedNumberScheduled());
        }
        if (other.hasNumberAvailable()) {
          setNumberAvailable(other.getNumberAvailable());
        }
        if (other.hasNumberUnavailable()) {
          setNumberUnavailable(other.getNumberUnavailable());
        }
        if (other.hasCollisionCount()) {
          setCollisionCount(other.getCollisionCount());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000200);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000200);
              conditionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getConditionsFieldBuilder() : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                currentNumberScheduled_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                numberMisscheduled_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                desiredNumberScheduled_ = input.readInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                numberReady_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                observedGeneration_ = input.readInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                updatedNumberScheduled_ = input.readInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 56: {
                numberAvailable_ = input.readInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 64: {
                numberUnavailable_ = input.readInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              case 72: {
                collisionCount_ = input.readInt32();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              case 82: {
                io.kubernetes.client.proto.V1Apps.DaemonSetCondition m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Apps.DaemonSetCondition.parser(),
                        extensionRegistry);
                if (conditionsBuilder_ == null) {
                  ensureConditionsIsMutable();
                  conditions_.add(m);
                } else {
                  conditionsBuilder_.addMessage(m);
                }
                break;
              } // case 82
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int currentNumberScheduled_ ;
      /**
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       * @return Whether the currentNumberScheduled field is set.
       */
      @java.lang.Override
      public boolean hasCurrentNumberScheduled() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       * @return The currentNumberScheduled.
       */
      @java.lang.Override
      public int getCurrentNumberScheduled() {
        return currentNumberScheduled_;
      }
      /**
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       * @param value The currentNumberScheduled to set.
       * @return This builder for chaining.
       */
      public Builder setCurrentNumberScheduled(int value) {

        currentNumberScheduled_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCurrentNumberScheduled() {
        bitField0_ = (bitField0_ & ~0x00000001);
        currentNumberScheduled_ = 0;
        onChanged();
        return this;
      }

      private int numberMisscheduled_ ;
      /**
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       * @return Whether the numberMisscheduled field is set.
       */
      @java.lang.Override
      public boolean hasNumberMisscheduled() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       * @return The numberMisscheduled.
       */
      @java.lang.Override
      public int getNumberMisscheduled() {
        return numberMisscheduled_;
      }
      /**
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       * @param value The numberMisscheduled to set.
       * @return This builder for chaining.
       */
      public Builder setNumberMisscheduled(int value) {

        numberMisscheduled_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumberMisscheduled() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numberMisscheduled_ = 0;
        onChanged();
        return this;
      }

      private int desiredNumberScheduled_ ;
      /**
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       * @return Whether the desiredNumberScheduled field is set.
       */
      @java.lang.Override
      public boolean hasDesiredNumberScheduled() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       * @return The desiredNumberScheduled.
       */
      @java.lang.Override
      public int getDesiredNumberScheduled() {
        return desiredNumberScheduled_;
      }
      /**
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       * @param value The desiredNumberScheduled to set.
       * @return This builder for chaining.
       */
      public Builder setDesiredNumberScheduled(int value) {

        desiredNumberScheduled_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDesiredNumberScheduled() {
        bitField0_ = (bitField0_ & ~0x00000004);
        desiredNumberScheduled_ = 0;
        onChanged();
        return this;
      }

      private int numberReady_ ;
      /**
       * <pre>
       * numberReady is the number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running with a Ready Condition.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       * @return Whether the numberReady field is set.
       */
      @java.lang.Override
      public boolean hasNumberReady() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * numberReady is the number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running with a Ready Condition.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       * @return The numberReady.
       */
      @java.lang.Override
      public int getNumberReady() {
        return numberReady_;
      }
      /**
       * <pre>
       * numberReady is the number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running with a Ready Condition.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       * @param value The numberReady to set.
       * @return This builder for chaining.
       */
      public Builder setNumberReady(int value) {

        numberReady_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * numberReady is the number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running with a Ready Condition.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumberReady() {
        bitField0_ = (bitField0_ & ~0x00000008);
        numberReady_ = 0;
        onChanged();
        return this;
      }

      private long observedGeneration_ ;
      /**
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       * @return Whether the observedGeneration field is set.
       */
      @java.lang.Override
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       * @return The observedGeneration.
       */
      @java.lang.Override
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       * @param value The observedGeneration to set.
       * @return This builder for chaining.
       */
      public Builder setObservedGeneration(long value) {

        observedGeneration_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000010);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private int updatedNumberScheduled_ ;
      /**
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       * @return Whether the updatedNumberScheduled field is set.
       */
      @java.lang.Override
      public boolean hasUpdatedNumberScheduled() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       * @return The updatedNumberScheduled.
       */
      @java.lang.Override
      public int getUpdatedNumberScheduled() {
        return updatedNumberScheduled_;
      }
      /**
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       * @param value The updatedNumberScheduled to set.
       * @return This builder for chaining.
       */
      public Builder setUpdatedNumberScheduled(int value) {

        updatedNumberScheduled_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpdatedNumberScheduled() {
        bitField0_ = (bitField0_ & ~0x00000020);
        updatedNumberScheduled_ = 0;
        onChanged();
        return this;
      }

      private int numberAvailable_ ;
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       * @return Whether the numberAvailable field is set.
       */
      @java.lang.Override
      public boolean hasNumberAvailable() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       * @return The numberAvailable.
       */
      @java.lang.Override
      public int getNumberAvailable() {
        return numberAvailable_;
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       * @param value The numberAvailable to set.
       * @return This builder for chaining.
       */
      public Builder setNumberAvailable(int value) {

        numberAvailable_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumberAvailable() {
        bitField0_ = (bitField0_ & ~0x00000040);
        numberAvailable_ = 0;
        onChanged();
        return this;
      }

      private int numberUnavailable_ ;
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       * @return Whether the numberUnavailable field is set.
       */
      @java.lang.Override
      public boolean hasNumberUnavailable() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       * @return The numberUnavailable.
       */
      @java.lang.Override
      public int getNumberUnavailable() {
        return numberUnavailable_;
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       * @param value The numberUnavailable to set.
       * @return This builder for chaining.
       */
      public Builder setNumberUnavailable(int value) {

        numberUnavailable_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumberUnavailable() {
        bitField0_ = (bitField0_ & ~0x00000080);
        numberUnavailable_ = 0;
        onChanged();
        return this;
      }

      private int collisionCount_ ;
      /**
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       * @return Whether the collisionCount field is set.
       */
      @java.lang.Override
      public boolean hasCollisionCount() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       * @return The collisionCount.
       */
      @java.lang.Override
      public int getCollisionCount() {
        return collisionCount_;
      }
      /**
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       * @param value The collisionCount to set.
       * @return This builder for chaining.
       */
      public Builder setCollisionCount(int value) {

        collisionCount_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearCollisionCount() {
        bitField0_ = (bitField0_ & ~0x00000100);
        collisionCount_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSetCondition> conditions_ =
        java.util.Collections.emptyList();
      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000200) != 0)) {
          conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.DaemonSetCondition>(conditions_);
          bitField0_ |= 0x00000200;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSetCondition, io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder> conditionsBuilder_;

      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSetCondition> getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetCondition getConditions(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addConditions(io.kubernetes.client.proto.V1Apps.DaemonSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.DaemonSetCondition> values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder getConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder getConditionsOrBuilder(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);  } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder> 
           getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder addConditionsBuilder() {
        return getConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.DaemonSetCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder addConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.DaemonSetCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSetCondition conditions = 10;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder> 
           getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DaemonSetCondition, io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder> 
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Apps.DaemonSetCondition, io.kubernetes.client.proto.V1Apps.DaemonSetCondition.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000200) != 0),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSetStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSetStatus)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSetStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSetStatus();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DaemonSetStatus>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSetStatus>() {
      @java.lang.Override
      public DaemonSetStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DaemonSetStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetUpdateStrategyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     * @return Whether the rollingUpdate field is set.
     */
    boolean hasRollingUpdate();
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     * @return The rollingUpdate.
     */
    io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getRollingUpdate();
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder getRollingUpdateOrBuilder();
  }
  /**
   * <pre>
   * DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetUpdateStrategy}
   */
  public static final class DaemonSetUpdateStrategy extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
      DaemonSetUpdateStrategyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DaemonSetUpdateStrategy.class.getName());
    }
    // Use DaemonSetUpdateStrategy.newBuilder() to construct.
    private DaemonSetUpdateStrategy(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DaemonSetUpdateStrategy() {
      type_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.class, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROLLINGUPDATE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet rollingUpdate_;
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     * @return Whether the rollingUpdate field is set.
     */
    @java.lang.Override
    public boolean hasRollingUpdate() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     * @return The rollingUpdate.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getRollingUpdate() {
      return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance() : rollingUpdate_;
    }
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder getRollingUpdateOrBuilder() {
      return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance() : rollingUpdate_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getRollingUpdate());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRollingUpdate());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy other = (io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasRollingUpdate() != other.hasRollingUpdate()) return false;
      if (hasRollingUpdate()) {
        if (!getRollingUpdate()
            .equals(other.getRollingUpdate())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasRollingUpdate()) {
        hash = (37 * hash) + ROLLINGUPDATE_FIELD_NUMBER;
        hash = (53 * hash) + getRollingUpdate().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetUpdateStrategy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
        io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.class, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getRollingUpdateFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        rollingUpdate_ = null;
        if (rollingUpdateBuilder_ != null) {
          rollingUpdateBuilder_.dispose();
          rollingUpdateBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy build() {
        io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy result = new io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.rollingUpdate_ = rollingUpdateBuilder_ == null
              ? rollingUpdate_
              : rollingUpdateBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance()) return this;
        if (other.hasType()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasRollingUpdate()) {
          mergeRollingUpdate(other.getRollingUpdate());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getRollingUpdateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet rollingUpdate_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder> rollingUpdateBuilder_;
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       * @return Whether the rollingUpdate field is set.
       */
      public boolean hasRollingUpdate() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       * @return The rollingUpdate.
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getRollingUpdate() {
        if (rollingUpdateBuilder_ == null) {
          return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance() : rollingUpdate_;
        } else {
          return rollingUpdateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public Builder setRollingUpdate(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet value) {
        if (rollingUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rollingUpdate_ = value;
        } else {
          rollingUpdateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public Builder setRollingUpdate(
          io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder builderForValue) {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = builderForValue.build();
        } else {
          rollingUpdateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public Builder mergeRollingUpdate(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet value) {
        if (rollingUpdateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            rollingUpdate_ != null &&
            rollingUpdate_ != io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance()) {
            getRollingUpdateBuilder().mergeFrom(value);
          } else {
            rollingUpdate_ = value;
          }
        } else {
          rollingUpdateBuilder_.mergeFrom(value);
        }
        if (rollingUpdate_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public Builder clearRollingUpdate() {
        bitField0_ = (bitField0_ & ~0x00000002);
        rollingUpdate_ = null;
        if (rollingUpdateBuilder_ != null) {
          rollingUpdateBuilder_.dispose();
          rollingUpdateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder getRollingUpdateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRollingUpdateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder getRollingUpdateOrBuilder() {
        if (rollingUpdateBuilder_ != null) {
          return rollingUpdateBuilder_.getMessageOrBuilder();
        } else {
          return rollingUpdate_ == null ?
              io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance() : rollingUpdate_;
        }
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder> 
          getRollingUpdateFieldBuilder() {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdateBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder>(
                  getRollingUpdate(),
                  getParentForChildren(),
                  isClean());
          rollingUpdate_ = null;
        }
        return rollingUpdateBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DaemonSetUpdateStrategy>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSetUpdateStrategy>() {
      @java.lang.Override
      public DaemonSetUpdateStrategy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DaemonSetUpdateStrategy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetUpdateStrategy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeploymentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.Deployment)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
     * @return The spec.
     */
    io.kubernetes.client.proto.V1Apps.DeploymentSpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.DeploymentSpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
     * @return The status.
     */
    io.kubernetes.client.proto.V1Apps.DeploymentStatus getStatus();
    /**
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Apps.DeploymentStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * Deployment enables declarative updates for Pods and ReplicaSets.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.Deployment}
   */
  public static final class Deployment extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.Deployment)
      DeploymentOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Deployment.class.getName());
    }
    // Use Deployment.newBuilder() to construct.
    private Deployment(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Deployment() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_Deployment_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_Deployment_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.Deployment.class, io.kubernetes.client.proto.V1Apps.Deployment.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Apps.DeploymentSpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    @java.lang.Override
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
     * @return The spec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.DeploymentSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.DeploymentSpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Apps.DeploymentStatus status_;
    /**
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
     * @return The status.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.DeploymentStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.DeploymentStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getStatus());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.Deployment)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.Deployment other = (io.kubernetes.client.proto.V1Apps.Deployment) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasSpec() != other.hasSpec()) return false;
      if (hasSpec()) {
        if (!getSpec()
            .equals(other.getSpec())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.Deployment parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.Deployment parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.Deployment parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.Deployment prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Deployment enables declarative updates for Pods and ReplicaSets.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.Deployment}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.Deployment)
        io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_Deployment_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_Deployment_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.Deployment.class, io.kubernetes.client.proto.V1Apps.Deployment.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.Deployment.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_Deployment_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.Deployment getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.Deployment.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.Deployment build() {
        io.kubernetes.client.proto.V1Apps.Deployment result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.Deployment buildPartial() {
        io.kubernetes.client.proto.V1Apps.Deployment result = new io.kubernetes.client.proto.V1Apps.Deployment(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.Deployment result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.spec_ = specBuilder_ == null
              ? spec_
              : specBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.status_ = statusBuilder_ == null
              ? status_
              : statusBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.Deployment) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.Deployment)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.Deployment other) {
        if (other == io.kubernetes.client.proto.V1Apps.Deployment.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getStatusFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.DeploymentSpec spec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DeploymentSpec, io.kubernetes.client.proto.V1Apps.DeploymentSpec.Builder, io.kubernetes.client.proto.V1Apps.DeploymentSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
       * @return Whether the spec field is set.
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
       * @return The spec.
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Apps.DeploymentSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Apps.DeploymentSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Apps.DeploymentSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Apps.DeploymentSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            spec_ != null &&
            spec_ != io.kubernetes.client.proto.V1Apps.DeploymentSpec.getDefaultInstance()) {
            getSpecBuilder().mergeFrom(value);
          } else {
            spec_ = value;
          }
        } else {
          specBuilder_.mergeFrom(value);
        }
        if (spec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Apps.DeploymentSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DeploymentSpec, io.kubernetes.client.proto.V1Apps.DeploymentSpec.Builder, io.kubernetes.client.proto.V1Apps.DeploymentSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.DeploymentSpec, io.kubernetes.client.proto.V1Apps.DeploymentSpec.Builder, io.kubernetes.client.proto.V1Apps.DeploymentSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.DeploymentStatus status_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DeploymentStatus, io.kubernetes.client.proto.V1Apps.DeploymentStatus.Builder, io.kubernetes.client.proto.V1Apps.DeploymentStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
       * @return The status.
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1Apps.DeploymentStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1Apps.DeploymentStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1Apps.DeploymentStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1Apps.DeploymentStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            status_ != null &&
            status_ != io.kubernetes.client.proto.V1Apps.DeploymentStatus.getDefaultInstance()) {
            getStatusBuilder().mergeFrom(value);
          } else {
            status_ = value;
          }
        } else {
          statusBuilder_.mergeFrom(value);
        }
        if (status_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000004);
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1Apps.DeploymentStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DeploymentStatus, io.kubernetes.client.proto.V1Apps.DeploymentStatus.Builder, io.kubernetes.client.proto.V1Apps.DeploymentStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.DeploymentStatus, io.kubernetes.client.proto.V1Apps.DeploymentStatus.Builder, io.kubernetes.client.proto.V1Apps.DeploymentStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.Deployment)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.Deployment)
    private static final io.kubernetes.client.proto.V1Apps.Deployment DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.Deployment();
    }

    public static io.kubernetes.client.proto.V1Apps.Deployment getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Deployment>
        PARSER = new com.google.protobuf.AbstractParser<Deployment>() {
      @java.lang.Override
      public Deployment parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Deployment> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Deployment> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.Deployment getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeploymentConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DeploymentCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    java.lang.String getStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    com.google.protobuf.ByteString
        getStatusBytes();

    /**
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     * @return Whether the lastUpdateTime field is set.
     */
    boolean hasLastUpdateTime();
    /**
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     * @return The lastUpdateTime.
     */
    io.kubernetes.client.proto.Meta.Time getLastUpdateTime();
    /**
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastUpdateTimeOrBuilder();

    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    boolean hasLastTransitionTime();
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     * @return The lastTransitionTime.
     */
    io.kubernetes.client.proto.Meta.Time getLastTransitionTime();
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder();

    /**
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * <pre>
   * DeploymentCondition describes the state of a deployment at a certain point.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DeploymentCondition}
   */
  public static final class DeploymentCondition extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DeploymentCondition)
      DeploymentConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DeploymentCondition.class.getName());
    }
    // Use DeploymentCondition.newBuilder() to construct.
    private DeploymentCondition(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DeploymentCondition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DeploymentCondition.class, io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object status_ = "";
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    @java.lang.Override
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LASTUPDATETIME_FIELD_NUMBER = 6;
    private io.kubernetes.client.proto.Meta.Time lastUpdateTime_;
    /**
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     * @return Whether the lastUpdateTime field is set.
     */
    @java.lang.Override
    public boolean hasLastUpdateTime() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     * @return The lastUpdateTime.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getLastUpdateTime() {
      return lastUpdateTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastUpdateTime_;
    }
    /**
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastUpdateTimeOrBuilder() {
      return lastUpdateTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastUpdateTime_;
    }

    public static final int LASTTRANSITIONTIME_FIELD_NUMBER = 7;
    private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    @java.lang.Override
    public boolean hasLastTransitionTime() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     * @return The lastTransitionTime.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, reason_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, message_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(6, getLastUpdateTime());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(7, getLastTransitionTime());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, reason_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, message_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getLastUpdateTime());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getLastTransitionTime());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DeploymentCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DeploymentCondition other = (io.kubernetes.client.proto.V1Apps.DeploymentCondition) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (hasLastUpdateTime() != other.hasLastUpdateTime()) return false;
      if (hasLastUpdateTime()) {
        if (!getLastUpdateTime()
            .equals(other.getLastUpdateTime())) return false;
      }
      if (hasLastTransitionTime() != other.hasLastTransitionTime()) return false;
      if (hasLastTransitionTime()) {
        if (!getLastTransitionTime()
            .equals(other.getLastTransitionTime())) return false;
      }
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasLastUpdateTime()) {
        hash = (37 * hash) + LASTUPDATETIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastUpdateTime().hashCode();
      }
      if (hasLastTransitionTime()) {
        hash = (37 * hash) + LASTTRANSITIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastTransitionTime().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DeploymentCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DeploymentCondition describes the state of a deployment at a certain point.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DeploymentCondition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DeploymentCondition)
        io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DeploymentCondition.class, io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DeploymentCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getLastUpdateTimeFieldBuilder();
          getLastTransitionTimeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        status_ = "";
        lastUpdateTime_ = null;
        if (lastUpdateTimeBuilder_ != null) {
          lastUpdateTimeBuilder_.dispose();
          lastUpdateTimeBuilder_ = null;
        }
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        reason_ = "";
        message_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentCondition getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DeploymentCondition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentCondition build() {
        io.kubernetes.client.proto.V1Apps.DeploymentCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentCondition buildPartial() {
        io.kubernetes.client.proto.V1Apps.DeploymentCondition result = new io.kubernetes.client.proto.V1Apps.DeploymentCondition(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DeploymentCondition result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.lastUpdateTime_ = lastUpdateTimeBuilder_ == null
              ? lastUpdateTime_
              : lastUpdateTimeBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.lastTransitionTime_ = lastTransitionTimeBuilder_ == null
              ? lastTransitionTime_
              : lastTransitionTimeBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000020;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DeploymentCondition) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DeploymentCondition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DeploymentCondition other) {
        if (other == io.kubernetes.client.proto.V1Apps.DeploymentCondition.getDefaultInstance()) return this;
        if (other.hasType()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasStatus()) {
          status_ = other.status_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasLastUpdateTime()) {
          mergeLastUpdateTime(other.getLastUpdateTime());
        }
        if (other.hasLastTransitionTime()) {
          mergeLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                status_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 34: {
                reason_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 34
              case 42: {
                message_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    getLastUpdateTimeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    getLastTransitionTimeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 58
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The status.
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The bytes for status.
       */
      public com.google.protobuf.ByteString
          getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        status_ = getDefaultInstance().getStatus();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The bytes for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time lastUpdateTime_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastUpdateTimeBuilder_;
      /**
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       * @return Whether the lastUpdateTime field is set.
       */
      public boolean hasLastUpdateTime() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       * @return The lastUpdateTime.
       */
      public io.kubernetes.client.proto.Meta.Time getLastUpdateTime() {
        if (lastUpdateTimeBuilder_ == null) {
          return lastUpdateTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastUpdateTime_;
        } else {
          return lastUpdateTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public Builder setLastUpdateTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastUpdateTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastUpdateTime_ = value;
        } else {
          lastUpdateTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public Builder setLastUpdateTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastUpdateTimeBuilder_ == null) {
          lastUpdateTime_ = builderForValue.build();
        } else {
          lastUpdateTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public Builder mergeLastUpdateTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastUpdateTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            lastUpdateTime_ != null &&
            lastUpdateTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getLastUpdateTimeBuilder().mergeFrom(value);
          } else {
            lastUpdateTime_ = value;
          }
        } else {
          lastUpdateTimeBuilder_.mergeFrom(value);
        }
        if (lastUpdateTime_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public Builder clearLastUpdateTime() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lastUpdateTime_ = null;
        if (lastUpdateTimeBuilder_ != null) {
          lastUpdateTimeBuilder_.dispose();
          lastUpdateTimeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastUpdateTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastUpdateTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastUpdateTimeOrBuilder() {
        if (lastUpdateTimeBuilder_ != null) {
          return lastUpdateTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastUpdateTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastUpdateTime_;
        }
      }
      /**
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastUpdateTimeFieldBuilder() {
        if (lastUpdateTimeBuilder_ == null) {
          lastUpdateTimeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastUpdateTime(),
                  getParentForChildren(),
                  isClean());
          lastUpdateTime_ = null;
        }
        return lastUpdateTimeBuilder_;
      }

      private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastTransitionTimeBuilder_;
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       * @return Whether the lastTransitionTime field is set.
       */
      public boolean hasLastTransitionTime() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       * @return The lastTransitionTime.
       */
      public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        } else {
          return lastTransitionTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public Builder setLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastTransitionTime_ = value;
        } else {
          lastTransitionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public Builder setLastTransitionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = builderForValue.build();
        } else {
          lastTransitionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public Builder mergeLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            lastTransitionTime_ != null &&
            lastTransitionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getLastTransitionTimeBuilder().mergeFrom(value);
          } else {
            lastTransitionTime_ = value;
          }
        } else {
          lastTransitionTimeBuilder_.mergeFrom(value);
        }
        if (lastTransitionTime_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public Builder clearLastTransitionTime() {
        bitField0_ = (bitField0_ & ~0x00000008);
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastTransitionTimeBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getLastTransitionTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
        if (lastTransitionTimeBuilder_ != null) {
          return lastTransitionTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastTransitionTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        }
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastTransitionTimeFieldBuilder() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTimeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastTransitionTime(),
                  getParentForChildren(),
                  isClean());
          lastTransitionTime_ = null;
        }
        return lastTransitionTimeBuilder_;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DeploymentCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DeploymentCondition)
    private static final io.kubernetes.client.proto.V1Apps.DeploymentCondition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DeploymentCondition();
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentCondition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeploymentCondition>
        PARSER = new com.google.protobuf.AbstractParser<DeploymentCondition>() {
      @java.lang.Override
      public DeploymentCondition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeploymentCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentCondition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeploymentListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DeploymentList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.Deployment> 
        getItemsList();
    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.Deployment getItems(int index);
    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * DeploymentList is a list of Deployments.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DeploymentList}
   */
  public static final class DeploymentList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DeploymentList)
      DeploymentListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DeploymentList.class.getName());
    }
    // Use DeploymentList.newBuilder() to construct.
    private DeploymentList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DeploymentList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DeploymentList.class, io.kubernetes.client.proto.V1Apps.DeploymentList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Apps.Deployment> items_;
    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Apps.Deployment> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.Deployment getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DeploymentList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DeploymentList other = (io.kubernetes.client.proto.V1Apps.DeploymentList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DeploymentList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DeploymentList is a list of Deployments.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DeploymentList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DeploymentList)
        io.kubernetes.client.proto.V1Apps.DeploymentListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DeploymentList.class, io.kubernetes.client.proto.V1Apps.DeploymentList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DeploymentList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DeploymentList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentList build() {
        io.kubernetes.client.proto.V1Apps.DeploymentList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentList buildPartial() {
        io.kubernetes.client.proto.V1Apps.DeploymentList result = new io.kubernetes.client.proto.V1Apps.DeploymentList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.DeploymentList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DeploymentList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DeploymentList) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DeploymentList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DeploymentList other) {
        if (other == io.kubernetes.client.proto.V1Apps.DeploymentList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Apps.Deployment m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Apps.Deployment.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.Deployment> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.Deployment>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.Deployment, io.kubernetes.client.proto.V1Apps.Deployment.Builder, io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.Deployment> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.Deployment getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.Deployment value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.Deployment.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Apps.Deployment value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.Deployment value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Apps.Deployment.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.Deployment.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.Deployment> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.Deployment.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.Deployment.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.Deployment.getDefaultInstance());
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.Deployment.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.Deployment.getDefaultInstance());
      }
      /**
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.Deployment items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.Deployment.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.Deployment, io.kubernetes.client.proto.V1Apps.Deployment.Builder, io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Apps.Deployment, io.kubernetes.client.proto.V1Apps.Deployment.Builder, io.kubernetes.client.proto.V1Apps.DeploymentOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DeploymentList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DeploymentList)
    private static final io.kubernetes.client.proto.V1Apps.DeploymentList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DeploymentList();
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeploymentList>
        PARSER = new com.google.protobuf.AbstractParser<DeploymentList>() {
      @java.lang.Override
      public DeploymentList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeploymentList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeploymentSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DeploymentSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Number of desired pods. This is a pointer to distinguish between explicit
     * zero and not specified. Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return Whether the replicas field is set.
     */
    boolean hasReplicas();
    /**
     * <pre>
     * Number of desired pods. This is a pointer to distinguish between explicit
     * zero and not specified. Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return The replicas.
     */
    int getReplicas();

    /**
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * It must match the pod template's labels.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return Whether the selector field is set.
     */
    boolean hasSelector();
    /**
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * It must match the pod template's labels.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return The selector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * It must match the pod template's labels.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     * <pre>
     * Template describes the pods that will be created.
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return Whether the template field is set.
     */
    boolean hasTemplate();
    /**
     * <pre>
     * Template describes the pods that will be created.
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return The template.
     */
    io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate();
    /**
     * <pre>
     * Template describes the pods that will be created.
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder();

    /**
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
     * @return Whether the strategy field is set.
     */
    boolean hasStrategy();
    /**
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
     * @return The strategy.
     */
    io.kubernetes.client.proto.V1Apps.DeploymentStrategy getStrategy();
    /**
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
     */
    io.kubernetes.client.proto.V1Apps.DeploymentStrategyOrBuilder getStrategyOrBuilder();

    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 5;</code>
     * @return Whether the minReadySeconds field is set.
     */
    boolean hasMinReadySeconds();
    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 5;</code>
     * @return The minReadySeconds.
     */
    int getMinReadySeconds();

    /**
     * <pre>
     * The number of old ReplicaSets to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     * @return Whether the revisionHistoryLimit field is set.
     */
    boolean hasRevisionHistoryLimit();
    /**
     * <pre>
     * The number of old ReplicaSets to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     * @return The revisionHistoryLimit.
     */
    int getRevisionHistoryLimit();

    /**
     * <pre>
     * Indicates that the deployment is paused.
     * +optional
     * </pre>
     *
     * <code>optional bool paused = 7;</code>
     * @return Whether the paused field is set.
     */
    boolean hasPaused();
    /**
     * <pre>
     * Indicates that the deployment is paused.
     * +optional
     * </pre>
     *
     * <code>optional bool paused = 7;</code>
     * @return The paused.
     */
    boolean getPaused();

    /**
     * <pre>
     * The maximum time in seconds for a deployment to make progress before it
     * is considered to be failed. The deployment controller will continue to
     * process failed deployments and a condition with a ProgressDeadlineExceeded
     * reason will be surfaced in the deployment status. Note that progress will
     * not be estimated during the time a deployment is paused. Defaults to 600s.
     * </pre>
     *
     * <code>optional int32 progressDeadlineSeconds = 9;</code>
     * @return Whether the progressDeadlineSeconds field is set.
     */
    boolean hasProgressDeadlineSeconds();
    /**
     * <pre>
     * The maximum time in seconds for a deployment to make progress before it
     * is considered to be failed. The deployment controller will continue to
     * process failed deployments and a condition with a ProgressDeadlineExceeded
     * reason will be surfaced in the deployment status. Note that progress will
     * not be estimated during the time a deployment is paused. Defaults to 600s.
     * </pre>
     *
     * <code>optional int32 progressDeadlineSeconds = 9;</code>
     * @return The progressDeadlineSeconds.
     */
    int getProgressDeadlineSeconds();
  }
  /**
   * <pre>
   * DeploymentSpec is the specification of the desired behavior of the Deployment.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DeploymentSpec}
   */
  public static final class DeploymentSpec extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DeploymentSpec)
      DeploymentSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DeploymentSpec.class.getName());
    }
    // Use DeploymentSpec.newBuilder() to construct.
    private DeploymentSpec(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DeploymentSpec() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DeploymentSpec.class, io.kubernetes.client.proto.V1Apps.DeploymentSpec.Builder.class);
    }

    private int bitField0_;
    public static final int REPLICAS_FIELD_NUMBER = 1;
    private int replicas_ = 0;
    /**
     * <pre>
     * Number of desired pods. This is a pointer to distinguish between explicit
     * zero and not specified. Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return Whether the replicas field is set.
     */
    @java.lang.Override
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Number of desired pods. This is a pointer to distinguish between explicit
     * zero and not specified. Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return The replicas.
     */
    @java.lang.Override
    public int getReplicas() {
      return replicas_;
    }

    public static final int SELECTOR_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * It must match the pod template's labels.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return Whether the selector field is set.
     */
    @java.lang.Override
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * It must match the pod template's labels.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return The selector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }
    /**
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * It must match the pod template's labels.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }

    public static final int TEMPLATE_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
    /**
     * <pre>
     * Template describes the pods that will be created.
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return Whether the template field is set.
     */
    @java.lang.Override
    public boolean hasTemplate() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Template describes the pods that will be created.
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return The template.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }
    /**
     * <pre>
     * Template describes the pods that will be created.
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }

    public static final int STRATEGY_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.V1Apps.DeploymentStrategy strategy_;
    /**
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
     * @return Whether the strategy field is set.
     */
    @java.lang.Override
    public boolean hasStrategy() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
     * @return The strategy.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentStrategy getStrategy() {
      return strategy_ == null ? io.kubernetes.client.proto.V1Apps.DeploymentStrategy.getDefaultInstance() : strategy_;
    }
    /**
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentStrategyOrBuilder getStrategyOrBuilder() {
      return strategy_ == null ? io.kubernetes.client.proto.V1Apps.DeploymentStrategy.getDefaultInstance() : strategy_;
    }

    public static final int MINREADYSECONDS_FIELD_NUMBER = 5;
    private int minReadySeconds_ = 0;
    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 5;</code>
     * @return Whether the minReadySeconds field is set.
     */
    @java.lang.Override
    public boolean hasMinReadySeconds() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 5;</code>
     * @return The minReadySeconds.
     */
    @java.lang.Override
    public int getMinReadySeconds() {
      return minReadySeconds_;
    }

    public static final int REVISIONHISTORYLIMIT_FIELD_NUMBER = 6;
    private int revisionHistoryLimit_ = 0;
    /**
     * <pre>
     * The number of old ReplicaSets to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     * @return Whether the revisionHistoryLimit field is set.
     */
    @java.lang.Override
    public boolean hasRevisionHistoryLimit() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The number of old ReplicaSets to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     * @return The revisionHistoryLimit.
     */
    @java.lang.Override
    public int getRevisionHistoryLimit() {
      return revisionHistoryLimit_;
    }

    public static final int PAUSED_FIELD_NUMBER = 7;
    private boolean paused_ = false;
    /**
     * <pre>
     * Indicates that the deployment is paused.
     * +optional
     * </pre>
     *
     * <code>optional bool paused = 7;</code>
     * @return Whether the paused field is set.
     */
    @java.lang.Override
    public boolean hasPaused() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Indicates that the deployment is paused.
     * +optional
     * </pre>
     *
     * <code>optional bool paused = 7;</code>
     * @return The paused.
     */
    @java.lang.Override
    public boolean getPaused() {
      return paused_;
    }

    public static final int PROGRESSDEADLINESECONDS_FIELD_NUMBER = 9;
    private int progressDeadlineSeconds_ = 0;
    /**
     * <pre>
     * The maximum time in seconds for a deployment to make progress before it
     * is considered to be failed. The deployment controller will continue to
     * process failed deployments and a condition with a ProgressDeadlineExceeded
     * reason will be surfaced in the deployment status. Note that progress will
     * not be estimated during the time a deployment is paused. Defaults to 600s.
     * </pre>
     *
     * <code>optional int32 progressDeadlineSeconds = 9;</code>
     * @return Whether the progressDeadlineSeconds field is set.
     */
    @java.lang.Override
    public boolean hasProgressDeadlineSeconds() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The maximum time in seconds for a deployment to make progress before it
     * is considered to be failed. The deployment controller will continue to
     * process failed deployments and a condition with a ProgressDeadlineExceeded
     * reason will be surfaced in the deployment status. Note that progress will
     * not be estimated during the time a deployment is paused. Defaults to 600s.
     * </pre>
     *
     * <code>optional int32 progressDeadlineSeconds = 9;</code>
     * @return The progressDeadlineSeconds.
     */
    @java.lang.Override
    public int getProgressDeadlineSeconds() {
      return progressDeadlineSeconds_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSelector());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getTemplate());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getStrategy());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt32(5, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeInt32(6, revisionHistoryLimit_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(7, paused_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt32(9, progressDeadlineSeconds_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSelector());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getTemplate());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getStrategy());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, revisionHistoryLimit_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, paused_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, progressDeadlineSeconds_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DeploymentSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DeploymentSpec other = (io.kubernetes.client.proto.V1Apps.DeploymentSpec) obj;

      if (hasReplicas() != other.hasReplicas()) return false;
      if (hasReplicas()) {
        if (getReplicas()
            != other.getReplicas()) return false;
      }
      if (hasSelector() != other.hasSelector()) return false;
      if (hasSelector()) {
        if (!getSelector()
            .equals(other.getSelector())) return false;
      }
      if (hasTemplate() != other.hasTemplate()) return false;
      if (hasTemplate()) {
        if (!getTemplate()
            .equals(other.getTemplate())) return false;
      }
      if (hasStrategy() != other.hasStrategy()) return false;
      if (hasStrategy()) {
        if (!getStrategy()
            .equals(other.getStrategy())) return false;
      }
      if (hasMinReadySeconds() != other.hasMinReadySeconds()) return false;
      if (hasMinReadySeconds()) {
        if (getMinReadySeconds()
            != other.getMinReadySeconds()) return false;
      }
      if (hasRevisionHistoryLimit() != other.hasRevisionHistoryLimit()) return false;
      if (hasRevisionHistoryLimit()) {
        if (getRevisionHistoryLimit()
            != other.getRevisionHistoryLimit()) return false;
      }
      if (hasPaused() != other.hasPaused()) return false;
      if (hasPaused()) {
        if (getPaused()
            != other.getPaused()) return false;
      }
      if (hasProgressDeadlineSeconds() != other.hasProgressDeadlineSeconds()) return false;
      if (hasProgressDeadlineSeconds()) {
        if (getProgressDeadlineSeconds()
            != other.getProgressDeadlineSeconds()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasTemplate()) {
        hash = (37 * hash) + TEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplate().hashCode();
      }
      if (hasStrategy()) {
        hash = (37 * hash) + STRATEGY_FIELD_NUMBER;
        hash = (53 * hash) + getStrategy().hashCode();
      }
      if (hasMinReadySeconds()) {
        hash = (37 * hash) + MINREADYSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getMinReadySeconds();
      }
      if (hasRevisionHistoryLimit()) {
        hash = (37 * hash) + REVISIONHISTORYLIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getRevisionHistoryLimit();
      }
      if (hasPaused()) {
        hash = (37 * hash) + PAUSED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPaused());
      }
      if (hasProgressDeadlineSeconds()) {
        hash = (37 * hash) + PROGRESSDEADLINESECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getProgressDeadlineSeconds();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DeploymentSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DeploymentSpec is the specification of the desired behavior of the Deployment.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DeploymentSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DeploymentSpec)
        io.kubernetes.client.proto.V1Apps.DeploymentSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DeploymentSpec.class, io.kubernetes.client.proto.V1Apps.DeploymentSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DeploymentSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
          getTemplateFieldBuilder();
          getStrategyFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        replicas_ = 0;
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        template_ = null;
        if (templateBuilder_ != null) {
          templateBuilder_.dispose();
          templateBuilder_ = null;
        }
        strategy_ = null;
        if (strategyBuilder_ != null) {
          strategyBuilder_.dispose();
          strategyBuilder_ = null;
        }
        minReadySeconds_ = 0;
        revisionHistoryLimit_ = 0;
        paused_ = false;
        progressDeadlineSeconds_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DeploymentSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentSpec build() {
        io.kubernetes.client.proto.V1Apps.DeploymentSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentSpec buildPartial() {
        io.kubernetes.client.proto.V1Apps.DeploymentSpec result = new io.kubernetes.client.proto.V1Apps.DeploymentSpec(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DeploymentSpec result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.replicas_ = replicas_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.selector_ = selectorBuilder_ == null
              ? selector_
              : selectorBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.template_ = templateBuilder_ == null
              ? template_
              : templateBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.strategy_ = strategyBuilder_ == null
              ? strategy_
              : strategyBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.minReadySeconds_ = minReadySeconds_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.revisionHistoryLimit_ = revisionHistoryLimit_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.paused_ = paused_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.progressDeadlineSeconds_ = progressDeadlineSeconds_;
          to_bitField0_ |= 0x00000080;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DeploymentSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DeploymentSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DeploymentSpec other) {
        if (other == io.kubernetes.client.proto.V1Apps.DeploymentSpec.getDefaultInstance()) return this;
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasTemplate()) {
          mergeTemplate(other.getTemplate());
        }
        if (other.hasStrategy()) {
          mergeStrategy(other.getStrategy());
        }
        if (other.hasMinReadySeconds()) {
          setMinReadySeconds(other.getMinReadySeconds());
        }
        if (other.hasRevisionHistoryLimit()) {
          setRevisionHistoryLimit(other.getRevisionHistoryLimit());
        }
        if (other.hasPaused()) {
          setPaused(other.getPaused());
        }
        if (other.hasProgressDeadlineSeconds()) {
          setProgressDeadlineSeconds(other.getProgressDeadlineSeconds());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                replicas_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                input.readMessage(
                    getSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getTemplateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getStrategyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 40: {
                minReadySeconds_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                revisionHistoryLimit_ = input.readInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 56: {
                paused_ = input.readBool();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 72: {
                progressDeadlineSeconds_ = input.readInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 72
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int replicas_ ;
      /**
       * <pre>
       * Number of desired pods. This is a pointer to distinguish between explicit
       * zero and not specified. Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return Whether the replicas field is set.
       */
      @java.lang.Override
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Number of desired pods. This is a pointer to distinguish between explicit
       * zero and not specified. Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return The replicas.
       */
      @java.lang.Override
      public int getReplicas() {
        return replicas_;
      }
      /**
       * <pre>
       * Number of desired pods. This is a pointer to distinguish between explicit
       * zero and not specified. Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @param value The replicas to set.
       * @return This builder for chaining.
       */
      public Builder setReplicas(int value) {

        replicas_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of desired pods. This is a pointer to distinguish between explicit
       * zero and not specified. Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector selector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> selectorBuilder_;
      /**
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       * @return Whether the selector field is set.
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       * @return The selector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            selector_ != null &&
            selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getSelectorBuilder().mergeFrom(value);
          } else {
            selector_ = value;
          }
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        if (selector_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder clearSelector() {
        bitField0_ = (bitField0_ & ~0x00000002);
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        }
      }
      /**
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(),
                  getParentForChildren(),
                  isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> templateBuilder_;
      /**
       * <pre>
       * Template describes the pods that will be created.
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       * @return Whether the template field is set.
       */
      public boolean hasTemplate() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Template describes the pods that will be created.
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       * @return The template.
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
        if (templateBuilder_ == null) {
          return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        } else {
          return templateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Template describes the pods that will be created.
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          template_ = value;
        } else {
          templateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Template describes the pods that will be created.
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(
          io.kubernetes.client.proto.V1.PodTemplateSpec.Builder builderForValue) {
        if (templateBuilder_ == null) {
          template_ = builderForValue.build();
        } else {
          templateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Template describes the pods that will be created.
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder mergeTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            template_ != null &&
            template_ != io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()) {
            getTemplateBuilder().mergeFrom(value);
          } else {
            template_ = value;
          }
        } else {
          templateBuilder_.mergeFrom(value);
        }
        if (template_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Template describes the pods that will be created.
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder clearTemplate() {
        bitField0_ = (bitField0_ & ~0x00000004);
        template_ = null;
        if (templateBuilder_ != null) {
          templateBuilder_.dispose();
          templateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Template describes the pods that will be created.
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec.Builder getTemplateBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getTemplateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Template describes the pods that will be created.
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
        if (templateBuilder_ != null) {
          return templateBuilder_.getMessageOrBuilder();
        } else {
          return template_ == null ?
              io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        }
      }
      /**
       * <pre>
       * Template describes the pods that will be created.
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> 
          getTemplateFieldBuilder() {
        if (templateBuilder_ == null) {
          templateBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>(
                  getTemplate(),
                  getParentForChildren(),
                  isClean());
          template_ = null;
        }
        return templateBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.DeploymentStrategy strategy_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DeploymentStrategy, io.kubernetes.client.proto.V1Apps.DeploymentStrategy.Builder, io.kubernetes.client.proto.V1Apps.DeploymentStrategyOrBuilder> strategyBuilder_;
      /**
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
       * @return Whether the strategy field is set.
       */
      public boolean hasStrategy() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
       * @return The strategy.
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentStrategy getStrategy() {
        if (strategyBuilder_ == null) {
          return strategy_ == null ? io.kubernetes.client.proto.V1Apps.DeploymentStrategy.getDefaultInstance() : strategy_;
        } else {
          return strategyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
       */
      public Builder setStrategy(io.kubernetes.client.proto.V1Apps.DeploymentStrategy value) {
        if (strategyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          strategy_ = value;
        } else {
          strategyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
       */
      public Builder setStrategy(
          io.kubernetes.client.proto.V1Apps.DeploymentStrategy.Builder builderForValue) {
        if (strategyBuilder_ == null) {
          strategy_ = builderForValue.build();
        } else {
          strategyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
       */
      public Builder mergeStrategy(io.kubernetes.client.proto.V1Apps.DeploymentStrategy value) {
        if (strategyBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            strategy_ != null &&
            strategy_ != io.kubernetes.client.proto.V1Apps.DeploymentStrategy.getDefaultInstance()) {
            getStrategyBuilder().mergeFrom(value);
          } else {
            strategy_ = value;
          }
        } else {
          strategyBuilder_.mergeFrom(value);
        }
        if (strategy_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
       */
      public Builder clearStrategy() {
        bitField0_ = (bitField0_ & ~0x00000008);
        strategy_ = null;
        if (strategyBuilder_ != null) {
          strategyBuilder_.dispose();
          strategyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentStrategy.Builder getStrategyBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getStrategyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentStrategyOrBuilder getStrategyOrBuilder() {
        if (strategyBuilder_ != null) {
          return strategyBuilder_.getMessageOrBuilder();
        } else {
          return strategy_ == null ?
              io.kubernetes.client.proto.V1Apps.DeploymentStrategy.getDefaultInstance() : strategy_;
        }
      }
      /**
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DeploymentStrategy strategy = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DeploymentStrategy, io.kubernetes.client.proto.V1Apps.DeploymentStrategy.Builder, io.kubernetes.client.proto.V1Apps.DeploymentStrategyOrBuilder> 
          getStrategyFieldBuilder() {
        if (strategyBuilder_ == null) {
          strategyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.DeploymentStrategy, io.kubernetes.client.proto.V1Apps.DeploymentStrategy.Builder, io.kubernetes.client.proto.V1Apps.DeploymentStrategyOrBuilder>(
                  getStrategy(),
                  getParentForChildren(),
                  isClean());
          strategy_ = null;
        }
        return strategyBuilder_;
      }

      private int minReadySeconds_ ;
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 5;</code>
       * @return Whether the minReadySeconds field is set.
       */
      @java.lang.Override
      public boolean hasMinReadySeconds() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 5;</code>
       * @return The minReadySeconds.
       */
      @java.lang.Override
      public int getMinReadySeconds() {
        return minReadySeconds_;
      }
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 5;</code>
       * @param value The minReadySeconds to set.
       * @return This builder for chaining.
       */
      public Builder setMinReadySeconds(int value) {

        minReadySeconds_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinReadySeconds() {
        bitField0_ = (bitField0_ & ~0x00000010);
        minReadySeconds_ = 0;
        onChanged();
        return this;
      }

      private int revisionHistoryLimit_ ;
      /**
       * <pre>
       * The number of old ReplicaSets to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       * @return Whether the revisionHistoryLimit field is set.
       */
      @java.lang.Override
      public boolean hasRevisionHistoryLimit() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The number of old ReplicaSets to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       * @return The revisionHistoryLimit.
       */
      @java.lang.Override
      public int getRevisionHistoryLimit() {
        return revisionHistoryLimit_;
      }
      /**
       * <pre>
       * The number of old ReplicaSets to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       * @param value The revisionHistoryLimit to set.
       * @return This builder for chaining.
       */
      public Builder setRevisionHistoryLimit(int value) {

        revisionHistoryLimit_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of old ReplicaSets to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearRevisionHistoryLimit() {
        bitField0_ = (bitField0_ & ~0x00000020);
        revisionHistoryLimit_ = 0;
        onChanged();
        return this;
      }

      private boolean paused_ ;
      /**
       * <pre>
       * Indicates that the deployment is paused.
       * +optional
       * </pre>
       *
       * <code>optional bool paused = 7;</code>
       * @return Whether the paused field is set.
       */
      @java.lang.Override
      public boolean hasPaused() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Indicates that the deployment is paused.
       * +optional
       * </pre>
       *
       * <code>optional bool paused = 7;</code>
       * @return The paused.
       */
      @java.lang.Override
      public boolean getPaused() {
        return paused_;
      }
      /**
       * <pre>
       * Indicates that the deployment is paused.
       * +optional
       * </pre>
       *
       * <code>optional bool paused = 7;</code>
       * @param value The paused to set.
       * @return This builder for chaining.
       */
      public Builder setPaused(boolean value) {

        paused_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates that the deployment is paused.
       * +optional
       * </pre>
       *
       * <code>optional bool paused = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaused() {
        bitField0_ = (bitField0_ & ~0x00000040);
        paused_ = false;
        onChanged();
        return this;
      }

      private int progressDeadlineSeconds_ ;
      /**
       * <pre>
       * The maximum time in seconds for a deployment to make progress before it
       * is considered to be failed. The deployment controller will continue to
       * process failed deployments and a condition with a ProgressDeadlineExceeded
       * reason will be surfaced in the deployment status. Note that progress will
       * not be estimated during the time a deployment is paused. Defaults to 600s.
       * </pre>
       *
       * <code>optional int32 progressDeadlineSeconds = 9;</code>
       * @return Whether the progressDeadlineSeconds field is set.
       */
      @java.lang.Override
      public boolean hasProgressDeadlineSeconds() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * The maximum time in seconds for a deployment to make progress before it
       * is considered to be failed. The deployment controller will continue to
       * process failed deployments and a condition with a ProgressDeadlineExceeded
       * reason will be surfaced in the deployment status. Note that progress will
       * not be estimated during the time a deployment is paused. Defaults to 600s.
       * </pre>
       *
       * <code>optional int32 progressDeadlineSeconds = 9;</code>
       * @return The progressDeadlineSeconds.
       */
      @java.lang.Override
      public int getProgressDeadlineSeconds() {
        return progressDeadlineSeconds_;
      }
      /**
       * <pre>
       * The maximum time in seconds for a deployment to make progress before it
       * is considered to be failed. The deployment controller will continue to
       * process failed deployments and a condition with a ProgressDeadlineExceeded
       * reason will be surfaced in the deployment status. Note that progress will
       * not be estimated during the time a deployment is paused. Defaults to 600s.
       * </pre>
       *
       * <code>optional int32 progressDeadlineSeconds = 9;</code>
       * @param value The progressDeadlineSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setProgressDeadlineSeconds(int value) {

        progressDeadlineSeconds_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum time in seconds for a deployment to make progress before it
       * is considered to be failed. The deployment controller will continue to
       * process failed deployments and a condition with a ProgressDeadlineExceeded
       * reason will be surfaced in the deployment status. Note that progress will
       * not be estimated during the time a deployment is paused. Defaults to 600s.
       * </pre>
       *
       * <code>optional int32 progressDeadlineSeconds = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearProgressDeadlineSeconds() {
        bitField0_ = (bitField0_ & ~0x00000080);
        progressDeadlineSeconds_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DeploymentSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DeploymentSpec)
    private static final io.kubernetes.client.proto.V1Apps.DeploymentSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DeploymentSpec();
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeploymentSpec>
        PARSER = new com.google.protobuf.AbstractParser<DeploymentSpec>() {
      @java.lang.Override
      public DeploymentSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeploymentSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeploymentStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DeploymentStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The generation observed by the deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return Whether the observedGeneration field is set.
     */
    boolean hasObservedGeneration();
    /**
     * <pre>
     * The generation observed by the deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return The observedGeneration.
     */
    long getObservedGeneration();

    /**
     * <pre>
     * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     * @return Whether the replicas field is set.
     */
    boolean hasReplicas();
    /**
     * <pre>
     * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     * @return The replicas.
     */
    int getReplicas();

    /**
     * <pre>
     * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 3;</code>
     * @return Whether the updatedReplicas field is set.
     */
    boolean hasUpdatedReplicas();
    /**
     * <pre>
     * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 3;</code>
     * @return The updatedReplicas.
     */
    int getUpdatedReplicas();

    /**
     * <pre>
     * readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 7;</code>
     * @return Whether the readyReplicas field is set.
     */
    boolean hasReadyReplicas();
    /**
     * <pre>
     * readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 7;</code>
     * @return The readyReplicas.
     */
    int getReadyReplicas();

    /**
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 4;</code>
     * @return Whether the availableReplicas field is set.
     */
    boolean hasAvailableReplicas();
    /**
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 4;</code>
     * @return The availableReplicas.
     */
    int getAvailableReplicas();

    /**
     * <pre>
     * Total number of unavailable pods targeted by this deployment. This is the total number of
     * pods that are still required for the deployment to have 100% available capacity. They may
     * either be pods that are running but not yet available or pods that still have not been created.
     * +optional
     * </pre>
     *
     * <code>optional int32 unavailableReplicas = 5;</code>
     * @return Whether the unavailableReplicas field is set.
     */
    boolean hasUnavailableReplicas();
    /**
     * <pre>
     * Total number of unavailable pods targeted by this deployment. This is the total number of
     * pods that are still required for the deployment to have 100% available capacity. They may
     * either be pods that are running but not yet available or pods that still have not been created.
     * +optional
     * </pre>
     *
     * <code>optional int32 unavailableReplicas = 5;</code>
     * @return The unavailableReplicas.
     */
    int getUnavailableReplicas();

    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.DeploymentCondition> 
        getConditionsList();
    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    io.kubernetes.client.proto.V1Apps.DeploymentCondition getConditions(int index);
    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    int getConditionsCount();
    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder> 
        getConditionsOrBuilderList();
    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder getConditionsOrBuilder(
        int index);

    /**
     * <pre>
     * Count of hash collisions for the Deployment. The Deployment controller uses this
     * field as a collision avoidance mechanism when it needs to create the name for the
     * newest ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 8;</code>
     * @return Whether the collisionCount field is set.
     */
    boolean hasCollisionCount();
    /**
     * <pre>
     * Count of hash collisions for the Deployment. The Deployment controller uses this
     * field as a collision avoidance mechanism when it needs to create the name for the
     * newest ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 8;</code>
     * @return The collisionCount.
     */
    int getCollisionCount();
  }
  /**
   * <pre>
   * DeploymentStatus is the most recently observed status of the Deployment.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DeploymentStatus}
   */
  public static final class DeploymentStatus extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DeploymentStatus)
      DeploymentStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DeploymentStatus.class.getName());
    }
    // Use DeploymentStatus.newBuilder() to construct.
    private DeploymentStatus(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DeploymentStatus() {
      conditions_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DeploymentStatus.class, io.kubernetes.client.proto.V1Apps.DeploymentStatus.Builder.class);
    }

    private int bitField0_;
    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 1;
    private long observedGeneration_ = 0L;
    /**
     * <pre>
     * The generation observed by the deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return Whether the observedGeneration field is set.
     */
    @java.lang.Override
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The generation observed by the deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return The observedGeneration.
     */
    @java.lang.Override
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int REPLICAS_FIELD_NUMBER = 2;
    private int replicas_ = 0;
    /**
     * <pre>
     * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     * @return Whether the replicas field is set.
     */
    @java.lang.Override
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     * @return The replicas.
     */
    @java.lang.Override
    public int getReplicas() {
      return replicas_;
    }

    public static final int UPDATEDREPLICAS_FIELD_NUMBER = 3;
    private int updatedReplicas_ = 0;
    /**
     * <pre>
     * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 3;</code>
     * @return Whether the updatedReplicas field is set.
     */
    @java.lang.Override
    public boolean hasUpdatedReplicas() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 3;</code>
     * @return The updatedReplicas.
     */
    @java.lang.Override
    public int getUpdatedReplicas() {
      return updatedReplicas_;
    }

    public static final int READYREPLICAS_FIELD_NUMBER = 7;
    private int readyReplicas_ = 0;
    /**
     * <pre>
     * readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 7;</code>
     * @return Whether the readyReplicas field is set.
     */
    @java.lang.Override
    public boolean hasReadyReplicas() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 7;</code>
     * @return The readyReplicas.
     */
    @java.lang.Override
    public int getReadyReplicas() {
      return readyReplicas_;
    }

    public static final int AVAILABLEREPLICAS_FIELD_NUMBER = 4;
    private int availableReplicas_ = 0;
    /**
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 4;</code>
     * @return Whether the availableReplicas field is set.
     */
    @java.lang.Override
    public boolean hasAvailableReplicas() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 4;</code>
     * @return The availableReplicas.
     */
    @java.lang.Override
    public int getAvailableReplicas() {
      return availableReplicas_;
    }

    public static final int UNAVAILABLEREPLICAS_FIELD_NUMBER = 5;
    private int unavailableReplicas_ = 0;
    /**
     * <pre>
     * Total number of unavailable pods targeted by this deployment. This is the total number of
     * pods that are still required for the deployment to have 100% available capacity. They may
     * either be pods that are running but not yet available or pods that still have not been created.
     * +optional
     * </pre>
     *
     * <code>optional int32 unavailableReplicas = 5;</code>
     * @return Whether the unavailableReplicas field is set.
     */
    @java.lang.Override
    public boolean hasUnavailableReplicas() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Total number of unavailable pods targeted by this deployment. This is the total number of
     * pods that are still required for the deployment to have 100% available capacity. They may
     * either be pods that are running but not yet available or pods that still have not been created.
     * +optional
     * </pre>
     *
     * <code>optional int32 unavailableReplicas = 5;</code>
     * @return The unavailableReplicas.
     */
    @java.lang.Override
    public int getUnavailableReplicas() {
      return unavailableReplicas_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Apps.DeploymentCondition> conditions_;
    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Apps.DeploymentCondition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    @java.lang.Override
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentCondition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }

    public static final int COLLISIONCOUNT_FIELD_NUMBER = 8;
    private int collisionCount_ = 0;
    /**
     * <pre>
     * Count of hash collisions for the Deployment. The Deployment controller uses this
     * field as a collision avoidance mechanism when it needs to create the name for the
     * newest ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 8;</code>
     * @return Whether the collisionCount field is set.
     */
    @java.lang.Override
    public boolean hasCollisionCount() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Count of hash collisions for the Deployment. The Deployment controller uses this
     * field as a collision avoidance mechanism when it needs to create the name for the
     * newest ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 8;</code>
     * @return The collisionCount.
     */
    @java.lang.Override
    public int getCollisionCount() {
      return collisionCount_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, replicas_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt32(3, updatedReplicas_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt32(4, availableReplicas_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeInt32(5, unavailableReplicas_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(6, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(7, readyReplicas_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeInt32(8, collisionCount_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, replicas_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, updatedReplicas_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, availableReplicas_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, unavailableReplicas_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, readyReplicas_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, collisionCount_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DeploymentStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DeploymentStatus other = (io.kubernetes.client.proto.V1Apps.DeploymentStatus) obj;

      if (hasObservedGeneration() != other.hasObservedGeneration()) return false;
      if (hasObservedGeneration()) {
        if (getObservedGeneration()
            != other.getObservedGeneration()) return false;
      }
      if (hasReplicas() != other.hasReplicas()) return false;
      if (hasReplicas()) {
        if (getReplicas()
            != other.getReplicas()) return false;
      }
      if (hasUpdatedReplicas() != other.hasUpdatedReplicas()) return false;
      if (hasUpdatedReplicas()) {
        if (getUpdatedReplicas()
            != other.getUpdatedReplicas()) return false;
      }
      if (hasReadyReplicas() != other.hasReadyReplicas()) return false;
      if (hasReadyReplicas()) {
        if (getReadyReplicas()
            != other.getReadyReplicas()) return false;
      }
      if (hasAvailableReplicas() != other.hasAvailableReplicas()) return false;
      if (hasAvailableReplicas()) {
        if (getAvailableReplicas()
            != other.getAvailableReplicas()) return false;
      }
      if (hasUnavailableReplicas() != other.hasUnavailableReplicas()) return false;
      if (hasUnavailableReplicas()) {
        if (getUnavailableReplicas()
            != other.getUnavailableReplicas()) return false;
      }
      if (!getConditionsList()
          .equals(other.getConditionsList())) return false;
      if (hasCollisionCount() != other.hasCollisionCount()) return false;
      if (hasCollisionCount()) {
        if (getCollisionCount()
            != other.getCollisionCount()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getObservedGeneration());
      }
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasUpdatedReplicas()) {
        hash = (37 * hash) + UPDATEDREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getUpdatedReplicas();
      }
      if (hasReadyReplicas()) {
        hash = (37 * hash) + READYREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReadyReplicas();
      }
      if (hasAvailableReplicas()) {
        hash = (37 * hash) + AVAILABLEREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getAvailableReplicas();
      }
      if (hasUnavailableReplicas()) {
        hash = (37 * hash) + UNAVAILABLEREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getUnavailableReplicas();
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      if (hasCollisionCount()) {
        hash = (37 * hash) + COLLISIONCOUNT_FIELD_NUMBER;
        hash = (53 * hash) + getCollisionCount();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DeploymentStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DeploymentStatus is the most recently observed status of the Deployment.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DeploymentStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DeploymentStatus)
        io.kubernetes.client.proto.V1Apps.DeploymentStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DeploymentStatus.class, io.kubernetes.client.proto.V1Apps.DeploymentStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DeploymentStatus.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        observedGeneration_ = 0L;
        replicas_ = 0;
        updatedReplicas_ = 0;
        readyReplicas_ = 0;
        availableReplicas_ = 0;
        unavailableReplicas_ = 0;
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
        } else {
          conditions_ = null;
          conditionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        collisionCount_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DeploymentStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentStatus build() {
        io.kubernetes.client.proto.V1Apps.DeploymentStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentStatus buildPartial() {
        io.kubernetes.client.proto.V1Apps.DeploymentStatus result = new io.kubernetes.client.proto.V1Apps.DeploymentStatus(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.DeploymentStatus result) {
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DeploymentStatus result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.observedGeneration_ = observedGeneration_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.replicas_ = replicas_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.updatedReplicas_ = updatedReplicas_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.readyReplicas_ = readyReplicas_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.availableReplicas_ = availableReplicas_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.unavailableReplicas_ = unavailableReplicas_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.collisionCount_ = collisionCount_;
          to_bitField0_ |= 0x00000040;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DeploymentStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DeploymentStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DeploymentStatus other) {
        if (other == io.kubernetes.client.proto.V1Apps.DeploymentStatus.getDefaultInstance()) return this;
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasUpdatedReplicas()) {
          setUpdatedReplicas(other.getUpdatedReplicas());
        }
        if (other.hasReadyReplicas()) {
          setReadyReplicas(other.getReadyReplicas());
        }
        if (other.hasAvailableReplicas()) {
          setAvailableReplicas(other.getAvailableReplicas());
        }
        if (other.hasUnavailableReplicas()) {
          setUnavailableReplicas(other.getUnavailableReplicas());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000040);
              conditionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getConditionsFieldBuilder() : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        if (other.hasCollisionCount()) {
          setCollisionCount(other.getCollisionCount());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                observedGeneration_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                replicas_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                updatedReplicas_ = input.readInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                availableReplicas_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 32
              case 40: {
                unavailableReplicas_ = input.readInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 40
              case 50: {
                io.kubernetes.client.proto.V1Apps.DeploymentCondition m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Apps.DeploymentCondition.parser(),
                        extensionRegistry);
                if (conditionsBuilder_ == null) {
                  ensureConditionsIsMutable();
                  conditions_.add(m);
                } else {
                  conditionsBuilder_.addMessage(m);
                }
                break;
              } // case 50
              case 56: {
                readyReplicas_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 56
              case 64: {
                collisionCount_ = input.readInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long observedGeneration_ ;
      /**
       * <pre>
       * The generation observed by the deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @return Whether the observedGeneration field is set.
       */
      @java.lang.Override
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The generation observed by the deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @return The observedGeneration.
       */
      @java.lang.Override
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       * <pre>
       * The generation observed by the deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @param value The observedGeneration to set.
       * @return This builder for chaining.
       */
      public Builder setObservedGeneration(long value) {

        observedGeneration_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The generation observed by the deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000001);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private int replicas_ ;
      /**
       * <pre>
       * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       * @return Whether the replicas field is set.
       */
      @java.lang.Override
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       * @return The replicas.
       */
      @java.lang.Override
      public int getReplicas() {
        return replicas_;
      }
      /**
       * <pre>
       * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       * @param value The replicas to set.
       * @return This builder for chaining.
       */
      public Builder setReplicas(int value) {

        replicas_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000002);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private int updatedReplicas_ ;
      /**
       * <pre>
       * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 3;</code>
       * @return Whether the updatedReplicas field is set.
       */
      @java.lang.Override
      public boolean hasUpdatedReplicas() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 3;</code>
       * @return The updatedReplicas.
       */
      @java.lang.Override
      public int getUpdatedReplicas() {
        return updatedReplicas_;
      }
      /**
       * <pre>
       * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 3;</code>
       * @param value The updatedReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setUpdatedReplicas(int value) {

        updatedReplicas_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpdatedReplicas() {
        bitField0_ = (bitField0_ & ~0x00000004);
        updatedReplicas_ = 0;
        onChanged();
        return this;
      }

      private int readyReplicas_ ;
      /**
       * <pre>
       * readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 7;</code>
       * @return Whether the readyReplicas field is set.
       */
      @java.lang.Override
      public boolean hasReadyReplicas() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 7;</code>
       * @return The readyReplicas.
       */
      @java.lang.Override
      public int getReadyReplicas() {
        return readyReplicas_;
      }
      /**
       * <pre>
       * readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 7;</code>
       * @param value The readyReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setReadyReplicas(int value) {

        readyReplicas_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearReadyReplicas() {
        bitField0_ = (bitField0_ & ~0x00000008);
        readyReplicas_ = 0;
        onChanged();
        return this;
      }

      private int availableReplicas_ ;
      /**
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 4;</code>
       * @return Whether the availableReplicas field is set.
       */
      @java.lang.Override
      public boolean hasAvailableReplicas() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 4;</code>
       * @return The availableReplicas.
       */
      @java.lang.Override
      public int getAvailableReplicas() {
        return availableReplicas_;
      }
      /**
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 4;</code>
       * @param value The availableReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setAvailableReplicas(int value) {

        availableReplicas_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearAvailableReplicas() {
        bitField0_ = (bitField0_ & ~0x00000010);
        availableReplicas_ = 0;
        onChanged();
        return this;
      }

      private int unavailableReplicas_ ;
      /**
       * <pre>
       * Total number of unavailable pods targeted by this deployment. This is the total number of
       * pods that are still required for the deployment to have 100% available capacity. They may
       * either be pods that are running but not yet available or pods that still have not been created.
       * +optional
       * </pre>
       *
       * <code>optional int32 unavailableReplicas = 5;</code>
       * @return Whether the unavailableReplicas field is set.
       */
      @java.lang.Override
      public boolean hasUnavailableReplicas() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Total number of unavailable pods targeted by this deployment. This is the total number of
       * pods that are still required for the deployment to have 100% available capacity. They may
       * either be pods that are running but not yet available or pods that still have not been created.
       * +optional
       * </pre>
       *
       * <code>optional int32 unavailableReplicas = 5;</code>
       * @return The unavailableReplicas.
       */
      @java.lang.Override
      public int getUnavailableReplicas() {
        return unavailableReplicas_;
      }
      /**
       * <pre>
       * Total number of unavailable pods targeted by this deployment. This is the total number of
       * pods that are still required for the deployment to have 100% available capacity. They may
       * either be pods that are running but not yet available or pods that still have not been created.
       * +optional
       * </pre>
       *
       * <code>optional int32 unavailableReplicas = 5;</code>
       * @param value The unavailableReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setUnavailableReplicas(int value) {

        unavailableReplicas_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Total number of unavailable pods targeted by this deployment. This is the total number of
       * pods that are still required for the deployment to have 100% available capacity. They may
       * either be pods that are running but not yet available or pods that still have not been created.
       * +optional
       * </pre>
       *
       * <code>optional int32 unavailableReplicas = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearUnavailableReplicas() {
        bitField0_ = (bitField0_ & ~0x00000020);
        unavailableReplicas_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.DeploymentCondition> conditions_ =
        java.util.Collections.emptyList();
      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.DeploymentCondition>(conditions_);
          bitField0_ |= 0x00000040;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DeploymentCondition, io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder, io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder> conditionsBuilder_;

      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.DeploymentCondition> getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentCondition getConditions(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Apps.DeploymentCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addConditions(io.kubernetes.client.proto.V1Apps.DeploymentCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Apps.DeploymentCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.DeploymentCondition> values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder getConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder getConditionsOrBuilder(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);  } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder> 
           getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder addConditionsBuilder() {
        return getConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.DeploymentCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder addConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.DeploymentCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DeploymentCondition conditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder> 
           getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.DeploymentCondition, io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder, io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder> 
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Apps.DeploymentCondition, io.kubernetes.client.proto.V1Apps.DeploymentCondition.Builder, io.kubernetes.client.proto.V1Apps.DeploymentConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000040) != 0),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      private int collisionCount_ ;
      /**
       * <pre>
       * Count of hash collisions for the Deployment. The Deployment controller uses this
       * field as a collision avoidance mechanism when it needs to create the name for the
       * newest ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 8;</code>
       * @return Whether the collisionCount field is set.
       */
      @java.lang.Override
      public boolean hasCollisionCount() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Count of hash collisions for the Deployment. The Deployment controller uses this
       * field as a collision avoidance mechanism when it needs to create the name for the
       * newest ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 8;</code>
       * @return The collisionCount.
       */
      @java.lang.Override
      public int getCollisionCount() {
        return collisionCount_;
      }
      /**
       * <pre>
       * Count of hash collisions for the Deployment. The Deployment controller uses this
       * field as a collision avoidance mechanism when it needs to create the name for the
       * newest ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 8;</code>
       * @param value The collisionCount to set.
       * @return This builder for chaining.
       */
      public Builder setCollisionCount(int value) {

        collisionCount_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Count of hash collisions for the Deployment. The Deployment controller uses this
       * field as a collision avoidance mechanism when it needs to create the name for the
       * newest ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearCollisionCount() {
        bitField0_ = (bitField0_ & ~0x00000080);
        collisionCount_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DeploymentStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DeploymentStatus)
    private static final io.kubernetes.client.proto.V1Apps.DeploymentStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DeploymentStatus();
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeploymentStatus>
        PARSER = new com.google.protobuf.AbstractParser<DeploymentStatus>() {
      @java.lang.Override
      public DeploymentStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeploymentStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeploymentStrategyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DeploymentStrategy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
     * @return Whether the rollingUpdate field is set.
     */
    boolean hasRollingUpdate();
    /**
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
     * @return The rollingUpdate.
     */
    io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment getRollingUpdate();
    /**
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.RollingUpdateDeploymentOrBuilder getRollingUpdateOrBuilder();
  }
  /**
   * <pre>
   * DeploymentStrategy describes how to replace existing pods with new ones.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DeploymentStrategy}
   */
  public static final class DeploymentStrategy extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DeploymentStrategy)
      DeploymentStrategyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DeploymentStrategy.class.getName());
    }
    // Use DeploymentStrategy.newBuilder() to construct.
    private DeploymentStrategy(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DeploymentStrategy() {
      type_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStrategy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStrategy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DeploymentStrategy.class, io.kubernetes.client.proto.V1Apps.DeploymentStrategy.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROLLINGUPDATE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment rollingUpdate_;
    /**
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
     * @return Whether the rollingUpdate field is set.
     */
    @java.lang.Override
    public boolean hasRollingUpdate() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
     * @return The rollingUpdate.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment getRollingUpdate() {
      return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.getDefaultInstance() : rollingUpdate_;
    }
    /**
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.RollingUpdateDeploymentOrBuilder getRollingUpdateOrBuilder() {
      return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.getDefaultInstance() : rollingUpdate_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getRollingUpdate());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRollingUpdate());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DeploymentStrategy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DeploymentStrategy other = (io.kubernetes.client.proto.V1Apps.DeploymentStrategy) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasRollingUpdate() != other.hasRollingUpdate()) return false;
      if (hasRollingUpdate()) {
        if (!getRollingUpdate()
            .equals(other.getRollingUpdate())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasRollingUpdate()) {
        hash = (37 * hash) + ROLLINGUPDATE_FIELD_NUMBER;
        hash = (53 * hash) + getRollingUpdate().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DeploymentStrategy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DeploymentStrategy describes how to replace existing pods with new ones.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DeploymentStrategy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DeploymentStrategy)
        io.kubernetes.client.proto.V1Apps.DeploymentStrategyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStrategy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStrategy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DeploymentStrategy.class, io.kubernetes.client.proto.V1Apps.DeploymentStrategy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DeploymentStrategy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getRollingUpdateFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        rollingUpdate_ = null;
        if (rollingUpdateBuilder_ != null) {
          rollingUpdateBuilder_.dispose();
          rollingUpdateBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DeploymentStrategy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentStrategy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DeploymentStrategy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentStrategy build() {
        io.kubernetes.client.proto.V1Apps.DeploymentStrategy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.DeploymentStrategy buildPartial() {
        io.kubernetes.client.proto.V1Apps.DeploymentStrategy result = new io.kubernetes.client.proto.V1Apps.DeploymentStrategy(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.DeploymentStrategy result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.rollingUpdate_ = rollingUpdateBuilder_ == null
              ? rollingUpdate_
              : rollingUpdateBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DeploymentStrategy) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DeploymentStrategy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DeploymentStrategy other) {
        if (other == io.kubernetes.client.proto.V1Apps.DeploymentStrategy.getDefaultInstance()) return this;
        if (other.hasType()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasRollingUpdate()) {
          mergeRollingUpdate(other.getRollingUpdate());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getRollingUpdateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment rollingUpdate_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment, io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateDeploymentOrBuilder> rollingUpdateBuilder_;
      /**
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
       * @return Whether the rollingUpdate field is set.
       */
      public boolean hasRollingUpdate() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
       * @return The rollingUpdate.
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment getRollingUpdate() {
        if (rollingUpdateBuilder_ == null) {
          return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.getDefaultInstance() : rollingUpdate_;
        } else {
          return rollingUpdateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
       */
      public Builder setRollingUpdate(io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment value) {
        if (rollingUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rollingUpdate_ = value;
        } else {
          rollingUpdateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
       */
      public Builder setRollingUpdate(
          io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.Builder builderForValue) {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = builderForValue.build();
        } else {
          rollingUpdateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
       */
      public Builder mergeRollingUpdate(io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment value) {
        if (rollingUpdateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            rollingUpdate_ != null &&
            rollingUpdate_ != io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.getDefaultInstance()) {
            getRollingUpdateBuilder().mergeFrom(value);
          } else {
            rollingUpdate_ = value;
          }
        } else {
          rollingUpdateBuilder_.mergeFrom(value);
        }
        if (rollingUpdate_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
       */
      public Builder clearRollingUpdate() {
        bitField0_ = (bitField0_ & ~0x00000002);
        rollingUpdate_ = null;
        if (rollingUpdateBuilder_ != null) {
          rollingUpdateBuilder_.dispose();
          rollingUpdateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.Builder getRollingUpdateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRollingUpdateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDeploymentOrBuilder getRollingUpdateOrBuilder() {
        if (rollingUpdateBuilder_ != null) {
          return rollingUpdateBuilder_.getMessageOrBuilder();
        } else {
          return rollingUpdate_ == null ?
              io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.getDefaultInstance() : rollingUpdate_;
        }
      }
      /**
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment, io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateDeploymentOrBuilder> 
          getRollingUpdateFieldBuilder() {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdateBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment, io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateDeploymentOrBuilder>(
                  getRollingUpdate(),
                  getParentForChildren(),
                  isClean());
          rollingUpdate_ = null;
        }
        return rollingUpdateBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DeploymentStrategy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DeploymentStrategy)
    private static final io.kubernetes.client.proto.V1Apps.DeploymentStrategy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DeploymentStrategy();
    }

    public static io.kubernetes.client.proto.V1Apps.DeploymentStrategy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeploymentStrategy>
        PARSER = new com.google.protobuf.AbstractParser<DeploymentStrategy>() {
      @java.lang.Override
      public DeploymentStrategy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeploymentStrategy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentStrategy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.DeploymentStrategy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ReplicaSetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.ReplicaSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    boolean hasSpec();
    /**
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
     * @return The spec.
     */
    io.kubernetes.client.proto.V1Apps.ReplicaSetSpec getSpec();
    /**
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.ReplicaSetSpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
     * @return The status.
     */
    io.kubernetes.client.proto.V1Apps.ReplicaSetStatus getStatus();
    /**
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Apps.ReplicaSetStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * ReplicaSet ensures that a specified number of pod replicas are running at any given time.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSet}
   */
  public static final class ReplicaSet extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.ReplicaSet)
      ReplicaSetOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ReplicaSet.class.getName());
    }
    // Use ReplicaSet.newBuilder() to construct.
    private ReplicaSet(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ReplicaSet() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSet_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.ReplicaSet.class, io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Apps.ReplicaSetSpec spec_;
    /**
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    @java.lang.Override
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
     * @return The spec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Apps.ReplicaSetStatus status_;
    /**
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
     * @return The status.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getStatus());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.ReplicaSet)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.ReplicaSet other = (io.kubernetes.client.proto.V1Apps.ReplicaSet) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasSpec() != other.hasSpec()) return false;
      if (hasSpec()) {
        if (!getSpec()
            .equals(other.getSpec())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.ReplicaSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ReplicaSet ensures that a specified number of pod replicas are running at any given time.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.ReplicaSet)
        io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSet_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.ReplicaSet.class, io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.ReplicaSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSet_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSet getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.ReplicaSet.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSet build() {
        io.kubernetes.client.proto.V1Apps.ReplicaSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSet buildPartial() {
        io.kubernetes.client.proto.V1Apps.ReplicaSet result = new io.kubernetes.client.proto.V1Apps.ReplicaSet(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.ReplicaSet result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.spec_ = specBuilder_ == null
              ? spec_
              : specBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.status_ = statusBuilder_ == null
              ? status_
              : statusBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.ReplicaSet) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.ReplicaSet)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.ReplicaSet other) {
        if (other == io.kubernetes.client.proto.V1Apps.ReplicaSet.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getStatusFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.ReplicaSetSpec spec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ReplicaSetSpec, io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
       * @return Whether the spec field is set.
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
       * @return The spec.
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Apps.ReplicaSetSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Apps.ReplicaSetSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            spec_ != null &&
            spec_ != io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.getDefaultInstance()) {
            getSpecBuilder().mergeFrom(value);
          } else {
            spec_ = value;
          }
        } else {
          specBuilder_.mergeFrom(value);
        }
        if (spec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ReplicaSetSpec, io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.ReplicaSetSpec, io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.ReplicaSetStatus status_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ReplicaSetStatus, io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
       * @return The status.
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1Apps.ReplicaSetStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1Apps.ReplicaSetStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            status_ != null &&
            status_ != io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.getDefaultInstance()) {
            getStatusBuilder().mergeFrom(value);
          } else {
            status_ = value;
          }
        } else {
          statusBuilder_.mergeFrom(value);
        }
        if (status_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000004);
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.ReplicaSetStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ReplicaSetStatus, io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.ReplicaSetStatus, io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.ReplicaSet)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.ReplicaSet)
    private static final io.kubernetes.client.proto.V1Apps.ReplicaSet DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.ReplicaSet();
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ReplicaSet>
        PARSER = new com.google.protobuf.AbstractParser<ReplicaSet>() {
      @java.lang.Override
      public ReplicaSet parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ReplicaSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSet> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ReplicaSetConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.ReplicaSetCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    java.lang.String getStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    com.google.protobuf.ByteString
        getStatusBytes();

    /**
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    boolean hasLastTransitionTime();
    /**
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return The lastTransitionTime.
     */
    io.kubernetes.client.proto.Meta.Time getLastTransitionTime();
    /**
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder();

    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * <pre>
   * ReplicaSetCondition describes the state of a replica set at a certain point.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSetCondition}
   */
  public static final class ReplicaSetCondition extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.ReplicaSetCondition)
      ReplicaSetConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ReplicaSetCondition.class.getName());
    }
    // Use ReplicaSetCondition.newBuilder() to construct.
    private ReplicaSetCondition(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ReplicaSetCondition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.class, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object status_ = "";
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    @java.lang.Override
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LASTTRANSITIONTIME_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
    /**
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    @java.lang.Override
    public boolean hasLastTransitionTime() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return The lastTransitionTime.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }
    /**
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, message_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, message_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.ReplicaSetCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.ReplicaSetCondition other = (io.kubernetes.client.proto.V1Apps.ReplicaSetCondition) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (hasLastTransitionTime() != other.hasLastTransitionTime()) return false;
      if (hasLastTransitionTime()) {
        if (!getLastTransitionTime()
            .equals(other.getLastTransitionTime())) return false;
      }
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasLastTransitionTime()) {
        hash = (37 * hash) + LASTTRANSITIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastTransitionTime().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.ReplicaSetCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ReplicaSetCondition describes the state of a replica set at a certain point.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSetCondition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.ReplicaSetCondition)
        io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.class, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getLastTransitionTimeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        status_ = "";
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        reason_ = "";
        message_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetCondition getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetCondition build() {
        io.kubernetes.client.proto.V1Apps.ReplicaSetCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetCondition buildPartial() {
        io.kubernetes.client.proto.V1Apps.ReplicaSetCondition result = new io.kubernetes.client.proto.V1Apps.ReplicaSetCondition(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.ReplicaSetCondition result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.lastTransitionTime_ = lastTransitionTimeBuilder_ == null
              ? lastTransitionTime_
              : lastTransitionTimeBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.ReplicaSetCondition) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.ReplicaSetCondition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.ReplicaSetCondition other) {
        if (other == io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.getDefaultInstance()) return this;
        if (other.hasType()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasStatus()) {
          status_ = other.status_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasLastTransitionTime()) {
          mergeLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                status_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getLastTransitionTimeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                reason_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                message_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The status.
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The bytes for status.
       */
      public com.google.protobuf.ByteString
          getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        status_ = getDefaultInstance().getStatus();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The bytes for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastTransitionTimeBuilder_;
      /**
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       * @return Whether the lastTransitionTime field is set.
       */
      public boolean hasLastTransitionTime() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       * @return The lastTransitionTime.
       */
      public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        } else {
          return lastTransitionTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastTransitionTime_ = value;
        } else {
          lastTransitionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = builderForValue.build();
        } else {
          lastTransitionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder mergeLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            lastTransitionTime_ != null &&
            lastTransitionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getLastTransitionTimeBuilder().mergeFrom(value);
          } else {
            lastTransitionTime_ = value;
          }
        } else {
          lastTransitionTimeBuilder_.mergeFrom(value);
        }
        if (lastTransitionTime_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder clearLastTransitionTime() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastTransitionTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastTransitionTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
        if (lastTransitionTimeBuilder_ != null) {
          return lastTransitionTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastTransitionTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        }
      }
      /**
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastTransitionTimeFieldBuilder() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTimeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastTransitionTime(),
                  getParentForChildren(),
                  isClean());
          lastTransitionTime_ = null;
        }
        return lastTransitionTimeBuilder_;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.ReplicaSetCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.ReplicaSetCondition)
    private static final io.kubernetes.client.proto.V1Apps.ReplicaSetCondition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.ReplicaSetCondition();
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetCondition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ReplicaSetCondition>
        PARSER = new com.google.protobuf.AbstractParser<ReplicaSetCondition>() {
      @java.lang.Override
      public ReplicaSetCondition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ReplicaSetCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSetCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetCondition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ReplicaSetListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.ReplicaSetList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSet> 
        getItemsList();
    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.ReplicaSet getItems(int index);
    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ReplicaSetList is a collection of ReplicaSets.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSetList}
   */
  public static final class ReplicaSetList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.ReplicaSetList)
      ReplicaSetListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ReplicaSetList.class.getName());
    }
    // Use ReplicaSetList.newBuilder() to construct.
    private ReplicaSetList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ReplicaSetList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.ReplicaSetList.class, io.kubernetes.client.proto.V1Apps.ReplicaSetList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSet> items_;
    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSet> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSet getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.ReplicaSetList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.ReplicaSetList other = (io.kubernetes.client.proto.V1Apps.ReplicaSetList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.ReplicaSetList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ReplicaSetList is a collection of ReplicaSets.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSetList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.ReplicaSetList)
        io.kubernetes.client.proto.V1Apps.ReplicaSetListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.ReplicaSetList.class, io.kubernetes.client.proto.V1Apps.ReplicaSetList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.ReplicaSetList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.ReplicaSetList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetList build() {
        io.kubernetes.client.proto.V1Apps.ReplicaSetList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetList buildPartial() {
        io.kubernetes.client.proto.V1Apps.ReplicaSetList result = new io.kubernetes.client.proto.V1Apps.ReplicaSetList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.ReplicaSetList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.ReplicaSetList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.ReplicaSetList) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.ReplicaSetList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.ReplicaSetList other) {
        if (other == io.kubernetes.client.proto.V1Apps.ReplicaSetList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Apps.ReplicaSet m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Apps.ReplicaSet.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSet> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.ReplicaSet>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ReplicaSet, io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSet> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSet getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.ReplicaSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Apps.ReplicaSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.ReplicaSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.ReplicaSet> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.ReplicaSet.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.ReplicaSet.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ReplicaSet, io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Apps.ReplicaSet, io.kubernetes.client.proto.V1Apps.ReplicaSet.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.ReplicaSetList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.ReplicaSetList)
    private static final io.kubernetes.client.proto.V1Apps.ReplicaSetList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.ReplicaSetList();
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ReplicaSetList>
        PARSER = new com.google.protobuf.AbstractParser<ReplicaSetList>() {
      @java.lang.Override
      public ReplicaSetList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ReplicaSetList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSetList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ReplicaSetSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.ReplicaSetSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Replicas is the number of desired replicas.
     * This is a pointer to distinguish between explicit zero and unspecified.
     * Defaults to 1.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return Whether the replicas field is set.
     */
    boolean hasReplicas();
    /**
     * <pre>
     * Replicas is the number of desired replicas.
     * This is a pointer to distinguish between explicit zero and unspecified.
     * Defaults to 1.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return The replicas.
     */
    int getReplicas();

    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     * @return Whether the minReadySeconds field is set.
     */
    boolean hasMinReadySeconds();
    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     * @return The minReadySeconds.
     */
    int getMinReadySeconds();

    /**
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * Label keys and values that must match in order to be controlled by this replica set.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return Whether the selector field is set.
     */
    boolean hasSelector();
    /**
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * Label keys and values that must match in order to be controlled by this replica set.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return The selector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * Label keys and values that must match in order to be controlled by this replica set.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return Whether the template field is set.
     */
    boolean hasTemplate();
    /**
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return The template.
     */
    io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate();
    /**
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder();
  }
  /**
   * <pre>
   * ReplicaSetSpec is the specification of a ReplicaSet.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSetSpec}
   */
  public static final class ReplicaSetSpec extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.ReplicaSetSpec)
      ReplicaSetSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ReplicaSetSpec.class.getName());
    }
    // Use ReplicaSetSpec.newBuilder() to construct.
    private ReplicaSetSpec(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ReplicaSetSpec() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.class, io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.Builder.class);
    }

    private int bitField0_;
    public static final int REPLICAS_FIELD_NUMBER = 1;
    private int replicas_ = 0;
    /**
     * <pre>
     * Replicas is the number of desired replicas.
     * This is a pointer to distinguish between explicit zero and unspecified.
     * Defaults to 1.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return Whether the replicas field is set.
     */
    @java.lang.Override
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Replicas is the number of desired replicas.
     * This is a pointer to distinguish between explicit zero and unspecified.
     * Defaults to 1.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return The replicas.
     */
    @java.lang.Override
    public int getReplicas() {
      return replicas_;
    }

    public static final int MINREADYSECONDS_FIELD_NUMBER = 4;
    private int minReadySeconds_ = 0;
    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     * @return Whether the minReadySeconds field is set.
     */
    @java.lang.Override
    public boolean hasMinReadySeconds() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     * @return The minReadySeconds.
     */
    @java.lang.Override
    public int getMinReadySeconds() {
      return minReadySeconds_;
    }

    public static final int SELECTOR_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * Label keys and values that must match in order to be controlled by this replica set.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return Whether the selector field is set.
     */
    @java.lang.Override
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * Label keys and values that must match in order to be controlled by this replica set.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return The selector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }
    /**
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * Label keys and values that must match in order to be controlled by this replica set.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }

    public static final int TEMPLATE_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
    /**
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return Whether the template field is set.
     */
    @java.lang.Override
    public boolean hasTemplate() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return The template.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }
    /**
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, replicas_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(2, getSelector());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(3, getTemplate());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(4, minReadySeconds_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, replicas_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSelector());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getTemplate());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, minReadySeconds_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.ReplicaSetSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.ReplicaSetSpec other = (io.kubernetes.client.proto.V1Apps.ReplicaSetSpec) obj;

      if (hasReplicas() != other.hasReplicas()) return false;
      if (hasReplicas()) {
        if (getReplicas()
            != other.getReplicas()) return false;
      }
      if (hasMinReadySeconds() != other.hasMinReadySeconds()) return false;
      if (hasMinReadySeconds()) {
        if (getMinReadySeconds()
            != other.getMinReadySeconds()) return false;
      }
      if (hasSelector() != other.hasSelector()) return false;
      if (hasSelector()) {
        if (!getSelector()
            .equals(other.getSelector())) return false;
      }
      if (hasTemplate() != other.hasTemplate()) return false;
      if (hasTemplate()) {
        if (!getTemplate()
            .equals(other.getTemplate())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasMinReadySeconds()) {
        hash = (37 * hash) + MINREADYSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getMinReadySeconds();
      }
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasTemplate()) {
        hash = (37 * hash) + TEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplate().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.ReplicaSetSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ReplicaSetSpec is the specification of a ReplicaSet.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSetSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.ReplicaSetSpec)
        io.kubernetes.client.proto.V1Apps.ReplicaSetSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.class, io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
          getTemplateFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        replicas_ = 0;
        minReadySeconds_ = 0;
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        template_ = null;
        if (templateBuilder_ != null) {
          templateBuilder_.dispose();
          templateBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetSpec build() {
        io.kubernetes.client.proto.V1Apps.ReplicaSetSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetSpec buildPartial() {
        io.kubernetes.client.proto.V1Apps.ReplicaSetSpec result = new io.kubernetes.client.proto.V1Apps.ReplicaSetSpec(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.ReplicaSetSpec result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.replicas_ = replicas_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.minReadySeconds_ = minReadySeconds_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.selector_ = selectorBuilder_ == null
              ? selector_
              : selectorBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.template_ = templateBuilder_ == null
              ? template_
              : templateBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.ReplicaSetSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.ReplicaSetSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.ReplicaSetSpec other) {
        if (other == io.kubernetes.client.proto.V1Apps.ReplicaSetSpec.getDefaultInstance()) return this;
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasMinReadySeconds()) {
          setMinReadySeconds(other.getMinReadySeconds());
        }
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasTemplate()) {
          mergeTemplate(other.getTemplate());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                replicas_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                input.readMessage(
                    getSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getTemplateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 26
              case 32: {
                minReadySeconds_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int replicas_ ;
      /**
       * <pre>
       * Replicas is the number of desired replicas.
       * This is a pointer to distinguish between explicit zero and unspecified.
       * Defaults to 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return Whether the replicas field is set.
       */
      @java.lang.Override
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Replicas is the number of desired replicas.
       * This is a pointer to distinguish between explicit zero and unspecified.
       * Defaults to 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return The replicas.
       */
      @java.lang.Override
      public int getReplicas() {
        return replicas_;
      }
      /**
       * <pre>
       * Replicas is the number of desired replicas.
       * This is a pointer to distinguish between explicit zero and unspecified.
       * Defaults to 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @param value The replicas to set.
       * @return This builder for chaining.
       */
      public Builder setReplicas(int value) {

        replicas_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Replicas is the number of desired replicas.
       * This is a pointer to distinguish between explicit zero and unspecified.
       * Defaults to 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private int minReadySeconds_ ;
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       * @return Whether the minReadySeconds field is set.
       */
      @java.lang.Override
      public boolean hasMinReadySeconds() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       * @return The minReadySeconds.
       */
      @java.lang.Override
      public int getMinReadySeconds() {
        return minReadySeconds_;
      }
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       * @param value The minReadySeconds to set.
       * @return This builder for chaining.
       */
      public Builder setMinReadySeconds(int value) {

        minReadySeconds_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinReadySeconds() {
        bitField0_ = (bitField0_ & ~0x00000002);
        minReadySeconds_ = 0;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector selector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> selectorBuilder_;
      /**
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * Label keys and values that must match in order to be controlled by this replica set.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       * @return Whether the selector field is set.
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * Label keys and values that must match in order to be controlled by this replica set.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       * @return The selector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * Label keys and values that must match in order to be controlled by this replica set.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * Label keys and values that must match in order to be controlled by this replica set.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * Label keys and values that must match in order to be controlled by this replica set.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            selector_ != null &&
            selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getSelectorBuilder().mergeFrom(value);
          } else {
            selector_ = value;
          }
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        if (selector_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * Label keys and values that must match in order to be controlled by this replica set.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder clearSelector() {
        bitField0_ = (bitField0_ & ~0x00000004);
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * Label keys and values that must match in order to be controlled by this replica set.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * Label keys and values that must match in order to be controlled by this replica set.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        }
      }
      /**
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * Label keys and values that must match in order to be controlled by this replica set.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(),
                  getParentForChildren(),
                  isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> templateBuilder_;
      /**
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       * @return Whether the template field is set.
       */
      public boolean hasTemplate() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       * @return The template.
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
        if (templateBuilder_ == null) {
          return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        } else {
          return templateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          template_ = value;
        } else {
          templateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(
          io.kubernetes.client.proto.V1.PodTemplateSpec.Builder builderForValue) {
        if (templateBuilder_ == null) {
          template_ = builderForValue.build();
        } else {
          templateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder mergeTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            template_ != null &&
            template_ != io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()) {
            getTemplateBuilder().mergeFrom(value);
          } else {
            template_ = value;
          }
        } else {
          templateBuilder_.mergeFrom(value);
        }
        if (template_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder clearTemplate() {
        bitField0_ = (bitField0_ & ~0x00000008);
        template_ = null;
        if (templateBuilder_ != null) {
          templateBuilder_.dispose();
          templateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec.Builder getTemplateBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getTemplateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
        if (templateBuilder_ != null) {
          return templateBuilder_.getMessageOrBuilder();
        } else {
          return template_ == null ?
              io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        }
      }
      /**
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> 
          getTemplateFieldBuilder() {
        if (templateBuilder_ == null) {
          templateBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>(
                  getTemplate(),
                  getParentForChildren(),
                  isClean());
          template_ = null;
        }
        return templateBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.ReplicaSetSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.ReplicaSetSpec)
    private static final io.kubernetes.client.proto.V1Apps.ReplicaSetSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.ReplicaSetSpec();
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ReplicaSetSpec>
        PARSER = new com.google.protobuf.AbstractParser<ReplicaSetSpec>() {
      @java.lang.Override
      public ReplicaSetSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ReplicaSetSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSetSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ReplicaSetStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.ReplicaSetStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Replicas is the most recently observed number of replicas.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return Whether the replicas field is set.
     */
    boolean hasReplicas();
    /**
     * <pre>
     * Replicas is the most recently observed number of replicas.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return The replicas.
     */
    int getReplicas();

    /**
     * <pre>
     * The number of pods that have labels matching the labels of the pod template of the replicaset.
     * +optional
     * </pre>
     *
     * <code>optional int32 fullyLabeledReplicas = 2;</code>
     * @return Whether the fullyLabeledReplicas field is set.
     */
    boolean hasFullyLabeledReplicas();
    /**
     * <pre>
     * The number of pods that have labels matching the labels of the pod template of the replicaset.
     * +optional
     * </pre>
     *
     * <code>optional int32 fullyLabeledReplicas = 2;</code>
     * @return The fullyLabeledReplicas.
     */
    int getFullyLabeledReplicas();

    /**
     * <pre>
     * readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 4;</code>
     * @return Whether the readyReplicas field is set.
     */
    boolean hasReadyReplicas();
    /**
     * <pre>
     * readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 4;</code>
     * @return The readyReplicas.
     */
    int getReadyReplicas();

    /**
     * <pre>
     * The number of available replicas (ready for at least minReadySeconds) for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 5;</code>
     * @return Whether the availableReplicas field is set.
     */
    boolean hasAvailableReplicas();
    /**
     * <pre>
     * The number of available replicas (ready for at least minReadySeconds) for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 5;</code>
     * @return The availableReplicas.
     */
    int getAvailableReplicas();

    /**
     * <pre>
     * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     * @return Whether the observedGeneration field is set.
     */
    boolean hasObservedGeneration();
    /**
     * <pre>
     * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     * @return The observedGeneration.
     */
    long getObservedGeneration();

    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSetCondition> 
        getConditionsList();
    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    io.kubernetes.client.proto.V1Apps.ReplicaSetCondition getConditions(int index);
    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    int getConditionsCount();
    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder> 
        getConditionsOrBuilderList();
    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder getConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ReplicaSetStatus represents the current status of a ReplicaSet.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSetStatus}
   */
  public static final class ReplicaSetStatus extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.ReplicaSetStatus)
      ReplicaSetStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ReplicaSetStatus.class.getName());
    }
    // Use ReplicaSetStatus.newBuilder() to construct.
    private ReplicaSetStatus(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ReplicaSetStatus() {
      conditions_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.class, io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.Builder.class);
    }

    private int bitField0_;
    public static final int REPLICAS_FIELD_NUMBER = 1;
    private int replicas_ = 0;
    /**
     * <pre>
     * Replicas is the most recently observed number of replicas.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return Whether the replicas field is set.
     */
    @java.lang.Override
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Replicas is the most recently observed number of replicas.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return The replicas.
     */
    @java.lang.Override
    public int getReplicas() {
      return replicas_;
    }

    public static final int FULLYLABELEDREPLICAS_FIELD_NUMBER = 2;
    private int fullyLabeledReplicas_ = 0;
    /**
     * <pre>
     * The number of pods that have labels matching the labels of the pod template of the replicaset.
     * +optional
     * </pre>
     *
     * <code>optional int32 fullyLabeledReplicas = 2;</code>
     * @return Whether the fullyLabeledReplicas field is set.
     */
    @java.lang.Override
    public boolean hasFullyLabeledReplicas() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The number of pods that have labels matching the labels of the pod template of the replicaset.
     * +optional
     * </pre>
     *
     * <code>optional int32 fullyLabeledReplicas = 2;</code>
     * @return The fullyLabeledReplicas.
     */
    @java.lang.Override
    public int getFullyLabeledReplicas() {
      return fullyLabeledReplicas_;
    }

    public static final int READYREPLICAS_FIELD_NUMBER = 4;
    private int readyReplicas_ = 0;
    /**
     * <pre>
     * readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 4;</code>
     * @return Whether the readyReplicas field is set.
     */
    @java.lang.Override
    public boolean hasReadyReplicas() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 4;</code>
     * @return The readyReplicas.
     */
    @java.lang.Override
    public int getReadyReplicas() {
      return readyReplicas_;
    }

    public static final int AVAILABLEREPLICAS_FIELD_NUMBER = 5;
    private int availableReplicas_ = 0;
    /**
     * <pre>
     * The number of available replicas (ready for at least minReadySeconds) for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 5;</code>
     * @return Whether the availableReplicas field is set.
     */
    @java.lang.Override
    public boolean hasAvailableReplicas() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The number of available replicas (ready for at least minReadySeconds) for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 5;</code>
     * @return The availableReplicas.
     */
    @java.lang.Override
    public int getAvailableReplicas() {
      return availableReplicas_;
    }

    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 3;
    private long observedGeneration_ = 0L;
    /**
     * <pre>
     * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     * @return Whether the observedGeneration field is set.
     */
    @java.lang.Override
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     * @return The observedGeneration.
     */
    @java.lang.Override
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSetCondition> conditions_;
    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSetCondition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    @java.lang.Override
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetCondition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, fullyLabeledReplicas_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt64(3, observedGeneration_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt32(4, readyReplicas_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(5, availableReplicas_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(6, conditions_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, fullyLabeledReplicas_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, observedGeneration_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, readyReplicas_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, availableReplicas_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, conditions_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.ReplicaSetStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.ReplicaSetStatus other = (io.kubernetes.client.proto.V1Apps.ReplicaSetStatus) obj;

      if (hasReplicas() != other.hasReplicas()) return false;
      if (hasReplicas()) {
        if (getReplicas()
            != other.getReplicas()) return false;
      }
      if (hasFullyLabeledReplicas() != other.hasFullyLabeledReplicas()) return false;
      if (hasFullyLabeledReplicas()) {
        if (getFullyLabeledReplicas()
            != other.getFullyLabeledReplicas()) return false;
      }
      if (hasReadyReplicas() != other.hasReadyReplicas()) return false;
      if (hasReadyReplicas()) {
        if (getReadyReplicas()
            != other.getReadyReplicas()) return false;
      }
      if (hasAvailableReplicas() != other.hasAvailableReplicas()) return false;
      if (hasAvailableReplicas()) {
        if (getAvailableReplicas()
            != other.getAvailableReplicas()) return false;
      }
      if (hasObservedGeneration() != other.hasObservedGeneration()) return false;
      if (hasObservedGeneration()) {
        if (getObservedGeneration()
            != other.getObservedGeneration()) return false;
      }
      if (!getConditionsList()
          .equals(other.getConditionsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasFullyLabeledReplicas()) {
        hash = (37 * hash) + FULLYLABELEDREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getFullyLabeledReplicas();
      }
      if (hasReadyReplicas()) {
        hash = (37 * hash) + READYREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReadyReplicas();
      }
      if (hasAvailableReplicas()) {
        hash = (37 * hash) + AVAILABLEREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getAvailableReplicas();
      }
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getObservedGeneration());
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.ReplicaSetStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ReplicaSetStatus represents the current status of a ReplicaSet.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.ReplicaSetStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.ReplicaSetStatus)
        io.kubernetes.client.proto.V1Apps.ReplicaSetStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.class, io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        replicas_ = 0;
        fullyLabeledReplicas_ = 0;
        readyReplicas_ = 0;
        availableReplicas_ = 0;
        observedGeneration_ = 0L;
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
        } else {
          conditions_ = null;
          conditionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetStatus build() {
        io.kubernetes.client.proto.V1Apps.ReplicaSetStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.ReplicaSetStatus buildPartial() {
        io.kubernetes.client.proto.V1Apps.ReplicaSetStatus result = new io.kubernetes.client.proto.V1Apps.ReplicaSetStatus(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.ReplicaSetStatus result) {
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.ReplicaSetStatus result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.replicas_ = replicas_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.fullyLabeledReplicas_ = fullyLabeledReplicas_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.readyReplicas_ = readyReplicas_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.availableReplicas_ = availableReplicas_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.observedGeneration_ = observedGeneration_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.ReplicaSetStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.ReplicaSetStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.ReplicaSetStatus other) {
        if (other == io.kubernetes.client.proto.V1Apps.ReplicaSetStatus.getDefaultInstance()) return this;
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasFullyLabeledReplicas()) {
          setFullyLabeledReplicas(other.getFullyLabeledReplicas());
        }
        if (other.hasReadyReplicas()) {
          setReadyReplicas(other.getReadyReplicas());
        }
        if (other.hasAvailableReplicas()) {
          setAvailableReplicas(other.getAvailableReplicas());
        }
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
              conditionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getConditionsFieldBuilder() : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                replicas_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                fullyLabeledReplicas_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                observedGeneration_ = input.readInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 24
              case 32: {
                readyReplicas_ = input.readInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 32
              case 40: {
                availableReplicas_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 40
              case 50: {
                io.kubernetes.client.proto.V1Apps.ReplicaSetCondition m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.parser(),
                        extensionRegistry);
                if (conditionsBuilder_ == null) {
                  ensureConditionsIsMutable();
                  conditions_.add(m);
                } else {
                  conditionsBuilder_.addMessage(m);
                }
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int replicas_ ;
      /**
       * <pre>
       * Replicas is the most recently observed number of replicas.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return Whether the replicas field is set.
       */
      @java.lang.Override
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Replicas is the most recently observed number of replicas.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return The replicas.
       */
      @java.lang.Override
      public int getReplicas() {
        return replicas_;
      }
      /**
       * <pre>
       * Replicas is the most recently observed number of replicas.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @param value The replicas to set.
       * @return This builder for chaining.
       */
      public Builder setReplicas(int value) {

        replicas_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Replicas is the most recently observed number of replicas.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private int fullyLabeledReplicas_ ;
      /**
       * <pre>
       * The number of pods that have labels matching the labels of the pod template of the replicaset.
       * +optional
       * </pre>
       *
       * <code>optional int32 fullyLabeledReplicas = 2;</code>
       * @return Whether the fullyLabeledReplicas field is set.
       */
      @java.lang.Override
      public boolean hasFullyLabeledReplicas() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The number of pods that have labels matching the labels of the pod template of the replicaset.
       * +optional
       * </pre>
       *
       * <code>optional int32 fullyLabeledReplicas = 2;</code>
       * @return The fullyLabeledReplicas.
       */
      @java.lang.Override
      public int getFullyLabeledReplicas() {
        return fullyLabeledReplicas_;
      }
      /**
       * <pre>
       * The number of pods that have labels matching the labels of the pod template of the replicaset.
       * +optional
       * </pre>
       *
       * <code>optional int32 fullyLabeledReplicas = 2;</code>
       * @param value The fullyLabeledReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setFullyLabeledReplicas(int value) {

        fullyLabeledReplicas_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of pods that have labels matching the labels of the pod template of the replicaset.
       * +optional
       * </pre>
       *
       * <code>optional int32 fullyLabeledReplicas = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFullyLabeledReplicas() {
        bitField0_ = (bitField0_ & ~0x00000002);
        fullyLabeledReplicas_ = 0;
        onChanged();
        return this;
      }

      private int readyReplicas_ ;
      /**
       * <pre>
       * readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 4;</code>
       * @return Whether the readyReplicas field is set.
       */
      @java.lang.Override
      public boolean hasReadyReplicas() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 4;</code>
       * @return The readyReplicas.
       */
      @java.lang.Override
      public int getReadyReplicas() {
        return readyReplicas_;
      }
      /**
       * <pre>
       * readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 4;</code>
       * @param value The readyReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setReadyReplicas(int value) {

        readyReplicas_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearReadyReplicas() {
        bitField0_ = (bitField0_ & ~0x00000004);
        readyReplicas_ = 0;
        onChanged();
        return this;
      }

      private int availableReplicas_ ;
      /**
       * <pre>
       * The number of available replicas (ready for at least minReadySeconds) for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 5;</code>
       * @return Whether the availableReplicas field is set.
       */
      @java.lang.Override
      public boolean hasAvailableReplicas() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The number of available replicas (ready for at least minReadySeconds) for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 5;</code>
       * @return The availableReplicas.
       */
      @java.lang.Override
      public int getAvailableReplicas() {
        return availableReplicas_;
      }
      /**
       * <pre>
       * The number of available replicas (ready for at least minReadySeconds) for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 5;</code>
       * @param value The availableReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setAvailableReplicas(int value) {

        availableReplicas_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of available replicas (ready for at least minReadySeconds) for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearAvailableReplicas() {
        bitField0_ = (bitField0_ & ~0x00000008);
        availableReplicas_ = 0;
        onChanged();
        return this;
      }

      private long observedGeneration_ ;
      /**
       * <pre>
       * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       * @return Whether the observedGeneration field is set.
       */
      @java.lang.Override
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       * @return The observedGeneration.
       */
      @java.lang.Override
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       * <pre>
       * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       * @param value The observedGeneration to set.
       * @return This builder for chaining.
       */
      public Builder setObservedGeneration(long value) {

        observedGeneration_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000010);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSetCondition> conditions_ =
        java.util.Collections.emptyList();
      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.ReplicaSetCondition>(conditions_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ReplicaSetCondition, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder> conditionsBuilder_;

      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSetCondition> getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetCondition getConditions(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addConditions(io.kubernetes.client.proto.V1Apps.ReplicaSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.ReplicaSetCondition> values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder getConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder getConditionsOrBuilder(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);  } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder> 
           getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder addConditionsBuilder() {
        return getConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder addConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.ReplicaSetCondition conditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder> 
           getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.ReplicaSetCondition, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder> 
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Apps.ReplicaSetCondition, io.kubernetes.client.proto.V1Apps.ReplicaSetCondition.Builder, io.kubernetes.client.proto.V1Apps.ReplicaSetConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.ReplicaSetStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.ReplicaSetStatus)
    private static final io.kubernetes.client.proto.V1Apps.ReplicaSetStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.ReplicaSetStatus();
    }

    public static io.kubernetes.client.proto.V1Apps.ReplicaSetStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ReplicaSetStatus>
        PARSER = new com.google.protobuf.AbstractParser<ReplicaSetStatus>() {
      @java.lang.Override
      public ReplicaSetStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ReplicaSetStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSetStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.ReplicaSetStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RollingUpdateDaemonSetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     * @return Whether the maxUnavailable field is set.
     */
    boolean hasMaxUnavailable();
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     * @return The maxUnavailable.
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable();
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder();

    /**
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     * @return Whether the maxSurge field is set.
     */
    boolean hasMaxSurge();
    /**
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     * @return The maxSurge.
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge();
    /**
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder();
  }
  /**
   * <pre>
   * Spec to control the desired behavior of daemon set rolling update.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.RollingUpdateDaemonSet}
   */
  public static final class RollingUpdateDaemonSet extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
      RollingUpdateDaemonSetOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        RollingUpdateDaemonSet.class.getName());
    }
    // Use RollingUpdateDaemonSet.newBuilder() to construct.
    private RollingUpdateDaemonSet(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private RollingUpdateDaemonSet() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.class, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder.class);
    }

    private int bitField0_;
    public static final int MAXUNAVAILABLE_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_;
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     * @return Whether the maxUnavailable field is set.
     */
    @java.lang.Override
    public boolean hasMaxUnavailable() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     * @return The maxUnavailable.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
      return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
    }
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
      return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
    }

    public static final int MAXSURGE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.IntStr.IntOrString maxSurge_;
    /**
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     * @return Whether the maxSurge field is set.
     */
    @java.lang.Override
    public boolean hasMaxSurge() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     * @return The maxSurge.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge() {
      return maxSurge_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxSurge_;
    }
    /**
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder() {
      return maxSurge_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxSurge_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMaxUnavailable());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getMaxSurge());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMaxUnavailable());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMaxSurge());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet other = (io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet) obj;

      if (hasMaxUnavailable() != other.hasMaxUnavailable()) return false;
      if (hasMaxUnavailable()) {
        if (!getMaxUnavailable()
            .equals(other.getMaxUnavailable())) return false;
      }
      if (hasMaxSurge() != other.hasMaxSurge()) return false;
      if (hasMaxSurge()) {
        if (!getMaxSurge()
            .equals(other.getMaxSurge())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMaxUnavailable()) {
        hash = (37 * hash) + MAXUNAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxUnavailable().hashCode();
      }
      if (hasMaxSurge()) {
        hash = (37 * hash) + MAXSURGE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxSurge().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Spec to control the desired behavior of daemon set rolling update.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.RollingUpdateDaemonSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
        io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.class, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMaxUnavailableFieldBuilder();
          getMaxSurgeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        maxUnavailable_ = null;
        if (maxUnavailableBuilder_ != null) {
          maxUnavailableBuilder_.dispose();
          maxUnavailableBuilder_ = null;
        }
        maxSurge_ = null;
        if (maxSurgeBuilder_ != null) {
          maxSurgeBuilder_.dispose();
          maxSurgeBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet build() {
        io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet buildPartial() {
        io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet result = new io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.maxUnavailable_ = maxUnavailableBuilder_ == null
              ? maxUnavailable_
              : maxUnavailableBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.maxSurge_ = maxSurgeBuilder_ == null
              ? maxSurge_
              : maxSurgeBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet other) {
        if (other == io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance()) return this;
        if (other.hasMaxUnavailable()) {
          mergeMaxUnavailable(other.getMaxUnavailable());
        }
        if (other.hasMaxSurge()) {
          mergeMaxSurge(other.getMaxSurge());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMaxUnavailableFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getMaxSurgeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> maxUnavailableBuilder_;
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       * @return Whether the maxUnavailable field is set.
       */
      public boolean hasMaxUnavailable() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       * @return The maxUnavailable.
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
        if (maxUnavailableBuilder_ == null) {
          return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
        } else {
          return maxUnavailableBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxUnavailable_ = value;
        } else {
          maxUnavailableBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = builderForValue.build();
        } else {
          maxUnavailableBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder mergeMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            maxUnavailable_ != null &&
            maxUnavailable_ != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            getMaxUnavailableBuilder().mergeFrom(value);
          } else {
            maxUnavailable_ = value;
          }
        } else {
          maxUnavailableBuilder_.mergeFrom(value);
        }
        if (maxUnavailable_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder clearMaxUnavailable() {
        bitField0_ = (bitField0_ & ~0x00000001);
        maxUnavailable_ = null;
        if (maxUnavailableBuilder_ != null) {
          maxUnavailableBuilder_.dispose();
          maxUnavailableBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxUnavailableBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMaxUnavailableFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
        if (maxUnavailableBuilder_ != null) {
          return maxUnavailableBuilder_.getMessageOrBuilder();
        } else {
          return maxUnavailable_ == null ?
              io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
        }
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> 
          getMaxUnavailableFieldBuilder() {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailableBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxUnavailable(),
                  getParentForChildren(),
                  isClean());
          maxUnavailable_ = null;
        }
        return maxUnavailableBuilder_;
      }

      private io.kubernetes.client.proto.IntStr.IntOrString maxSurge_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> maxSurgeBuilder_;
      /**
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       * @return Whether the maxSurge field is set.
       */
      public boolean hasMaxSurge() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       * @return The maxSurge.
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge() {
        if (maxSurgeBuilder_ == null) {
          return maxSurge_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxSurge_;
        } else {
          return maxSurgeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder setMaxSurge(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxSurgeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxSurge_ = value;
        } else {
          maxSurgeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder setMaxSurge(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxSurgeBuilder_ == null) {
          maxSurge_ = builderForValue.build();
        } else {
          maxSurgeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder mergeMaxSurge(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxSurgeBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            maxSurge_ != null &&
            maxSurge_ != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            getMaxSurgeBuilder().mergeFrom(value);
          } else {
            maxSurge_ = value;
          }
        } else {
          maxSurgeBuilder_.mergeFrom(value);
        }
        if (maxSurge_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder clearMaxSurge() {
        bitField0_ = (bitField0_ & ~0x00000002);
        maxSurge_ = null;
        if (maxSurgeBuilder_ != null) {
          maxSurgeBuilder_.dispose();
          maxSurgeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxSurgeBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getMaxSurgeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder() {
        if (maxSurgeBuilder_ != null) {
          return maxSurgeBuilder_.getMessageOrBuilder();
        } else {
          return maxSurge_ == null ?
              io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxSurge_;
        }
      }
      /**
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> 
          getMaxSurgeFieldBuilder() {
        if (maxSurgeBuilder_ == null) {
          maxSurgeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxSurge(),
                  getParentForChildren(),
                  isClean());
          maxSurge_ = null;
        }
        return maxSurgeBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
    private static final io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet();
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RollingUpdateDaemonSet>
        PARSER = new com.google.protobuf.AbstractParser<RollingUpdateDaemonSet>() {
      @java.lang.Override
      public RollingUpdateDaemonSet parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<RollingUpdateDaemonSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RollingUpdateDaemonSet> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RollingUpdateDeploymentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.RollingUpdateDeployment)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * Defaults to 25%.
     * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
     * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     * @return Whether the maxUnavailable field is set.
     */
    boolean hasMaxUnavailable();
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * Defaults to 25%.
     * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
     * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     * @return The maxUnavailable.
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable();
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * Defaults to 25%.
     * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
     * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder();

    /**
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * Defaults to 25%.
     * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new ReplicaSet can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     * @return Whether the maxSurge field is set.
     */
    boolean hasMaxSurge();
    /**
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * Defaults to 25%.
     * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new ReplicaSet can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     * @return The maxSurge.
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge();
    /**
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * Defaults to 25%.
     * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new ReplicaSet can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder();
  }
  /**
   * <pre>
   * Spec to control the desired behavior of rolling update.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.RollingUpdateDeployment}
   */
  public static final class RollingUpdateDeployment extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.RollingUpdateDeployment)
      RollingUpdateDeploymentOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        RollingUpdateDeployment.class.getName());
    }
    // Use RollingUpdateDeployment.newBuilder() to construct.
    private RollingUpdateDeployment(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private RollingUpdateDeployment() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.class, io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.Builder.class);
    }

    private int bitField0_;
    public static final int MAXUNAVAILABLE_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_;
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * Defaults to 25%.
     * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
     * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     * @return Whether the maxUnavailable field is set.
     */
    @java.lang.Override
    public boolean hasMaxUnavailable() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * Defaults to 25%.
     * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
     * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     * @return The maxUnavailable.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
      return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
    }
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * Defaults to 25%.
     * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
     * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
      return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
    }

    public static final int MAXSURGE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.IntStr.IntOrString maxSurge_;
    /**
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * Defaults to 25%.
     * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new ReplicaSet can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     * @return Whether the maxSurge field is set.
     */
    @java.lang.Override
    public boolean hasMaxSurge() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * Defaults to 25%.
     * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new ReplicaSet can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     * @return The maxSurge.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge() {
      return maxSurge_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxSurge_;
    }
    /**
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * Defaults to 25%.
     * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new ReplicaSet can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder() {
      return maxSurge_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxSurge_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMaxUnavailable());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getMaxSurge());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMaxUnavailable());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMaxSurge());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment other = (io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment) obj;

      if (hasMaxUnavailable() != other.hasMaxUnavailable()) return false;
      if (hasMaxUnavailable()) {
        if (!getMaxUnavailable()
            .equals(other.getMaxUnavailable())) return false;
      }
      if (hasMaxSurge() != other.hasMaxSurge()) return false;
      if (hasMaxSurge()) {
        if (!getMaxSurge()
            .equals(other.getMaxSurge())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMaxUnavailable()) {
        hash = (37 * hash) + MAXUNAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxUnavailable().hashCode();
      }
      if (hasMaxSurge()) {
        hash = (37 * hash) + MAXSURGE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxSurge().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Spec to control the desired behavior of rolling update.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.RollingUpdateDeployment}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.RollingUpdateDeployment)
        io.kubernetes.client.proto.V1Apps.RollingUpdateDeploymentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.class, io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMaxUnavailableFieldBuilder();
          getMaxSurgeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        maxUnavailable_ = null;
        if (maxUnavailableBuilder_ != null) {
          maxUnavailableBuilder_.dispose();
          maxUnavailableBuilder_ = null;
        }
        maxSurge_ = null;
        if (maxSurgeBuilder_ != null) {
          maxSurgeBuilder_.dispose();
          maxSurgeBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment build() {
        io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment buildPartial() {
        io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment result = new io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.maxUnavailable_ = maxUnavailableBuilder_ == null
              ? maxUnavailable_
              : maxUnavailableBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.maxSurge_ = maxSurgeBuilder_ == null
              ? maxSurge_
              : maxSurgeBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment other) {
        if (other == io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment.getDefaultInstance()) return this;
        if (other.hasMaxUnavailable()) {
          mergeMaxUnavailable(other.getMaxUnavailable());
        }
        if (other.hasMaxSurge()) {
          mergeMaxSurge(other.getMaxSurge());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMaxUnavailableFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getMaxSurgeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> maxUnavailableBuilder_;
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * Defaults to 25%.
       * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       * @return Whether the maxUnavailable field is set.
       */
      public boolean hasMaxUnavailable() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * Defaults to 25%.
       * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       * @return The maxUnavailable.
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
        if (maxUnavailableBuilder_ == null) {
          return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
        } else {
          return maxUnavailableBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * Defaults to 25%.
       * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxUnavailable_ = value;
        } else {
          maxUnavailableBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * Defaults to 25%.
       * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = builderForValue.build();
        } else {
          maxUnavailableBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * Defaults to 25%.
       * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder mergeMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            maxUnavailable_ != null &&
            maxUnavailable_ != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            getMaxUnavailableBuilder().mergeFrom(value);
          } else {
            maxUnavailable_ = value;
          }
        } else {
          maxUnavailableBuilder_.mergeFrom(value);
        }
        if (maxUnavailable_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * Defaults to 25%.
       * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder clearMaxUnavailable() {
        bitField0_ = (bitField0_ & ~0x00000001);
        maxUnavailable_ = null;
        if (maxUnavailableBuilder_ != null) {
          maxUnavailableBuilder_.dispose();
          maxUnavailableBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * Defaults to 25%.
       * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxUnavailableBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMaxUnavailableFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * Defaults to 25%.
       * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
        if (maxUnavailableBuilder_ != null) {
          return maxUnavailableBuilder_.getMessageOrBuilder();
        } else {
          return maxUnavailable_ == null ?
              io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
        }
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * Defaults to 25%.
       * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> 
          getMaxUnavailableFieldBuilder() {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailableBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxUnavailable(),
                  getParentForChildren(),
                  isClean());
          maxUnavailable_ = null;
        }
        return maxUnavailableBuilder_;
      }

      private io.kubernetes.client.proto.IntStr.IntOrString maxSurge_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> maxSurgeBuilder_;
      /**
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new ReplicaSet can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       * @return Whether the maxSurge field is set.
       */
      public boolean hasMaxSurge() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new ReplicaSet can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       * @return The maxSurge.
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge() {
        if (maxSurgeBuilder_ == null) {
          return maxSurge_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxSurge_;
        } else {
          return maxSurgeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new ReplicaSet can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder setMaxSurge(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxSurgeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxSurge_ = value;
        } else {
          maxSurgeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new ReplicaSet can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder setMaxSurge(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxSurgeBuilder_ == null) {
          maxSurge_ = builderForValue.build();
        } else {
          maxSurgeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new ReplicaSet can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder mergeMaxSurge(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxSurgeBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            maxSurge_ != null &&
            maxSurge_ != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            getMaxSurgeBuilder().mergeFrom(value);
          } else {
            maxSurge_ = value;
          }
        } else {
          maxSurgeBuilder_.mergeFrom(value);
        }
        if (maxSurge_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new ReplicaSet can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder clearMaxSurge() {
        bitField0_ = (bitField0_ & ~0x00000002);
        maxSurge_ = null;
        if (maxSurgeBuilder_ != null) {
          maxSurgeBuilder_.dispose();
          maxSurgeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new ReplicaSet can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxSurgeBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getMaxSurgeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new ReplicaSet can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder() {
        if (maxSurgeBuilder_ != null) {
          return maxSurgeBuilder_.getMessageOrBuilder();
        } else {
          return maxSurge_ == null ?
              io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxSurge_;
        }
      }
      /**
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new ReplicaSet can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> 
          getMaxSurgeFieldBuilder() {
        if (maxSurgeBuilder_ == null) {
          maxSurgeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxSurge(),
                  getParentForChildren(),
                  isClean());
          maxSurge_ = null;
        }
        return maxSurgeBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.RollingUpdateDeployment)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.RollingUpdateDeployment)
    private static final io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment();
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RollingUpdateDeployment>
        PARSER = new com.google.protobuf.AbstractParser<RollingUpdateDeployment>() {
      @java.lang.Override
      public RollingUpdateDeployment parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<RollingUpdateDeployment> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RollingUpdateDeployment> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.RollingUpdateDeployment getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RollingUpdateStatefulSetStrategyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Partition indicates the ordinal at which the StatefulSet should be partitioned
     * for updates. During a rolling update, all pods from ordinal Replicas-1 to
     * Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
     * This is helpful in being able to do a canary based deployment. The default value is 0.
     * +optional
     * </pre>
     *
     * <code>optional int32 partition = 1;</code>
     * @return Whether the partition field is set.
     */
    boolean hasPartition();
    /**
     * <pre>
     * Partition indicates the ordinal at which the StatefulSet should be partitioned
     * for updates. During a rolling update, all pods from ordinal Replicas-1 to
     * Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
     * This is helpful in being able to do a canary based deployment. The default value is 0.
     * +optional
     * </pre>
     *
     * <code>optional int32 partition = 1;</code>
     * @return The partition.
     */
    int getPartition();

    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding up. This can not be 0.
     * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
     * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
     * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
     * will be counted towards MaxUnavailable.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
     * @return Whether the maxUnavailable field is set.
     */
    boolean hasMaxUnavailable();
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding up. This can not be 0.
     * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
     * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
     * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
     * will be counted towards MaxUnavailable.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
     * @return The maxUnavailable.
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable();
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding up. This can not be 0.
     * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
     * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
     * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
     * will be counted towards MaxUnavailable.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder();
  }
  /**
   * <pre>
   * RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy}
   */
  public static final class RollingUpdateStatefulSetStrategy extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy)
      RollingUpdateStatefulSetStrategyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        RollingUpdateStatefulSetStrategy.class.getName());
    }
    // Use RollingUpdateStatefulSetStrategy.newBuilder() to construct.
    private RollingUpdateStatefulSetStrategy(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private RollingUpdateStatefulSetStrategy() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.class, io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.Builder.class);
    }

    private int bitField0_;
    public static final int PARTITION_FIELD_NUMBER = 1;
    private int partition_ = 0;
    /**
     * <pre>
     * Partition indicates the ordinal at which the StatefulSet should be partitioned
     * for updates. During a rolling update, all pods from ordinal Replicas-1 to
     * Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
     * This is helpful in being able to do a canary based deployment. The default value is 0.
     * +optional
     * </pre>
     *
     * <code>optional int32 partition = 1;</code>
     * @return Whether the partition field is set.
     */
    @java.lang.Override
    public boolean hasPartition() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Partition indicates the ordinal at which the StatefulSet should be partitioned
     * for updates. During a rolling update, all pods from ordinal Replicas-1 to
     * Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
     * This is helpful in being able to do a canary based deployment. The default value is 0.
     * +optional
     * </pre>
     *
     * <code>optional int32 partition = 1;</code>
     * @return The partition.
     */
    @java.lang.Override
    public int getPartition() {
      return partition_;
    }

    public static final int MAXUNAVAILABLE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_;
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding up. This can not be 0.
     * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
     * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
     * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
     * will be counted towards MaxUnavailable.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
     * @return Whether the maxUnavailable field is set.
     */
    @java.lang.Override
    public boolean hasMaxUnavailable() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding up. This can not be 0.
     * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
     * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
     * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
     * will be counted towards MaxUnavailable.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
     * @return The maxUnavailable.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
      return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
    }
    /**
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding up. This can not be 0.
     * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
     * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
     * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
     * will be counted towards MaxUnavailable.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
      return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, partition_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getMaxUnavailable());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, partition_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMaxUnavailable());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy other = (io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy) obj;

      if (hasPartition() != other.hasPartition()) return false;
      if (hasPartition()) {
        if (getPartition()
            != other.getPartition()) return false;
      }
      if (hasMaxUnavailable() != other.hasMaxUnavailable()) return false;
      if (hasMaxUnavailable()) {
        if (!getMaxUnavailable()
            .equals(other.getMaxUnavailable())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPartition()) {
        hash = (37 * hash) + PARTITION_FIELD_NUMBER;
        hash = (53 * hash) + getPartition();
      }
      if (hasMaxUnavailable()) {
        hash = (37 * hash) + MAXUNAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxUnavailable().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy)
        io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.class, io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMaxUnavailableFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        partition_ = 0;
        maxUnavailable_ = null;
        if (maxUnavailableBuilder_ != null) {
          maxUnavailableBuilder_.dispose();
          maxUnavailableBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy build() {
        io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy buildPartial() {
        io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy result = new io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.partition_ = partition_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.maxUnavailable_ = maxUnavailableBuilder_ == null
              ? maxUnavailable_
              : maxUnavailableBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy other) {
        if (other == io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.getDefaultInstance()) return this;
        if (other.hasPartition()) {
          setPartition(other.getPartition());
        }
        if (other.hasMaxUnavailable()) {
          mergeMaxUnavailable(other.getMaxUnavailable());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                partition_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                input.readMessage(
                    getMaxUnavailableFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int partition_ ;
      /**
       * <pre>
       * Partition indicates the ordinal at which the StatefulSet should be partitioned
       * for updates. During a rolling update, all pods from ordinal Replicas-1 to
       * Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
       * This is helpful in being able to do a canary based deployment. The default value is 0.
       * +optional
       * </pre>
       *
       * <code>optional int32 partition = 1;</code>
       * @return Whether the partition field is set.
       */
      @java.lang.Override
      public boolean hasPartition() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Partition indicates the ordinal at which the StatefulSet should be partitioned
       * for updates. During a rolling update, all pods from ordinal Replicas-1 to
       * Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
       * This is helpful in being able to do a canary based deployment. The default value is 0.
       * +optional
       * </pre>
       *
       * <code>optional int32 partition = 1;</code>
       * @return The partition.
       */
      @java.lang.Override
      public int getPartition() {
        return partition_;
      }
      /**
       * <pre>
       * Partition indicates the ordinal at which the StatefulSet should be partitioned
       * for updates. During a rolling update, all pods from ordinal Replicas-1 to
       * Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
       * This is helpful in being able to do a canary based deployment. The default value is 0.
       * +optional
       * </pre>
       *
       * <code>optional int32 partition = 1;</code>
       * @param value The partition to set.
       * @return This builder for chaining.
       */
      public Builder setPartition(int value) {

        partition_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Partition indicates the ordinal at which the StatefulSet should be partitioned
       * for updates. During a rolling update, all pods from ordinal Replicas-1 to
       * Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
       * This is helpful in being able to do a canary based deployment. The default value is 0.
       * +optional
       * </pre>
       *
       * <code>optional int32 partition = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartition() {
        bitField0_ = (bitField0_ & ~0x00000001);
        partition_ = 0;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> maxUnavailableBuilder_;
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding up. This can not be 0.
       * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
       * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
       * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
       * will be counted towards MaxUnavailable.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
       * @return Whether the maxUnavailable field is set.
       */
      public boolean hasMaxUnavailable() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding up. This can not be 0.
       * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
       * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
       * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
       * will be counted towards MaxUnavailable.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
       * @return The maxUnavailable.
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
        if (maxUnavailableBuilder_ == null) {
          return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
        } else {
          return maxUnavailableBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding up. This can not be 0.
       * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
       * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
       * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
       * will be counted towards MaxUnavailable.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
       */
      public Builder setMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxUnavailable_ = value;
        } else {
          maxUnavailableBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding up. This can not be 0.
       * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
       * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
       * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
       * will be counted towards MaxUnavailable.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
       */
      public Builder setMaxUnavailable(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = builderForValue.build();
        } else {
          maxUnavailableBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding up. This can not be 0.
       * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
       * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
       * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
       * will be counted towards MaxUnavailable.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
       */
      public Builder mergeMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            maxUnavailable_ != null &&
            maxUnavailable_ != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            getMaxUnavailableBuilder().mergeFrom(value);
          } else {
            maxUnavailable_ = value;
          }
        } else {
          maxUnavailableBuilder_.mergeFrom(value);
        }
        if (maxUnavailable_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding up. This can not be 0.
       * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
       * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
       * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
       * will be counted towards MaxUnavailable.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
       */
      public Builder clearMaxUnavailable() {
        bitField0_ = (bitField0_ & ~0x00000002);
        maxUnavailable_ = null;
        if (maxUnavailableBuilder_ != null) {
          maxUnavailableBuilder_.dispose();
          maxUnavailableBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding up. This can not be 0.
       * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
       * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
       * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
       * will be counted towards MaxUnavailable.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxUnavailableBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getMaxUnavailableFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding up. This can not be 0.
       * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
       * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
       * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
       * will be counted towards MaxUnavailable.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
        if (maxUnavailableBuilder_ != null) {
          return maxUnavailableBuilder_.getMessageOrBuilder();
        } else {
          return maxUnavailable_ == null ?
              io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
        }
      }
      /**
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding up. This can not be 0.
       * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
       * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
       * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
       * will be counted towards MaxUnavailable.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> 
          getMaxUnavailableFieldBuilder() {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailableBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxUnavailable(),
                  getParentForChildren(),
                  isClean());
          maxUnavailable_ = null;
        }
        return maxUnavailableBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy)
    private static final io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy();
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RollingUpdateStatefulSetStrategy>
        PARSER = new com.google.protobuf.AbstractParser<RollingUpdateStatefulSetStrategy>() {
      @java.lang.Override
      public RollingUpdateStatefulSetStrategy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<RollingUpdateStatefulSetStrategy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RollingUpdateStatefulSetStrategy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatefulSetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.StatefulSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Spec defines the desired identities of pods in this set.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    boolean hasSpec();
    /**
     * <pre>
     * Spec defines the desired identities of pods in this set.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
     * @return The spec.
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetSpec getSpec();
    /**
     * <pre>
     * Spec defines the desired identities of pods in this set.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetSpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * Status is the current status of Pods in this StatefulSet. This data
     * may be out of date by some window of time.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * Status is the current status of Pods in this StatefulSet. This data
     * may be out of date by some window of time.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
     * @return The status.
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetStatus getStatus();
    /**
     * <pre>
     * Status is the current status of Pods in this StatefulSet. This data
     * may be out of date by some window of time.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * StatefulSet represents a set of pods with consistent identities.
   * Identities are defined as:
   * - Network: A single stable DNS and hostname.
   * - Storage: As many VolumeClaims as requested.
   *
   * The StatefulSet guarantees that a given network identity will always
   * map to the same storage identity.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.StatefulSet}
   */
  public static final class StatefulSet extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.StatefulSet)
      StatefulSetOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatefulSet.class.getName());
    }
    // Use StatefulSet.newBuilder() to construct.
    private StatefulSet(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatefulSet() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSet_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.StatefulSet.class, io.kubernetes.client.proto.V1Apps.StatefulSet.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Apps.StatefulSetSpec spec_;
    /**
     * <pre>
     * Spec defines the desired identities of pods in this set.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    @java.lang.Override
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Spec defines the desired identities of pods in this set.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
     * @return The spec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Spec defines the desired identities of pods in this set.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetSpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Apps.StatefulSetStatus status_;
    /**
     * <pre>
     * Status is the current status of Pods in this StatefulSet. This data
     * may be out of date by some window of time.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Status is the current status of Pods in this StatefulSet. This data
     * may be out of date by some window of time.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
     * @return The status.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * Status is the current status of Pods in this StatefulSet. This data
     * may be out of date by some window of time.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getStatus());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.StatefulSet)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.StatefulSet other = (io.kubernetes.client.proto.V1Apps.StatefulSet) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasSpec() != other.hasSpec()) return false;
      if (hasSpec()) {
        if (!getSpec()
            .equals(other.getSpec())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.StatefulSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StatefulSet represents a set of pods with consistent identities.
     * Identities are defined as:
     * - Network: A single stable DNS and hostname.
     * - Storage: As many VolumeClaims as requested.
     *
     * The StatefulSet guarantees that a given network identity will always
     * map to the same storage identity.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.StatefulSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.StatefulSet)
        io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSet_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.StatefulSet.class, io.kubernetes.client.proto.V1Apps.StatefulSet.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.StatefulSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSet_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSet getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.StatefulSet.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSet build() {
        io.kubernetes.client.proto.V1Apps.StatefulSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSet buildPartial() {
        io.kubernetes.client.proto.V1Apps.StatefulSet result = new io.kubernetes.client.proto.V1Apps.StatefulSet(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.StatefulSet result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.spec_ = specBuilder_ == null
              ? spec_
              : specBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.status_ = statusBuilder_ == null
              ? status_
              : statusBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.StatefulSet) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.StatefulSet)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.StatefulSet other) {
        if (other == io.kubernetes.client.proto.V1Apps.StatefulSet.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getStatusFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.StatefulSetSpec spec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetSpec, io.kubernetes.client.proto.V1Apps.StatefulSetSpec.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Spec defines the desired identities of pods in this set.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
       * @return Whether the spec field is set.
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Spec defines the desired identities of pods in this set.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
       * @return The spec.
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Spec defines the desired identities of pods in this set.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Apps.StatefulSetSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Spec defines the desired identities of pods in this set.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Apps.StatefulSetSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Spec defines the desired identities of pods in this set.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Apps.StatefulSetSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            spec_ != null &&
            spec_ != io.kubernetes.client.proto.V1Apps.StatefulSetSpec.getDefaultInstance()) {
            getSpecBuilder().mergeFrom(value);
          } else {
            spec_ = value;
          }
        } else {
          specBuilder_.mergeFrom(value);
        }
        if (spec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Spec defines the desired identities of pods in this set.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Spec defines the desired identities of pods in this set.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Spec defines the desired identities of pods in this set.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Apps.StatefulSetSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Spec defines the desired identities of pods in this set.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetSpec, io.kubernetes.client.proto.V1Apps.StatefulSetSpec.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.StatefulSetSpec, io.kubernetes.client.proto.V1Apps.StatefulSetSpec.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.StatefulSetStatus status_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetStatus, io.kubernetes.client.proto.V1Apps.StatefulSetStatus.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * Status is the current status of Pods in this StatefulSet. This data
       * may be out of date by some window of time.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Status is the current status of Pods in this StatefulSet. This data
       * may be out of date by some window of time.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
       * @return The status.
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Status is the current status of Pods in this StatefulSet. This data
       * may be out of date by some window of time.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1Apps.StatefulSetStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status is the current status of Pods in this StatefulSet. This data
       * may be out of date by some window of time.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1Apps.StatefulSetStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status is the current status of Pods in this StatefulSet. This data
       * may be out of date by some window of time.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1Apps.StatefulSetStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            status_ != null &&
            status_ != io.kubernetes.client.proto.V1Apps.StatefulSetStatus.getDefaultInstance()) {
            getStatusBuilder().mergeFrom(value);
          } else {
            status_ = value;
          }
        } else {
          statusBuilder_.mergeFrom(value);
        }
        if (status_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Status is the current status of Pods in this StatefulSet. This data
       * may be out of date by some window of time.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000004);
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status is the current status of Pods in this StatefulSet. This data
       * may be out of date by some window of time.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Status is the current status of Pods in this StatefulSet. This data
       * may be out of date by some window of time.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1Apps.StatefulSetStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * Status is the current status of Pods in this StatefulSet. This data
       * may be out of date by some window of time.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetStatus, io.kubernetes.client.proto.V1Apps.StatefulSetStatus.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.StatefulSetStatus, io.kubernetes.client.proto.V1Apps.StatefulSetStatus.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.StatefulSet)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.StatefulSet)
    private static final io.kubernetes.client.proto.V1Apps.StatefulSet DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.StatefulSet();
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatefulSet>
        PARSER = new com.google.protobuf.AbstractParser<StatefulSet>() {
      @java.lang.Override
      public StatefulSet parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatefulSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatefulSet> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatefulSetConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.StatefulSetCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of statefulset condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type of statefulset condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of statefulset condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    java.lang.String getStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    com.google.protobuf.ByteString
        getStatusBytes();

    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    boolean hasLastTransitionTime();
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return The lastTransitionTime.
     */
    io.kubernetes.client.proto.Meta.Time getLastTransitionTime();
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder();

    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * <pre>
   * StatefulSetCondition describes the state of a statefulset at a certain point.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetCondition}
   */
  public static final class StatefulSetCondition extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.StatefulSetCondition)
      StatefulSetConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatefulSetCondition.class.getName());
    }
    // Use StatefulSetCondition.newBuilder() to construct.
    private StatefulSetCondition(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatefulSetCondition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.StatefulSetCondition.class, io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <pre>
     * Type of statefulset condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Type of statefulset condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of statefulset condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object status_ = "";
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The status.
     */
    @java.lang.Override
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     * @return The bytes for status.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LASTTRANSITIONTIME_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return Whether the lastTransitionTime field is set.
     */
    @java.lang.Override
    public boolean hasLastTransitionTime() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     * @return The lastTransitionTime.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }
    /**
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, message_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, reason_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, message_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.StatefulSetCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.StatefulSetCondition other = (io.kubernetes.client.proto.V1Apps.StatefulSetCondition) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (hasLastTransitionTime() != other.hasLastTransitionTime()) return false;
      if (hasLastTransitionTime()) {
        if (!getLastTransitionTime()
            .equals(other.getLastTransitionTime())) return false;
      }
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasLastTransitionTime()) {
        hash = (37 * hash) + LASTTRANSITIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastTransitionTime().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.StatefulSetCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StatefulSetCondition describes the state of a statefulset at a certain point.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetCondition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.StatefulSetCondition)
        io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.StatefulSetCondition.class, io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.StatefulSetCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getLastTransitionTimeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        status_ = "";
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        reason_ = "";
        message_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetCondition getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.StatefulSetCondition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetCondition build() {
        io.kubernetes.client.proto.V1Apps.StatefulSetCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetCondition buildPartial() {
        io.kubernetes.client.proto.V1Apps.StatefulSetCondition result = new io.kubernetes.client.proto.V1Apps.StatefulSetCondition(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.StatefulSetCondition result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.lastTransitionTime_ = lastTransitionTimeBuilder_ == null
              ? lastTransitionTime_
              : lastTransitionTimeBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.StatefulSetCondition) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.StatefulSetCondition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.StatefulSetCondition other) {
        if (other == io.kubernetes.client.proto.V1Apps.StatefulSetCondition.getDefaultInstance()) return this;
        if (other.hasType()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasStatus()) {
          status_ = other.status_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasLastTransitionTime()) {
          mergeLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                status_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getLastTransitionTimeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                reason_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                message_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of statefulset condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Type of statefulset condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of statefulset condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of statefulset condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of statefulset condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of statefulset condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The status.
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return The bytes for status.
       */
      public com.google.protobuf.ByteString
          getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        status_ = getDefaultInstance().getStatus();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       * @param value The bytes for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastTransitionTimeBuilder_;
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       * @return Whether the lastTransitionTime field is set.
       */
      public boolean hasLastTransitionTime() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       * @return The lastTransitionTime.
       */
      public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        } else {
          return lastTransitionTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastTransitionTime_ = value;
        } else {
          lastTransitionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = builderForValue.build();
        } else {
          lastTransitionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder mergeLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            lastTransitionTime_ != null &&
            lastTransitionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            getLastTransitionTimeBuilder().mergeFrom(value);
          } else {
            lastTransitionTime_ = value;
          }
        } else {
          lastTransitionTimeBuilder_.mergeFrom(value);
        }
        if (lastTransitionTime_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder clearLastTransitionTime() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lastTransitionTime_ = null;
        if (lastTransitionTimeBuilder_ != null) {
          lastTransitionTimeBuilder_.dispose();
          lastTransitionTimeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastTransitionTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastTransitionTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
        if (lastTransitionTimeBuilder_ != null) {
          return lastTransitionTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastTransitionTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        }
      }
      /**
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastTransitionTimeFieldBuilder() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTimeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastTransitionTime(),
                  getParentForChildren(),
                  isClean());
          lastTransitionTime_ = null;
        }
        return lastTransitionTimeBuilder_;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.StatefulSetCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.StatefulSetCondition)
    private static final io.kubernetes.client.proto.V1Apps.StatefulSetCondition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.StatefulSetCondition();
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetCondition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatefulSetCondition>
        PARSER = new com.google.protobuf.AbstractParser<StatefulSetCondition>() {
      @java.lang.Override
      public StatefulSetCondition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatefulSetCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatefulSetCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetCondition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatefulSetListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.StatefulSetList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSet> 
        getItemsList();
    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.StatefulSet getItems(int index);
    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * StatefulSetList is a collection of StatefulSets.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetList}
   */
  public static final class StatefulSetList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.StatefulSetList)
      StatefulSetListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatefulSetList.class.getName());
    }
    // Use StatefulSetList.newBuilder() to construct.
    private StatefulSetList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatefulSetList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.StatefulSetList.class, io.kubernetes.client.proto.V1Apps.StatefulSetList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSet> items_;
    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSet> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSet getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * Items is the list of stateful sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.StatefulSetList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.StatefulSetList other = (io.kubernetes.client.proto.V1Apps.StatefulSetList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.StatefulSetList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StatefulSetList is a collection of StatefulSets.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.StatefulSetList)
        io.kubernetes.client.proto.V1Apps.StatefulSetListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.StatefulSetList.class, io.kubernetes.client.proto.V1Apps.StatefulSetList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.StatefulSetList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.StatefulSetList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetList build() {
        io.kubernetes.client.proto.V1Apps.StatefulSetList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetList buildPartial() {
        io.kubernetes.client.proto.V1Apps.StatefulSetList result = new io.kubernetes.client.proto.V1Apps.StatefulSetList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.StatefulSetList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.StatefulSetList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.StatefulSetList) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.StatefulSetList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.StatefulSetList other) {
        if (other == io.kubernetes.client.proto.V1Apps.StatefulSetList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1Apps.StatefulSet m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Apps.StatefulSet.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSet> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.StatefulSet>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSet, io.kubernetes.client.proto.V1Apps.StatefulSet.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSet> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSet getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.StatefulSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.StatefulSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Apps.StatefulSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.StatefulSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Apps.StatefulSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.StatefulSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.StatefulSet> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSet.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSet.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.StatefulSet.getDefaultInstance());
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSet.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.StatefulSet.getDefaultInstance());
      }
      /**
       * <pre>
       * Items is the list of stateful sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSet.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSet, io.kubernetes.client.proto.V1Apps.StatefulSet.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Apps.StatefulSet, io.kubernetes.client.proto.V1Apps.StatefulSet.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.StatefulSetList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.StatefulSetList)
    private static final io.kubernetes.client.proto.V1Apps.StatefulSetList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.StatefulSetList();
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatefulSetList>
        PARSER = new com.google.protobuf.AbstractParser<StatefulSetList>() {
      @java.lang.Override
      public StatefulSetList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatefulSetList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatefulSetList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatefulSetOrdinalsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.StatefulSetOrdinals)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * start is the number representing the first replica's index. It may be used
     * to number replicas from an alternate index (eg: 1-indexed) over the default
     * 0-indexed names, or to orchestrate progressive movement of replicas from
     * one StatefulSet to another.
     * If set, replica indices will be in the range:
     * [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).
     * If unset, defaults to 0. Replica indices will be in the range:
     * [0, .spec.replicas).
     * +optional
     * </pre>
     *
     * <code>optional int32 start = 1;</code>
     * @return Whether the start field is set.
     */
    boolean hasStart();
    /**
     * <pre>
     * start is the number representing the first replica's index. It may be used
     * to number replicas from an alternate index (eg: 1-indexed) over the default
     * 0-indexed names, or to orchestrate progressive movement of replicas from
     * one StatefulSet to another.
     * If set, replica indices will be in the range:
     * [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).
     * If unset, defaults to 0. Replica indices will be in the range:
     * [0, .spec.replicas).
     * +optional
     * </pre>
     *
     * <code>optional int32 start = 1;</code>
     * @return The start.
     */
    int getStart();
  }
  /**
   * <pre>
   * StatefulSetOrdinals describes the policy used for replica ordinal assignment
   * in this StatefulSet.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetOrdinals}
   */
  public static final class StatefulSetOrdinals extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.StatefulSetOrdinals)
      StatefulSetOrdinalsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatefulSetOrdinals.class.getName());
    }
    // Use StatefulSetOrdinals.newBuilder() to construct.
    private StatefulSetOrdinals(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatefulSetOrdinals() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.class, io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.Builder.class);
    }

    private int bitField0_;
    public static final int START_FIELD_NUMBER = 1;
    private int start_ = 0;
    /**
     * <pre>
     * start is the number representing the first replica's index. It may be used
     * to number replicas from an alternate index (eg: 1-indexed) over the default
     * 0-indexed names, or to orchestrate progressive movement of replicas from
     * one StatefulSet to another.
     * If set, replica indices will be in the range:
     * [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).
     * If unset, defaults to 0. Replica indices will be in the range:
     * [0, .spec.replicas).
     * +optional
     * </pre>
     *
     * <code>optional int32 start = 1;</code>
     * @return Whether the start field is set.
     */
    @java.lang.Override
    public boolean hasStart() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * start is the number representing the first replica's index. It may be used
     * to number replicas from an alternate index (eg: 1-indexed) over the default
     * 0-indexed names, or to orchestrate progressive movement of replicas from
     * one StatefulSet to another.
     * If set, replica indices will be in the range:
     * [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).
     * If unset, defaults to 0. Replica indices will be in the range:
     * [0, .spec.replicas).
     * +optional
     * </pre>
     *
     * <code>optional int32 start = 1;</code>
     * @return The start.
     */
    @java.lang.Override
    public int getStart() {
      return start_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, start_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, start_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals other = (io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals) obj;

      if (hasStart() != other.hasStart()) return false;
      if (hasStart()) {
        if (getStart()
            != other.getStart()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasStart()) {
        hash = (37 * hash) + START_FIELD_NUMBER;
        hash = (53 * hash) + getStart();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StatefulSetOrdinals describes the policy used for replica ordinal assignment
     * in this StatefulSet.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetOrdinals}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.StatefulSetOrdinals)
        io.kubernetes.client.proto.V1Apps.StatefulSetOrdinalsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.class, io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        start_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals build() {
        io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals buildPartial() {
        io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals result = new io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.start_ = start_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals other) {
        if (other == io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.getDefaultInstance()) return this;
        if (other.hasStart()) {
          setStart(other.getStart());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                start_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int start_ ;
      /**
       * <pre>
       * start is the number representing the first replica's index. It may be used
       * to number replicas from an alternate index (eg: 1-indexed) over the default
       * 0-indexed names, or to orchestrate progressive movement of replicas from
       * one StatefulSet to another.
       * If set, replica indices will be in the range:
       * [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).
       * If unset, defaults to 0. Replica indices will be in the range:
       * [0, .spec.replicas).
       * +optional
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return Whether the start field is set.
       */
      @java.lang.Override
      public boolean hasStart() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * start is the number representing the first replica's index. It may be used
       * to number replicas from an alternate index (eg: 1-indexed) over the default
       * 0-indexed names, or to orchestrate progressive movement of replicas from
       * one StatefulSet to another.
       * If set, replica indices will be in the range:
       * [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).
       * If unset, defaults to 0. Replica indices will be in the range:
       * [0, .spec.replicas).
       * +optional
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return The start.
       */
      @java.lang.Override
      public int getStart() {
        return start_;
      }
      /**
       * <pre>
       * start is the number representing the first replica's index. It may be used
       * to number replicas from an alternate index (eg: 1-indexed) over the default
       * 0-indexed names, or to orchestrate progressive movement of replicas from
       * one StatefulSet to another.
       * If set, replica indices will be in the range:
       * [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).
       * If unset, defaults to 0. Replica indices will be in the range:
       * [0, .spec.replicas).
       * +optional
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @param value The start to set.
       * @return This builder for chaining.
       */
      public Builder setStart(int value) {

        start_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * start is the number representing the first replica's index. It may be used
       * to number replicas from an alternate index (eg: 1-indexed) over the default
       * 0-indexed names, or to orchestrate progressive movement of replicas from
       * one StatefulSet to another.
       * If set, replica indices will be in the range:
       * [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).
       * If unset, defaults to 0. Replica indices will be in the range:
       * [0, .spec.replicas).
       * +optional
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStart() {
        bitField0_ = (bitField0_ & ~0x00000001);
        start_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.StatefulSetOrdinals)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.StatefulSetOrdinals)
    private static final io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals();
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatefulSetOrdinals>
        PARSER = new com.google.protobuf.AbstractParser<StatefulSetOrdinals>() {
      @java.lang.Override
      public StatefulSetOrdinals parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatefulSetOrdinals> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatefulSetOrdinals> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatefulSetPersistentVolumeClaimRetentionPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * WhenDeleted specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
     * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
     * `Delete` policy causes those PVCs to be deleted.
     * </pre>
     *
     * <code>optional string whenDeleted = 1;</code>
     * @return Whether the whenDeleted field is set.
     */
    boolean hasWhenDeleted();
    /**
     * <pre>
     * WhenDeleted specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
     * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
     * `Delete` policy causes those PVCs to be deleted.
     * </pre>
     *
     * <code>optional string whenDeleted = 1;</code>
     * @return The whenDeleted.
     */
    java.lang.String getWhenDeleted();
    /**
     * <pre>
     * WhenDeleted specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
     * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
     * `Delete` policy causes those PVCs to be deleted.
     * </pre>
     *
     * <code>optional string whenDeleted = 1;</code>
     * @return The bytes for whenDeleted.
     */
    com.google.protobuf.ByteString
        getWhenDeletedBytes();

    /**
     * <pre>
     * WhenScaled specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is scaled down. The default
     * policy of `Retain` causes PVCs to not be affected by a scaledown. The
     * `Delete` policy causes the associated PVCs for any excess pods above
     * the replica count to be deleted.
     * </pre>
     *
     * <code>optional string whenScaled = 2;</code>
     * @return Whether the whenScaled field is set.
     */
    boolean hasWhenScaled();
    /**
     * <pre>
     * WhenScaled specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is scaled down. The default
     * policy of `Retain` causes PVCs to not be affected by a scaledown. The
     * `Delete` policy causes the associated PVCs for any excess pods above
     * the replica count to be deleted.
     * </pre>
     *
     * <code>optional string whenScaled = 2;</code>
     * @return The whenScaled.
     */
    java.lang.String getWhenScaled();
    /**
     * <pre>
     * WhenScaled specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is scaled down. The default
     * policy of `Retain` causes PVCs to not be affected by a scaledown. The
     * `Delete` policy causes the associated PVCs for any excess pods above
     * the replica count to be deleted.
     * </pre>
     *
     * <code>optional string whenScaled = 2;</code>
     * @return The bytes for whenScaled.
     */
    com.google.protobuf.ByteString
        getWhenScaledBytes();
  }
  /**
   * <pre>
   * StatefulSetPersistentVolumeClaimRetentionPolicy describes the policy used for PVCs
   * created from the StatefulSet VolumeClaimTemplates.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy}
   */
  public static final class StatefulSetPersistentVolumeClaimRetentionPolicy extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy)
      StatefulSetPersistentVolumeClaimRetentionPolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatefulSetPersistentVolumeClaimRetentionPolicy.class.getName());
    }
    // Use StatefulSetPersistentVolumeClaimRetentionPolicy.newBuilder() to construct.
    private StatefulSetPersistentVolumeClaimRetentionPolicy(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatefulSetPersistentVolumeClaimRetentionPolicy() {
      whenDeleted_ = "";
      whenScaled_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.class, io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.Builder.class);
    }

    private int bitField0_;
    public static final int WHENDELETED_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object whenDeleted_ = "";
    /**
     * <pre>
     * WhenDeleted specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
     * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
     * `Delete` policy causes those PVCs to be deleted.
     * </pre>
     *
     * <code>optional string whenDeleted = 1;</code>
     * @return Whether the whenDeleted field is set.
     */
    @java.lang.Override
    public boolean hasWhenDeleted() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * WhenDeleted specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
     * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
     * `Delete` policy causes those PVCs to be deleted.
     * </pre>
     *
     * <code>optional string whenDeleted = 1;</code>
     * @return The whenDeleted.
     */
    @java.lang.Override
    public java.lang.String getWhenDeleted() {
      java.lang.Object ref = whenDeleted_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          whenDeleted_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * WhenDeleted specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
     * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
     * `Delete` policy causes those PVCs to be deleted.
     * </pre>
     *
     * <code>optional string whenDeleted = 1;</code>
     * @return The bytes for whenDeleted.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getWhenDeletedBytes() {
      java.lang.Object ref = whenDeleted_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        whenDeleted_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WHENSCALED_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object whenScaled_ = "";
    /**
     * <pre>
     * WhenScaled specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is scaled down. The default
     * policy of `Retain` causes PVCs to not be affected by a scaledown. The
     * `Delete` policy causes the associated PVCs for any excess pods above
     * the replica count to be deleted.
     * </pre>
     *
     * <code>optional string whenScaled = 2;</code>
     * @return Whether the whenScaled field is set.
     */
    @java.lang.Override
    public boolean hasWhenScaled() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * WhenScaled specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is scaled down. The default
     * policy of `Retain` causes PVCs to not be affected by a scaledown. The
     * `Delete` policy causes the associated PVCs for any excess pods above
     * the replica count to be deleted.
     * </pre>
     *
     * <code>optional string whenScaled = 2;</code>
     * @return The whenScaled.
     */
    @java.lang.Override
    public java.lang.String getWhenScaled() {
      java.lang.Object ref = whenScaled_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          whenScaled_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * WhenScaled specifies what happens to PVCs created from StatefulSet
     * VolumeClaimTemplates when the StatefulSet is scaled down. The default
     * policy of `Retain` causes PVCs to not be affected by a scaledown. The
     * `Delete` policy causes the associated PVCs for any excess pods above
     * the replica count to be deleted.
     * </pre>
     *
     * <code>optional string whenScaled = 2;</code>
     * @return The bytes for whenScaled.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getWhenScaledBytes() {
      java.lang.Object ref = whenScaled_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        whenScaled_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, whenDeleted_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, whenScaled_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, whenDeleted_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, whenScaled_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy other = (io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy) obj;

      if (hasWhenDeleted() != other.hasWhenDeleted()) return false;
      if (hasWhenDeleted()) {
        if (!getWhenDeleted()
            .equals(other.getWhenDeleted())) return false;
      }
      if (hasWhenScaled() != other.hasWhenScaled()) return false;
      if (hasWhenScaled()) {
        if (!getWhenScaled()
            .equals(other.getWhenScaled())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasWhenDeleted()) {
        hash = (37 * hash) + WHENDELETED_FIELD_NUMBER;
        hash = (53 * hash) + getWhenDeleted().hashCode();
      }
      if (hasWhenScaled()) {
        hash = (37 * hash) + WHENSCALED_FIELD_NUMBER;
        hash = (53 * hash) + getWhenScaled().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StatefulSetPersistentVolumeClaimRetentionPolicy describes the policy used for PVCs
     * created from the StatefulSet VolumeClaimTemplates.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy)
        io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.class, io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        whenDeleted_ = "";
        whenScaled_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy build() {
        io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy buildPartial() {
        io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy result = new io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.whenDeleted_ = whenDeleted_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.whenScaled_ = whenScaled_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy other) {
        if (other == io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.getDefaultInstance()) return this;
        if (other.hasWhenDeleted()) {
          whenDeleted_ = other.whenDeleted_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasWhenScaled()) {
          whenScaled_ = other.whenScaled_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                whenDeleted_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                whenScaled_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object whenDeleted_ = "";
      /**
       * <pre>
       * WhenDeleted specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
       * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
       * `Delete` policy causes those PVCs to be deleted.
       * </pre>
       *
       * <code>optional string whenDeleted = 1;</code>
       * @return Whether the whenDeleted field is set.
       */
      public boolean hasWhenDeleted() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * WhenDeleted specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
       * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
       * `Delete` policy causes those PVCs to be deleted.
       * </pre>
       *
       * <code>optional string whenDeleted = 1;</code>
       * @return The whenDeleted.
       */
      public java.lang.String getWhenDeleted() {
        java.lang.Object ref = whenDeleted_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            whenDeleted_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * WhenDeleted specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
       * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
       * `Delete` policy causes those PVCs to be deleted.
       * </pre>
       *
       * <code>optional string whenDeleted = 1;</code>
       * @return The bytes for whenDeleted.
       */
      public com.google.protobuf.ByteString
          getWhenDeletedBytes() {
        java.lang.Object ref = whenDeleted_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          whenDeleted_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * WhenDeleted specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
       * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
       * `Delete` policy causes those PVCs to be deleted.
       * </pre>
       *
       * <code>optional string whenDeleted = 1;</code>
       * @param value The whenDeleted to set.
       * @return This builder for chaining.
       */
      public Builder setWhenDeleted(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        whenDeleted_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * WhenDeleted specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
       * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
       * `Delete` policy causes those PVCs to be deleted.
       * </pre>
       *
       * <code>optional string whenDeleted = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearWhenDeleted() {
        whenDeleted_ = getDefaultInstance().getWhenDeleted();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * WhenDeleted specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
       * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
       * `Delete` policy causes those PVCs to be deleted.
       * </pre>
       *
       * <code>optional string whenDeleted = 1;</code>
       * @param value The bytes for whenDeleted to set.
       * @return This builder for chaining.
       */
      public Builder setWhenDeletedBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        whenDeleted_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object whenScaled_ = "";
      /**
       * <pre>
       * WhenScaled specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is scaled down. The default
       * policy of `Retain` causes PVCs to not be affected by a scaledown. The
       * `Delete` policy causes the associated PVCs for any excess pods above
       * the replica count to be deleted.
       * </pre>
       *
       * <code>optional string whenScaled = 2;</code>
       * @return Whether the whenScaled field is set.
       */
      public boolean hasWhenScaled() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * WhenScaled specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is scaled down. The default
       * policy of `Retain` causes PVCs to not be affected by a scaledown. The
       * `Delete` policy causes the associated PVCs for any excess pods above
       * the replica count to be deleted.
       * </pre>
       *
       * <code>optional string whenScaled = 2;</code>
       * @return The whenScaled.
       */
      public java.lang.String getWhenScaled() {
        java.lang.Object ref = whenScaled_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            whenScaled_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * WhenScaled specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is scaled down. The default
       * policy of `Retain` causes PVCs to not be affected by a scaledown. The
       * `Delete` policy causes the associated PVCs for any excess pods above
       * the replica count to be deleted.
       * </pre>
       *
       * <code>optional string whenScaled = 2;</code>
       * @return The bytes for whenScaled.
       */
      public com.google.protobuf.ByteString
          getWhenScaledBytes() {
        java.lang.Object ref = whenScaled_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          whenScaled_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * WhenScaled specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is scaled down. The default
       * policy of `Retain` causes PVCs to not be affected by a scaledown. The
       * `Delete` policy causes the associated PVCs for any excess pods above
       * the replica count to be deleted.
       * </pre>
       *
       * <code>optional string whenScaled = 2;</code>
       * @param value The whenScaled to set.
       * @return This builder for chaining.
       */
      public Builder setWhenScaled(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        whenScaled_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * WhenScaled specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is scaled down. The default
       * policy of `Retain` causes PVCs to not be affected by a scaledown. The
       * `Delete` policy causes the associated PVCs for any excess pods above
       * the replica count to be deleted.
       * </pre>
       *
       * <code>optional string whenScaled = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearWhenScaled() {
        whenScaled_ = getDefaultInstance().getWhenScaled();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * WhenScaled specifies what happens to PVCs created from StatefulSet
       * VolumeClaimTemplates when the StatefulSet is scaled down. The default
       * policy of `Retain` causes PVCs to not be affected by a scaledown. The
       * `Delete` policy causes the associated PVCs for any excess pods above
       * the replica count to be deleted.
       * </pre>
       *
       * <code>optional string whenScaled = 2;</code>
       * @param value The bytes for whenScaled to set.
       * @return This builder for chaining.
       */
      public Builder setWhenScaledBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        whenScaled_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy)
    private static final io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy();
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatefulSetPersistentVolumeClaimRetentionPolicy>
        PARSER = new com.google.protobuf.AbstractParser<StatefulSetPersistentVolumeClaimRetentionPolicy>() {
      @java.lang.Override
      public StatefulSetPersistentVolumeClaimRetentionPolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatefulSetPersistentVolumeClaimRetentionPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatefulSetPersistentVolumeClaimRetentionPolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatefulSetSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.StatefulSetSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * replicas is the desired number of replicas of the given Template.
     * These are replicas in the sense that they are instantiations of the
     * same Template, but individual replicas also have a consistent identity.
     * If unspecified, defaults to 1.
     * TODO: Consider a rename of this field.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return Whether the replicas field is set.
     */
    boolean hasReplicas();
    /**
     * <pre>
     * replicas is the desired number of replicas of the given Template.
     * These are replicas in the sense that they are instantiations of the
     * same Template, but individual replicas also have a consistent identity.
     * If unspecified, defaults to 1.
     * TODO: Consider a rename of this field.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return The replicas.
     */
    int getReplicas();

    /**
     * <pre>
     * selector is a label query over pods that should match the replica count.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return Whether the selector field is set.
     */
    boolean hasSelector();
    /**
     * <pre>
     * selector is a label query over pods that should match the replica count.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return The selector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     * <pre>
     * selector is a label query over pods that should match the replica count.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     * <pre>
     * template is the object that describes the pod that will be created if
     * insufficient replicas are detected. Each pod stamped out by the StatefulSet
     * will fulfill this Template, but have a unique identity from the rest
     * of the StatefulSet. Each pod will be named with the format
     * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
     * "web" with index number "3" would be named "web-3".
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return Whether the template field is set.
     */
    boolean hasTemplate();
    /**
     * <pre>
     * template is the object that describes the pod that will be created if
     * insufficient replicas are detected. Each pod stamped out by the StatefulSet
     * will fulfill this Template, but have a unique identity from the rest
     * of the StatefulSet. Each pod will be named with the format
     * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
     * "web" with index number "3" would be named "web-3".
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return The template.
     */
    io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate();
    /**
     * <pre>
     * template is the object that describes the pod that will be created if
     * insufficient replicas are detected. Each pod stamped out by the StatefulSet
     * will fulfill this Template, but have a unique identity from the rest
     * of the StatefulSet. Each pod will be named with the format
     * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
     * "web" with index number "3" would be named "web-3".
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder();

    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1.PersistentVolumeClaim> 
        getVolumeClaimTemplatesList();
    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    io.kubernetes.client.proto.V1.PersistentVolumeClaim getVolumeClaimTemplates(int index);
    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    int getVolumeClaimTemplatesCount();
    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1.PersistentVolumeClaimOrBuilder> 
        getVolumeClaimTemplatesOrBuilderList();
    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    io.kubernetes.client.proto.V1.PersistentVolumeClaimOrBuilder getVolumeClaimTemplatesOrBuilder(
        int index);

    /**
     * <pre>
     * serviceName is the name of the service that governs this StatefulSet.
     * This service must exist before the StatefulSet, and is responsible for
     * the network identity of the set. Pods get DNS/hostnames that follow the
     * pattern: pod-specific-string.serviceName.default.svc.cluster.local
     * where "pod-specific-string" is managed by the StatefulSet controller.
     * </pre>
     *
     * <code>optional string serviceName = 5;</code>
     * @return Whether the serviceName field is set.
     */
    boolean hasServiceName();
    /**
     * <pre>
     * serviceName is the name of the service that governs this StatefulSet.
     * This service must exist before the StatefulSet, and is responsible for
     * the network identity of the set. Pods get DNS/hostnames that follow the
     * pattern: pod-specific-string.serviceName.default.svc.cluster.local
     * where "pod-specific-string" is managed by the StatefulSet controller.
     * </pre>
     *
     * <code>optional string serviceName = 5;</code>
     * @return The serviceName.
     */
    java.lang.String getServiceName();
    /**
     * <pre>
     * serviceName is the name of the service that governs this StatefulSet.
     * This service must exist before the StatefulSet, and is responsible for
     * the network identity of the set. Pods get DNS/hostnames that follow the
     * pattern: pod-specific-string.serviceName.default.svc.cluster.local
     * where "pod-specific-string" is managed by the StatefulSet controller.
     * </pre>
     *
     * <code>optional string serviceName = 5;</code>
     * @return The bytes for serviceName.
     */
    com.google.protobuf.ByteString
        getServiceNameBytes();

    /**
     * <pre>
     * podManagementPolicy controls how pods are created during initial scale up,
     * when replacing pods on nodes, or when scaling down. The default policy is
     * `OrderedReady`, where pods are created in increasing order (pod-0, then
     * pod-1, etc) and the controller will wait until each pod is ready before
     * continuing. When scaling down, the pods are removed in the opposite order.
     * The alternative policy is `Parallel` which will create pods in parallel
     * to match the desired scale without waiting, and on scale down will delete
     * all pods at once.
     * +optional
     * </pre>
     *
     * <code>optional string podManagementPolicy = 6;</code>
     * @return Whether the podManagementPolicy field is set.
     */
    boolean hasPodManagementPolicy();
    /**
     * <pre>
     * podManagementPolicy controls how pods are created during initial scale up,
     * when replacing pods on nodes, or when scaling down. The default policy is
     * `OrderedReady`, where pods are created in increasing order (pod-0, then
     * pod-1, etc) and the controller will wait until each pod is ready before
     * continuing. When scaling down, the pods are removed in the opposite order.
     * The alternative policy is `Parallel` which will create pods in parallel
     * to match the desired scale without waiting, and on scale down will delete
     * all pods at once.
     * +optional
     * </pre>
     *
     * <code>optional string podManagementPolicy = 6;</code>
     * @return The podManagementPolicy.
     */
    java.lang.String getPodManagementPolicy();
    /**
     * <pre>
     * podManagementPolicy controls how pods are created during initial scale up,
     * when replacing pods on nodes, or when scaling down. The default policy is
     * `OrderedReady`, where pods are created in increasing order (pod-0, then
     * pod-1, etc) and the controller will wait until each pod is ready before
     * continuing. When scaling down, the pods are removed in the opposite order.
     * The alternative policy is `Parallel` which will create pods in parallel
     * to match the desired scale without waiting, and on scale down will delete
     * all pods at once.
     * +optional
     * </pre>
     *
     * <code>optional string podManagementPolicy = 6;</code>
     * @return The bytes for podManagementPolicy.
     */
    com.google.protobuf.ByteString
        getPodManagementPolicyBytes();

    /**
     * <pre>
     * updateStrategy indicates the StatefulSetUpdateStrategy that will be
     * employed to update Pods in the StatefulSet when a revision is made to
     * Template.
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
     * @return Whether the updateStrategy field is set.
     */
    boolean hasUpdateStrategy();
    /**
     * <pre>
     * updateStrategy indicates the StatefulSetUpdateStrategy that will be
     * employed to update Pods in the StatefulSet when a revision is made to
     * Template.
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
     * @return The updateStrategy.
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy getUpdateStrategy();
    /**
     * <pre>
     * updateStrategy indicates the StatefulSetUpdateStrategy that will be
     * employed to update Pods in the StatefulSet when a revision is made to
     * Template.
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategyOrBuilder getUpdateStrategyOrBuilder();

    /**
     * <pre>
     * revisionHistoryLimit is the maximum number of revisions that will
     * be maintained in the StatefulSet's revision history. The revision history
     * consists of all revisions not represented by a currently applied
     * StatefulSetSpec version. The default value is 10.
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 8;</code>
     * @return Whether the revisionHistoryLimit field is set.
     */
    boolean hasRevisionHistoryLimit();
    /**
     * <pre>
     * revisionHistoryLimit is the maximum number of revisions that will
     * be maintained in the StatefulSet's revision history. The revision history
     * consists of all revisions not represented by a currently applied
     * StatefulSetSpec version. The default value is 10.
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 8;</code>
     * @return The revisionHistoryLimit.
     */
    int getRevisionHistoryLimit();

    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 9;</code>
     * @return Whether the minReadySeconds field is set.
     */
    boolean hasMinReadySeconds();
    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 9;</code>
     * @return The minReadySeconds.
     */
    int getMinReadySeconds();

    /**
     * <pre>
     * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
     * volume claims created from volumeClaimTemplates. By default, all persistent
     * volume claims are created as needed and retained until manually deleted. This
     * policy allows the lifecycle to be altered, for example by deleting persistent
     * volume claims when their stateful set is deleted, or when their pod is scaled
     * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
     * which is alpha.  +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
     * @return Whether the persistentVolumeClaimRetentionPolicy field is set.
     */
    boolean hasPersistentVolumeClaimRetentionPolicy();
    /**
     * <pre>
     * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
     * volume claims created from volumeClaimTemplates. By default, all persistent
     * volume claims are created as needed and retained until manually deleted. This
     * policy allows the lifecycle to be altered, for example by deleting persistent
     * volume claims when their stateful set is deleted, or when their pod is scaled
     * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
     * which is alpha.  +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
     * @return The persistentVolumeClaimRetentionPolicy.
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy getPersistentVolumeClaimRetentionPolicy();
    /**
     * <pre>
     * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
     * volume claims created from volumeClaimTemplates. By default, all persistent
     * volume claims are created as needed and retained until manually deleted. This
     * policy allows the lifecycle to be altered, for example by deleting persistent
     * volume claims when their stateful set is deleted, or when their pod is scaled
     * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
     * which is alpha.  +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicyOrBuilder getPersistentVolumeClaimRetentionPolicyOrBuilder();

    /**
     * <pre>
     * ordinals controls the numbering of replica indices in a StatefulSet. The
     * default ordinals behavior assigns a "0" index to the first replica and
     * increments the index by one for each additional replica requested. Using
     * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
     * enabled, which is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
     * @return Whether the ordinals field is set.
     */
    boolean hasOrdinals();
    /**
     * <pre>
     * ordinals controls the numbering of replica indices in a StatefulSet. The
     * default ordinals behavior assigns a "0" index to the first replica and
     * increments the index by one for each additional replica requested. Using
     * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
     * enabled, which is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
     * @return The ordinals.
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals getOrdinals();
    /**
     * <pre>
     * ordinals controls the numbering of replica indices in a StatefulSet. The
     * default ordinals behavior assigns a "0" index to the first replica and
     * increments the index by one for each additional replica requested. Using
     * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
     * enabled, which is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetOrdinalsOrBuilder getOrdinalsOrBuilder();
  }
  /**
   * <pre>
   * A StatefulSetSpec is the specification of a StatefulSet.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetSpec}
   */
  public static final class StatefulSetSpec extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.StatefulSetSpec)
      StatefulSetSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatefulSetSpec.class.getName());
    }
    // Use StatefulSetSpec.newBuilder() to construct.
    private StatefulSetSpec(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatefulSetSpec() {
      volumeClaimTemplates_ = java.util.Collections.emptyList();
      serviceName_ = "";
      podManagementPolicy_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.StatefulSetSpec.class, io.kubernetes.client.proto.V1Apps.StatefulSetSpec.Builder.class);
    }

    private int bitField0_;
    public static final int REPLICAS_FIELD_NUMBER = 1;
    private int replicas_ = 0;
    /**
     * <pre>
     * replicas is the desired number of replicas of the given Template.
     * These are replicas in the sense that they are instantiations of the
     * same Template, but individual replicas also have a consistent identity.
     * If unspecified, defaults to 1.
     * TODO: Consider a rename of this field.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return Whether the replicas field is set.
     */
    @java.lang.Override
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * replicas is the desired number of replicas of the given Template.
     * These are replicas in the sense that they are instantiations of the
     * same Template, but individual replicas also have a consistent identity.
     * If unspecified, defaults to 1.
     * TODO: Consider a rename of this field.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     * @return The replicas.
     */
    @java.lang.Override
    public int getReplicas() {
      return replicas_;
    }

    public static final int SELECTOR_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     * <pre>
     * selector is a label query over pods that should match the replica count.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return Whether the selector field is set.
     */
    @java.lang.Override
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * selector is a label query over pods that should match the replica count.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     * @return The selector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }
    /**
     * <pre>
     * selector is a label query over pods that should match the replica count.
     * It must match the pod template's labels.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }

    public static final int TEMPLATE_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
    /**
     * <pre>
     * template is the object that describes the pod that will be created if
     * insufficient replicas are detected. Each pod stamped out by the StatefulSet
     * will fulfill this Template, but have a unique identity from the rest
     * of the StatefulSet. Each pod will be named with the format
     * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
     * "web" with index number "3" would be named "web-3".
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return Whether the template field is set.
     */
    @java.lang.Override
    public boolean hasTemplate() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * template is the object that describes the pod that will be created if
     * insufficient replicas are detected. Each pod stamped out by the StatefulSet
     * will fulfill this Template, but have a unique identity from the rest
     * of the StatefulSet. Each pod will be named with the format
     * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
     * "web" with index number "3" would be named "web-3".
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     * @return The template.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }
    /**
     * <pre>
     * template is the object that describes the pod that will be created if
     * insufficient replicas are detected. Each pod stamped out by the StatefulSet
     * will fulfill this Template, but have a unique identity from the rest
     * of the StatefulSet. Each pod will be named with the format
     * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
     * "web" with index number "3" would be named "web-3".
     * The only allowed template.spec.restartPolicy value is "Always".
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }

    public static final int VOLUMECLAIMTEMPLATES_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1.PersistentVolumeClaim> volumeClaimTemplates_;
    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1.PersistentVolumeClaim> getVolumeClaimTemplatesList() {
      return volumeClaimTemplates_;
    }
    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1.PersistentVolumeClaimOrBuilder> 
        getVolumeClaimTemplatesOrBuilderList() {
      return volumeClaimTemplates_;
    }
    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    @java.lang.Override
    public int getVolumeClaimTemplatesCount() {
      return volumeClaimTemplates_.size();
    }
    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PersistentVolumeClaim getVolumeClaimTemplates(int index) {
      return volumeClaimTemplates_.get(index);
    }
    /**
     * <pre>
     * volumeClaimTemplates is a list of claims that pods are allowed to reference.
     * The StatefulSet controller is responsible for mapping network identities to
     * claims in a way that maintains the identity of a pod. Every claim in
     * this list must have at least one matching (by name) volumeMount in one
     * container in the template. A claim in this list takes precedence over
     * any volumes in the template, with the same name.
     * TODO: Define the behavior if a claim already exists with the same name.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1.PersistentVolumeClaimOrBuilder getVolumeClaimTemplatesOrBuilder(
        int index) {
      return volumeClaimTemplates_.get(index);
    }

    public static final int SERVICENAME_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object serviceName_ = "";
    /**
     * <pre>
     * serviceName is the name of the service that governs this StatefulSet.
     * This service must exist before the StatefulSet, and is responsible for
     * the network identity of the set. Pods get DNS/hostnames that follow the
     * pattern: pod-specific-string.serviceName.default.svc.cluster.local
     * where "pod-specific-string" is managed by the StatefulSet controller.
     * </pre>
     *
     * <code>optional string serviceName = 5;</code>
     * @return Whether the serviceName field is set.
     */
    @java.lang.Override
    public boolean hasServiceName() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * serviceName is the name of the service that governs this StatefulSet.
     * This service must exist before the StatefulSet, and is responsible for
     * the network identity of the set. Pods get DNS/hostnames that follow the
     * pattern: pod-specific-string.serviceName.default.svc.cluster.local
     * where "pod-specific-string" is managed by the StatefulSet controller.
     * </pre>
     *
     * <code>optional string serviceName = 5;</code>
     * @return The serviceName.
     */
    @java.lang.Override
    public java.lang.String getServiceName() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          serviceName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * serviceName is the name of the service that governs this StatefulSet.
     * This service must exist before the StatefulSet, and is responsible for
     * the network identity of the set. Pods get DNS/hostnames that follow the
     * pattern: pod-specific-string.serviceName.default.svc.cluster.local
     * where "pod-specific-string" is managed by the StatefulSet controller.
     * </pre>
     *
     * <code>optional string serviceName = 5;</code>
     * @return The bytes for serviceName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServiceNameBytes() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serviceName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PODMANAGEMENTPOLICY_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object podManagementPolicy_ = "";
    /**
     * <pre>
     * podManagementPolicy controls how pods are created during initial scale up,
     * when replacing pods on nodes, or when scaling down. The default policy is
     * `OrderedReady`, where pods are created in increasing order (pod-0, then
     * pod-1, etc) and the controller will wait until each pod is ready before
     * continuing. When scaling down, the pods are removed in the opposite order.
     * The alternative policy is `Parallel` which will create pods in parallel
     * to match the desired scale without waiting, and on scale down will delete
     * all pods at once.
     * +optional
     * </pre>
     *
     * <code>optional string podManagementPolicy = 6;</code>
     * @return Whether the podManagementPolicy field is set.
     */
    @java.lang.Override
    public boolean hasPodManagementPolicy() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * podManagementPolicy controls how pods are created during initial scale up,
     * when replacing pods on nodes, or when scaling down. The default policy is
     * `OrderedReady`, where pods are created in increasing order (pod-0, then
     * pod-1, etc) and the controller will wait until each pod is ready before
     * continuing. When scaling down, the pods are removed in the opposite order.
     * The alternative policy is `Parallel` which will create pods in parallel
     * to match the desired scale without waiting, and on scale down will delete
     * all pods at once.
     * +optional
     * </pre>
     *
     * <code>optional string podManagementPolicy = 6;</code>
     * @return The podManagementPolicy.
     */
    @java.lang.Override
    public java.lang.String getPodManagementPolicy() {
      java.lang.Object ref = podManagementPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          podManagementPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * podManagementPolicy controls how pods are created during initial scale up,
     * when replacing pods on nodes, or when scaling down. The default policy is
     * `OrderedReady`, where pods are created in increasing order (pod-0, then
     * pod-1, etc) and the controller will wait until each pod is ready before
     * continuing. When scaling down, the pods are removed in the opposite order.
     * The alternative policy is `Parallel` which will create pods in parallel
     * to match the desired scale without waiting, and on scale down will delete
     * all pods at once.
     * +optional
     * </pre>
     *
     * <code>optional string podManagementPolicy = 6;</code>
     * @return The bytes for podManagementPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPodManagementPolicyBytes() {
      java.lang.Object ref = podManagementPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        podManagementPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UPDATESTRATEGY_FIELD_NUMBER = 7;
    private io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy updateStrategy_;
    /**
     * <pre>
     * updateStrategy indicates the StatefulSetUpdateStrategy that will be
     * employed to update Pods in the StatefulSet when a revision is made to
     * Template.
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
     * @return Whether the updateStrategy field is set.
     */
    @java.lang.Override
    public boolean hasUpdateStrategy() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * updateStrategy indicates the StatefulSetUpdateStrategy that will be
     * employed to update Pods in the StatefulSet when a revision is made to
     * Template.
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
     * @return The updateStrategy.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy getUpdateStrategy() {
      return updateStrategy_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
    }
    /**
     * <pre>
     * updateStrategy indicates the StatefulSetUpdateStrategy that will be
     * employed to update Pods in the StatefulSet when a revision is made to
     * Template.
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategyOrBuilder getUpdateStrategyOrBuilder() {
      return updateStrategy_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
    }

    public static final int REVISIONHISTORYLIMIT_FIELD_NUMBER = 8;
    private int revisionHistoryLimit_ = 0;
    /**
     * <pre>
     * revisionHistoryLimit is the maximum number of revisions that will
     * be maintained in the StatefulSet's revision history. The revision history
     * consists of all revisions not represented by a currently applied
     * StatefulSetSpec version. The default value is 10.
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 8;</code>
     * @return Whether the revisionHistoryLimit field is set.
     */
    @java.lang.Override
    public boolean hasRevisionHistoryLimit() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * revisionHistoryLimit is the maximum number of revisions that will
     * be maintained in the StatefulSet's revision history. The revision history
     * consists of all revisions not represented by a currently applied
     * StatefulSetSpec version. The default value is 10.
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 8;</code>
     * @return The revisionHistoryLimit.
     */
    @java.lang.Override
    public int getRevisionHistoryLimit() {
      return revisionHistoryLimit_;
    }

    public static final int MINREADYSECONDS_FIELD_NUMBER = 9;
    private int minReadySeconds_ = 0;
    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 9;</code>
     * @return Whether the minReadySeconds field is set.
     */
    @java.lang.Override
    public boolean hasMinReadySeconds() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 9;</code>
     * @return The minReadySeconds.
     */
    @java.lang.Override
    public int getMinReadySeconds() {
      return minReadySeconds_;
    }

    public static final int PERSISTENTVOLUMECLAIMRETENTIONPOLICY_FIELD_NUMBER = 10;
    private io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy_;
    /**
     * <pre>
     * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
     * volume claims created from volumeClaimTemplates. By default, all persistent
     * volume claims are created as needed and retained until manually deleted. This
     * policy allows the lifecycle to be altered, for example by deleting persistent
     * volume claims when their stateful set is deleted, or when their pod is scaled
     * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
     * which is alpha.  +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
     * @return Whether the persistentVolumeClaimRetentionPolicy field is set.
     */
    @java.lang.Override
    public boolean hasPersistentVolumeClaimRetentionPolicy() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
     * volume claims created from volumeClaimTemplates. By default, all persistent
     * volume claims are created as needed and retained until manually deleted. This
     * policy allows the lifecycle to be altered, for example by deleting persistent
     * volume claims when their stateful set is deleted, or when their pod is scaled
     * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
     * which is alpha.  +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
     * @return The persistentVolumeClaimRetentionPolicy.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy getPersistentVolumeClaimRetentionPolicy() {
      return persistentVolumeClaimRetentionPolicy_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.getDefaultInstance() : persistentVolumeClaimRetentionPolicy_;
    }
    /**
     * <pre>
     * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
     * volume claims created from volumeClaimTemplates. By default, all persistent
     * volume claims are created as needed and retained until manually deleted. This
     * policy allows the lifecycle to be altered, for example by deleting persistent
     * volume claims when their stateful set is deleted, or when their pod is scaled
     * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
     * which is alpha.  +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicyOrBuilder getPersistentVolumeClaimRetentionPolicyOrBuilder() {
      return persistentVolumeClaimRetentionPolicy_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.getDefaultInstance() : persistentVolumeClaimRetentionPolicy_;
    }

    public static final int ORDINALS_FIELD_NUMBER = 11;
    private io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals ordinals_;
    /**
     * <pre>
     * ordinals controls the numbering of replica indices in a StatefulSet. The
     * default ordinals behavior assigns a "0" index to the first replica and
     * increments the index by one for each additional replica requested. Using
     * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
     * enabled, which is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
     * @return Whether the ordinals field is set.
     */
    @java.lang.Override
    public boolean hasOrdinals() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * ordinals controls the numbering of replica indices in a StatefulSet. The
     * default ordinals behavior assigns a "0" index to the first replica and
     * increments the index by one for each additional replica requested. Using
     * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
     * enabled, which is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
     * @return The ordinals.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals getOrdinals() {
      return ordinals_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.getDefaultInstance() : ordinals_;
    }
    /**
     * <pre>
     * ordinals controls the numbering of replica indices in a StatefulSet. The
     * default ordinals behavior assigns a "0" index to the first replica and
     * increments the index by one for each additional replica requested. Using
     * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
     * enabled, which is beta.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetOrdinalsOrBuilder getOrdinalsOrBuilder() {
      return ordinals_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.getDefaultInstance() : ordinals_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSelector());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getTemplate());
      }
      for (int i = 0; i < volumeClaimTemplates_.size(); i++) {
        output.writeMessage(4, volumeClaimTemplates_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, serviceName_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, podManagementPolicy_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(7, getUpdateStrategy());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeInt32(8, revisionHistoryLimit_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt32(9, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(10, getPersistentVolumeClaimRetentionPolicy());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeMessage(11, getOrdinals());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSelector());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getTemplate());
      }
      for (int i = 0; i < volumeClaimTemplates_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, volumeClaimTemplates_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, serviceName_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, podManagementPolicy_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getUpdateStrategy());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, revisionHistoryLimit_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getPersistentVolumeClaimRetentionPolicy());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getOrdinals());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.StatefulSetSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.StatefulSetSpec other = (io.kubernetes.client.proto.V1Apps.StatefulSetSpec) obj;

      if (hasReplicas() != other.hasReplicas()) return false;
      if (hasReplicas()) {
        if (getReplicas()
            != other.getReplicas()) return false;
      }
      if (hasSelector() != other.hasSelector()) return false;
      if (hasSelector()) {
        if (!getSelector()
            .equals(other.getSelector())) return false;
      }
      if (hasTemplate() != other.hasTemplate()) return false;
      if (hasTemplate()) {
        if (!getTemplate()
            .equals(other.getTemplate())) return false;
      }
      if (!getVolumeClaimTemplatesList()
          .equals(other.getVolumeClaimTemplatesList())) return false;
      if (hasServiceName() != other.hasServiceName()) return false;
      if (hasServiceName()) {
        if (!getServiceName()
            .equals(other.getServiceName())) return false;
      }
      if (hasPodManagementPolicy() != other.hasPodManagementPolicy()) return false;
      if (hasPodManagementPolicy()) {
        if (!getPodManagementPolicy()
            .equals(other.getPodManagementPolicy())) return false;
      }
      if (hasUpdateStrategy() != other.hasUpdateStrategy()) return false;
      if (hasUpdateStrategy()) {
        if (!getUpdateStrategy()
            .equals(other.getUpdateStrategy())) return false;
      }
      if (hasRevisionHistoryLimit() != other.hasRevisionHistoryLimit()) return false;
      if (hasRevisionHistoryLimit()) {
        if (getRevisionHistoryLimit()
            != other.getRevisionHistoryLimit()) return false;
      }
      if (hasMinReadySeconds() != other.hasMinReadySeconds()) return false;
      if (hasMinReadySeconds()) {
        if (getMinReadySeconds()
            != other.getMinReadySeconds()) return false;
      }
      if (hasPersistentVolumeClaimRetentionPolicy() != other.hasPersistentVolumeClaimRetentionPolicy()) return false;
      if (hasPersistentVolumeClaimRetentionPolicy()) {
        if (!getPersistentVolumeClaimRetentionPolicy()
            .equals(other.getPersistentVolumeClaimRetentionPolicy())) return false;
      }
      if (hasOrdinals() != other.hasOrdinals()) return false;
      if (hasOrdinals()) {
        if (!getOrdinals()
            .equals(other.getOrdinals())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasTemplate()) {
        hash = (37 * hash) + TEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplate().hashCode();
      }
      if (getVolumeClaimTemplatesCount() > 0) {
        hash = (37 * hash) + VOLUMECLAIMTEMPLATES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeClaimTemplatesList().hashCode();
      }
      if (hasServiceName()) {
        hash = (37 * hash) + SERVICENAME_FIELD_NUMBER;
        hash = (53 * hash) + getServiceName().hashCode();
      }
      if (hasPodManagementPolicy()) {
        hash = (37 * hash) + PODMANAGEMENTPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getPodManagementPolicy().hashCode();
      }
      if (hasUpdateStrategy()) {
        hash = (37 * hash) + UPDATESTRATEGY_FIELD_NUMBER;
        hash = (53 * hash) + getUpdateStrategy().hashCode();
      }
      if (hasRevisionHistoryLimit()) {
        hash = (37 * hash) + REVISIONHISTORYLIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getRevisionHistoryLimit();
      }
      if (hasMinReadySeconds()) {
        hash = (37 * hash) + MINREADYSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getMinReadySeconds();
      }
      if (hasPersistentVolumeClaimRetentionPolicy()) {
        hash = (37 * hash) + PERSISTENTVOLUMECLAIMRETENTIONPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getPersistentVolumeClaimRetentionPolicy().hashCode();
      }
      if (hasOrdinals()) {
        hash = (37 * hash) + ORDINALS_FIELD_NUMBER;
        hash = (53 * hash) + getOrdinals().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.StatefulSetSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A StatefulSetSpec is the specification of a StatefulSet.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.StatefulSetSpec)
        io.kubernetes.client.proto.V1Apps.StatefulSetSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.StatefulSetSpec.class, io.kubernetes.client.proto.V1Apps.StatefulSetSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.StatefulSetSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
          getTemplateFieldBuilder();
          getVolumeClaimTemplatesFieldBuilder();
          getUpdateStrategyFieldBuilder();
          getPersistentVolumeClaimRetentionPolicyFieldBuilder();
          getOrdinalsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        replicas_ = 0;
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        template_ = null;
        if (templateBuilder_ != null) {
          templateBuilder_.dispose();
          templateBuilder_ = null;
        }
        if (volumeClaimTemplatesBuilder_ == null) {
          volumeClaimTemplates_ = java.util.Collections.emptyList();
        } else {
          volumeClaimTemplates_ = null;
          volumeClaimTemplatesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        serviceName_ = "";
        podManagementPolicy_ = "";
        updateStrategy_ = null;
        if (updateStrategyBuilder_ != null) {
          updateStrategyBuilder_.dispose();
          updateStrategyBuilder_ = null;
        }
        revisionHistoryLimit_ = 0;
        minReadySeconds_ = 0;
        persistentVolumeClaimRetentionPolicy_ = null;
        if (persistentVolumeClaimRetentionPolicyBuilder_ != null) {
          persistentVolumeClaimRetentionPolicyBuilder_.dispose();
          persistentVolumeClaimRetentionPolicyBuilder_ = null;
        }
        ordinals_ = null;
        if (ordinalsBuilder_ != null) {
          ordinalsBuilder_.dispose();
          ordinalsBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.StatefulSetSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetSpec build() {
        io.kubernetes.client.proto.V1Apps.StatefulSetSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetSpec buildPartial() {
        io.kubernetes.client.proto.V1Apps.StatefulSetSpec result = new io.kubernetes.client.proto.V1Apps.StatefulSetSpec(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.StatefulSetSpec result) {
        if (volumeClaimTemplatesBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            volumeClaimTemplates_ = java.util.Collections.unmodifiableList(volumeClaimTemplates_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.volumeClaimTemplates_ = volumeClaimTemplates_;
        } else {
          result.volumeClaimTemplates_ = volumeClaimTemplatesBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.StatefulSetSpec result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.replicas_ = replicas_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.selector_ = selectorBuilder_ == null
              ? selector_
              : selectorBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.template_ = templateBuilder_ == null
              ? template_
              : templateBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.serviceName_ = serviceName_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.podManagementPolicy_ = podManagementPolicy_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.updateStrategy_ = updateStrategyBuilder_ == null
              ? updateStrategy_
              : updateStrategyBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.revisionHistoryLimit_ = revisionHistoryLimit_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.minReadySeconds_ = minReadySeconds_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.persistentVolumeClaimRetentionPolicy_ = persistentVolumeClaimRetentionPolicyBuilder_ == null
              ? persistentVolumeClaimRetentionPolicy_
              : persistentVolumeClaimRetentionPolicyBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.ordinals_ = ordinalsBuilder_ == null
              ? ordinals_
              : ordinalsBuilder_.build();
          to_bitField0_ |= 0x00000200;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.StatefulSetSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.StatefulSetSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.StatefulSetSpec other) {
        if (other == io.kubernetes.client.proto.V1Apps.StatefulSetSpec.getDefaultInstance()) return this;
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasTemplate()) {
          mergeTemplate(other.getTemplate());
        }
        if (volumeClaimTemplatesBuilder_ == null) {
          if (!other.volumeClaimTemplates_.isEmpty()) {
            if (volumeClaimTemplates_.isEmpty()) {
              volumeClaimTemplates_ = other.volumeClaimTemplates_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureVolumeClaimTemplatesIsMutable();
              volumeClaimTemplates_.addAll(other.volumeClaimTemplates_);
            }
            onChanged();
          }
        } else {
          if (!other.volumeClaimTemplates_.isEmpty()) {
            if (volumeClaimTemplatesBuilder_.isEmpty()) {
              volumeClaimTemplatesBuilder_.dispose();
              volumeClaimTemplatesBuilder_ = null;
              volumeClaimTemplates_ = other.volumeClaimTemplates_;
              bitField0_ = (bitField0_ & ~0x00000008);
              volumeClaimTemplatesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getVolumeClaimTemplatesFieldBuilder() : null;
            } else {
              volumeClaimTemplatesBuilder_.addAllMessages(other.volumeClaimTemplates_);
            }
          }
        }
        if (other.hasServiceName()) {
          serviceName_ = other.serviceName_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasPodManagementPolicy()) {
          podManagementPolicy_ = other.podManagementPolicy_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (other.hasUpdateStrategy()) {
          mergeUpdateStrategy(other.getUpdateStrategy());
        }
        if (other.hasRevisionHistoryLimit()) {
          setRevisionHistoryLimit(other.getRevisionHistoryLimit());
        }
        if (other.hasMinReadySeconds()) {
          setMinReadySeconds(other.getMinReadySeconds());
        }
        if (other.hasPersistentVolumeClaimRetentionPolicy()) {
          mergePersistentVolumeClaimRetentionPolicy(other.getPersistentVolumeClaimRetentionPolicy());
        }
        if (other.hasOrdinals()) {
          mergeOrdinals(other.getOrdinals());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                replicas_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                input.readMessage(
                    getSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getTemplateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                io.kubernetes.client.proto.V1.PersistentVolumeClaim m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1.PersistentVolumeClaim.parser(),
                        extensionRegistry);
                if (volumeClaimTemplatesBuilder_ == null) {
                  ensureVolumeClaimTemplatesIsMutable();
                  volumeClaimTemplates_.add(m);
                } else {
                  volumeClaimTemplatesBuilder_.addMessage(m);
                }
                break;
              } // case 34
              case 42: {
                serviceName_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                podManagementPolicy_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    getUpdateStrategyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 64: {
                revisionHistoryLimit_ = input.readInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              case 72: {
                minReadySeconds_ = input.readInt32();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              case 82: {
                input.readMessage(
                    getPersistentVolumeClaimRetentionPolicyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000200;
                break;
              } // case 82
              case 90: {
                input.readMessage(
                    getOrdinalsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000400;
                break;
              } // case 90
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int replicas_ ;
      /**
       * <pre>
       * replicas is the desired number of replicas of the given Template.
       * These are replicas in the sense that they are instantiations of the
       * same Template, but individual replicas also have a consistent identity.
       * If unspecified, defaults to 1.
       * TODO: Consider a rename of this field.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return Whether the replicas field is set.
       */
      @java.lang.Override
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * replicas is the desired number of replicas of the given Template.
       * These are replicas in the sense that they are instantiations of the
       * same Template, but individual replicas also have a consistent identity.
       * If unspecified, defaults to 1.
       * TODO: Consider a rename of this field.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return The replicas.
       */
      @java.lang.Override
      public int getReplicas() {
        return replicas_;
      }
      /**
       * <pre>
       * replicas is the desired number of replicas of the given Template.
       * These are replicas in the sense that they are instantiations of the
       * same Template, but individual replicas also have a consistent identity.
       * If unspecified, defaults to 1.
       * TODO: Consider a rename of this field.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @param value The replicas to set.
       * @return This builder for chaining.
       */
      public Builder setReplicas(int value) {

        replicas_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * replicas is the desired number of replicas of the given Template.
       * These are replicas in the sense that they are instantiations of the
       * same Template, but individual replicas also have a consistent identity.
       * If unspecified, defaults to 1.
       * TODO: Consider a rename of this field.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector selector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> selectorBuilder_;
      /**
       * <pre>
       * selector is a label query over pods that should match the replica count.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       * @return Whether the selector field is set.
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * selector is a label query over pods that should match the replica count.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       * @return The selector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * selector is a label query over pods that should match the replica count.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * selector is a label query over pods that should match the replica count.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * selector is a label query over pods that should match the replica count.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            selector_ != null &&
            selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getSelectorBuilder().mergeFrom(value);
          } else {
            selector_ = value;
          }
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        if (selector_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * selector is a label query over pods that should match the replica count.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder clearSelector() {
        bitField0_ = (bitField0_ & ~0x00000002);
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * selector is a label query over pods that should match the replica count.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * selector is a label query over pods that should match the replica count.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        }
      }
      /**
       * <pre>
       * selector is a label query over pods that should match the replica count.
       * It must match the pod template's labels.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(),
                  getParentForChildren(),
                  isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> templateBuilder_;
      /**
       * <pre>
       * template is the object that describes the pod that will be created if
       * insufficient replicas are detected. Each pod stamped out by the StatefulSet
       * will fulfill this Template, but have a unique identity from the rest
       * of the StatefulSet. Each pod will be named with the format
       * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
       * "web" with index number "3" would be named "web-3".
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       * @return Whether the template field is set.
       */
      public boolean hasTemplate() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * template is the object that describes the pod that will be created if
       * insufficient replicas are detected. Each pod stamped out by the StatefulSet
       * will fulfill this Template, but have a unique identity from the rest
       * of the StatefulSet. Each pod will be named with the format
       * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
       * "web" with index number "3" would be named "web-3".
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       * @return The template.
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
        if (templateBuilder_ == null) {
          return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        } else {
          return templateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * template is the object that describes the pod that will be created if
       * insufficient replicas are detected. Each pod stamped out by the StatefulSet
       * will fulfill this Template, but have a unique identity from the rest
       * of the StatefulSet. Each pod will be named with the format
       * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
       * "web" with index number "3" would be named "web-3".
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          template_ = value;
        } else {
          templateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * template is the object that describes the pod that will be created if
       * insufficient replicas are detected. Each pod stamped out by the StatefulSet
       * will fulfill this Template, but have a unique identity from the rest
       * of the StatefulSet. Each pod will be named with the format
       * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
       * "web" with index number "3" would be named "web-3".
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(
          io.kubernetes.client.proto.V1.PodTemplateSpec.Builder builderForValue) {
        if (templateBuilder_ == null) {
          template_ = builderForValue.build();
        } else {
          templateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * template is the object that describes the pod that will be created if
       * insufficient replicas are detected. Each pod stamped out by the StatefulSet
       * will fulfill this Template, but have a unique identity from the rest
       * of the StatefulSet. Each pod will be named with the format
       * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
       * "web" with index number "3" would be named "web-3".
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder mergeTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            template_ != null &&
            template_ != io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()) {
            getTemplateBuilder().mergeFrom(value);
          } else {
            template_ = value;
          }
        } else {
          templateBuilder_.mergeFrom(value);
        }
        if (template_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * template is the object that describes the pod that will be created if
       * insufficient replicas are detected. Each pod stamped out by the StatefulSet
       * will fulfill this Template, but have a unique identity from the rest
       * of the StatefulSet. Each pod will be named with the format
       * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
       * "web" with index number "3" would be named "web-3".
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder clearTemplate() {
        bitField0_ = (bitField0_ & ~0x00000004);
        template_ = null;
        if (templateBuilder_ != null) {
          templateBuilder_.dispose();
          templateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * template is the object that describes the pod that will be created if
       * insufficient replicas are detected. Each pod stamped out by the StatefulSet
       * will fulfill this Template, but have a unique identity from the rest
       * of the StatefulSet. Each pod will be named with the format
       * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
       * "web" with index number "3" would be named "web-3".
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec.Builder getTemplateBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getTemplateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * template is the object that describes the pod that will be created if
       * insufficient replicas are detected. Each pod stamped out by the StatefulSet
       * will fulfill this Template, but have a unique identity from the rest
       * of the StatefulSet. Each pod will be named with the format
       * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
       * "web" with index number "3" would be named "web-3".
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
        if (templateBuilder_ != null) {
          return templateBuilder_.getMessageOrBuilder();
        } else {
          return template_ == null ?
              io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        }
      }
      /**
       * <pre>
       * template is the object that describes the pod that will be created if
       * insufficient replicas are detected. Each pod stamped out by the StatefulSet
       * will fulfill this Template, but have a unique identity from the rest
       * of the StatefulSet. Each pod will be named with the format
       * &lt;statefulsetname&gt;-&lt;podindex&gt;. For example, a pod in a StatefulSet named
       * "web" with index number "3" would be named "web-3".
       * The only allowed template.spec.restartPolicy value is "Always".
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> 
          getTemplateFieldBuilder() {
        if (templateBuilder_ == null) {
          templateBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>(
                  getTemplate(),
                  getParentForChildren(),
                  isClean());
          template_ = null;
        }
        return templateBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1.PersistentVolumeClaim> volumeClaimTemplates_ =
        java.util.Collections.emptyList();
      private void ensureVolumeClaimTemplatesIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          volumeClaimTemplates_ = new java.util.ArrayList<io.kubernetes.client.proto.V1.PersistentVolumeClaim>(volumeClaimTemplates_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1.PersistentVolumeClaim, io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder, io.kubernetes.client.proto.V1.PersistentVolumeClaimOrBuilder> volumeClaimTemplatesBuilder_;

      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1.PersistentVolumeClaim> getVolumeClaimTemplatesList() {
        if (volumeClaimTemplatesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(volumeClaimTemplates_);
        } else {
          return volumeClaimTemplatesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public int getVolumeClaimTemplatesCount() {
        if (volumeClaimTemplatesBuilder_ == null) {
          return volumeClaimTemplates_.size();
        } else {
          return volumeClaimTemplatesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public io.kubernetes.client.proto.V1.PersistentVolumeClaim getVolumeClaimTemplates(int index) {
        if (volumeClaimTemplatesBuilder_ == null) {
          return volumeClaimTemplates_.get(index);
        } else {
          return volumeClaimTemplatesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public Builder setVolumeClaimTemplates(
          int index, io.kubernetes.client.proto.V1.PersistentVolumeClaim value) {
        if (volumeClaimTemplatesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeClaimTemplatesIsMutable();
          volumeClaimTemplates_.set(index, value);
          onChanged();
        } else {
          volumeClaimTemplatesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public Builder setVolumeClaimTemplates(
          int index, io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder builderForValue) {
        if (volumeClaimTemplatesBuilder_ == null) {
          ensureVolumeClaimTemplatesIsMutable();
          volumeClaimTemplates_.set(index, builderForValue.build());
          onChanged();
        } else {
          volumeClaimTemplatesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public Builder addVolumeClaimTemplates(io.kubernetes.client.proto.V1.PersistentVolumeClaim value) {
        if (volumeClaimTemplatesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeClaimTemplatesIsMutable();
          volumeClaimTemplates_.add(value);
          onChanged();
        } else {
          volumeClaimTemplatesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public Builder addVolumeClaimTemplates(
          int index, io.kubernetes.client.proto.V1.PersistentVolumeClaim value) {
        if (volumeClaimTemplatesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeClaimTemplatesIsMutable();
          volumeClaimTemplates_.add(index, value);
          onChanged();
        } else {
          volumeClaimTemplatesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public Builder addVolumeClaimTemplates(
          io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder builderForValue) {
        if (volumeClaimTemplatesBuilder_ == null) {
          ensureVolumeClaimTemplatesIsMutable();
          volumeClaimTemplates_.add(builderForValue.build());
          onChanged();
        } else {
          volumeClaimTemplatesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public Builder addVolumeClaimTemplates(
          int index, io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder builderForValue) {
        if (volumeClaimTemplatesBuilder_ == null) {
          ensureVolumeClaimTemplatesIsMutable();
          volumeClaimTemplates_.add(index, builderForValue.build());
          onChanged();
        } else {
          volumeClaimTemplatesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public Builder addAllVolumeClaimTemplates(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1.PersistentVolumeClaim> values) {
        if (volumeClaimTemplatesBuilder_ == null) {
          ensureVolumeClaimTemplatesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, volumeClaimTemplates_);
          onChanged();
        } else {
          volumeClaimTemplatesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public Builder clearVolumeClaimTemplates() {
        if (volumeClaimTemplatesBuilder_ == null) {
          volumeClaimTemplates_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          volumeClaimTemplatesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public Builder removeVolumeClaimTemplates(int index) {
        if (volumeClaimTemplatesBuilder_ == null) {
          ensureVolumeClaimTemplatesIsMutable();
          volumeClaimTemplates_.remove(index);
          onChanged();
        } else {
          volumeClaimTemplatesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder getVolumeClaimTemplatesBuilder(
          int index) {
        return getVolumeClaimTemplatesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public io.kubernetes.client.proto.V1.PersistentVolumeClaimOrBuilder getVolumeClaimTemplatesOrBuilder(
          int index) {
        if (volumeClaimTemplatesBuilder_ == null) {
          return volumeClaimTemplates_.get(index);  } else {
          return volumeClaimTemplatesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1.PersistentVolumeClaimOrBuilder> 
           getVolumeClaimTemplatesOrBuilderList() {
        if (volumeClaimTemplatesBuilder_ != null) {
          return volumeClaimTemplatesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(volumeClaimTemplates_);
        }
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder addVolumeClaimTemplatesBuilder() {
        return getVolumeClaimTemplatesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1.PersistentVolumeClaim.getDefaultInstance());
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder addVolumeClaimTemplatesBuilder(
          int index) {
        return getVolumeClaimTemplatesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1.PersistentVolumeClaim.getDefaultInstance());
      }
      /**
       * <pre>
       * volumeClaimTemplates is a list of claims that pods are allowed to reference.
       * The StatefulSet controller is responsible for mapping network identities to
       * claims in a way that maintains the identity of a pod. Every claim in
       * this list must have at least one matching (by name) volumeMount in one
       * container in the template. A claim in this list takes precedence over
       * any volumes in the template, with the same name.
       * TODO: Define the behavior if a claim already exists with the same name.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder> 
           getVolumeClaimTemplatesBuilderList() {
        return getVolumeClaimTemplatesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1.PersistentVolumeClaim, io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder, io.kubernetes.client.proto.V1.PersistentVolumeClaimOrBuilder> 
          getVolumeClaimTemplatesFieldBuilder() {
        if (volumeClaimTemplatesBuilder_ == null) {
          volumeClaimTemplatesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1.PersistentVolumeClaim, io.kubernetes.client.proto.V1.PersistentVolumeClaim.Builder, io.kubernetes.client.proto.V1.PersistentVolumeClaimOrBuilder>(
                  volumeClaimTemplates_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          volumeClaimTemplates_ = null;
        }
        return volumeClaimTemplatesBuilder_;
      }

      private java.lang.Object serviceName_ = "";
      /**
       * <pre>
       * serviceName is the name of the service that governs this StatefulSet.
       * This service must exist before the StatefulSet, and is responsible for
       * the network identity of the set. Pods get DNS/hostnames that follow the
       * pattern: pod-specific-string.serviceName.default.svc.cluster.local
       * where "pod-specific-string" is managed by the StatefulSet controller.
       * </pre>
       *
       * <code>optional string serviceName = 5;</code>
       * @return Whether the serviceName field is set.
       */
      public boolean hasServiceName() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * serviceName is the name of the service that governs this StatefulSet.
       * This service must exist before the StatefulSet, and is responsible for
       * the network identity of the set. Pods get DNS/hostnames that follow the
       * pattern: pod-specific-string.serviceName.default.svc.cluster.local
       * where "pod-specific-string" is managed by the StatefulSet controller.
       * </pre>
       *
       * <code>optional string serviceName = 5;</code>
       * @return The serviceName.
       */
      public java.lang.String getServiceName() {
        java.lang.Object ref = serviceName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            serviceName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * serviceName is the name of the service that governs this StatefulSet.
       * This service must exist before the StatefulSet, and is responsible for
       * the network identity of the set. Pods get DNS/hostnames that follow the
       * pattern: pod-specific-string.serviceName.default.svc.cluster.local
       * where "pod-specific-string" is managed by the StatefulSet controller.
       * </pre>
       *
       * <code>optional string serviceName = 5;</code>
       * @return The bytes for serviceName.
       */
      public com.google.protobuf.ByteString
          getServiceNameBytes() {
        java.lang.Object ref = serviceName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serviceName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * serviceName is the name of the service that governs this StatefulSet.
       * This service must exist before the StatefulSet, and is responsible for
       * the network identity of the set. Pods get DNS/hostnames that follow the
       * pattern: pod-specific-string.serviceName.default.svc.cluster.local
       * where "pod-specific-string" is managed by the StatefulSet controller.
       * </pre>
       *
       * <code>optional string serviceName = 5;</code>
       * @param value The serviceName to set.
       * @return This builder for chaining.
       */
      public Builder setServiceName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        serviceName_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * serviceName is the name of the service that governs this StatefulSet.
       * This service must exist before the StatefulSet, and is responsible for
       * the network identity of the set. Pods get DNS/hostnames that follow the
       * pattern: pod-specific-string.serviceName.default.svc.cluster.local
       * where "pod-specific-string" is managed by the StatefulSet controller.
       * </pre>
       *
       * <code>optional string serviceName = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearServiceName() {
        serviceName_ = getDefaultInstance().getServiceName();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * serviceName is the name of the service that governs this StatefulSet.
       * This service must exist before the StatefulSet, and is responsible for
       * the network identity of the set. Pods get DNS/hostnames that follow the
       * pattern: pod-specific-string.serviceName.default.svc.cluster.local
       * where "pod-specific-string" is managed by the StatefulSet controller.
       * </pre>
       *
       * <code>optional string serviceName = 5;</code>
       * @param value The bytes for serviceName to set.
       * @return This builder for chaining.
       */
      public Builder setServiceNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        serviceName_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object podManagementPolicy_ = "";
      /**
       * <pre>
       * podManagementPolicy controls how pods are created during initial scale up,
       * when replacing pods on nodes, or when scaling down. The default policy is
       * `OrderedReady`, where pods are created in increasing order (pod-0, then
       * pod-1, etc) and the controller will wait until each pod is ready before
       * continuing. When scaling down, the pods are removed in the opposite order.
       * The alternative policy is `Parallel` which will create pods in parallel
       * to match the desired scale without waiting, and on scale down will delete
       * all pods at once.
       * +optional
       * </pre>
       *
       * <code>optional string podManagementPolicy = 6;</code>
       * @return Whether the podManagementPolicy field is set.
       */
      public boolean hasPodManagementPolicy() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * podManagementPolicy controls how pods are created during initial scale up,
       * when replacing pods on nodes, or when scaling down. The default policy is
       * `OrderedReady`, where pods are created in increasing order (pod-0, then
       * pod-1, etc) and the controller will wait until each pod is ready before
       * continuing. When scaling down, the pods are removed in the opposite order.
       * The alternative policy is `Parallel` which will create pods in parallel
       * to match the desired scale without waiting, and on scale down will delete
       * all pods at once.
       * +optional
       * </pre>
       *
       * <code>optional string podManagementPolicy = 6;</code>
       * @return The podManagementPolicy.
       */
      public java.lang.String getPodManagementPolicy() {
        java.lang.Object ref = podManagementPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            podManagementPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * podManagementPolicy controls how pods are created during initial scale up,
       * when replacing pods on nodes, or when scaling down. The default policy is
       * `OrderedReady`, where pods are created in increasing order (pod-0, then
       * pod-1, etc) and the controller will wait until each pod is ready before
       * continuing. When scaling down, the pods are removed in the opposite order.
       * The alternative policy is `Parallel` which will create pods in parallel
       * to match the desired scale without waiting, and on scale down will delete
       * all pods at once.
       * +optional
       * </pre>
       *
       * <code>optional string podManagementPolicy = 6;</code>
       * @return The bytes for podManagementPolicy.
       */
      public com.google.protobuf.ByteString
          getPodManagementPolicyBytes() {
        java.lang.Object ref = podManagementPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          podManagementPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * podManagementPolicy controls how pods are created during initial scale up,
       * when replacing pods on nodes, or when scaling down. The default policy is
       * `OrderedReady`, where pods are created in increasing order (pod-0, then
       * pod-1, etc) and the controller will wait until each pod is ready before
       * continuing. When scaling down, the pods are removed in the opposite order.
       * The alternative policy is `Parallel` which will create pods in parallel
       * to match the desired scale without waiting, and on scale down will delete
       * all pods at once.
       * +optional
       * </pre>
       *
       * <code>optional string podManagementPolicy = 6;</code>
       * @param value The podManagementPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setPodManagementPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        podManagementPolicy_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * podManagementPolicy controls how pods are created during initial scale up,
       * when replacing pods on nodes, or when scaling down. The default policy is
       * `OrderedReady`, where pods are created in increasing order (pod-0, then
       * pod-1, etc) and the controller will wait until each pod is ready before
       * continuing. When scaling down, the pods are removed in the opposite order.
       * The alternative policy is `Parallel` which will create pods in parallel
       * to match the desired scale without waiting, and on scale down will delete
       * all pods at once.
       * +optional
       * </pre>
       *
       * <code>optional string podManagementPolicy = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearPodManagementPolicy() {
        podManagementPolicy_ = getDefaultInstance().getPodManagementPolicy();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * podManagementPolicy controls how pods are created during initial scale up,
       * when replacing pods on nodes, or when scaling down. The default policy is
       * `OrderedReady`, where pods are created in increasing order (pod-0, then
       * pod-1, etc) and the controller will wait until each pod is ready before
       * continuing. When scaling down, the pods are removed in the opposite order.
       * The alternative policy is `Parallel` which will create pods in parallel
       * to match the desired scale without waiting, and on scale down will delete
       * all pods at once.
       * +optional
       * </pre>
       *
       * <code>optional string podManagementPolicy = 6;</code>
       * @param value The bytes for podManagementPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setPodManagementPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        podManagementPolicy_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy updateStrategy_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy, io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategyOrBuilder> updateStrategyBuilder_;
      /**
       * <pre>
       * updateStrategy indicates the StatefulSetUpdateStrategy that will be
       * employed to update Pods in the StatefulSet when a revision is made to
       * Template.
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
       * @return Whether the updateStrategy field is set.
       */
      public boolean hasUpdateStrategy() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * updateStrategy indicates the StatefulSetUpdateStrategy that will be
       * employed to update Pods in the StatefulSet when a revision is made to
       * Template.
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
       * @return The updateStrategy.
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy getUpdateStrategy() {
        if (updateStrategyBuilder_ == null) {
          return updateStrategy_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
        } else {
          return updateStrategyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * updateStrategy indicates the StatefulSetUpdateStrategy that will be
       * employed to update Pods in the StatefulSet when a revision is made to
       * Template.
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
       */
      public Builder setUpdateStrategy(io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy value) {
        if (updateStrategyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          updateStrategy_ = value;
        } else {
          updateStrategyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * updateStrategy indicates the StatefulSetUpdateStrategy that will be
       * employed to update Pods in the StatefulSet when a revision is made to
       * Template.
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
       */
      public Builder setUpdateStrategy(
          io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.Builder builderForValue) {
        if (updateStrategyBuilder_ == null) {
          updateStrategy_ = builderForValue.build();
        } else {
          updateStrategyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * updateStrategy indicates the StatefulSetUpdateStrategy that will be
       * employed to update Pods in the StatefulSet when a revision is made to
       * Template.
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
       */
      public Builder mergeUpdateStrategy(io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy value) {
        if (updateStrategyBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            updateStrategy_ != null &&
            updateStrategy_ != io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.getDefaultInstance()) {
            getUpdateStrategyBuilder().mergeFrom(value);
          } else {
            updateStrategy_ = value;
          }
        } else {
          updateStrategyBuilder_.mergeFrom(value);
        }
        if (updateStrategy_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * updateStrategy indicates the StatefulSetUpdateStrategy that will be
       * employed to update Pods in the StatefulSet when a revision is made to
       * Template.
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
       */
      public Builder clearUpdateStrategy() {
        bitField0_ = (bitField0_ & ~0x00000040);
        updateStrategy_ = null;
        if (updateStrategyBuilder_ != null) {
          updateStrategyBuilder_.dispose();
          updateStrategyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * updateStrategy indicates the StatefulSetUpdateStrategy that will be
       * employed to update Pods in the StatefulSet when a revision is made to
       * Template.
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.Builder getUpdateStrategyBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getUpdateStrategyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * updateStrategy indicates the StatefulSetUpdateStrategy that will be
       * employed to update Pods in the StatefulSet when a revision is made to
       * Template.
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategyOrBuilder getUpdateStrategyOrBuilder() {
        if (updateStrategyBuilder_ != null) {
          return updateStrategyBuilder_.getMessageOrBuilder();
        } else {
          return updateStrategy_ == null ?
              io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
        }
      }
      /**
       * <pre>
       * updateStrategy indicates the StatefulSetUpdateStrategy that will be
       * employed to update Pods in the StatefulSet when a revision is made to
       * Template.
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy, io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategyOrBuilder> 
          getUpdateStrategyFieldBuilder() {
        if (updateStrategyBuilder_ == null) {
          updateStrategyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy, io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategyOrBuilder>(
                  getUpdateStrategy(),
                  getParentForChildren(),
                  isClean());
          updateStrategy_ = null;
        }
        return updateStrategyBuilder_;
      }

      private int revisionHistoryLimit_ ;
      /**
       * <pre>
       * revisionHistoryLimit is the maximum number of revisions that will
       * be maintained in the StatefulSet's revision history. The revision history
       * consists of all revisions not represented by a currently applied
       * StatefulSetSpec version. The default value is 10.
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 8;</code>
       * @return Whether the revisionHistoryLimit field is set.
       */
      @java.lang.Override
      public boolean hasRevisionHistoryLimit() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * revisionHistoryLimit is the maximum number of revisions that will
       * be maintained in the StatefulSet's revision history. The revision history
       * consists of all revisions not represented by a currently applied
       * StatefulSetSpec version. The default value is 10.
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 8;</code>
       * @return The revisionHistoryLimit.
       */
      @java.lang.Override
      public int getRevisionHistoryLimit() {
        return revisionHistoryLimit_;
      }
      /**
       * <pre>
       * revisionHistoryLimit is the maximum number of revisions that will
       * be maintained in the StatefulSet's revision history. The revision history
       * consists of all revisions not represented by a currently applied
       * StatefulSetSpec version. The default value is 10.
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 8;</code>
       * @param value The revisionHistoryLimit to set.
       * @return This builder for chaining.
       */
      public Builder setRevisionHistoryLimit(int value) {

        revisionHistoryLimit_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * revisionHistoryLimit is the maximum number of revisions that will
       * be maintained in the StatefulSet's revision history. The revision history
       * consists of all revisions not represented by a currently applied
       * StatefulSetSpec version. The default value is 10.
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearRevisionHistoryLimit() {
        bitField0_ = (bitField0_ & ~0x00000080);
        revisionHistoryLimit_ = 0;
        onChanged();
        return this;
      }

      private int minReadySeconds_ ;
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 9;</code>
       * @return Whether the minReadySeconds field is set.
       */
      @java.lang.Override
      public boolean hasMinReadySeconds() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 9;</code>
       * @return The minReadySeconds.
       */
      @java.lang.Override
      public int getMinReadySeconds() {
        return minReadySeconds_;
      }
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 9;</code>
       * @param value The minReadySeconds to set.
       * @return This builder for chaining.
       */
      public Builder setMinReadySeconds(int value) {

        minReadySeconds_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinReadySeconds() {
        bitField0_ = (bitField0_ & ~0x00000100);
        minReadySeconds_ = 0;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy, io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicyOrBuilder> persistentVolumeClaimRetentionPolicyBuilder_;
      /**
       * <pre>
       * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
       * volume claims created from volumeClaimTemplates. By default, all persistent
       * volume claims are created as needed and retained until manually deleted. This
       * policy allows the lifecycle to be altered, for example by deleting persistent
       * volume claims when their stateful set is deleted, or when their pod is scaled
       * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
       * which is alpha.  +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
       * @return Whether the persistentVolumeClaimRetentionPolicy field is set.
       */
      public boolean hasPersistentVolumeClaimRetentionPolicy() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
       * volume claims created from volumeClaimTemplates. By default, all persistent
       * volume claims are created as needed and retained until manually deleted. This
       * policy allows the lifecycle to be altered, for example by deleting persistent
       * volume claims when their stateful set is deleted, or when their pod is scaled
       * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
       * which is alpha.  +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
       * @return The persistentVolumeClaimRetentionPolicy.
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy getPersistentVolumeClaimRetentionPolicy() {
        if (persistentVolumeClaimRetentionPolicyBuilder_ == null) {
          return persistentVolumeClaimRetentionPolicy_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.getDefaultInstance() : persistentVolumeClaimRetentionPolicy_;
        } else {
          return persistentVolumeClaimRetentionPolicyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
       * volume claims created from volumeClaimTemplates. By default, all persistent
       * volume claims are created as needed and retained until manually deleted. This
       * policy allows the lifecycle to be altered, for example by deleting persistent
       * volume claims when their stateful set is deleted, or when their pod is scaled
       * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
       * which is alpha.  +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
       */
      public Builder setPersistentVolumeClaimRetentionPolicy(io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy value) {
        if (persistentVolumeClaimRetentionPolicyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          persistentVolumeClaimRetentionPolicy_ = value;
        } else {
          persistentVolumeClaimRetentionPolicyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
       * volume claims created from volumeClaimTemplates. By default, all persistent
       * volume claims are created as needed and retained until manually deleted. This
       * policy allows the lifecycle to be altered, for example by deleting persistent
       * volume claims when their stateful set is deleted, or when their pod is scaled
       * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
       * which is alpha.  +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
       */
      public Builder setPersistentVolumeClaimRetentionPolicy(
          io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.Builder builderForValue) {
        if (persistentVolumeClaimRetentionPolicyBuilder_ == null) {
          persistentVolumeClaimRetentionPolicy_ = builderForValue.build();
        } else {
          persistentVolumeClaimRetentionPolicyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
       * volume claims created from volumeClaimTemplates. By default, all persistent
       * volume claims are created as needed and retained until manually deleted. This
       * policy allows the lifecycle to be altered, for example by deleting persistent
       * volume claims when their stateful set is deleted, or when their pod is scaled
       * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
       * which is alpha.  +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
       */
      public Builder mergePersistentVolumeClaimRetentionPolicy(io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy value) {
        if (persistentVolumeClaimRetentionPolicyBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
            persistentVolumeClaimRetentionPolicy_ != null &&
            persistentVolumeClaimRetentionPolicy_ != io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.getDefaultInstance()) {
            getPersistentVolumeClaimRetentionPolicyBuilder().mergeFrom(value);
          } else {
            persistentVolumeClaimRetentionPolicy_ = value;
          }
        } else {
          persistentVolumeClaimRetentionPolicyBuilder_.mergeFrom(value);
        }
        if (persistentVolumeClaimRetentionPolicy_ != null) {
          bitField0_ |= 0x00000200;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
       * volume claims created from volumeClaimTemplates. By default, all persistent
       * volume claims are created as needed and retained until manually deleted. This
       * policy allows the lifecycle to be altered, for example by deleting persistent
       * volume claims when their stateful set is deleted, or when their pod is scaled
       * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
       * which is alpha.  +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
       */
      public Builder clearPersistentVolumeClaimRetentionPolicy() {
        bitField0_ = (bitField0_ & ~0x00000200);
        persistentVolumeClaimRetentionPolicy_ = null;
        if (persistentVolumeClaimRetentionPolicyBuilder_ != null) {
          persistentVolumeClaimRetentionPolicyBuilder_.dispose();
          persistentVolumeClaimRetentionPolicyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
       * volume claims created from volumeClaimTemplates. By default, all persistent
       * volume claims are created as needed and retained until manually deleted. This
       * policy allows the lifecycle to be altered, for example by deleting persistent
       * volume claims when their stateful set is deleted, or when their pod is scaled
       * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
       * which is alpha.  +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.Builder getPersistentVolumeClaimRetentionPolicyBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getPersistentVolumeClaimRetentionPolicyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
       * volume claims created from volumeClaimTemplates. By default, all persistent
       * volume claims are created as needed and retained until manually deleted. This
       * policy allows the lifecycle to be altered, for example by deleting persistent
       * volume claims when their stateful set is deleted, or when their pod is scaled
       * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
       * which is alpha.  +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicyOrBuilder getPersistentVolumeClaimRetentionPolicyOrBuilder() {
        if (persistentVolumeClaimRetentionPolicyBuilder_ != null) {
          return persistentVolumeClaimRetentionPolicyBuilder_.getMessageOrBuilder();
        } else {
          return persistentVolumeClaimRetentionPolicy_ == null ?
              io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.getDefaultInstance() : persistentVolumeClaimRetentionPolicy_;
        }
      }
      /**
       * <pre>
       * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
       * volume claims created from volumeClaimTemplates. By default, all persistent
       * volume claims are created as needed and retained until manually deleted. This
       * policy allows the lifecycle to be altered, for example by deleting persistent
       * volume claims when their stateful set is deleted, or when their pod is scaled
       * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
       * which is alpha.  +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy, io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicyOrBuilder> 
          getPersistentVolumeClaimRetentionPolicyFieldBuilder() {
        if (persistentVolumeClaimRetentionPolicyBuilder_ == null) {
          persistentVolumeClaimRetentionPolicyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy, io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicy.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetPersistentVolumeClaimRetentionPolicyOrBuilder>(
                  getPersistentVolumeClaimRetentionPolicy(),
                  getParentForChildren(),
                  isClean());
          persistentVolumeClaimRetentionPolicy_ = null;
        }
        return persistentVolumeClaimRetentionPolicyBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals ordinals_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals, io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetOrdinalsOrBuilder> ordinalsBuilder_;
      /**
       * <pre>
       * ordinals controls the numbering of replica indices in a StatefulSet. The
       * default ordinals behavior assigns a "0" index to the first replica and
       * increments the index by one for each additional replica requested. Using
       * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
       * enabled, which is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
       * @return Whether the ordinals field is set.
       */
      public boolean hasOrdinals() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * ordinals controls the numbering of replica indices in a StatefulSet. The
       * default ordinals behavior assigns a "0" index to the first replica and
       * increments the index by one for each additional replica requested. Using
       * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
       * enabled, which is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
       * @return The ordinals.
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals getOrdinals() {
        if (ordinalsBuilder_ == null) {
          return ordinals_ == null ? io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.getDefaultInstance() : ordinals_;
        } else {
          return ordinalsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ordinals controls the numbering of replica indices in a StatefulSet. The
       * default ordinals behavior assigns a "0" index to the first replica and
       * increments the index by one for each additional replica requested. Using
       * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
       * enabled, which is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
       */
      public Builder setOrdinals(io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals value) {
        if (ordinalsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ordinals_ = value;
        } else {
          ordinalsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ordinals controls the numbering of replica indices in a StatefulSet. The
       * default ordinals behavior assigns a "0" index to the first replica and
       * increments the index by one for each additional replica requested. Using
       * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
       * enabled, which is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
       */
      public Builder setOrdinals(
          io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.Builder builderForValue) {
        if (ordinalsBuilder_ == null) {
          ordinals_ = builderForValue.build();
        } else {
          ordinalsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ordinals controls the numbering of replica indices in a StatefulSet. The
       * default ordinals behavior assigns a "0" index to the first replica and
       * increments the index by one for each additional replica requested. Using
       * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
       * enabled, which is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
       */
      public Builder mergeOrdinals(io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals value) {
        if (ordinalsBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
            ordinals_ != null &&
            ordinals_ != io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.getDefaultInstance()) {
            getOrdinalsBuilder().mergeFrom(value);
          } else {
            ordinals_ = value;
          }
        } else {
          ordinalsBuilder_.mergeFrom(value);
        }
        if (ordinals_ != null) {
          bitField0_ |= 0x00000400;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * ordinals controls the numbering of replica indices in a StatefulSet. The
       * default ordinals behavior assigns a "0" index to the first replica and
       * increments the index by one for each additional replica requested. Using
       * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
       * enabled, which is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
       */
      public Builder clearOrdinals() {
        bitField0_ = (bitField0_ & ~0x00000400);
        ordinals_ = null;
        if (ordinalsBuilder_ != null) {
          ordinalsBuilder_.dispose();
          ordinalsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ordinals controls the numbering of replica indices in a StatefulSet. The
       * default ordinals behavior assigns a "0" index to the first replica and
       * increments the index by one for each additional replica requested. Using
       * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
       * enabled, which is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.Builder getOrdinalsBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getOrdinalsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ordinals controls the numbering of replica indices in a StatefulSet. The
       * default ordinals behavior assigns a "0" index to the first replica and
       * increments the index by one for each additional replica requested. Using
       * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
       * enabled, which is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetOrdinalsOrBuilder getOrdinalsOrBuilder() {
        if (ordinalsBuilder_ != null) {
          return ordinalsBuilder_.getMessageOrBuilder();
        } else {
          return ordinals_ == null ?
              io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.getDefaultInstance() : ordinals_;
        }
      }
      /**
       * <pre>
       * ordinals controls the numbering of replica indices in a StatefulSet. The
       * default ordinals behavior assigns a "0" index to the first replica and
       * increments the index by one for each additional replica requested. Using
       * the ordinals field requires the StatefulSetStartOrdinal feature gate to be
       * enabled, which is beta.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.StatefulSetOrdinals ordinals = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals, io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetOrdinalsOrBuilder> 
          getOrdinalsFieldBuilder() {
        if (ordinalsBuilder_ == null) {
          ordinalsBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals, io.kubernetes.client.proto.V1Apps.StatefulSetOrdinals.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetOrdinalsOrBuilder>(
                  getOrdinals(),
                  getParentForChildren(),
                  isClean());
          ordinals_ = null;
        }
        return ordinalsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.StatefulSetSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.StatefulSetSpec)
    private static final io.kubernetes.client.proto.V1Apps.StatefulSetSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.StatefulSetSpec();
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatefulSetSpec>
        PARSER = new com.google.protobuf.AbstractParser<StatefulSetSpec>() {
      @java.lang.Override
      public StatefulSetSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatefulSetSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatefulSetSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatefulSetStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.StatefulSetStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
     * StatefulSet's generation, which is updated on mutation by the API Server.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return Whether the observedGeneration field is set.
     */
    boolean hasObservedGeneration();
    /**
     * <pre>
     * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
     * StatefulSet's generation, which is updated on mutation by the API Server.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return The observedGeneration.
     */
    long getObservedGeneration();

    /**
     * <pre>
     * replicas is the number of Pods created by the StatefulSet controller.
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     * @return Whether the replicas field is set.
     */
    boolean hasReplicas();
    /**
     * <pre>
     * replicas is the number of Pods created by the StatefulSet controller.
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     * @return The replicas.
     */
    int getReplicas();

    /**
     * <pre>
     * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
     * </pre>
     *
     * <code>optional int32 readyReplicas = 3;</code>
     * @return Whether the readyReplicas field is set.
     */
    boolean hasReadyReplicas();
    /**
     * <pre>
     * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
     * </pre>
     *
     * <code>optional int32 readyReplicas = 3;</code>
     * @return The readyReplicas.
     */
    int getReadyReplicas();

    /**
     * <pre>
     * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
     * indicated by currentRevision.
     * </pre>
     *
     * <code>optional int32 currentReplicas = 4;</code>
     * @return Whether the currentReplicas field is set.
     */
    boolean hasCurrentReplicas();
    /**
     * <pre>
     * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
     * indicated by currentRevision.
     * </pre>
     *
     * <code>optional int32 currentReplicas = 4;</code>
     * @return The currentReplicas.
     */
    int getCurrentReplicas();

    /**
     * <pre>
     * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
     * indicated by updateRevision.
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 5;</code>
     * @return Whether the updatedReplicas field is set.
     */
    boolean hasUpdatedReplicas();
    /**
     * <pre>
     * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
     * indicated by updateRevision.
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 5;</code>
     * @return The updatedReplicas.
     */
    int getUpdatedReplicas();

    /**
     * <pre>
     * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
     * sequence [0,currentReplicas).
     * </pre>
     *
     * <code>optional string currentRevision = 6;</code>
     * @return Whether the currentRevision field is set.
     */
    boolean hasCurrentRevision();
    /**
     * <pre>
     * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
     * sequence [0,currentReplicas).
     * </pre>
     *
     * <code>optional string currentRevision = 6;</code>
     * @return The currentRevision.
     */
    java.lang.String getCurrentRevision();
    /**
     * <pre>
     * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
     * sequence [0,currentReplicas).
     * </pre>
     *
     * <code>optional string currentRevision = 6;</code>
     * @return The bytes for currentRevision.
     */
    com.google.protobuf.ByteString
        getCurrentRevisionBytes();

    /**
     * <pre>
     * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
     * [replicas-updatedReplicas,replicas)
     * </pre>
     *
     * <code>optional string updateRevision = 7;</code>
     * @return Whether the updateRevision field is set.
     */
    boolean hasUpdateRevision();
    /**
     * <pre>
     * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
     * [replicas-updatedReplicas,replicas)
     * </pre>
     *
     * <code>optional string updateRevision = 7;</code>
     * @return The updateRevision.
     */
    java.lang.String getUpdateRevision();
    /**
     * <pre>
     * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
     * [replicas-updatedReplicas,replicas)
     * </pre>
     *
     * <code>optional string updateRevision = 7;</code>
     * @return The bytes for updateRevision.
     */
    com.google.protobuf.ByteString
        getUpdateRevisionBytes();

    /**
     * <pre>
     * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
     * uses this field as a collision avoidance mechanism when it needs to create the name for the
     * newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     * @return Whether the collisionCount field is set.
     */
    boolean hasCollisionCount();
    /**
     * <pre>
     * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
     * uses this field as a collision avoidance mechanism when it needs to create the name for the
     * newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     * @return The collisionCount.
     */
    int getCollisionCount();

    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSetCondition> 
        getConditionsList();
    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetCondition getConditions(int index);
    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    int getConditionsCount();
    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder> 
        getConditionsOrBuilderList();
    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder getConditionsOrBuilder(
        int index);

    /**
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 11;</code>
     * @return Whether the availableReplicas field is set.
     */
    boolean hasAvailableReplicas();
    /**
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 11;</code>
     * @return The availableReplicas.
     */
    int getAvailableReplicas();
  }
  /**
   * <pre>
   * StatefulSetStatus represents the current state of a StatefulSet.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetStatus}
   */
  public static final class StatefulSetStatus extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.StatefulSetStatus)
      StatefulSetStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatefulSetStatus.class.getName());
    }
    // Use StatefulSetStatus.newBuilder() to construct.
    private StatefulSetStatus(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatefulSetStatus() {
      currentRevision_ = "";
      updateRevision_ = "";
      conditions_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.StatefulSetStatus.class, io.kubernetes.client.proto.V1Apps.StatefulSetStatus.Builder.class);
    }

    private int bitField0_;
    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 1;
    private long observedGeneration_ = 0L;
    /**
     * <pre>
     * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
     * StatefulSet's generation, which is updated on mutation by the API Server.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return Whether the observedGeneration field is set.
     */
    @java.lang.Override
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
     * StatefulSet's generation, which is updated on mutation by the API Server.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return The observedGeneration.
     */
    @java.lang.Override
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int REPLICAS_FIELD_NUMBER = 2;
    private int replicas_ = 0;
    /**
     * <pre>
     * replicas is the number of Pods created by the StatefulSet controller.
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     * @return Whether the replicas field is set.
     */
    @java.lang.Override
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * replicas is the number of Pods created by the StatefulSet controller.
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     * @return The replicas.
     */
    @java.lang.Override
    public int getReplicas() {
      return replicas_;
    }

    public static final int READYREPLICAS_FIELD_NUMBER = 3;
    private int readyReplicas_ = 0;
    /**
     * <pre>
     * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
     * </pre>
     *
     * <code>optional int32 readyReplicas = 3;</code>
     * @return Whether the readyReplicas field is set.
     */
    @java.lang.Override
    public boolean hasReadyReplicas() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
     * </pre>
     *
     * <code>optional int32 readyReplicas = 3;</code>
     * @return The readyReplicas.
     */
    @java.lang.Override
    public int getReadyReplicas() {
      return readyReplicas_;
    }

    public static final int CURRENTREPLICAS_FIELD_NUMBER = 4;
    private int currentReplicas_ = 0;
    /**
     * <pre>
     * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
     * indicated by currentRevision.
     * </pre>
     *
     * <code>optional int32 currentReplicas = 4;</code>
     * @return Whether the currentReplicas field is set.
     */
    @java.lang.Override
    public boolean hasCurrentReplicas() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
     * indicated by currentRevision.
     * </pre>
     *
     * <code>optional int32 currentReplicas = 4;</code>
     * @return The currentReplicas.
     */
    @java.lang.Override
    public int getCurrentReplicas() {
      return currentReplicas_;
    }

    public static final int UPDATEDREPLICAS_FIELD_NUMBER = 5;
    private int updatedReplicas_ = 0;
    /**
     * <pre>
     * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
     * indicated by updateRevision.
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 5;</code>
     * @return Whether the updatedReplicas field is set.
     */
    @java.lang.Override
    public boolean hasUpdatedReplicas() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
     * indicated by updateRevision.
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 5;</code>
     * @return The updatedReplicas.
     */
    @java.lang.Override
    public int getUpdatedReplicas() {
      return updatedReplicas_;
    }

    public static final int CURRENTREVISION_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object currentRevision_ = "";
    /**
     * <pre>
     * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
     * sequence [0,currentReplicas).
     * </pre>
     *
     * <code>optional string currentRevision = 6;</code>
     * @return Whether the currentRevision field is set.
     */
    @java.lang.Override
    public boolean hasCurrentRevision() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
     * sequence [0,currentReplicas).
     * </pre>
     *
     * <code>optional string currentRevision = 6;</code>
     * @return The currentRevision.
     */
    @java.lang.Override
    public java.lang.String getCurrentRevision() {
      java.lang.Object ref = currentRevision_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          currentRevision_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
     * sequence [0,currentReplicas).
     * </pre>
     *
     * <code>optional string currentRevision = 6;</code>
     * @return The bytes for currentRevision.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getCurrentRevisionBytes() {
      java.lang.Object ref = currentRevision_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        currentRevision_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UPDATEREVISION_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object updateRevision_ = "";
    /**
     * <pre>
     * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
     * [replicas-updatedReplicas,replicas)
     * </pre>
     *
     * <code>optional string updateRevision = 7;</code>
     * @return Whether the updateRevision field is set.
     */
    @java.lang.Override
    public boolean hasUpdateRevision() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
     * [replicas-updatedReplicas,replicas)
     * </pre>
     *
     * <code>optional string updateRevision = 7;</code>
     * @return The updateRevision.
     */
    @java.lang.Override
    public java.lang.String getUpdateRevision() {
      java.lang.Object ref = updateRevision_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          updateRevision_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
     * [replicas-updatedReplicas,replicas)
     * </pre>
     *
     * <code>optional string updateRevision = 7;</code>
     * @return The bytes for updateRevision.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUpdateRevisionBytes() {
      java.lang.Object ref = updateRevision_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        updateRevision_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COLLISIONCOUNT_FIELD_NUMBER = 9;
    private int collisionCount_ = 0;
    /**
     * <pre>
     * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
     * uses this field as a collision avoidance mechanism when it needs to create the name for the
     * newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     * @return Whether the collisionCount field is set.
     */
    @java.lang.Override
    public boolean hasCollisionCount() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
     * uses this field as a collision avoidance mechanism when it needs to create the name for the
     * newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     * @return The collisionCount.
     */
    @java.lang.Override
    public int getCollisionCount() {
      return collisionCount_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSetCondition> conditions_;
    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSetCondition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetCondition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * Represents the latest available observations of a statefulset's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }

    public static final int AVAILABLEREPLICAS_FIELD_NUMBER = 11;
    private int availableReplicas_ = 0;
    /**
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 11;</code>
     * @return Whether the availableReplicas field is set.
     */
    @java.lang.Override
    public boolean hasAvailableReplicas() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 11;</code>
     * @return The availableReplicas.
     */
    @java.lang.Override
    public int getAvailableReplicas() {
      return availableReplicas_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, replicas_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt32(3, readyReplicas_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(4, currentReplicas_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt32(5, updatedReplicas_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, currentRevision_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 7, updateRevision_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt32(9, collisionCount_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(10, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeInt32(11, availableReplicas_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, replicas_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, readyReplicas_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, currentReplicas_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, updatedReplicas_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, currentRevision_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(7, updateRevision_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, collisionCount_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(11, availableReplicas_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.StatefulSetStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.StatefulSetStatus other = (io.kubernetes.client.proto.V1Apps.StatefulSetStatus) obj;

      if (hasObservedGeneration() != other.hasObservedGeneration()) return false;
      if (hasObservedGeneration()) {
        if (getObservedGeneration()
            != other.getObservedGeneration()) return false;
      }
      if (hasReplicas() != other.hasReplicas()) return false;
      if (hasReplicas()) {
        if (getReplicas()
            != other.getReplicas()) return false;
      }
      if (hasReadyReplicas() != other.hasReadyReplicas()) return false;
      if (hasReadyReplicas()) {
        if (getReadyReplicas()
            != other.getReadyReplicas()) return false;
      }
      if (hasCurrentReplicas() != other.hasCurrentReplicas()) return false;
      if (hasCurrentReplicas()) {
        if (getCurrentReplicas()
            != other.getCurrentReplicas()) return false;
      }
      if (hasUpdatedReplicas() != other.hasUpdatedReplicas()) return false;
      if (hasUpdatedReplicas()) {
        if (getUpdatedReplicas()
            != other.getUpdatedReplicas()) return false;
      }
      if (hasCurrentRevision() != other.hasCurrentRevision()) return false;
      if (hasCurrentRevision()) {
        if (!getCurrentRevision()
            .equals(other.getCurrentRevision())) return false;
      }
      if (hasUpdateRevision() != other.hasUpdateRevision()) return false;
      if (hasUpdateRevision()) {
        if (!getUpdateRevision()
            .equals(other.getUpdateRevision())) return false;
      }
      if (hasCollisionCount() != other.hasCollisionCount()) return false;
      if (hasCollisionCount()) {
        if (getCollisionCount()
            != other.getCollisionCount()) return false;
      }
      if (!getConditionsList()
          .equals(other.getConditionsList())) return false;
      if (hasAvailableReplicas() != other.hasAvailableReplicas()) return false;
      if (hasAvailableReplicas()) {
        if (getAvailableReplicas()
            != other.getAvailableReplicas()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getObservedGeneration());
      }
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasReadyReplicas()) {
        hash = (37 * hash) + READYREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReadyReplicas();
      }
      if (hasCurrentReplicas()) {
        hash = (37 * hash) + CURRENTREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getCurrentReplicas();
      }
      if (hasUpdatedReplicas()) {
        hash = (37 * hash) + UPDATEDREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getUpdatedReplicas();
      }
      if (hasCurrentRevision()) {
        hash = (37 * hash) + CURRENTREVISION_FIELD_NUMBER;
        hash = (53 * hash) + getCurrentRevision().hashCode();
      }
      if (hasUpdateRevision()) {
        hash = (37 * hash) + UPDATEREVISION_FIELD_NUMBER;
        hash = (53 * hash) + getUpdateRevision().hashCode();
      }
      if (hasCollisionCount()) {
        hash = (37 * hash) + COLLISIONCOUNT_FIELD_NUMBER;
        hash = (53 * hash) + getCollisionCount();
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      if (hasAvailableReplicas()) {
        hash = (37 * hash) + AVAILABLEREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getAvailableReplicas();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.StatefulSetStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StatefulSetStatus represents the current state of a StatefulSet.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.StatefulSetStatus)
        io.kubernetes.client.proto.V1Apps.StatefulSetStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.StatefulSetStatus.class, io.kubernetes.client.proto.V1Apps.StatefulSetStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.StatefulSetStatus.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        observedGeneration_ = 0L;
        replicas_ = 0;
        readyReplicas_ = 0;
        currentReplicas_ = 0;
        updatedReplicas_ = 0;
        currentRevision_ = "";
        updateRevision_ = "";
        collisionCount_ = 0;
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
        } else {
          conditions_ = null;
          conditionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        availableReplicas_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.StatefulSetStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetStatus build() {
        io.kubernetes.client.proto.V1Apps.StatefulSetStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetStatus buildPartial() {
        io.kubernetes.client.proto.V1Apps.StatefulSetStatus result = new io.kubernetes.client.proto.V1Apps.StatefulSetStatus(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1Apps.StatefulSetStatus result) {
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000100);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.StatefulSetStatus result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.observedGeneration_ = observedGeneration_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.replicas_ = replicas_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.readyReplicas_ = readyReplicas_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.currentReplicas_ = currentReplicas_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.updatedReplicas_ = updatedReplicas_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.currentRevision_ = currentRevision_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.updateRevision_ = updateRevision_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.collisionCount_ = collisionCount_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.availableReplicas_ = availableReplicas_;
          to_bitField0_ |= 0x00000100;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.StatefulSetStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.StatefulSetStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.StatefulSetStatus other) {
        if (other == io.kubernetes.client.proto.V1Apps.StatefulSetStatus.getDefaultInstance()) return this;
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasReadyReplicas()) {
          setReadyReplicas(other.getReadyReplicas());
        }
        if (other.hasCurrentReplicas()) {
          setCurrentReplicas(other.getCurrentReplicas());
        }
        if (other.hasUpdatedReplicas()) {
          setUpdatedReplicas(other.getUpdatedReplicas());
        }
        if (other.hasCurrentRevision()) {
          currentRevision_ = other.currentRevision_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (other.hasUpdateRevision()) {
          updateRevision_ = other.updateRevision_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        if (other.hasCollisionCount()) {
          setCollisionCount(other.getCollisionCount());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000100);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000100);
              conditionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getConditionsFieldBuilder() : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        if (other.hasAvailableReplicas()) {
          setAvailableReplicas(other.getAvailableReplicas());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                observedGeneration_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                replicas_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                readyReplicas_ = input.readInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                currentReplicas_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                updatedReplicas_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 50: {
                currentRevision_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 58: {
                updateRevision_ = input.readBytes();
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 72: {
                collisionCount_ = input.readInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 72
              case 82: {
                io.kubernetes.client.proto.V1Apps.StatefulSetCondition m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Apps.StatefulSetCondition.parser(),
                        extensionRegistry);
                if (conditionsBuilder_ == null) {
                  ensureConditionsIsMutable();
                  conditions_.add(m);
                } else {
                  conditionsBuilder_.addMessage(m);
                }
                break;
              } // case 82
              case 88: {
                availableReplicas_ = input.readInt32();
                bitField0_ |= 0x00000200;
                break;
              } // case 88
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long observedGeneration_ ;
      /**
       * <pre>
       * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
       * StatefulSet's generation, which is updated on mutation by the API Server.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @return Whether the observedGeneration field is set.
       */
      @java.lang.Override
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
       * StatefulSet's generation, which is updated on mutation by the API Server.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @return The observedGeneration.
       */
      @java.lang.Override
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       * <pre>
       * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
       * StatefulSet's generation, which is updated on mutation by the API Server.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @param value The observedGeneration to set.
       * @return This builder for chaining.
       */
      public Builder setObservedGeneration(long value) {

        observedGeneration_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
       * StatefulSet's generation, which is updated on mutation by the API Server.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000001);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private int replicas_ ;
      /**
       * <pre>
       * replicas is the number of Pods created by the StatefulSet controller.
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       * @return Whether the replicas field is set.
       */
      @java.lang.Override
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * replicas is the number of Pods created by the StatefulSet controller.
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       * @return The replicas.
       */
      @java.lang.Override
      public int getReplicas() {
        return replicas_;
      }
      /**
       * <pre>
       * replicas is the number of Pods created by the StatefulSet controller.
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       * @param value The replicas to set.
       * @return This builder for chaining.
       */
      public Builder setReplicas(int value) {

        replicas_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * replicas is the number of Pods created by the StatefulSet controller.
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000002);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private int readyReplicas_ ;
      /**
       * <pre>
       * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
       * </pre>
       *
       * <code>optional int32 readyReplicas = 3;</code>
       * @return Whether the readyReplicas field is set.
       */
      @java.lang.Override
      public boolean hasReadyReplicas() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
       * </pre>
       *
       * <code>optional int32 readyReplicas = 3;</code>
       * @return The readyReplicas.
       */
      @java.lang.Override
      public int getReadyReplicas() {
        return readyReplicas_;
      }
      /**
       * <pre>
       * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
       * </pre>
       *
       * <code>optional int32 readyReplicas = 3;</code>
       * @param value The readyReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setReadyReplicas(int value) {

        readyReplicas_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
       * </pre>
       *
       * <code>optional int32 readyReplicas = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearReadyReplicas() {
        bitField0_ = (bitField0_ & ~0x00000004);
        readyReplicas_ = 0;
        onChanged();
        return this;
      }

      private int currentReplicas_ ;
      /**
       * <pre>
       * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
       * indicated by currentRevision.
       * </pre>
       *
       * <code>optional int32 currentReplicas = 4;</code>
       * @return Whether the currentReplicas field is set.
       */
      @java.lang.Override
      public boolean hasCurrentReplicas() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
       * indicated by currentRevision.
       * </pre>
       *
       * <code>optional int32 currentReplicas = 4;</code>
       * @return The currentReplicas.
       */
      @java.lang.Override
      public int getCurrentReplicas() {
        return currentReplicas_;
      }
      /**
       * <pre>
       * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
       * indicated by currentRevision.
       * </pre>
       *
       * <code>optional int32 currentReplicas = 4;</code>
       * @param value The currentReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setCurrentReplicas(int value) {

        currentReplicas_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
       * indicated by currentRevision.
       * </pre>
       *
       * <code>optional int32 currentReplicas = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearCurrentReplicas() {
        bitField0_ = (bitField0_ & ~0x00000008);
        currentReplicas_ = 0;
        onChanged();
        return this;
      }

      private int updatedReplicas_ ;
      /**
       * <pre>
       * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
       * indicated by updateRevision.
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 5;</code>
       * @return Whether the updatedReplicas field is set.
       */
      @java.lang.Override
      public boolean hasUpdatedReplicas() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
       * indicated by updateRevision.
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 5;</code>
       * @return The updatedReplicas.
       */
      @java.lang.Override
      public int getUpdatedReplicas() {
        return updatedReplicas_;
      }
      /**
       * <pre>
       * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
       * indicated by updateRevision.
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 5;</code>
       * @param value The updatedReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setUpdatedReplicas(int value) {

        updatedReplicas_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
       * indicated by updateRevision.
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpdatedReplicas() {
        bitField0_ = (bitField0_ & ~0x00000010);
        updatedReplicas_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object currentRevision_ = "";
      /**
       * <pre>
       * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
       * sequence [0,currentReplicas).
       * </pre>
       *
       * <code>optional string currentRevision = 6;</code>
       * @return Whether the currentRevision field is set.
       */
      public boolean hasCurrentRevision() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
       * sequence [0,currentReplicas).
       * </pre>
       *
       * <code>optional string currentRevision = 6;</code>
       * @return The currentRevision.
       */
      public java.lang.String getCurrentRevision() {
        java.lang.Object ref = currentRevision_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            currentRevision_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
       * sequence [0,currentReplicas).
       * </pre>
       *
       * <code>optional string currentRevision = 6;</code>
       * @return The bytes for currentRevision.
       */
      public com.google.protobuf.ByteString
          getCurrentRevisionBytes() {
        java.lang.Object ref = currentRevision_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          currentRevision_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
       * sequence [0,currentReplicas).
       * </pre>
       *
       * <code>optional string currentRevision = 6;</code>
       * @param value The currentRevision to set.
       * @return This builder for chaining.
       */
      public Builder setCurrentRevision(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        currentRevision_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
       * sequence [0,currentReplicas).
       * </pre>
       *
       * <code>optional string currentRevision = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearCurrentRevision() {
        currentRevision_ = getDefaultInstance().getCurrentRevision();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
       * sequence [0,currentReplicas).
       * </pre>
       *
       * <code>optional string currentRevision = 6;</code>
       * @param value The bytes for currentRevision to set.
       * @return This builder for chaining.
       */
      public Builder setCurrentRevisionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        currentRevision_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private java.lang.Object updateRevision_ = "";
      /**
       * <pre>
       * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
       * [replicas-updatedReplicas,replicas)
       * </pre>
       *
       * <code>optional string updateRevision = 7;</code>
       * @return Whether the updateRevision field is set.
       */
      public boolean hasUpdateRevision() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
       * [replicas-updatedReplicas,replicas)
       * </pre>
       *
       * <code>optional string updateRevision = 7;</code>
       * @return The updateRevision.
       */
      public java.lang.String getUpdateRevision() {
        java.lang.Object ref = updateRevision_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            updateRevision_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
       * [replicas-updatedReplicas,replicas)
       * </pre>
       *
       * <code>optional string updateRevision = 7;</code>
       * @return The bytes for updateRevision.
       */
      public com.google.protobuf.ByteString
          getUpdateRevisionBytes() {
        java.lang.Object ref = updateRevision_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          updateRevision_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
       * [replicas-updatedReplicas,replicas)
       * </pre>
       *
       * <code>optional string updateRevision = 7;</code>
       * @param value The updateRevision to set.
       * @return This builder for chaining.
       */
      public Builder setUpdateRevision(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        updateRevision_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
       * [replicas-updatedReplicas,replicas)
       * </pre>
       *
       * <code>optional string updateRevision = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpdateRevision() {
        updateRevision_ = getDefaultInstance().getUpdateRevision();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
       * [replicas-updatedReplicas,replicas)
       * </pre>
       *
       * <code>optional string updateRevision = 7;</code>
       * @param value The bytes for updateRevision to set.
       * @return This builder for chaining.
       */
      public Builder setUpdateRevisionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        updateRevision_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      private int collisionCount_ ;
      /**
       * <pre>
       * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
       * uses this field as a collision avoidance mechanism when it needs to create the name for the
       * newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       * @return Whether the collisionCount field is set.
       */
      @java.lang.Override
      public boolean hasCollisionCount() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
       * uses this field as a collision avoidance mechanism when it needs to create the name for the
       * newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       * @return The collisionCount.
       */
      @java.lang.Override
      public int getCollisionCount() {
        return collisionCount_;
      }
      /**
       * <pre>
       * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
       * uses this field as a collision avoidance mechanism when it needs to create the name for the
       * newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       * @param value The collisionCount to set.
       * @return This builder for chaining.
       */
      public Builder setCollisionCount(int value) {

        collisionCount_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
       * uses this field as a collision avoidance mechanism when it needs to create the name for the
       * newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearCollisionCount() {
        bitField0_ = (bitField0_ & ~0x00000080);
        collisionCount_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSetCondition> conditions_ =
        java.util.Collections.emptyList();
      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.StatefulSetCondition>(conditions_);
          bitField0_ |= 0x00000100;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetCondition, io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder> conditionsBuilder_;

      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSetCondition> getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetCondition getConditions(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Apps.StatefulSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public Builder addConditions(io.kubernetes.client.proto.V1Apps.StatefulSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Apps.StatefulSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.StatefulSetCondition> values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder getConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder getConditionsOrBuilder(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);  } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder> 
           getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder addConditionsBuilder() {
        return getConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.StatefulSetCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder addConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.StatefulSetCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the latest available observations of a statefulset's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.StatefulSetCondition conditions = 10;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder> 
           getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Apps.StatefulSetCondition, io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder> 
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Apps.StatefulSetCondition, io.kubernetes.client.proto.V1Apps.StatefulSetCondition.Builder, io.kubernetes.client.proto.V1Apps.StatefulSetConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000100) != 0),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      private int availableReplicas_ ;
      /**
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 11;</code>
       * @return Whether the availableReplicas field is set.
       */
      @java.lang.Override
      public boolean hasAvailableReplicas() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 11;</code>
       * @return The availableReplicas.
       */
      @java.lang.Override
      public int getAvailableReplicas() {
        return availableReplicas_;
      }
      /**
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 11;</code>
       * @param value The availableReplicas to set.
       * @return This builder for chaining.
       */
      public Builder setAvailableReplicas(int value) {

        availableReplicas_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearAvailableReplicas() {
        bitField0_ = (bitField0_ & ~0x00000200);
        availableReplicas_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.StatefulSetStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.StatefulSetStatus)
    private static final io.kubernetes.client.proto.V1Apps.StatefulSetStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.StatefulSetStatus();
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatefulSetStatus>
        PARSER = new com.google.protobuf.AbstractParser<StatefulSetStatus>() {
      @java.lang.Override
      public StatefulSetStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatefulSetStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatefulSetStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatefulSetUpdateStrategyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.StatefulSetUpdateStrategy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type indicates the type of the StatefulSetUpdateStrategy.
     * Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type indicates the type of the StatefulSetUpdateStrategy.
     * Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type indicates the type of the StatefulSetUpdateStrategy.
     * Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
     * @return Whether the rollingUpdate field is set.
     */
    boolean hasRollingUpdate();
    /**
     * <pre>
     * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
     * @return The rollingUpdate.
     */
    io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy getRollingUpdate();
    /**
     * <pre>
     * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategyOrBuilder getRollingUpdateOrBuilder();
  }
  /**
   * <pre>
   * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet
   * controller will use to perform updates. It includes any additional parameters
   * necessary to perform the update for the indicated strategy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetUpdateStrategy}
   */
  public static final class StatefulSetUpdateStrategy extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.StatefulSetUpdateStrategy)
      StatefulSetUpdateStrategyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        StatefulSetUpdateStrategy.class.getName());
    }
    // Use StatefulSetUpdateStrategy.newBuilder() to construct.
    private StatefulSetUpdateStrategy(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StatefulSetUpdateStrategy() {
      type_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.class, io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object type_ = "";
    /**
     * <pre>
     * Type indicates the type of the StatefulSetUpdateStrategy.
     * Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Type indicates the type of the StatefulSetUpdateStrategy.
     * Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type indicates the type of the StatefulSetUpdateStrategy.
     * Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROLLINGUPDATE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy rollingUpdate_;
    /**
     * <pre>
     * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
     * @return Whether the rollingUpdate field is set.
     */
    @java.lang.Override
    public boolean hasRollingUpdate() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
     * @return The rollingUpdate.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy getRollingUpdate() {
      return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.getDefaultInstance() : rollingUpdate_;
    }
    /**
     * <pre>
     * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategyOrBuilder getRollingUpdateOrBuilder() {
      return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.getDefaultInstance() : rollingUpdate_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getRollingUpdate());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRollingUpdate());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy other = (io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasRollingUpdate() != other.hasRollingUpdate()) return false;
      if (hasRollingUpdate()) {
        if (!getRollingUpdate()
            .equals(other.getRollingUpdate())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasRollingUpdate()) {
        hash = (37 * hash) + ROLLINGUPDATE_FIELD_NUMBER;
        hash = (53 * hash) + getRollingUpdate().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet
     * controller will use to perform updates. It includes any additional parameters
     * necessary to perform the update for the indicated strategy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.StatefulSetUpdateStrategy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.StatefulSetUpdateStrategy)
        io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.class, io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getRollingUpdateFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = "";
        rollingUpdate_ = null;
        if (rollingUpdateBuilder_ != null) {
          rollingUpdateBuilder_.dispose();
          rollingUpdateBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy build() {
        io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy buildPartial() {
        io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy result = new io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.rollingUpdate_ = rollingUpdateBuilder_ == null
              ? rollingUpdate_
              : rollingUpdateBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy other) {
        if (other == io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy.getDefaultInstance()) return this;
        if (other.hasType()) {
          type_ = other.type_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasRollingUpdate()) {
          mergeRollingUpdate(other.getRollingUpdate());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                type_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getRollingUpdateFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type indicates the type of the StatefulSetUpdateStrategy.
       * Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Type indicates the type of the StatefulSetUpdateStrategy.
       * Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type indicates the type of the StatefulSetUpdateStrategy.
       * Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type indicates the type of the StatefulSetUpdateStrategy.
       * Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type indicates the type of the StatefulSetUpdateStrategy.
       * Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type indicates the type of the StatefulSetUpdateStrategy.
       * Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy rollingUpdate_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy, io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategyOrBuilder> rollingUpdateBuilder_;
      /**
       * <pre>
       * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
       * @return Whether the rollingUpdate field is set.
       */
      public boolean hasRollingUpdate() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
       * @return The rollingUpdate.
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy getRollingUpdate() {
        if (rollingUpdateBuilder_ == null) {
          return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.getDefaultInstance() : rollingUpdate_;
        } else {
          return rollingUpdateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
       */
      public Builder setRollingUpdate(io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy value) {
        if (rollingUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rollingUpdate_ = value;
        } else {
          rollingUpdateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
       */
      public Builder setRollingUpdate(
          io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.Builder builderForValue) {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = builderForValue.build();
        } else {
          rollingUpdateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
       */
      public Builder mergeRollingUpdate(io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy value) {
        if (rollingUpdateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            rollingUpdate_ != null &&
            rollingUpdate_ != io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.getDefaultInstance()) {
            getRollingUpdateBuilder().mergeFrom(value);
          } else {
            rollingUpdate_ = value;
          }
        } else {
          rollingUpdateBuilder_.mergeFrom(value);
        }
        if (rollingUpdate_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
       */
      public Builder clearRollingUpdate() {
        bitField0_ = (bitField0_ & ~0x00000002);
        rollingUpdate_ = null;
        if (rollingUpdateBuilder_ != null) {
          rollingUpdateBuilder_.dispose();
          rollingUpdateBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.Builder getRollingUpdateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRollingUpdateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategyOrBuilder getRollingUpdateOrBuilder() {
        if (rollingUpdateBuilder_ != null) {
          return rollingUpdateBuilder_.getMessageOrBuilder();
        } else {
          return rollingUpdate_ == null ?
              io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.getDefaultInstance() : rollingUpdate_;
        }
      }
      /**
       * <pre>
       * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy, io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategyOrBuilder> 
          getRollingUpdateFieldBuilder() {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdateBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy, io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategy.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateStatefulSetStrategyOrBuilder>(
                  getRollingUpdate(),
                  getParentForChildren(),
                  isClean());
          rollingUpdate_ = null;
        }
        return rollingUpdateBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.StatefulSetUpdateStrategy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.StatefulSetUpdateStrategy)
    private static final io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy();
    }

    public static io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StatefulSetUpdateStrategy>
        PARSER = new com.google.protobuf.AbstractParser<StatefulSetUpdateStrategy>() {
      @java.lang.Override
      public StatefulSetUpdateStrategy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StatefulSetUpdateStrategy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StatefulSetUpdateStrategy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Apps.StatefulSetUpdateStrategy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_ControllerRevision_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_ControllerRevision_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_ControllerRevisionList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_ControllerRevisionList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSetCondition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSetCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSetList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSetSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSetStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_Deployment_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_Deployment_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DeploymentCondition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DeploymentCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DeploymentList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DeploymentList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DeploymentSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DeploymentSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DeploymentStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DeploymentStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DeploymentStrategy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DeploymentStrategy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_ReplicaSet_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_ReplicaSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_ReplicaSetList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_ReplicaSetList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_StatefulSet_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_StatefulSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_StatefulSetCondition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_StatefulSetCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_StatefulSetList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_StatefulSetList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_StatefulSetSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_StatefulSetSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_StatefulSetStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_StatefulSetStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\"k8s.io/api/apps/v1/generated.proto\022\022k8" +
      "s.io.api.apps.v1\032\"k8s.io/api/core/v1/gen" +
      "erated.proto\0324k8s.io/apimachinery/pkg/ap" +
      "is/meta/v1/generated.proto\032/k8s.io/apima" +
      "chinery/pkg/runtime/generated.proto\0326k8s" +
      ".io/apimachinery/pkg/runtime/schema/gene" +
      "rated.proto\0323k8s.io/apimachinery/pkg/uti" +
      "l/intstr/generated.proto\"\247\001\n\022ControllerR" +
      "evision\022B\n\010metadata\030\001 \001(\01320.k8s.io.apima" +
      "chinery.pkg.apis.meta.v1.ObjectMeta\022;\n\004d" +
      "ata\030\002 \001(\0132-.k8s.io.apimachinery.pkg.runt" +
      "ime.RawExtension\022\020\n\010revision\030\003 \001(\003\"\221\001\n\026C" +
      "ontrollerRevisionList\022@\n\010metadata\030\001 \001(\0132" +
      "..k8s.io.apimachinery.pkg.apis.meta.v1.L" +
      "istMeta\0225\n\005items\030\002 \003(\0132&.k8s.io.api.apps" +
      ".v1.ControllerRevision\"\265\001\n\tDaemonSet\022B\n\010" +
      "metadata\030\001 \001(\01320.k8s.io.apimachinery.pkg" +
      ".apis.meta.v1.ObjectMeta\022/\n\004spec\030\002 \001(\0132!" +
      ".k8s.io.api.apps.v1.DaemonSetSpec\0223\n\006sta" +
      "tus\030\003 \001(\0132#.k8s.io.api.apps.v1.DaemonSet" +
      "Status\"\233\001\n\022DaemonSetCondition\022\014\n\004type\030\001 " +
      "\001(\t\022\016\n\006status\030\002 \001(\t\022F\n\022lastTransitionTim" +
      "e\030\003 \001(\0132*.k8s.io.apimachinery.pkg.apis.m" +
      "eta.v1.Time\022\016\n\006reason\030\004 \001(\t\022\017\n\007message\030\005" +
      " \001(\t\"\177\n\rDaemonSetList\022@\n\010metadata\030\001 \001(\0132" +
      "..k8s.io.apimachinery.pkg.apis.meta.v1.L" +
      "istMeta\022,\n\005items\030\002 \003(\0132\035.k8s.io.api.apps" +
      ".v1.DaemonSet\"\211\002\n\rDaemonSetSpec\022E\n\010selec" +
      "tor\030\001 \001(\01323.k8s.io.apimachinery.pkg.apis" +
      ".meta.v1.LabelSelector\0225\n\010template\030\002 \001(\013" +
      "2#.k8s.io.api.core.v1.PodTemplateSpec\022C\n" +
      "\016updateStrategy\030\003 \001(\0132+.k8s.io.api.apps." +
      "v1.DaemonSetUpdateStrategy\022\027\n\017minReadySe" +
      "conds\030\004 \001(\005\022\034\n\024revisionHistoryLimit\030\006 \001(" +
      "\005\"\306\002\n\017DaemonSetStatus\022\036\n\026currentNumberSc" +
      "heduled\030\001 \001(\005\022\032\n\022numberMisscheduled\030\002 \001(" +
      "\005\022\036\n\026desiredNumberScheduled\030\003 \001(\005\022\023\n\013num" +
      "berReady\030\004 \001(\005\022\032\n\022observedGeneration\030\005 \001" +
      "(\003\022\036\n\026updatedNumberScheduled\030\006 \001(\005\022\027\n\017nu" +
      "mberAvailable\030\007 \001(\005\022\031\n\021numberUnavailable" +
      "\030\010 \001(\005\022\026\n\016collisionCount\030\t \001(\005\022:\n\ncondit" +
      "ions\030\n \003(\0132&.k8s.io.api.apps.v1.DaemonSe" +
      "tCondition\"j\n\027DaemonSetUpdateStrategy\022\014\n" +
      "\004type\030\001 \001(\t\022A\n\rrollingUpdate\030\002 \001(\0132*.k8s" +
      ".io.api.apps.v1.RollingUpdateDaemonSet\"\270" +
      "\001\n\nDeployment\022B\n\010metadata\030\001 \001(\01320.k8s.io" +
      ".apimachinery.pkg.apis.meta.v1.ObjectMet" +
      "a\0220\n\004spec\030\002 \001(\0132\".k8s.io.api.apps.v1.Dep" +
      "loymentSpec\0224\n\006status\030\003 \001(\0132$.k8s.io.api" +
      ".apps.v1.DeploymentStatus\"\340\001\n\023Deployment" +
      "Condition\022\014\n\004type\030\001 \001(\t\022\016\n\006status\030\002 \001(\t\022" +
      "B\n\016lastUpdateTime\030\006 \001(\0132*.k8s.io.apimach" +
      "inery.pkg.apis.meta.v1.Time\022F\n\022lastTrans" +
      "itionTime\030\007 \001(\0132*.k8s.io.apimachinery.pk" +
      "g.apis.meta.v1.Time\022\016\n\006reason\030\004 \001(\t\022\017\n\007m" +
      "essage\030\005 \001(\t\"\201\001\n\016DeploymentList\022@\n\010metad" +
      "ata\030\001 \001(\0132..k8s.io.apimachinery.pkg.apis" +
      ".meta.v1.ListMeta\022-\n\005items\030\002 \003(\0132\036.k8s.i" +
      "o.api.apps.v1.Deployment\"\302\002\n\016DeploymentS" +
      "pec\022\020\n\010replicas\030\001 \001(\005\022E\n\010selector\030\002 \001(\0132" +
      "3.k8s.io.apimachinery.pkg.apis.meta.v1.L" +
      "abelSelector\0225\n\010template\030\003 \001(\0132#.k8s.io." +
      "api.core.v1.PodTemplateSpec\0228\n\010strategy\030" +
      "\004 \001(\0132&.k8s.io.api.apps.v1.DeploymentStr" +
      "ategy\022\027\n\017minReadySeconds\030\005 \001(\005\022\034\n\024revisi" +
      "onHistoryLimit\030\006 \001(\005\022\016\n\006paused\030\007 \001(\010\022\037\n\027" +
      "progressDeadlineSeconds\030\t \001(\005\"\375\001\n\020Deploy" +
      "mentStatus\022\032\n\022observedGeneration\030\001 \001(\003\022\020" +
      "\n\010replicas\030\002 \001(\005\022\027\n\017updatedReplicas\030\003 \001(" +
      "\005\022\025\n\rreadyReplicas\030\007 \001(\005\022\031\n\021availableRep" +
      "licas\030\004 \001(\005\022\033\n\023unavailableReplicas\030\005 \001(\005" +
      "\022;\n\nconditions\030\006 \003(\0132\'.k8s.io.api.apps.v" +
      "1.DeploymentCondition\022\026\n\016collisionCount\030" +
      "\010 \001(\005\"f\n\022DeploymentStrategy\022\014\n\004type\030\001 \001(" +
      "\t\022B\n\rrollingUpdate\030\002 \001(\0132+.k8s.io.api.ap" +
      "ps.v1.RollingUpdateDeployment\"\270\001\n\nReplic" +
      "aSet\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimachi" +
      "nery.pkg.apis.meta.v1.ObjectMeta\0220\n\004spec" +
      "\030\002 \001(\0132\".k8s.io.api.apps.v1.ReplicaSetSp" +
      "ec\0224\n\006status\030\003 \001(\0132$.k8s.io.api.apps.v1." +
      "ReplicaSetStatus\"\234\001\n\023ReplicaSetCondition" +
      "\022\014\n\004type\030\001 \001(\t\022\016\n\006status\030\002 \001(\t\022F\n\022lastTr" +
      "ansitionTime\030\003 \001(\0132*.k8s.io.apimachinery" +
      ".pkg.apis.meta.v1.Time\022\016\n\006reason\030\004 \001(\t\022\017" +
      "\n\007message\030\005 \001(\t\"\201\001\n\016ReplicaSetList\022@\n\010me" +
      "tadata\030\001 \001(\0132..k8s.io.apimachinery.pkg.a" +
      "pis.meta.v1.ListMeta\022-\n\005items\030\002 \003(\0132\036.k8" +
      "s.io.api.apps.v1.ReplicaSet\"\271\001\n\016ReplicaS" +
      "etSpec\022\020\n\010replicas\030\001 \001(\005\022\027\n\017minReadySeco" +
      "nds\030\004 \001(\005\022E\n\010selector\030\002 \001(\01323.k8s.io.api" +
      "machinery.pkg.apis.meta.v1.LabelSelector" +
      "\0225\n\010template\030\003 \001(\0132#.k8s.io.api.core.v1." +
      "PodTemplateSpec\"\315\001\n\020ReplicaSetStatus\022\020\n\010" +
      "replicas\030\001 \001(\005\022\034\n\024fullyLabeledReplicas\030\002" +
      " \001(\005\022\025\n\rreadyReplicas\030\004 \001(\005\022\031\n\021available" +
      "Replicas\030\005 \001(\005\022\032\n\022observedGeneration\030\003 \001" +
      "(\003\022;\n\nconditions\030\006 \003(\0132\'.k8s.io.api.apps" +
      ".v1.ReplicaSetCondition\"\246\001\n\026RollingUpdat" +
      "eDaemonSet\022H\n\016maxUnavailable\030\001 \001(\01320.k8s" +
      ".io.apimachinery.pkg.util.intstr.IntOrSt" +
      "ring\022B\n\010maxSurge\030\002 \001(\01320.k8s.io.apimachi" +
      "nery.pkg.util.intstr.IntOrString\"\247\001\n\027Rol" +
      "lingUpdateDeployment\022H\n\016maxUnavailable\030\001" +
      " \001(\01320.k8s.io.apimachinery.pkg.util.ints" +
      "tr.IntOrString\022B\n\010maxSurge\030\002 \001(\01320.k8s.i" +
      "o.apimachinery.pkg.util.intstr.IntOrStri" +
      "ng\"\177\n RollingUpdateStatefulSetStrategy\022\021" +
      "\n\tpartition\030\001 \001(\005\022H\n\016maxUnavailable\030\002 \001(" +
      "\01320.k8s.io.apimachinery.pkg.util.intstr." +
      "IntOrString\"\273\001\n\013StatefulSet\022B\n\010metadata\030" +
      "\001 \001(\01320.k8s.io.apimachinery.pkg.apis.met" +
      "a.v1.ObjectMeta\0221\n\004spec\030\002 \001(\0132#.k8s.io.a" +
      "pi.apps.v1.StatefulSetSpec\0225\n\006status\030\003 \001" +
      "(\0132%.k8s.io.api.apps.v1.StatefulSetStatu" +
      "s\"\235\001\n\024StatefulSetCondition\022\014\n\004type\030\001 \001(\t" +
      "\022\016\n\006status\030\002 \001(\t\022F\n\022lastTransitionTime\030\003" +
      " \001(\0132*.k8s.io.apimachinery.pkg.apis.meta" +
      ".v1.Time\022\016\n\006reason\030\004 \001(\t\022\017\n\007message\030\005 \001(" +
      "\t\"\203\001\n\017StatefulSetList\022@\n\010metadata\030\001 \001(\0132" +
      "..k8s.io.apimachinery.pkg.apis.meta.v1.L" +
      "istMeta\022.\n\005items\030\002 \003(\0132\037.k8s.io.api.apps" +
      ".v1.StatefulSet\"$\n\023StatefulSetOrdinals\022\r" +
      "\n\005start\030\001 \001(\005\"Z\n/StatefulSetPersistentVo" +
      "lumeClaimRetentionPolicy\022\023\n\013whenDeleted\030" +
      "\001 \001(\t\022\022\n\nwhenScaled\030\002 \001(\t\"\310\004\n\017StatefulSe" +
      "tSpec\022\020\n\010replicas\030\001 \001(\005\022E\n\010selector\030\002 \001(" +
      "\01323.k8s.io.apimachinery.pkg.apis.meta.v1" +
      ".LabelSelector\0225\n\010template\030\003 \001(\0132#.k8s.i" +
      "o.api.core.v1.PodTemplateSpec\022G\n\024volumeC" +
      "laimTemplates\030\004 \003(\0132).k8s.io.api.core.v1" +
      ".PersistentVolumeClaim\022\023\n\013serviceName\030\005 " +
      "\001(\t\022\033\n\023podManagementPolicy\030\006 \001(\t\022E\n\016upda" +
      "teStrategy\030\007 \001(\0132-.k8s.io.api.apps.v1.St" +
      "atefulSetUpdateStrategy\022\034\n\024revisionHisto" +
      "ryLimit\030\010 \001(\005\022\027\n\017minReadySeconds\030\t \001(\005\022q" +
      "\n$persistentVolumeClaimRetentionPolicy\030\n" +
      " \001(\0132C.k8s.io.api.apps.v1.StatefulSetPer" +
      "sistentVolumeClaimRetentionPolicy\0229\n\010ord" +
      "inals\030\013 \001(\0132\'.k8s.io.api.apps.v1.Statefu" +
      "lSetOrdinals\"\254\002\n\021StatefulSetStatus\022\032\n\022ob" +
      "servedGeneration\030\001 \001(\003\022\020\n\010replicas\030\002 \001(\005" +
      "\022\025\n\rreadyReplicas\030\003 \001(\005\022\027\n\017currentReplic" +
      "as\030\004 \001(\005\022\027\n\017updatedReplicas\030\005 \001(\005\022\027\n\017cur" +
      "rentRevision\030\006 \001(\t\022\026\n\016updateRevision\030\007 \001" +
      "(\t\022\026\n\016collisionCount\030\t \001(\005\022<\n\nconditions" +
      "\030\n \003(\0132(.k8s.io.api.apps.v1.StatefulSetC" +
      "ondition\022\031\n\021availableReplicas\030\013 \001(\005\"v\n\031S" +
      "tatefulSetUpdateStrategy\022\014\n\004type\030\001 \001(\t\022K" +
      "\n\rrollingUpdate\030\002 \001(\01324.k8s.io.api.apps." +
      "v1.RollingUpdateStatefulSetStrategyB8\n\032i" +
      "o.kubernetes.client.protoB\006V1AppsZ\022k8s.i" +
      "o/api/apps/v1"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.kubernetes.client.proto.V1.getDescriptor(),
          io.kubernetes.client.proto.Meta.getDescriptor(),
          io.kubernetes.client.proto.Runtime.getDescriptor(),
          io.kubernetes.client.proto.RuntimeSchema.getDescriptor(),
          io.kubernetes.client.proto.IntStr.getDescriptor(),
        });
    internal_static_k8s_io_api_apps_v1_ControllerRevision_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_k8s_io_api_apps_v1_ControllerRevision_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_ControllerRevision_descriptor,
        new java.lang.String[] { "Metadata", "Data", "Revision", });
    internal_static_k8s_io_api_apps_v1_ControllerRevisionList_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_k8s_io_api_apps_v1_ControllerRevisionList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_ControllerRevisionList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_k8s_io_api_apps_v1_DaemonSet_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_apps_v1_DaemonSetCondition_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_k8s_io_api_apps_v1_DaemonSetCondition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSetCondition_descriptor,
        new java.lang.String[] { "Type", "Status", "LastTransitionTime", "Reason", "Message", });
    internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_k8s_io_api_apps_v1_DaemonSetList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_k8s_io_api_apps_v1_DaemonSetSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor,
        new java.lang.String[] { "Selector", "Template", "UpdateStrategy", "MinReadySeconds", "RevisionHistoryLimit", });
    internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_k8s_io_api_apps_v1_DaemonSetStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor,
        new java.lang.String[] { "CurrentNumberScheduled", "NumberMisscheduled", "DesiredNumberScheduled", "NumberReady", "ObservedGeneration", "UpdatedNumberScheduled", "NumberAvailable", "NumberUnavailable", "CollisionCount", "Conditions", });
    internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor,
        new java.lang.String[] { "Type", "RollingUpdate", });
    internal_static_k8s_io_api_apps_v1_Deployment_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_k8s_io_api_apps_v1_Deployment_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_Deployment_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_apps_v1_DeploymentCondition_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_k8s_io_api_apps_v1_DeploymentCondition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DeploymentCondition_descriptor,
        new java.lang.String[] { "Type", "Status", "LastUpdateTime", "LastTransitionTime", "Reason", "Message", });
    internal_static_k8s_io_api_apps_v1_DeploymentList_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_k8s_io_api_apps_v1_DeploymentList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DeploymentList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_apps_v1_DeploymentSpec_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_k8s_io_api_apps_v1_DeploymentSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DeploymentSpec_descriptor,
        new java.lang.String[] { "Replicas", "Selector", "Template", "Strategy", "MinReadySeconds", "RevisionHistoryLimit", "Paused", "ProgressDeadlineSeconds", });
    internal_static_k8s_io_api_apps_v1_DeploymentStatus_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_k8s_io_api_apps_v1_DeploymentStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DeploymentStatus_descriptor,
        new java.lang.String[] { "ObservedGeneration", "Replicas", "UpdatedReplicas", "ReadyReplicas", "AvailableReplicas", "UnavailableReplicas", "Conditions", "CollisionCount", });
    internal_static_k8s_io_api_apps_v1_DeploymentStrategy_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_k8s_io_api_apps_v1_DeploymentStrategy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DeploymentStrategy_descriptor,
        new java.lang.String[] { "Type", "RollingUpdate", });
    internal_static_k8s_io_api_apps_v1_ReplicaSet_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_k8s_io_api_apps_v1_ReplicaSet_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_ReplicaSet_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_ReplicaSetCondition_descriptor,
        new java.lang.String[] { "Type", "Status", "LastTransitionTime", "Reason", "Message", });
    internal_static_k8s_io_api_apps_v1_ReplicaSetList_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_k8s_io_api_apps_v1_ReplicaSetList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_ReplicaSetList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_ReplicaSetSpec_descriptor,
        new java.lang.String[] { "Replicas", "MinReadySeconds", "Selector", "Template", });
    internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_ReplicaSetStatus_descriptor,
        new java.lang.String[] { "Replicas", "FullyLabeledReplicas", "ReadyReplicas", "AvailableReplicas", "ObservedGeneration", "Conditions", });
    internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor,
        new java.lang.String[] { "MaxUnavailable", "MaxSurge", });
    internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_RollingUpdateDeployment_descriptor,
        new java.lang.String[] { "MaxUnavailable", "MaxSurge", });
    internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_RollingUpdateStatefulSetStrategy_descriptor,
        new java.lang.String[] { "Partition", "MaxUnavailable", });
    internal_static_k8s_io_api_apps_v1_StatefulSet_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_k8s_io_api_apps_v1_StatefulSet_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_StatefulSet_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_apps_v1_StatefulSetCondition_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_k8s_io_api_apps_v1_StatefulSetCondition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_StatefulSetCondition_descriptor,
        new java.lang.String[] { "Type", "Status", "LastTransitionTime", "Reason", "Message", });
    internal_static_k8s_io_api_apps_v1_StatefulSetList_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_k8s_io_api_apps_v1_StatefulSetList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_StatefulSetList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_descriptor =
      getDescriptor().getMessageTypes().get(25);
    internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_StatefulSetOrdinals_descriptor,
        new java.lang.String[] { "Start", });
    internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_descriptor =
      getDescriptor().getMessageTypes().get(26);
    internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_StatefulSetPersistentVolumeClaimRetentionPolicy_descriptor,
        new java.lang.String[] { "WhenDeleted", "WhenScaled", });
    internal_static_k8s_io_api_apps_v1_StatefulSetSpec_descriptor =
      getDescriptor().getMessageTypes().get(27);
    internal_static_k8s_io_api_apps_v1_StatefulSetSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_StatefulSetSpec_descriptor,
        new java.lang.String[] { "Replicas", "Selector", "Template", "VolumeClaimTemplates", "ServiceName", "PodManagementPolicy", "UpdateStrategy", "RevisionHistoryLimit", "MinReadySeconds", "PersistentVolumeClaimRetentionPolicy", "Ordinals", });
    internal_static_k8s_io_api_apps_v1_StatefulSetStatus_descriptor =
      getDescriptor().getMessageTypes().get(28);
    internal_static_k8s_io_api_apps_v1_StatefulSetStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_StatefulSetStatus_descriptor,
        new java.lang.String[] { "ObservedGeneration", "Replicas", "ReadyReplicas", "CurrentReplicas", "UpdatedReplicas", "CurrentRevision", "UpdateRevision", "CollisionCount", "Conditions", "AvailableReplicas", });
    internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_descriptor =
      getDescriptor().getMessageTypes().get(29);
    internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_StatefulSetUpdateStrategy_descriptor,
        new java.lang.String[] { "Type", "RollingUpdate", });
    descriptor.resolveAllFeaturesImmutable();
    io.kubernetes.client.proto.V1.getDescriptor();
    io.kubernetes.client.proto.Meta.getDescriptor();
    io.kubernetes.client.proto.Runtime.getDescriptor();
    io.kubernetes.client.proto.RuntimeSchema.getDescriptor();
    io.kubernetes.client.proto.IntStr.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
