// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: k8s.io/api/admissionregistration/v1beta1/generated.proto
// Protobuf Java Version: 4.26.1

package io.kubernetes.client.proto;

public final class V1beta1Admissionregistration {
  private V1beta1Admissionregistration() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 26,
      /* patch= */ 1,
      /* suffix= */ "",
      V1beta1Admissionregistration.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface AuditAnnotationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     *
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     *
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     *
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     *
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     *
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     *
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     *
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     *
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     *
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     *
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     *
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     * @return Whether the valueExpression field is set.
     */
    boolean hasValueExpression();
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     *
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     *
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     * @return The valueExpression.
     */
    java.lang.String getValueExpression();
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     *
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     *
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     * @return The bytes for valueExpression.
     */
    com.google.protobuf.ByteString
        getValueExpressionBytes();
  }
  /**
   * <pre>
   * AuditAnnotation describes how to produce an audit annotation for an API request.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.AuditAnnotation}
   */
  public static final class AuditAnnotation extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
      AuditAnnotationOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        AuditAnnotation.class.getName());
    }
    // Use AuditAnnotation.newBuilder() to construct.
    private AuditAnnotation(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private AuditAnnotation() {
      key_ = "";
      valueExpression_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder.class);
    }

    private int bitField0_;
    public static final int KEY_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object key_ = "";
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     *
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     *
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     *
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     *
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     *
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     *
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          key_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     *
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     *
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     *
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUEEXPRESSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object valueExpression_ = "";
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     *
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     *
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     * @return Whether the valueExpression field is set.
     */
    @java.lang.Override
    public boolean hasValueExpression() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     *
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     *
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     * @return The valueExpression.
     */
    @java.lang.Override
    public java.lang.String getValueExpression() {
      java.lang.Object ref = valueExpression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          valueExpression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     *
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     *
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     * @return The bytes for valueExpression.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValueExpressionBytes() {
      java.lang.Object ref = valueExpression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        valueExpression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, key_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, valueExpression_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, key_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, valueExpression_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation other = (io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation) obj;

      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (hasValueExpression() != other.hasValueExpression()) return false;
      if (hasValueExpression()) {
        if (!getValueExpression()
            .equals(other.getValueExpression())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasValueExpression()) {
        hash = (37 * hash) + VALUEEXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getValueExpression().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * AuditAnnotation describes how to produce an audit annotation for an API request.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.AuditAnnotation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
        io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        key_ = "";
        valueExpression_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation result = new io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.key_ = key_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.valueExpression_ = valueExpression_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.getDefaultInstance()) return this;
        if (other.hasKey()) {
          key_ = other.key_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasValueExpression()) {
          valueExpression_ = other.valueExpression_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                key_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                valueExpression_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object key_ = "";
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       *
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       *
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       *
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @return Whether the key field is set.
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       *
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       *
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       *
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @return The key.
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       *
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       *
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       *
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @return The bytes for key.
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       *
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       *
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       *
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       *
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       *
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       *
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        key_ = getDefaultInstance().getKey();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       *
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       *
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       *
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object valueExpression_ = "";
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       *
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       *
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       * @return Whether the valueExpression field is set.
       */
      public boolean hasValueExpression() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       *
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       *
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       * @return The valueExpression.
       */
      public java.lang.String getValueExpression() {
        java.lang.Object ref = valueExpression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            valueExpression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       *
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       *
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       * @return The bytes for valueExpression.
       */
      public com.google.protobuf.ByteString
          getValueExpressionBytes() {
        java.lang.Object ref = valueExpression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          valueExpression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       *
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       *
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       * @param value The valueExpression to set.
       * @return This builder for chaining.
       */
      public Builder setValueExpression(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        valueExpression_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       *
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       *
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearValueExpression() {
        valueExpression_ = getDefaultInstance().getValueExpression();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       *
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       *
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       * @param value The bytes for valueExpression to set.
       * @return This builder for chaining.
       */
      public Builder setValueExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        valueExpression_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AuditAnnotation>
        PARSER = new com.google.protobuf.AbstractParser<AuditAnnotation>() {
      @java.lang.Override
      public AuditAnnotation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<AuditAnnotation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AuditAnnotation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ExpressionWarningOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     * @return Whether the fieldRef field is set.
     */
    boolean hasFieldRef();
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     * @return The fieldRef.
     */
    java.lang.String getFieldRef();
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     * @return The bytes for fieldRef.
     */
    com.google.protobuf.ByteString
        getFieldRefBytes();

    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     * @return Whether the warning field is set.
     */
    boolean hasWarning();
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     * @return The warning.
     */
    java.lang.String getWarning();
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     * @return The bytes for warning.
     */
    com.google.protobuf.ByteString
        getWarningBytes();
  }
  /**
   * <pre>
   * ExpressionWarning is a warning information that targets a specific expression.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ExpressionWarning}
   */
  public static final class ExpressionWarning extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
      ExpressionWarningOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ExpressionWarning.class.getName());
    }
    // Use ExpressionWarning.newBuilder() to construct.
    private ExpressionWarning(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ExpressionWarning() {
      fieldRef_ = "";
      warning_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder.class);
    }

    private int bitField0_;
    public static final int FIELDREF_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object fieldRef_ = "";
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     * @return Whether the fieldRef field is set.
     */
    @java.lang.Override
    public boolean hasFieldRef() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     * @return The fieldRef.
     */
    @java.lang.Override
    public java.lang.String getFieldRef() {
      java.lang.Object ref = fieldRef_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldRef_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     * @return The bytes for fieldRef.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFieldRefBytes() {
      java.lang.Object ref = fieldRef_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldRef_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WARNING_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object warning_ = "";
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     * @return Whether the warning field is set.
     */
    @java.lang.Override
    public boolean hasWarning() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     * @return The warning.
     */
    @java.lang.Override
    public java.lang.String getWarning() {
      java.lang.Object ref = warning_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          warning_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     * @return The bytes for warning.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getWarningBytes() {
      java.lang.Object ref = warning_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        warning_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, fieldRef_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, warning_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, fieldRef_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, warning_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning) obj;

      if (hasFieldRef() != other.hasFieldRef()) return false;
      if (hasFieldRef()) {
        if (!getFieldRef()
            .equals(other.getFieldRef())) return false;
      }
      if (hasWarning() != other.hasWarning()) return false;
      if (hasWarning()) {
        if (!getWarning()
            .equals(other.getWarning())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasFieldRef()) {
        hash = (37 * hash) + FIELDREF_FIELD_NUMBER;
        hash = (53 * hash) + getFieldRef().hashCode();
      }
      if (hasWarning()) {
        hash = (37 * hash) + WARNING_FIELD_NUMBER;
        hash = (53 * hash) + getWarning().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ExpressionWarning is a warning information that targets a specific expression.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ExpressionWarning}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        fieldRef_ = "";
        warning_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.fieldRef_ = fieldRef_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.warning_ = warning_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.getDefaultInstance()) return this;
        if (other.hasFieldRef()) {
          fieldRef_ = other.fieldRef_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasWarning()) {
          warning_ = other.warning_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 18: {
                fieldRef_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 18
              case 26: {
                warning_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object fieldRef_ = "";
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       * @return Whether the fieldRef field is set.
       */
      public boolean hasFieldRef() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       * @return The fieldRef.
       */
      public java.lang.String getFieldRef() {
        java.lang.Object ref = fieldRef_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldRef_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       * @return The bytes for fieldRef.
       */
      public com.google.protobuf.ByteString
          getFieldRefBytes() {
        java.lang.Object ref = fieldRef_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldRef_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       * @param value The fieldRef to set.
       * @return This builder for chaining.
       */
      public Builder setFieldRef(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        fieldRef_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldRef() {
        fieldRef_ = getDefaultInstance().getFieldRef();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       * @param value The bytes for fieldRef to set.
       * @return This builder for chaining.
       */
      public Builder setFieldRefBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        fieldRef_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object warning_ = "";
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       * @return Whether the warning field is set.
       */
      public boolean hasWarning() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       * @return The warning.
       */
      public java.lang.String getWarning() {
        java.lang.Object ref = warning_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            warning_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       * @return The bytes for warning.
       */
      public com.google.protobuf.ByteString
          getWarningBytes() {
        java.lang.Object ref = warning_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          warning_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       * @param value The warning to set.
       * @return This builder for chaining.
       */
      public Builder setWarning(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        warning_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearWarning() {
        warning_ = getDefaultInstance().getWarning();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       * @param value The bytes for warning to set.
       * @return This builder for chaining.
       */
      public Builder setWarningBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        warning_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ExpressionWarning>
        PARSER = new com.google.protobuf.AbstractParser<ExpressionWarning>() {
      @java.lang.Override
      public ExpressionWarning parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ExpressionWarning> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExpressionWarning> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MatchConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     *
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     *
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     *
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     *
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     *
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     * @return Whether the expression field is set.
     */
    boolean hasExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     *
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     *
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     * @return The expression.
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     *
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     *
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     * @return The bytes for expression.
     */
    com.google.protobuf.ByteString
        getExpressionBytes();
  }
  /**
   * <pre>
   * MatchCondition represents a condition which must be fulfilled for a request to be sent to a webhook.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MatchCondition}
   */
  public static final class MatchCondition extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
      MatchConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        MatchCondition.class.getName());
    }
    // Use MatchCondition.newBuilder() to construct.
    private MatchCondition(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private MatchCondition() {
      name_ = "";
      expression_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     *
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     *
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     *
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EXPRESSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object expression_ = "";
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     *
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     *
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     * @return Whether the expression field is set.
     */
    @java.lang.Override
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     *
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     *
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     * @return The expression.
     */
    @java.lang.Override
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     *
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     *
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     * @return The bytes for expression.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, expression_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, expression_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasExpression() != other.hasExpression()) return false;
      if (hasExpression()) {
        if (!getExpression()
            .equals(other.getExpression())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MatchCondition represents a condition which must be fulfilled for a request to be sent to a webhook.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MatchCondition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        expression_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.expression_ = expression_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasExpression()) {
          expression_ = other.expression_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                expression_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       *
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       *
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       *
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       *
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       *
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       *
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       *
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       *
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       * @return Whether the expression field is set.
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       *
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       *
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       * @return The expression.
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       *
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       *
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       * @return The bytes for expression.
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       *
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       *
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       * @param value The expression to set.
       * @return This builder for chaining.
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        expression_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       *
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       *
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpression() {
        expression_ = getDefaultInstance().getExpression();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       *
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       *
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       * @param value The bytes for expression to set.
       * @return This builder for chaining.
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        expression_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MatchCondition>
        PARSER = new com.google.protobuf.AbstractParser<MatchCondition>() {
      @java.lang.Override
      public MatchCondition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MatchCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MatchCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MatchResourcesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MatchResources)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     * @return Whether the namespaceSelector field is set.
     */
    boolean hasNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     * @return The namespaceSelector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     * @return Whether the objectSelector field is set.
     */
    boolean hasObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     * @return The objectSelector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder();

    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> 
        getResourceRulesList();
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getResourceRules(int index);
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    int getResourceRulesCount();
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getResourceRulesOrBuilderList();
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getResourceRulesOrBuilder(
        int index);

    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> 
        getExcludeResourceRulesList();
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getExcludeResourceRules(int index);
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    int getExcludeResourceRulesCount();
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getExcludeResourceRulesOrBuilderList();
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getExcludeResourceRulesOrBuilder(
        int index);

    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     *
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     * @return Whether the matchPolicy field is set.
     */
    boolean hasMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     *
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     * @return The matchPolicy.
     */
    java.lang.String getMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     *
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     * @return The bytes for matchPolicy.
     */
    com.google.protobuf.ByteString
        getMatchPolicyBytes();
  }
  /**
   * <pre>
   * MatchResources decides whether to run the admission control policy on an object based
   * on whether it meets the match criteria.
   * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MatchResources}
   */
  public static final class MatchResources extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MatchResources)
      MatchResourcesOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        MatchResources.class.getName());
    }
    // Use MatchResources.newBuilder() to construct.
    private MatchResources(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private MatchResources() {
      resourceRules_ = java.util.Collections.emptyList();
      excludeResourceRules_ = java.util.Collections.emptyList();
      matchPolicy_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder.class);
    }

    private int bitField0_;
    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     * @return Whether the namespaceSelector field is set.
     */
    @java.lang.Override
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     * @return The namespaceSelector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }

    public static final int OBJECTSELECTOR_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     * @return Whether the objectSelector field is set.
     */
    @java.lang.Override
    public boolean hasObjectSelector() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     * @return The objectSelector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }

    public static final int RESOURCERULES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> resourceRules_;
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> getResourceRulesList() {
      return resourceRules_;
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getResourceRulesOrBuilderList() {
      return resourceRules_;
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    @java.lang.Override
    public int getResourceRulesCount() {
      return resourceRules_.size();
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getResourceRules(int index) {
      return resourceRules_.get(index);
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getResourceRulesOrBuilder(
        int index) {
      return resourceRules_.get(index);
    }

    public static final int EXCLUDERESOURCERULES_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> excludeResourceRules_;
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> getExcludeResourceRulesList() {
      return excludeResourceRules_;
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getExcludeResourceRulesOrBuilderList() {
      return excludeResourceRules_;
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    @java.lang.Override
    public int getExcludeResourceRulesCount() {
      return excludeResourceRules_.size();
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getExcludeResourceRules(int index) {
      return excludeResourceRules_.get(index);
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getExcludeResourceRulesOrBuilder(
        int index) {
      return excludeResourceRules_.get(index);
    }

    public static final int MATCHPOLICY_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object matchPolicy_ = "";
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     *
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     * @return Whether the matchPolicy field is set.
     */
    @java.lang.Override
    public boolean hasMatchPolicy() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     *
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     * @return The matchPolicy.
     */
    @java.lang.Override
    public java.lang.String getMatchPolicy() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     *
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     * @return The bytes for matchPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMatchPolicyBytes() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        matchPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getObjectSelector());
      }
      for (int i = 0; i < resourceRules_.size(); i++) {
        output.writeMessage(3, resourceRules_.get(i));
      }
      for (int i = 0; i < excludeResourceRules_.size(); i++) {
        output.writeMessage(4, excludeResourceRules_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 7, matchPolicy_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getObjectSelector());
      }
      for (int i = 0; i < resourceRules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, resourceRules_.get(i));
      }
      for (int i = 0; i < excludeResourceRules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, excludeResourceRules_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(7, matchPolicy_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources) obj;

      if (hasNamespaceSelector() != other.hasNamespaceSelector()) return false;
      if (hasNamespaceSelector()) {
        if (!getNamespaceSelector()
            .equals(other.getNamespaceSelector())) return false;
      }
      if (hasObjectSelector() != other.hasObjectSelector()) return false;
      if (hasObjectSelector()) {
        if (!getObjectSelector()
            .equals(other.getObjectSelector())) return false;
      }
      if (!getResourceRulesList()
          .equals(other.getResourceRulesList())) return false;
      if (!getExcludeResourceRulesList()
          .equals(other.getExcludeResourceRulesList())) return false;
      if (hasMatchPolicy() != other.hasMatchPolicy()) return false;
      if (hasMatchPolicy()) {
        if (!getMatchPolicy()
            .equals(other.getMatchPolicy())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasObjectSelector()) {
        hash = (37 * hash) + OBJECTSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getObjectSelector().hashCode();
      }
      if (getResourceRulesCount() > 0) {
        hash = (37 * hash) + RESOURCERULES_FIELD_NUMBER;
        hash = (53 * hash) + getResourceRulesList().hashCode();
      }
      if (getExcludeResourceRulesCount() > 0) {
        hash = (37 * hash) + EXCLUDERESOURCERULES_FIELD_NUMBER;
        hash = (53 * hash) + getExcludeResourceRulesList().hashCode();
      }
      if (hasMatchPolicy()) {
        hash = (37 * hash) + MATCHPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getMatchPolicy().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MatchResources decides whether to run the admission control policy on an object based
     * on whether it meets the match criteria.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MatchResources}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MatchResources)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getNamespaceSelectorFieldBuilder();
          getObjectSelectorFieldBuilder();
          getResourceRulesFieldBuilder();
          getExcludeResourceRulesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        namespaceSelector_ = null;
        if (namespaceSelectorBuilder_ != null) {
          namespaceSelectorBuilder_.dispose();
          namespaceSelectorBuilder_ = null;
        }
        objectSelector_ = null;
        if (objectSelectorBuilder_ != null) {
          objectSelectorBuilder_.dispose();
          objectSelectorBuilder_ = null;
        }
        if (resourceRulesBuilder_ == null) {
          resourceRules_ = java.util.Collections.emptyList();
        } else {
          resourceRules_ = null;
          resourceRulesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (excludeResourceRulesBuilder_ == null) {
          excludeResourceRules_ = java.util.Collections.emptyList();
        } else {
          excludeResourceRules_ = null;
          excludeResourceRulesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        matchPolicy_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources result) {
        if (resourceRulesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            resourceRules_ = java.util.Collections.unmodifiableList(resourceRules_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.resourceRules_ = resourceRules_;
        } else {
          result.resourceRules_ = resourceRulesBuilder_.build();
        }
        if (excludeResourceRulesBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            excludeResourceRules_ = java.util.Collections.unmodifiableList(excludeResourceRules_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.excludeResourceRules_ = excludeResourceRules_;
        } else {
          result.excludeResourceRules_ = excludeResourceRulesBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.namespaceSelector_ = namespaceSelectorBuilder_ == null
              ? namespaceSelector_
              : namespaceSelectorBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.objectSelector_ = objectSelectorBuilder_ == null
              ? objectSelector_
              : objectSelectorBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.matchPolicy_ = matchPolicy_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance()) return this;
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasObjectSelector()) {
          mergeObjectSelector(other.getObjectSelector());
        }
        if (resourceRulesBuilder_ == null) {
          if (!other.resourceRules_.isEmpty()) {
            if (resourceRules_.isEmpty()) {
              resourceRules_ = other.resourceRules_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureResourceRulesIsMutable();
              resourceRules_.addAll(other.resourceRules_);
            }
            onChanged();
          }
        } else {
          if (!other.resourceRules_.isEmpty()) {
            if (resourceRulesBuilder_.isEmpty()) {
              resourceRulesBuilder_.dispose();
              resourceRulesBuilder_ = null;
              resourceRules_ = other.resourceRules_;
              bitField0_ = (bitField0_ & ~0x00000004);
              resourceRulesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getResourceRulesFieldBuilder() : null;
            } else {
              resourceRulesBuilder_.addAllMessages(other.resourceRules_);
            }
          }
        }
        if (excludeResourceRulesBuilder_ == null) {
          if (!other.excludeResourceRules_.isEmpty()) {
            if (excludeResourceRules_.isEmpty()) {
              excludeResourceRules_ = other.excludeResourceRules_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureExcludeResourceRulesIsMutable();
              excludeResourceRules_.addAll(other.excludeResourceRules_);
            }
            onChanged();
          }
        } else {
          if (!other.excludeResourceRules_.isEmpty()) {
            if (excludeResourceRulesBuilder_.isEmpty()) {
              excludeResourceRulesBuilder_.dispose();
              excludeResourceRulesBuilder_ = null;
              excludeResourceRules_ = other.excludeResourceRules_;
              bitField0_ = (bitField0_ & ~0x00000008);
              excludeResourceRulesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getExcludeResourceRulesFieldBuilder() : null;
            } else {
              excludeResourceRulesBuilder_.addAllMessages(other.excludeResourceRules_);
            }
          }
        }
        if (other.hasMatchPolicy()) {
          matchPolicy_ = other.matchPolicy_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getNamespaceSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getObjectSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.parser(),
                        extensionRegistry);
                if (resourceRulesBuilder_ == null) {
                  ensureResourceRulesIsMutable();
                  resourceRules_.add(m);
                } else {
                  resourceRulesBuilder_.addMessage(m);
                }
                break;
              } // case 26
              case 34: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.parser(),
                        extensionRegistry);
                if (excludeResourceRulesBuilder_ == null) {
                  ensureExcludeResourceRulesIsMutable();
                  excludeResourceRules_.add(m);
                } else {
                  excludeResourceRulesBuilder_.addMessage(m);
                }
                break;
              } // case 34
              case 58: {
                matchPolicy_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 58
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> namespaceSelectorBuilder_;
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       * @return Whether the namespaceSelector field is set.
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       * @return The namespaceSelector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            namespaceSelector_ != null &&
            namespaceSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getNamespaceSelectorBuilder().mergeFrom(value);
          } else {
            namespaceSelector_ = value;
          }
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        if (namespaceSelector_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder clearNamespaceSelector() {
        bitField0_ = (bitField0_ & ~0x00000001);
        namespaceSelector_ = null;
        if (namespaceSelectorBuilder_ != null) {
          namespaceSelectorBuilder_.dispose();
          namespaceSelectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(),
                  getParentForChildren(),
                  isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> objectSelectorBuilder_;
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       * @return Whether the objectSelector field is set.
       */
      public boolean hasObjectSelector() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       * @return The objectSelector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        } else {
          return objectSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder setObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectSelector_ = value;
        } else {
          objectSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder setObjectSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = builderForValue.build();
        } else {
          objectSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder mergeObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            objectSelector_ != null &&
            objectSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getObjectSelectorBuilder().mergeFrom(value);
          } else {
            objectSelector_ = value;
          }
        } else {
          objectSelectorBuilder_.mergeFrom(value);
        }
        if (objectSelector_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder clearObjectSelector() {
        bitField0_ = (bitField0_ & ~0x00000002);
        objectSelector_ = null;
        if (objectSelectorBuilder_ != null) {
          objectSelectorBuilder_.dispose();
          objectSelectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getObjectSelectorBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getObjectSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
        if (objectSelectorBuilder_ != null) {
          return objectSelectorBuilder_.getMessageOrBuilder();
        } else {
          return objectSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getObjectSelectorFieldBuilder() {
        if (objectSelectorBuilder_ == null) {
          objectSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getObjectSelector(),
                  getParentForChildren(),
                  isClean());
          objectSelector_ = null;
        }
        return objectSelectorBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> resourceRules_ =
        java.util.Collections.emptyList();
      private void ensureResourceRulesIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          resourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations>(resourceRules_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> resourceRulesBuilder_;

      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> getResourceRulesList() {
        if (resourceRulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(resourceRules_);
        } else {
          return resourceRulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public int getResourceRulesCount() {
        if (resourceRulesBuilder_ == null) {
          return resourceRules_.size();
        } else {
          return resourceRulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getResourceRules(int index) {
        if (resourceRulesBuilder_ == null) {
          return resourceRules_.get(index);
        } else {
          return resourceRulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder setResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (resourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceRulesIsMutable();
          resourceRules_.set(index, value);
          onChanged();
        } else {
          resourceRulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder setResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.set(index, builderForValue.build());
          onChanged();
        } else {
          resourceRulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (resourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceRulesIsMutable();
          resourceRules_.add(value);
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (resourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceRulesIsMutable();
          resourceRules_.add(index, value);
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.add(builderForValue.build());
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.add(index, builderForValue.build());
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addAllResourceRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> values) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, resourceRules_);
          onChanged();
        } else {
          resourceRulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder clearResourceRules() {
        if (resourceRulesBuilder_ == null) {
          resourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          resourceRulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder removeResourceRules(int index) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.remove(index);
          onChanged();
        } else {
          resourceRulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder getResourceRulesBuilder(
          int index) {
        return getResourceRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getResourceRulesOrBuilder(
          int index) {
        if (resourceRulesBuilder_ == null) {
          return resourceRules_.get(index);  } else {
          return resourceRulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
           getResourceRulesOrBuilderList() {
        if (resourceRulesBuilder_ != null) {
          return resourceRulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(resourceRules_);
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder addResourceRulesBuilder() {
        return getResourceRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder addResourceRulesBuilder(
          int index) {
        return getResourceRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder> 
           getResourceRulesBuilderList() {
        return getResourceRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
          getResourceRulesFieldBuilder() {
        if (resourceRulesBuilder_ == null) {
          resourceRulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder>(
                  resourceRules_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          resourceRules_ = null;
        }
        return resourceRulesBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> excludeResourceRules_ =
        java.util.Collections.emptyList();
      private void ensureExcludeResourceRulesIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          excludeResourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations>(excludeResourceRules_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> excludeResourceRulesBuilder_;

      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> getExcludeResourceRulesList() {
        if (excludeResourceRulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(excludeResourceRules_);
        } else {
          return excludeResourceRulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public int getExcludeResourceRulesCount() {
        if (excludeResourceRulesBuilder_ == null) {
          return excludeResourceRules_.size();
        } else {
          return excludeResourceRulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getExcludeResourceRules(int index) {
        if (excludeResourceRulesBuilder_ == null) {
          return excludeResourceRules_.get(index);
        } else {
          return excludeResourceRulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder setExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (excludeResourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.set(index, value);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder setExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.set(index, builderForValue.build());
          onChanged();
        } else {
          excludeResourceRulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (excludeResourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(value);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (excludeResourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(index, value);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(builderForValue.build());
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(index, builderForValue.build());
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addAllExcludeResourceRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> values) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, excludeResourceRules_);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder clearExcludeResourceRules() {
        if (excludeResourceRulesBuilder_ == null) {
          excludeResourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder removeExcludeResourceRules(int index) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.remove(index);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder getExcludeResourceRulesBuilder(
          int index) {
        return getExcludeResourceRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getExcludeResourceRulesOrBuilder(
          int index) {
        if (excludeResourceRulesBuilder_ == null) {
          return excludeResourceRules_.get(index);  } else {
          return excludeResourceRulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
           getExcludeResourceRulesOrBuilderList() {
        if (excludeResourceRulesBuilder_ != null) {
          return excludeResourceRulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(excludeResourceRules_);
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder addExcludeResourceRulesBuilder() {
        return getExcludeResourceRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder addExcludeResourceRulesBuilder(
          int index) {
        return getExcludeResourceRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder> 
           getExcludeResourceRulesBuilderList() {
        return getExcludeResourceRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
          getExcludeResourceRulesFieldBuilder() {
        if (excludeResourceRulesBuilder_ == null) {
          excludeResourceRulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder>(
                  excludeResourceRules_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          excludeResourceRules_ = null;
        }
        return excludeResourceRulesBuilder_;
      }

      private java.lang.Object matchPolicy_ = "";
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       *
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       * @return Whether the matchPolicy field is set.
       */
      public boolean hasMatchPolicy() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       *
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       * @return The matchPolicy.
       */
      public java.lang.String getMatchPolicy() {
        java.lang.Object ref = matchPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       *
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       * @return The bytes for matchPolicy.
       */
      public com.google.protobuf.ByteString
          getMatchPolicyBytes() {
        java.lang.Object ref = matchPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          matchPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       *
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       * @param value The matchPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setMatchPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        matchPolicy_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       *
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearMatchPolicy() {
        matchPolicy_ = getDefaultInstance().getMatchPolicy();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       *
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       * @param value The bytes for matchPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setMatchPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        matchPolicy_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MatchResources)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MatchResources)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MatchResources>
        PARSER = new com.google.protobuf.AbstractParser<MatchResources>() {
      @java.lang.Override
      public MatchResources parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MatchResources> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MatchResources> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingWebhookOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     * @return Whether the clientConfig field is set.
     */
    boolean hasClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     * @return The clientConfig.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder();

    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> 
        getRulesList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index);
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index);

    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return Whether the failurePolicy field is set.
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The failurePolicy.
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The bytes for failurePolicy.
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return Whether the matchPolicy field is set.
     */
    boolean hasMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return The matchPolicy.
     */
    java.lang.String getMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return The bytes for matchPolicy.
     */
    com.google.protobuf.ByteString
        getMatchPolicyBytes();

    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     * @return Whether the namespaceSelector field is set.
     */
    boolean hasNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     * @return The namespaceSelector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     * @return Whether the objectSelector field is set.
     */
    boolean hasObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     * @return The objectSelector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder();

    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return Whether the sideEffects field is set.
     */
    boolean hasSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return The sideEffects.
     */
    java.lang.String getSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return The bytes for sideEffects.
     */
    com.google.protobuf.ByteString
        getSideEffectsBytes();

    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     * @return Whether the timeoutSeconds field is set.
     */
    boolean hasTimeoutSeconds();
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     * @return The timeoutSeconds.
     */
    int getTimeoutSeconds();

    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @return A list containing the admissionReviewVersions.
     */
    java.util.List<java.lang.String>
        getAdmissionReviewVersionsList();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @return The count of admissionReviewVersions.
     */
    int getAdmissionReviewVersionsCount();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @param index The index of the element to return.
     * @return The admissionReviewVersions at the given index.
     */
    java.lang.String getAdmissionReviewVersions(int index);
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the admissionReviewVersions at the given index.
     */
    com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index);

    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     *
     * Never: the webhook will not be called more than once in a single admission evaluation.
     *
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     *
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     * @return Whether the reinvocationPolicy field is set.
     */
    boolean hasReinvocationPolicy();
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     *
     * Never: the webhook will not be called more than once in a single admission evaluation.
     *
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     *
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     * @return The reinvocationPolicy.
     */
    java.lang.String getReinvocationPolicy();
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     *
     * Never: the webhook will not be called more than once in a single admission evaluation.
     *
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     *
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     * @return The bytes for reinvocationPolicy.
     */
    com.google.protobuf.ByteString
        getReinvocationPolicyBytes();

    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingWebhook describes an admission webhook and the resources and operations it applies to.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhook}
   */
  public static final class MutatingWebhook extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
      MutatingWebhookOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        MutatingWebhook.class.getName());
    }
    // Use MutatingWebhook.newBuilder() to construct.
    private MutatingWebhook(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private MutatingWebhook() {
      name_ = "";
      rules_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      matchPolicy_ = "";
      sideEffects_ = "";
      admissionReviewVersions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      reinvocationPolicy_ = "";
      matchConditions_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CLIENTCONFIG_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig clientConfig_;
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     * @return Whether the clientConfig field is set.
     */
    @java.lang.Override
    public boolean hasClientConfig() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     * @return The clientConfig.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }

    public static final int RULES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_;
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object failurePolicy_ = "";
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return Whether the failurePolicy field is set.
     */
    @java.lang.Override
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The failurePolicy.
     */
    @java.lang.Override
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The bytes for failurePolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHPOLICY_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private volatile java.lang.Object matchPolicy_ = "";
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return Whether the matchPolicy field is set.
     */
    @java.lang.Override
    public boolean hasMatchPolicy() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return The matchPolicy.
     */
    @java.lang.Override
    public java.lang.String getMatchPolicy() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return The bytes for matchPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMatchPolicyBytes() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        matchPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     * @return Whether the namespaceSelector field is set.
     */
    @java.lang.Override
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     * @return The namespaceSelector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }

    public static final int OBJECTSELECTOR_FIELD_NUMBER = 11;
    private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     * @return Whether the objectSelector field is set.
     */
    @java.lang.Override
    public boolean hasObjectSelector() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     * @return The objectSelector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }

    public static final int SIDEEFFECTS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object sideEffects_ = "";
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return Whether the sideEffects field is set.
     */
    @java.lang.Override
    public boolean hasSideEffects() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return The sideEffects.
     */
    @java.lang.Override
    public java.lang.String getSideEffects() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          sideEffects_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return The bytes for sideEffects.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSideEffectsBytes() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sideEffects_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TIMEOUTSECONDS_FIELD_NUMBER = 7;
    private int timeoutSeconds_ = 0;
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     * @return Whether the timeoutSeconds field is set.
     */
    @java.lang.Override
    public boolean hasTimeoutSeconds() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     * @return The timeoutSeconds.
     */
    @java.lang.Override
    public int getTimeoutSeconds() {
      return timeoutSeconds_;
    }

    public static final int ADMISSIONREVIEWVERSIONS_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList admissionReviewVersions_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @return A list containing the admissionReviewVersions.
     */
    public com.google.protobuf.ProtocolStringList
        getAdmissionReviewVersionsList() {
      return admissionReviewVersions_;
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @return The count of admissionReviewVersions.
     */
    public int getAdmissionReviewVersionsCount() {
      return admissionReviewVersions_.size();
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @param index The index of the element to return.
     * @return The admissionReviewVersions at the given index.
     */
    public java.lang.String getAdmissionReviewVersions(int index) {
      return admissionReviewVersions_.get(index);
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the admissionReviewVersions at the given index.
     */
    public com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index) {
      return admissionReviewVersions_.getByteString(index);
    }

    public static final int REINVOCATIONPOLICY_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reinvocationPolicy_ = "";
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     *
     * Never: the webhook will not be called more than once in a single admission evaluation.
     *
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     *
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     * @return Whether the reinvocationPolicy field is set.
     */
    @java.lang.Override
    public boolean hasReinvocationPolicy() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     *
     * Never: the webhook will not be called more than once in a single admission evaluation.
     *
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     *
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     * @return The reinvocationPolicy.
     */
    @java.lang.Override
    public java.lang.String getReinvocationPolicy() {
      java.lang.Object ref = reinvocationPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reinvocationPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     *
     * Never: the webhook will not be called more than once in a single admission evaluation.
     *
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     *
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     * @return The bytes for reinvocationPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReinvocationPolicyBytes() {
      java.lang.Object ref = reinvocationPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reinvocationPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    @java.lang.Override
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt32(7, timeoutSeconds_);
      }
      for (int i = 0; i < admissionReviewVersions_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, admissionReviewVersions_.getRaw(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 10, reinvocationPolicy_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(11, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(12, matchConditions_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, timeoutSeconds_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < admissionReviewVersions_.size(); i++) {
          dataSize += computeStringSizeNoTag(admissionReviewVersions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAdmissionReviewVersionsList().size();
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(10, reinvocationPolicy_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, matchConditions_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasClientConfig() != other.hasClientConfig()) return false;
      if (hasClientConfig()) {
        if (!getClientConfig()
            .equals(other.getClientConfig())) return false;
      }
      if (!getRulesList()
          .equals(other.getRulesList())) return false;
      if (hasFailurePolicy() != other.hasFailurePolicy()) return false;
      if (hasFailurePolicy()) {
        if (!getFailurePolicy()
            .equals(other.getFailurePolicy())) return false;
      }
      if (hasMatchPolicy() != other.hasMatchPolicy()) return false;
      if (hasMatchPolicy()) {
        if (!getMatchPolicy()
            .equals(other.getMatchPolicy())) return false;
      }
      if (hasNamespaceSelector() != other.hasNamespaceSelector()) return false;
      if (hasNamespaceSelector()) {
        if (!getNamespaceSelector()
            .equals(other.getNamespaceSelector())) return false;
      }
      if (hasObjectSelector() != other.hasObjectSelector()) return false;
      if (hasObjectSelector()) {
        if (!getObjectSelector()
            .equals(other.getObjectSelector())) return false;
      }
      if (hasSideEffects() != other.hasSideEffects()) return false;
      if (hasSideEffects()) {
        if (!getSideEffects()
            .equals(other.getSideEffects())) return false;
      }
      if (hasTimeoutSeconds() != other.hasTimeoutSeconds()) return false;
      if (hasTimeoutSeconds()) {
        if (getTimeoutSeconds()
            != other.getTimeoutSeconds()) return false;
      }
      if (!getAdmissionReviewVersionsList()
          .equals(other.getAdmissionReviewVersionsList())) return false;
      if (hasReinvocationPolicy() != other.hasReinvocationPolicy()) return false;
      if (hasReinvocationPolicy()) {
        if (!getReinvocationPolicy()
            .equals(other.getReinvocationPolicy())) return false;
      }
      if (!getMatchConditionsList()
          .equals(other.getMatchConditionsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasClientConfig()) {
        hash = (37 * hash) + CLIENTCONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getClientConfig().hashCode();
      }
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (hasMatchPolicy()) {
        hash = (37 * hash) + MATCHPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getMatchPolicy().hashCode();
      }
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasObjectSelector()) {
        hash = (37 * hash) + OBJECTSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getObjectSelector().hashCode();
      }
      if (hasSideEffects()) {
        hash = (37 * hash) + SIDEEFFECTS_FIELD_NUMBER;
        hash = (53 * hash) + getSideEffects().hashCode();
      }
      if (hasTimeoutSeconds()) {
        hash = (37 * hash) + TIMEOUTSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getTimeoutSeconds();
      }
      if (getAdmissionReviewVersionsCount() > 0) {
        hash = (37 * hash) + ADMISSIONREVIEWVERSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAdmissionReviewVersionsList().hashCode();
      }
      if (hasReinvocationPolicy()) {
        hash = (37 * hash) + REINVOCATIONPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getReinvocationPolicy().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingWebhook describes an admission webhook and the resources and operations it applies to.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhook}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getClientConfigFieldBuilder();
          getRulesFieldBuilder();
          getNamespaceSelectorFieldBuilder();
          getObjectSelectorFieldBuilder();
          getMatchConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        clientConfig_ = null;
        if (clientConfigBuilder_ != null) {
          clientConfigBuilder_.dispose();
          clientConfigBuilder_ = null;
        }
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
        } else {
          rules_ = null;
          rulesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        failurePolicy_ = "";
        matchPolicy_ = "";
        namespaceSelector_ = null;
        if (namespaceSelectorBuilder_ != null) {
          namespaceSelectorBuilder_.dispose();
          namespaceSelectorBuilder_ = null;
        }
        objectSelector_ = null;
        if (objectSelectorBuilder_ != null) {
          objectSelectorBuilder_.dispose();
          objectSelectorBuilder_ = null;
        }
        sideEffects_ = "";
        timeoutSeconds_ = 0;
        admissionReviewVersions_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        reinvocationPolicy_ = "";
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
        } else {
          matchConditions_ = null;
          matchConditionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000800);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook result) {
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000800) != 0)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000800);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.clientConfig_ = clientConfigBuilder_ == null
              ? clientConfig_
              : clientConfigBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.failurePolicy_ = failurePolicy_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.matchPolicy_ = matchPolicy_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.namespaceSelector_ = namespaceSelectorBuilder_ == null
              ? namespaceSelector_
              : namespaceSelectorBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.objectSelector_ = objectSelectorBuilder_ == null
              ? objectSelector_
              : objectSelectorBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.sideEffects_ = sideEffects_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.timeoutSeconds_ = timeoutSeconds_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          admissionReviewVersions_.makeImmutable();
          result.admissionReviewVersions_ = admissionReviewVersions_;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.reinvocationPolicy_ = reinvocationPolicy_;
          to_bitField0_ |= 0x00000100;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasClientConfig()) {
          mergeClientConfig(other.getClientConfig());
        }
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          failurePolicy_ = other.failurePolicy_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasMatchPolicy()) {
          matchPolicy_ = other.matchPolicy_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasObjectSelector()) {
          mergeObjectSelector(other.getObjectSelector());
        }
        if (other.hasSideEffects()) {
          sideEffects_ = other.sideEffects_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (other.hasTimeoutSeconds()) {
          setTimeoutSeconds(other.getTimeoutSeconds());
        }
        if (!other.admissionReviewVersions_.isEmpty()) {
          if (admissionReviewVersions_.isEmpty()) {
            admissionReviewVersions_ = other.admissionReviewVersions_;
            bitField0_ |= 0x00000200;
          } else {
            ensureAdmissionReviewVersionsIsMutable();
            admissionReviewVersions_.addAll(other.admissionReviewVersions_);
          }
          onChanged();
        }
        if (other.hasReinvocationPolicy()) {
          reinvocationPolicy_ = other.reinvocationPolicy_;
          bitField0_ |= 0x00000400;
          onChanged();
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000800);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000800);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getClientConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.parser(),
                        extensionRegistry);
                if (rulesBuilder_ == null) {
                  ensureRulesIsMutable();
                  rules_.add(m);
                } else {
                  rulesBuilder_.addMessage(m);
                }
                break;
              } // case 26
              case 34: {
                failurePolicy_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getNamespaceSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 42
              case 50: {
                sideEffects_ = input.readBytes();
                bitField0_ |= 0x00000080;
                break;
              } // case 50
              case 56: {
                timeoutSeconds_ = input.readInt32();
                bitField0_ |= 0x00000100;
                break;
              } // case 56
              case 66: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureAdmissionReviewVersionsIsMutable();
                admissionReviewVersions_.add(bs);
                break;
              } // case 66
              case 74: {
                matchPolicy_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 74
              case 82: {
                reinvocationPolicy_ = input.readBytes();
                bitField0_ |= 0x00000400;
                break;
              } // case 82
              case 90: {
                input.readMessage(
                    getObjectSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 90
              case 98: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.parser(),
                        extensionRegistry);
                if (matchConditionsBuilder_ == null) {
                  ensureMatchConditionsIsMutable();
                  matchConditions_.add(m);
                } else {
                  matchConditionsBuilder_.addMessage(m);
                }
                break;
              } // case 98
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig clientConfig_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder> clientConfigBuilder_;
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       * @return Whether the clientConfig field is set.
       */
      public boolean hasClientConfig() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       * @return The clientConfig.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig() {
        if (clientConfigBuilder_ == null) {
          return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        } else {
          return clientConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          clientConfig_ = value;
        } else {
          clientConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder builderForValue) {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = builderForValue.build();
        } else {
          clientConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder mergeClientConfig(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            clientConfig_ != null &&
            clientConfig_ != io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance()) {
            getClientConfigBuilder().mergeFrom(value);
          } else {
            clientConfig_ = value;
          }
        } else {
          clientConfigBuilder_.mergeFrom(value);
        }
        if (clientConfig_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder clearClientConfig() {
        bitField0_ = (bitField0_ & ~0x00000002);
        clientConfig_ = null;
        if (clientConfigBuilder_ != null) {
          clientConfigBuilder_.dispose();
          clientConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder getClientConfigBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getClientConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
        if (clientConfigBuilder_ != null) {
          return clientConfigBuilder_.getMessageOrBuilder();
        } else {
          return clientConfig_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder> 
          getClientConfigFieldBuilder() {
        if (clientConfigBuilder_ == null) {
          clientConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder>(
                  getClientConfig(),
                  getParentForChildren(),
                  isClean());
          clientConfig_ = null;
        }
        return clientConfigBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>(rules_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> rulesBuilder_;

      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder> 
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return Whether the failurePolicy field is set.
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return The failurePolicy.
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return The bytes for failurePolicy.
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @param value The failurePolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        failurePolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFailurePolicy() {
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @param value The bytes for failurePolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        failurePolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object matchPolicy_ = "";
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @return Whether the matchPolicy field is set.
       */
      public boolean hasMatchPolicy() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @return The matchPolicy.
       */
      public java.lang.String getMatchPolicy() {
        java.lang.Object ref = matchPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @return The bytes for matchPolicy.
       */
      public com.google.protobuf.ByteString
          getMatchPolicyBytes() {
        java.lang.Object ref = matchPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          matchPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @param value The matchPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setMatchPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        matchPolicy_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMatchPolicy() {
        matchPolicy_ = getDefaultInstance().getMatchPolicy();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @param value The bytes for matchPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setMatchPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        matchPolicy_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> namespaceSelectorBuilder_;
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       * @return Whether the namespaceSelector field is set.
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       * @return The namespaceSelector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            namespaceSelector_ != null &&
            namespaceSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getNamespaceSelectorBuilder().mergeFrom(value);
          } else {
            namespaceSelector_ = value;
          }
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        if (namespaceSelector_ != null) {
          bitField0_ |= 0x00000020;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder clearNamespaceSelector() {
        bitField0_ = (bitField0_ & ~0x00000020);
        namespaceSelector_ = null;
        if (namespaceSelectorBuilder_ != null) {
          namespaceSelectorBuilder_.dispose();
          namespaceSelectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(),
                  getParentForChildren(),
                  isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> objectSelectorBuilder_;
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       * @return Whether the objectSelector field is set.
       */
      public boolean hasObjectSelector() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       * @return The objectSelector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        } else {
          return objectSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder setObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectSelector_ = value;
        } else {
          objectSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder setObjectSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = builderForValue.build();
        } else {
          objectSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder mergeObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            objectSelector_ != null &&
            objectSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getObjectSelectorBuilder().mergeFrom(value);
          } else {
            objectSelector_ = value;
          }
        } else {
          objectSelectorBuilder_.mergeFrom(value);
        }
        if (objectSelector_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder clearObjectSelector() {
        bitField0_ = (bitField0_ & ~0x00000040);
        objectSelector_ = null;
        if (objectSelectorBuilder_ != null) {
          objectSelectorBuilder_.dispose();
          objectSelectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getObjectSelectorBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getObjectSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
        if (objectSelectorBuilder_ != null) {
          return objectSelectorBuilder_.getMessageOrBuilder();
        } else {
          return objectSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getObjectSelectorFieldBuilder() {
        if (objectSelectorBuilder_ == null) {
          objectSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getObjectSelector(),
                  getParentForChildren(),
                  isClean());
          objectSelector_ = null;
        }
        return objectSelectorBuilder_;
      }

      private java.lang.Object sideEffects_ = "";
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @return Whether the sideEffects field is set.
       */
      public boolean hasSideEffects() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @return The sideEffects.
       */
      public java.lang.String getSideEffects() {
        java.lang.Object ref = sideEffects_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            sideEffects_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @return The bytes for sideEffects.
       */
      public com.google.protobuf.ByteString
          getSideEffectsBytes() {
        java.lang.Object ref = sideEffects_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sideEffects_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @param value The sideEffects to set.
       * @return This builder for chaining.
       */
      public Builder setSideEffects(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        sideEffects_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearSideEffects() {
        sideEffects_ = getDefaultInstance().getSideEffects();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @param value The bytes for sideEffects to set.
       * @return This builder for chaining.
       */
      public Builder setSideEffectsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        sideEffects_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private int timeoutSeconds_ ;
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       * @return Whether the timeoutSeconds field is set.
       */
      @java.lang.Override
      public boolean hasTimeoutSeconds() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       * @return The timeoutSeconds.
       */
      @java.lang.Override
      public int getTimeoutSeconds() {
        return timeoutSeconds_;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       * @param value The timeoutSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setTimeoutSeconds(int value) {

        timeoutSeconds_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeoutSeconds() {
        bitField0_ = (bitField0_ & ~0x00000100);
        timeoutSeconds_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList admissionReviewVersions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureAdmissionReviewVersionsIsMutable() {
        if (!admissionReviewVersions_.isModifiable()) {
          admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList(admissionReviewVersions_);
        }
        bitField0_ |= 0x00000200;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @return A list containing the admissionReviewVersions.
       */
      public com.google.protobuf.ProtocolStringList
          getAdmissionReviewVersionsList() {
        admissionReviewVersions_.makeImmutable();
        return admissionReviewVersions_;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @return The count of admissionReviewVersions.
       */
      public int getAdmissionReviewVersionsCount() {
        return admissionReviewVersions_.size();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param index The index of the element to return.
       * @return The admissionReviewVersions at the given index.
       */
      public java.lang.String getAdmissionReviewVersions(int index) {
        return admissionReviewVersions_.get(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param index The index of the value to return.
       * @return The bytes of the admissionReviewVersions at the given index.
       */
      public com.google.protobuf.ByteString
          getAdmissionReviewVersionsBytes(int index) {
        return admissionReviewVersions_.getByteString(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param index The index to set the value at.
       * @param value The admissionReviewVersions to set.
       * @return This builder for chaining.
       */
      public Builder setAdmissionReviewVersions(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.set(index, value);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param value The admissionReviewVersions to add.
       * @return This builder for chaining.
       */
      public Builder addAdmissionReviewVersions(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param values The admissionReviewVersions to add.
       * @return This builder for chaining.
       */
      public Builder addAllAdmissionReviewVersions(
          java.lang.Iterable<java.lang.String> values) {
        ensureAdmissionReviewVersionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, admissionReviewVersions_);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearAdmissionReviewVersions() {
        admissionReviewVersions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param value The bytes of the admissionReviewVersions to add.
       * @return This builder for chaining.
       */
      public Builder addAdmissionReviewVersionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      private java.lang.Object reinvocationPolicy_ = "";
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       *
       * Never: the webhook will not be called more than once in a single admission evaluation.
       *
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       *
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       * @return Whether the reinvocationPolicy field is set.
       */
      public boolean hasReinvocationPolicy() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       *
       * Never: the webhook will not be called more than once in a single admission evaluation.
       *
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       *
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       * @return The reinvocationPolicy.
       */
      public java.lang.String getReinvocationPolicy() {
        java.lang.Object ref = reinvocationPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reinvocationPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       *
       * Never: the webhook will not be called more than once in a single admission evaluation.
       *
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       *
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       * @return The bytes for reinvocationPolicy.
       */
      public com.google.protobuf.ByteString
          getReinvocationPolicyBytes() {
        java.lang.Object ref = reinvocationPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reinvocationPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       *
       * Never: the webhook will not be called more than once in a single admission evaluation.
       *
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       *
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       * @param value The reinvocationPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setReinvocationPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reinvocationPolicy_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       *
       * Never: the webhook will not be called more than once in a single admission evaluation.
       *
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       *
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearReinvocationPolicy() {
        reinvocationPolicy_ = getDefaultInstance().getReinvocationPolicy();
        bitField0_ = (bitField0_ & ~0x00000400);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       *
       * Never: the webhook will not be called more than once in a single admission evaluation.
       *
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       *
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       * @param value The bytes for reinvocationPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setReinvocationPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reinvocationPolicy_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000800) != 0)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000800;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000800);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000800) != 0),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MutatingWebhook>
        PARSER = new com.google.protobuf.AbstractParser<MutatingWebhook>() {
      @java.lang.Override
      public MutatingWebhook parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MutatingWebhook> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingWebhook> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingWebhookConfigurationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> 
        getWebhooksList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getWebhooks(int index);
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    int getWebhooksCount();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> 
        getWebhooksOrBuilderList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder getWebhooksOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
   * Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 MutatingWebhookConfiguration instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration}
   */
  public static final class MutatingWebhookConfiguration extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
      MutatingWebhookConfigurationOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        MutatingWebhookConfiguration.class.getName());
    }
    // Use MutatingWebhookConfiguration.newBuilder() to construct.
    private MutatingWebhookConfiguration(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private MutatingWebhookConfiguration() {
      webhooks_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int WEBHOOKS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> webhooks_;
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> getWebhooksList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> 
        getWebhooksOrBuilderList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public int getWebhooksCount() {
      return webhooks_.size();
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getWebhooks(int index) {
      return webhooks_.get(index);
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder getWebhooksOrBuilder(
        int index) {
      return webhooks_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        output.writeMessage(2, webhooks_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, webhooks_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getWebhooksList()
          .equals(other.getWebhooksList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getWebhooksCount() > 0) {
        hash = (37 * hash) + WEBHOOKS_FIELD_NUMBER;
        hash = (53 * hash) + getWebhooksList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
     * Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 MutatingWebhookConfiguration instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getWebhooksFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
        } else {
          webhooks_ = null;
          webhooksBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration result) {
        if (webhooksBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.webhooks_ = webhooks_;
        } else {
          result.webhooks_ = webhooksBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (webhooksBuilder_ == null) {
          if (!other.webhooks_.isEmpty()) {
            if (webhooks_.isEmpty()) {
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureWebhooksIsMutable();
              webhooks_.addAll(other.webhooks_);
            }
            onChanged();
          }
        } else {
          if (!other.webhooks_.isEmpty()) {
            if (webhooksBuilder_.isEmpty()) {
              webhooksBuilder_.dispose();
              webhooksBuilder_ = null;
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
              webhooksBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getWebhooksFieldBuilder() : null;
            } else {
              webhooksBuilder_.addAllMessages(other.webhooks_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.parser(),
                        extensionRegistry);
                if (webhooksBuilder_ == null) {
                  ensureWebhooksIsMutable();
                  webhooks_.add(m);
                } else {
                  webhooksBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> webhooks_ =
        java.util.Collections.emptyList();
      private void ensureWebhooksIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook>(webhooks_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> webhooksBuilder_;

      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> getWebhooksList() {
        if (webhooksBuilder_ == null) {
          return java.util.Collections.unmodifiableList(webhooks_);
        } else {
          return webhooksBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public int getWebhooksCount() {
        if (webhooksBuilder_ == null) {
          return webhooks_.size();
        } else {
          return webhooksBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);
        } else {
          return webhooksBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.set(index, value);
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.set(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(index, value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addAllWebhooks(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> values) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, webhooks_);
          onChanged();
        } else {
          webhooksBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder clearWebhooks() {
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder removeWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.remove(index);
          onChanged();
        } else {
          webhooksBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder getWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder getWebhooksOrBuilder(
          int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);  } else {
          return webhooksBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> 
           getWebhooksOrBuilderList() {
        if (webhooksBuilder_ != null) {
          return webhooksBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(webhooks_);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder addWebhooksBuilder() {
        return getWebhooksFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder addWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder> 
           getWebhooksBuilderList() {
        return getWebhooksFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> 
          getWebhooksFieldBuilder() {
        if (webhooksBuilder_ == null) {
          webhooksBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder>(
                  webhooks_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          webhooks_ = null;
        }
        return webhooksBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MutatingWebhookConfiguration>
        PARSER = new com.google.protobuf.AbstractParser<MutatingWebhookConfiguration>() {
      @java.lang.Override
      public MutatingWebhookConfiguration parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MutatingWebhookConfiguration> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingWebhookConfiguration> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingWebhookConfigurationListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> 
        getItemsList();
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getItems(int index);
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList}
   */
  public static final class MutatingWebhookConfigurationList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
      MutatingWebhookConfigurationListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        MutatingWebhookConfigurationList.class.getName());
    }
    // Use MutatingWebhookConfigurationList.newBuilder() to construct.
    private MutatingWebhookConfigurationList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private MutatingWebhookConfigurationList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> items_;
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MutatingWebhookConfigurationList>
        PARSER = new com.google.protobuf.AbstractParser<MutatingWebhookConfigurationList>() {
      @java.lang.Override
      public MutatingWebhookConfigurationList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MutatingWebhookConfigurationList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingWebhookConfigurationList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NamedRuleWithOperationsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     * @return A list containing the resourceNames.
     */
    java.util.List<java.lang.String>
        getResourceNamesList();
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     * @return The count of resourceNames.
     */
    int getResourceNamesCount();
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     * @param index The index of the element to return.
     * @return The resourceNames at the given index.
     */
    java.lang.String getResourceNames(int index);
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the resourceNames at the given index.
     */
    com.google.protobuf.ByteString
        getResourceNamesBytes(int index);

    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     * @return Whether the ruleWithOperations field is set.
     */
    boolean hasRuleWithOperations();
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     * @return The ruleWithOperations.
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRuleWithOperations();
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRuleWithOperationsOrBuilder();
  }
  /**
   * <pre>
   * NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations}
   */
  public static final class NamedRuleWithOperations extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
      NamedRuleWithOperationsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        NamedRuleWithOperations.class.getName());
    }
    // Use NamedRuleWithOperations.newBuilder() to construct.
    private NamedRuleWithOperations(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private NamedRuleWithOperations() {
      resourceNames_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.class, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder.class);
    }

    private int bitField0_;
    public static final int RESOURCENAMES_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList resourceNames_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     * @return A list containing the resourceNames.
     */
    public com.google.protobuf.ProtocolStringList
        getResourceNamesList() {
      return resourceNames_;
    }
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     * @return The count of resourceNames.
     */
    public int getResourceNamesCount() {
      return resourceNames_.size();
    }
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     * @param index The index of the element to return.
     * @return The resourceNames at the given index.
     */
    public java.lang.String getResourceNames(int index) {
      return resourceNames_.get(index);
    }
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the resourceNames at the given index.
     */
    public com.google.protobuf.ByteString
        getResourceNamesBytes(int index) {
      return resourceNames_.getByteString(index);
    }

    public static final int RULEWITHOPERATIONS_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations ruleWithOperations_;
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     * @return Whether the ruleWithOperations field is set.
     */
    @java.lang.Override
    public boolean hasRuleWithOperations() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     * @return The ruleWithOperations.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRuleWithOperations() {
      return ruleWithOperations_ == null ? io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
    }
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRuleWithOperationsOrBuilder() {
      return ruleWithOperations_ == null ? io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < resourceNames_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, resourceNames_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getRuleWithOperations());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < resourceNames_.size(); i++) {
          dataSize += computeStringSizeNoTag(resourceNames_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getResourceNamesList().size();
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRuleWithOperations());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations other = (io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations) obj;

      if (!getResourceNamesList()
          .equals(other.getResourceNamesList())) return false;
      if (hasRuleWithOperations() != other.hasRuleWithOperations()) return false;
      if (hasRuleWithOperations()) {
        if (!getRuleWithOperations()
            .equals(other.getRuleWithOperations())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getResourceNamesCount() > 0) {
        hash = (37 * hash) + RESOURCENAMES_FIELD_NUMBER;
        hash = (53 * hash) + getResourceNamesList().hashCode();
      }
      if (hasRuleWithOperations()) {
        hash = (37 * hash) + RULEWITHOPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getRuleWithOperations().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
        io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.class, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getRuleWithOperationsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        resourceNames_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        ruleWithOperations_ = null;
        if (ruleWithOperationsBuilder_ != null) {
          ruleWithOperationsBuilder_.dispose();
          ruleWithOperationsBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations result = new io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          resourceNames_.makeImmutable();
          result.resourceNames_ = resourceNames_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.ruleWithOperations_ = ruleWithOperationsBuilder_ == null
              ? ruleWithOperations_
              : ruleWithOperationsBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance()) return this;
        if (!other.resourceNames_.isEmpty()) {
          if (resourceNames_.isEmpty()) {
            resourceNames_ = other.resourceNames_;
            bitField0_ |= 0x00000001;
          } else {
            ensureResourceNamesIsMutable();
            resourceNames_.addAll(other.resourceNames_);
          }
          onChanged();
        }
        if (other.hasRuleWithOperations()) {
          mergeRuleWithOperations(other.getRuleWithOperations());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureResourceNamesIsMutable();
                resourceNames_.add(bs);
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getRuleWithOperationsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList resourceNames_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureResourceNamesIsMutable() {
        if (!resourceNames_.isModifiable()) {
          resourceNames_ = new com.google.protobuf.LazyStringArrayList(resourceNames_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       * @return A list containing the resourceNames.
       */
      public com.google.protobuf.ProtocolStringList
          getResourceNamesList() {
        resourceNames_.makeImmutable();
        return resourceNames_;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       * @return The count of resourceNames.
       */
      public int getResourceNamesCount() {
        return resourceNames_.size();
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       * @param index The index of the element to return.
       * @return The resourceNames at the given index.
       */
      public java.lang.String getResourceNames(int index) {
        return resourceNames_.get(index);
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the resourceNames at the given index.
       */
      public com.google.protobuf.ByteString
          getResourceNamesBytes(int index) {
        return resourceNames_.getByteString(index);
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       * @param index The index to set the value at.
       * @param value The resourceNames to set.
       * @return This builder for chaining.
       */
      public Builder setResourceNames(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureResourceNamesIsMutable();
        resourceNames_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       * @param value The resourceNames to add.
       * @return This builder for chaining.
       */
      public Builder addResourceNames(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureResourceNamesIsMutable();
        resourceNames_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       * @param values The resourceNames to add.
       * @return This builder for chaining.
       */
      public Builder addAllResourceNames(
          java.lang.Iterable<java.lang.String> values) {
        ensureResourceNamesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, resourceNames_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceNames() {
        resourceNames_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       * @param value The bytes of the resourceNames to add.
       * @return This builder for chaining.
       */
      public Builder addResourceNamesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureResourceNamesIsMutable();
        resourceNames_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations ruleWithOperations_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> ruleWithOperationsBuilder_;
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       * @return Whether the ruleWithOperations field is set.
       */
      public boolean hasRuleWithOperations() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       * @return The ruleWithOperations.
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRuleWithOperations() {
        if (ruleWithOperationsBuilder_ == null) {
          return ruleWithOperations_ == null ? io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
        } else {
          return ruleWithOperationsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder setRuleWithOperations(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (ruleWithOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ruleWithOperations_ = value;
        } else {
          ruleWithOperationsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder setRuleWithOperations(
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperations_ = builderForValue.build();
        } else {
          ruleWithOperationsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder mergeRuleWithOperations(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (ruleWithOperationsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            ruleWithOperations_ != null &&
            ruleWithOperations_ != io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance()) {
            getRuleWithOperationsBuilder().mergeFrom(value);
          } else {
            ruleWithOperations_ = value;
          }
        } else {
          ruleWithOperationsBuilder_.mergeFrom(value);
        }
        if (ruleWithOperations_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder clearRuleWithOperations() {
        bitField0_ = (bitField0_ & ~0x00000002);
        ruleWithOperations_ = null;
        if (ruleWithOperationsBuilder_ != null) {
          ruleWithOperationsBuilder_.dispose();
          ruleWithOperationsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder getRuleWithOperationsBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRuleWithOperationsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRuleWithOperationsOrBuilder() {
        if (ruleWithOperationsBuilder_ != null) {
          return ruleWithOperationsBuilder_.getMessageOrBuilder();
        } else {
          return ruleWithOperations_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
        }
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
          getRuleWithOperationsFieldBuilder() {
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperationsBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder>(
                  getRuleWithOperations(),
                  getParentForChildren(),
                  isClean());
          ruleWithOperations_ = null;
        }
        return ruleWithOperationsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NamedRuleWithOperations>
        PARSER = new com.google.protobuf.AbstractParser<NamedRuleWithOperations>() {
      @java.lang.Override
      public NamedRuleWithOperations parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<NamedRuleWithOperations> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NamedRuleWithOperations> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ParamKindOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ParamKind)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     * @return Whether the apiVersion field is set.
     */
    boolean hasApiVersion();
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     * @return The apiVersion.
     */
    java.lang.String getApiVersion();
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     * @return The bytes for apiVersion.
     */
    com.google.protobuf.ByteString
        getApiVersionBytes();

    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     * @return Whether the kind field is set.
     */
    boolean hasKind();
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     * @return The kind.
     */
    java.lang.String getKind();
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     * @return The bytes for kind.
     */
    com.google.protobuf.ByteString
        getKindBytes();
  }
  /**
   * <pre>
   * ParamKind is a tuple of Group Kind and Version.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ParamKind}
   */
  public static final class ParamKind extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ParamKind)
      ParamKindOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ParamKind.class.getName());
    }
    // Use ParamKind.newBuilder() to construct.
    private ParamKind(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ParamKind() {
      apiVersion_ = "";
      kind_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder.class);
    }

    private int bitField0_;
    public static final int APIVERSION_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object apiVersion_ = "";
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     * @return Whether the apiVersion field is set.
     */
    @java.lang.Override
    public boolean hasApiVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     * @return The apiVersion.
     */
    @java.lang.Override
    public java.lang.String getApiVersion() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          apiVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     * @return The bytes for apiVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getApiVersionBytes() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        apiVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KIND_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object kind_ = "";
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     * @return Whether the kind field is set.
     */
    @java.lang.Override
    public boolean hasKind() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     * @return The kind.
     */
    @java.lang.Override
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          kind_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     * @return The bytes for kind.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, apiVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, kind_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, apiVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, kind_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind) obj;

      if (hasApiVersion() != other.hasApiVersion()) return false;
      if (hasApiVersion()) {
        if (!getApiVersion()
            .equals(other.getApiVersion())) return false;
      }
      if (hasKind() != other.hasKind()) return false;
      if (hasKind()) {
        if (!getKind()
            .equals(other.getKind())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasApiVersion()) {
        hash = (37 * hash) + APIVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getApiVersion().hashCode();
      }
      if (hasKind()) {
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + getKind().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ParamKind is a tuple of Group Kind and Version.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ParamKind}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ParamKind)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        apiVersion_ = "";
        kind_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.apiVersion_ = apiVersion_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.kind_ = kind_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance()) return this;
        if (other.hasApiVersion()) {
          apiVersion_ = other.apiVersion_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasKind()) {
          kind_ = other.kind_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                apiVersion_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                kind_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object apiVersion_ = "";
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       * @return Whether the apiVersion field is set.
       */
      public boolean hasApiVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       * @return The apiVersion.
       */
      public java.lang.String getApiVersion() {
        java.lang.Object ref = apiVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            apiVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       * @return The bytes for apiVersion.
       */
      public com.google.protobuf.ByteString
          getApiVersionBytes() {
        java.lang.Object ref = apiVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          apiVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       * @param value The apiVersion to set.
       * @return This builder for chaining.
       */
      public Builder setApiVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        apiVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearApiVersion() {
        apiVersion_ = getDefaultInstance().getApiVersion();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       * @param value The bytes for apiVersion to set.
       * @return This builder for chaining.
       */
      public Builder setApiVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        apiVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object kind_ = "";
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       * @return Whether the kind field is set.
       */
      public boolean hasKind() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       * @return The kind.
       */
      public java.lang.String getKind() {
        java.lang.Object ref = kind_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            kind_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       * @return The bytes for kind.
       */
      public com.google.protobuf.ByteString
          getKindBytes() {
        java.lang.Object ref = kind_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          kind_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       * @param value The kind to set.
       * @return This builder for chaining.
       */
      public Builder setKind(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearKind() {
        kind_ = getDefaultInstance().getKind();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       * @param value The bytes for kind to set.
       * @return This builder for chaining.
       */
      public Builder setKindBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        kind_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ParamKind)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ParamKind)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ParamKind>
        PARSER = new com.google.protobuf.AbstractParser<ParamKind>() {
      @java.lang.Override
      public ParamKind parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ParamKind> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ParamKind> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ParamRefOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ParamRef)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * name is the name of the resource being referenced.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * name is the name of the resource being referenced.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * name is the name of the resource being referenced.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     *
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     *
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     *
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     *
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     * @return Whether the namespace field is set.
     */
    boolean hasNamespace();
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     *
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     *
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     *
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     *
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     * @return The namespace.
     */
    java.lang.String getNamespace();
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     *
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     *
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     *
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     *
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     * @return The bytes for namespace.
     */
    com.google.protobuf.ByteString
        getNamespaceBytes();

    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     *
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     * @return Whether the selector field is set.
     */
    boolean hasSelector();
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     *
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     * @return The selector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     *
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     *
     * Allowed values are `Allow` or `Deny`
     *
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     * @return Whether the parameterNotFoundAction field is set.
     */
    boolean hasParameterNotFoundAction();
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     *
     * Allowed values are `Allow` or `Deny`
     *
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     * @return The parameterNotFoundAction.
     */
    java.lang.String getParameterNotFoundAction();
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     *
     * Allowed values are `Allow` or `Deny`
     *
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     * @return The bytes for parameterNotFoundAction.
     */
    com.google.protobuf.ByteString
        getParameterNotFoundActionBytes();
  }
  /**
   * <pre>
   * ParamRef describes how to locate the params to be used as input to
   * expressions of rules applied by a policy binding.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ParamRef}
   */
  public static final class ParamRef extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ParamRef)
      ParamRefOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ParamRef.class.getName());
    }
    // Use ParamRef.newBuilder() to construct.
    private ParamRef(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ParamRef() {
      name_ = "";
      namespace_ = "";
      parameterNotFoundAction_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * name is the name of the resource being referenced.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * name is the name of the resource being referenced.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * name is the name of the resource being referenced.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object namespace_ = "";
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     *
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     *
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     *
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     *
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     * @return Whether the namespace field is set.
     */
    @java.lang.Override
    public boolean hasNamespace() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     *
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     *
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     *
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     *
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     * @return The namespace.
     */
    @java.lang.Override
    public java.lang.String getNamespace() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          namespace_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     *
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     *
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     *
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     *
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     * @return The bytes for namespace.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNamespaceBytes() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        namespace_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SELECTOR_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     *
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     * @return Whether the selector field is set.
     */
    @java.lang.Override
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     *
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     * @return The selector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     *
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     *
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }

    public static final int PARAMETERNOTFOUNDACTION_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object parameterNotFoundAction_ = "";
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     *
     * Allowed values are `Allow` or `Deny`
     *
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     * @return Whether the parameterNotFoundAction field is set.
     */
    @java.lang.Override
    public boolean hasParameterNotFoundAction() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     *
     * Allowed values are `Allow` or `Deny`
     *
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     * @return The parameterNotFoundAction.
     */
    @java.lang.Override
    public java.lang.String getParameterNotFoundAction() {
      java.lang.Object ref = parameterNotFoundAction_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          parameterNotFoundAction_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     *
     * Allowed values are `Allow` or `Deny`
     *
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     * @return The bytes for parameterNotFoundAction.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getParameterNotFoundActionBytes() {
      java.lang.Object ref = parameterNotFoundAction_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        parameterNotFoundAction_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, namespace_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getSelector());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, parameterNotFoundAction_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, namespace_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getSelector());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, parameterNotFoundAction_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasNamespace() != other.hasNamespace()) return false;
      if (hasNamespace()) {
        if (!getNamespace()
            .equals(other.getNamespace())) return false;
      }
      if (hasSelector() != other.hasSelector()) return false;
      if (hasSelector()) {
        if (!getSelector()
            .equals(other.getSelector())) return false;
      }
      if (hasParameterNotFoundAction() != other.hasParameterNotFoundAction()) return false;
      if (hasParameterNotFoundAction()) {
        if (!getParameterNotFoundAction()
            .equals(other.getParameterNotFoundAction())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasNamespace()) {
        hash = (37 * hash) + NAMESPACE_FIELD_NUMBER;
        hash = (53 * hash) + getNamespace().hashCode();
      }
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasParameterNotFoundAction()) {
        hash = (37 * hash) + PARAMETERNOTFOUNDACTION_FIELD_NUMBER;
        hash = (53 * hash) + getParameterNotFoundAction().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ParamRef describes how to locate the params to be used as input to
     * expressions of rules applied by a policy binding.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ParamRef}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ParamRef)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        namespace_ = "";
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        parameterNotFoundAction_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.namespace_ = namespace_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.selector_ = selectorBuilder_ == null
              ? selector_
              : selectorBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.parameterNotFoundAction_ = parameterNotFoundAction_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasNamespace()) {
          namespace_ = other.namespace_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasParameterNotFoundAction()) {
          parameterNotFoundAction_ = other.parameterNotFoundAction_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                namespace_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                parameterNotFoundAction_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * name is the name of the resource being referenced.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object namespace_ = "";
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       *
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       *
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       *
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       *
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       * @return Whether the namespace field is set.
       */
      public boolean hasNamespace() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       *
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       *
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       *
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       *
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       * @return The namespace.
       */
      public java.lang.String getNamespace() {
        java.lang.Object ref = namespace_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            namespace_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       *
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       *
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       *
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       *
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       * @return The bytes for namespace.
       */
      public com.google.protobuf.ByteString
          getNamespaceBytes() {
        java.lang.Object ref = namespace_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          namespace_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       *
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       *
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       *
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       *
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       * @param value The namespace to set.
       * @return This builder for chaining.
       */
      public Builder setNamespace(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        namespace_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       *
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       *
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       *
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       *
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNamespace() {
        namespace_ = getDefaultInstance().getNamespace();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       *
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       *
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       *
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       *
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       * @param value The bytes for namespace to set.
       * @return This builder for chaining.
       */
      public Builder setNamespaceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        namespace_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector selector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> selectorBuilder_;
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       *
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       * @return Whether the selector field is set.
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       *
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       * @return The selector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       *
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       *
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       *
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            selector_ != null &&
            selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getSelectorBuilder().mergeFrom(value);
          } else {
            selector_ = value;
          }
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        if (selector_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       *
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder clearSelector() {
        bitField0_ = (bitField0_ & ~0x00000004);
        selector_ = null;
        if (selectorBuilder_ != null) {
          selectorBuilder_.dispose();
          selectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       *
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       *
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        }
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       *
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       *
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(),
                  getParentForChildren(),
                  isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private java.lang.Object parameterNotFoundAction_ = "";
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       *
       * Allowed values are `Allow` or `Deny`
       *
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       * @return Whether the parameterNotFoundAction field is set.
       */
      public boolean hasParameterNotFoundAction() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       *
       * Allowed values are `Allow` or `Deny`
       *
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       * @return The parameterNotFoundAction.
       */
      public java.lang.String getParameterNotFoundAction() {
        java.lang.Object ref = parameterNotFoundAction_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            parameterNotFoundAction_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       *
       * Allowed values are `Allow` or `Deny`
       *
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       * @return The bytes for parameterNotFoundAction.
       */
      public com.google.protobuf.ByteString
          getParameterNotFoundActionBytes() {
        java.lang.Object ref = parameterNotFoundAction_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          parameterNotFoundAction_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       *
       * Allowed values are `Allow` or `Deny`
       *
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       * @param value The parameterNotFoundAction to set.
       * @return This builder for chaining.
       */
      public Builder setParameterNotFoundAction(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        parameterNotFoundAction_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       *
       * Allowed values are `Allow` or `Deny`
       *
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearParameterNotFoundAction() {
        parameterNotFoundAction_ = getDefaultInstance().getParameterNotFoundAction();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       *
       * Allowed values are `Allow` or `Deny`
       *
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       * @param value The bytes for parameterNotFoundAction to set.
       * @return This builder for chaining.
       */
      public Builder setParameterNotFoundActionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        parameterNotFoundAction_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ParamRef)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ParamRef)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ParamRef>
        PARSER = new com.google.protobuf.AbstractParser<ParamRef>() {
      @java.lang.Override
      public ParamRef parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ParamRef> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ParamRef> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ServiceReferenceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     * @return Whether the namespace field is set.
     */
    boolean hasNamespace();
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     * @return The namespace.
     */
    java.lang.String getNamespace();
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     * @return The bytes for namespace.
     */
    com.google.protobuf.ByteString
        getNamespaceBytes();

    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     * @return Whether the path field is set.
     */
    boolean hasPath();
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     * @return The path.
     */
    java.lang.String getPath();
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     * @return The bytes for path.
     */
    com.google.protobuf.ByteString
        getPathBytes();

    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     * @return Whether the port field is set.
     */
    boolean hasPort();
    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     * @return The port.
     */
    int getPort();
  }
  /**
   * <pre>
   * ServiceReference holds a reference to Service.legacy.k8s.io
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ServiceReference}
   */
  public static final class ServiceReference extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
      ServiceReferenceOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ServiceReference.class.getName());
    }
    // Use ServiceReference.newBuilder() to construct.
    private ServiceReference(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ServiceReference() {
      namespace_ = "";
      name_ = "";
      path_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder.class);
    }

    private int bitField0_;
    public static final int NAMESPACE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object namespace_ = "";
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     * @return Whether the namespace field is set.
     */
    @java.lang.Override
    public boolean hasNamespace() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     * @return The namespace.
     */
    @java.lang.Override
    public java.lang.String getNamespace() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          namespace_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     * @return The bytes for namespace.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNamespaceBytes() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        namespace_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAME_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PATH_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object path_ = "";
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     * @return Whether the path field is set.
     */
    @java.lang.Override
    public boolean hasPath() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     * @return The path.
     */
    @java.lang.Override
    public java.lang.String getPath() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          path_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     * @return The bytes for path.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPathBytes() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        path_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PORT_FIELD_NUMBER = 4;
    private int port_ = 0;
    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     * @return Whether the port field is set.
     */
    @java.lang.Override
    public boolean hasPort() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     * @return The port.
     */
    @java.lang.Override
    public int getPort() {
      return port_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, namespace_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, name_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, path_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(4, port_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, namespace_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, name_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, path_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, port_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference) obj;

      if (hasNamespace() != other.hasNamespace()) return false;
      if (hasNamespace()) {
        if (!getNamespace()
            .equals(other.getNamespace())) return false;
      }
      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasPath() != other.hasPath()) return false;
      if (hasPath()) {
        if (!getPath()
            .equals(other.getPath())) return false;
      }
      if (hasPort() != other.hasPort()) return false;
      if (hasPort()) {
        if (getPort()
            != other.getPort()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNamespace()) {
        hash = (37 * hash) + NAMESPACE_FIELD_NUMBER;
        hash = (53 * hash) + getNamespace().hashCode();
      }
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasPath()) {
        hash = (37 * hash) + PATH_FIELD_NUMBER;
        hash = (53 * hash) + getPath().hashCode();
      }
      if (hasPort()) {
        hash = (37 * hash) + PORT_FIELD_NUMBER;
        hash = (53 * hash) + getPort();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ServiceReference holds a reference to Service.legacy.k8s.io
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ServiceReference}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        namespace_ = "";
        name_ = "";
        path_ = "";
        port_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.namespace_ = namespace_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.path_ = path_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.port_ = port_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance()) return this;
        if (other.hasNamespace()) {
          namespace_ = other.namespace_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasPath()) {
          path_ = other.path_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasPort()) {
          setPort(other.getPort());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                namespace_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                path_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                port_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object namespace_ = "";
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       * @return Whether the namespace field is set.
       */
      public boolean hasNamespace() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       * @return The namespace.
       */
      public java.lang.String getNamespace() {
        java.lang.Object ref = namespace_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            namespace_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       * @return The bytes for namespace.
       */
      public com.google.protobuf.ByteString
          getNamespaceBytes() {
        java.lang.Object ref = namespace_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          namespace_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       * @param value The namespace to set.
       * @return This builder for chaining.
       */
      public Builder setNamespace(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        namespace_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNamespace() {
        namespace_ = getDefaultInstance().getNamespace();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       * @param value The bytes for namespace to set.
       * @return This builder for chaining.
       */
      public Builder setNamespaceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        namespace_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object path_ = "";
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       * @return Whether the path field is set.
       */
      public boolean hasPath() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       * @return The path.
       */
      public java.lang.String getPath() {
        java.lang.Object ref = path_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            path_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       * @return The bytes for path.
       */
      public com.google.protobuf.ByteString
          getPathBytes() {
        java.lang.Object ref = path_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          path_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       * @param value The path to set.
       * @return This builder for chaining.
       */
      public Builder setPath(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        path_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPath() {
        path_ = getDefaultInstance().getPath();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       * @param value The bytes for path to set.
       * @return This builder for chaining.
       */
      public Builder setPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        path_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private int port_ ;
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       * @return Whether the port field is set.
       */
      @java.lang.Override
      public boolean hasPort() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       * @return The port.
       */
      @java.lang.Override
      public int getPort() {
        return port_;
      }
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       * @param value The port to set.
       * @return This builder for chaining.
       */
      public Builder setPort(int value) {

        port_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPort() {
        bitField0_ = (bitField0_ & ~0x00000008);
        port_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ServiceReference>
        PARSER = new com.google.protobuf.AbstractParser<ServiceReference>() {
      @java.lang.Override
      public ServiceReference parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ServiceReference> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ServiceReference> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TypeCheckingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> 
        getExpressionWarningsList();
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getExpressionWarnings(int index);
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    int getExpressionWarningsCount();
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> 
        getExpressionWarningsOrBuilderList();
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder getExpressionWarningsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * TypeChecking contains results of type checking the expressions in the
   * ValidatingAdmissionPolicy
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.TypeChecking}
   */
  public static final class TypeChecking extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
      TypeCheckingOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        TypeChecking.class.getName());
    }
    // Use TypeChecking.newBuilder() to construct.
    private TypeChecking(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private TypeChecking() {
      expressionWarnings_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.class, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder.class);
    }

    public static final int EXPRESSIONWARNINGS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> expressionWarnings_;
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> getExpressionWarningsList() {
      return expressionWarnings_;
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> 
        getExpressionWarningsOrBuilderList() {
      return expressionWarnings_;
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    @java.lang.Override
    public int getExpressionWarningsCount() {
      return expressionWarnings_.size();
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getExpressionWarnings(int index) {
      return expressionWarnings_.get(index);
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder getExpressionWarningsOrBuilder(
        int index) {
      return expressionWarnings_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < expressionWarnings_.size(); i++) {
        output.writeMessage(1, expressionWarnings_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < expressionWarnings_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, expressionWarnings_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking other = (io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking) obj;

      if (!getExpressionWarningsList()
          .equals(other.getExpressionWarningsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getExpressionWarningsCount() > 0) {
        hash = (37 * hash) + EXPRESSIONWARNINGS_FIELD_NUMBER;
        hash = (53 * hash) + getExpressionWarningsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TypeChecking contains results of type checking the expressions in the
     * ValidatingAdmissionPolicy
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.TypeChecking}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
        io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.class, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (expressionWarningsBuilder_ == null) {
          expressionWarnings_ = java.util.Collections.emptyList();
        } else {
          expressionWarnings_ = null;
          expressionWarningsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking result = new io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking result) {
        if (expressionWarningsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            expressionWarnings_ = java.util.Collections.unmodifiableList(expressionWarnings_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.expressionWarnings_ = expressionWarnings_;
        } else {
          result.expressionWarnings_ = expressionWarningsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance()) return this;
        if (expressionWarningsBuilder_ == null) {
          if (!other.expressionWarnings_.isEmpty()) {
            if (expressionWarnings_.isEmpty()) {
              expressionWarnings_ = other.expressionWarnings_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureExpressionWarningsIsMutable();
              expressionWarnings_.addAll(other.expressionWarnings_);
            }
            onChanged();
          }
        } else {
          if (!other.expressionWarnings_.isEmpty()) {
            if (expressionWarningsBuilder_.isEmpty()) {
              expressionWarningsBuilder_.dispose();
              expressionWarningsBuilder_ = null;
              expressionWarnings_ = other.expressionWarnings_;
              bitField0_ = (bitField0_ & ~0x00000001);
              expressionWarningsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getExpressionWarningsFieldBuilder() : null;
            } else {
              expressionWarningsBuilder_.addAllMessages(other.expressionWarnings_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.parser(),
                        extensionRegistry);
                if (expressionWarningsBuilder_ == null) {
                  ensureExpressionWarningsIsMutable();
                  expressionWarnings_.add(m);
                } else {
                  expressionWarningsBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> expressionWarnings_ =
        java.util.Collections.emptyList();
      private void ensureExpressionWarningsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          expressionWarnings_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning>(expressionWarnings_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> expressionWarningsBuilder_;

      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> getExpressionWarningsList() {
        if (expressionWarningsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(expressionWarnings_);
        } else {
          return expressionWarningsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public int getExpressionWarningsCount() {
        if (expressionWarningsBuilder_ == null) {
          return expressionWarnings_.size();
        } else {
          return expressionWarningsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getExpressionWarnings(int index) {
        if (expressionWarningsBuilder_ == null) {
          return expressionWarnings_.get(index);
        } else {
          return expressionWarningsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder setExpressionWarnings(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning value) {
        if (expressionWarningsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.set(index, value);
          onChanged();
        } else {
          expressionWarningsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder setExpressionWarnings(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder builderForValue) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.set(index, builderForValue.build());
          onChanged();
        } else {
          expressionWarningsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning value) {
        if (expressionWarningsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(value);
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning value) {
        if (expressionWarningsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(index, value);
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder builderForValue) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(builderForValue.build());
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder builderForValue) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(index, builderForValue.build());
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addAllExpressionWarnings(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> values) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, expressionWarnings_);
          onChanged();
        } else {
          expressionWarningsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder clearExpressionWarnings() {
        if (expressionWarningsBuilder_ == null) {
          expressionWarnings_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          expressionWarningsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder removeExpressionWarnings(int index) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.remove(index);
          onChanged();
        } else {
          expressionWarningsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder getExpressionWarningsBuilder(
          int index) {
        return getExpressionWarningsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder getExpressionWarningsOrBuilder(
          int index) {
        if (expressionWarningsBuilder_ == null) {
          return expressionWarnings_.get(index);  } else {
          return expressionWarningsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> 
           getExpressionWarningsOrBuilderList() {
        if (expressionWarningsBuilder_ != null) {
          return expressionWarningsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(expressionWarnings_);
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder addExpressionWarningsBuilder() {
        return getExpressionWarningsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.getDefaultInstance());
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder addExpressionWarningsBuilder(
          int index) {
        return getExpressionWarningsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.getDefaultInstance());
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder> 
           getExpressionWarningsBuilderList() {
        return getExpressionWarningsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> 
          getExpressionWarningsFieldBuilder() {
        if (expressionWarningsBuilder_ == null) {
          expressionWarningsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder>(
                  expressionWarnings_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          expressionWarnings_ = null;
        }
        return expressionWarningsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TypeChecking>
        PARSER = new com.google.protobuf.AbstractParser<TypeChecking>() {
      @java.lang.Override
      public TypeChecking parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TypeChecking> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TypeChecking> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     * @return The spec.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     * @return The status.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getStatus();
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * +genclient
   * +genclient:nonNamespaced
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * +k8s:prerelease-lifecycle-gen:introduced=1.28
   * ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy}
   */
  public static final class ValidatingAdmissionPolicy extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
      ValidatingAdmissionPolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingAdmissionPolicy.class.getName());
    }
    // Use ValidatingAdmissionPolicy.newBuilder() to construct.
    private ValidatingAdmissionPolicy(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicy() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    @java.lang.Override
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     * @return The spec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus status_;
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     * @return The status.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getStatus());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasSpec() != other.hasSpec()) return false;
      if (hasSpec()) {
        if (!getSpec()
            .equals(other.getSpec())) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * +genclient
     * +genclient:nonNamespaced
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * +k8s:prerelease-lifecycle-gen:introduced=1.28
     * ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.spec_ = specBuilder_ == null
              ? spec_
              : specBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.status_ = statusBuilder_ == null
              ? status_
              : statusBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getStatusFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec spec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       * @return Whether the spec field is set.
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       * @return The spec.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            spec_ != null &&
            spec_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance()) {
            getSpecBuilder().mergeFrom(value);
          } else {
            spec_ = value;
          }
        } else {
          specBuilder_.mergeFrom(value);
        }
        if (spec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder clearSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus status_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       * @return The status.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            status_ != null &&
            status_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance()) {
            getStatusBuilder().mergeFrom(value);
          } else {
            status_ = value;
          }
        } else {
          statusBuilder_.mergeFrom(value);
        }
        if (status_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000004);
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingAdmissionPolicy>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicy>() {
      @java.lang.Override
      public ValidatingAdmissionPolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyBindingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     * @return The spec.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder();
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources.
   * ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.
   *
   * For a given admission request, each binding will cause its policy to be
   * evaluated N times, where N is 1 for policies/bindings that don't use
   * params, otherwise N is the number of parameters selected by the binding.
   *
   * The CEL expressions of a policy must have a computed CEL cost below the maximum
   * CEL budget. Each evaluation of the policy is given an independent CEL cost budget.
   * Adding/removing policies, bindings, or params can not affect whether a
   * given (policy, binding, param) combination is within its own CEL budget.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding}
   */
  public static final class ValidatingAdmissionPolicyBinding extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
      ValidatingAdmissionPolicyBindingOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingAdmissionPolicyBinding.class.getName());
    }
    // Use ValidatingAdmissionPolicyBinding.newBuilder() to construct.
    private ValidatingAdmissionPolicyBinding(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyBinding() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     * @return Whether the spec field is set.
     */
    @java.lang.Override
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     * @return The spec.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSpec());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (hasSpec() != other.hasSpec()) return false;
      if (hasSpec()) {
        if (!getSpec()
            .equals(other.getSpec())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources.
     * ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.
     *
     * For a given admission request, each binding will cause its policy to be
     * evaluated N times, where N is 1 for policies/bindings that don't use
     * params, otherwise N is the number of parameters selected by the binding.
     *
     * The CEL expressions of a policy must have a computed CEL cost below the maximum
     * CEL budget. Each evaluation of the policy is given an independent CEL cost budget.
     * Adding/removing policies, bindings, or params can not affect whether a
     * given (policy, binding, param) combination is within its own CEL budget.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.spec_ = specBuilder_ == null
              ? spec_
              : specBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getSpecFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec spec_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       * @return Whether the spec field is set.
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       * @return The spec.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            spec_ != null &&
            spec_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance()) {
            getSpecBuilder().mergeFrom(value);
          } else {
            spec_ = value;
          }
        } else {
          specBuilder_.mergeFrom(value);
        }
        if (spec_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        bitField0_ = (bitField0_ & ~0x00000002);
        spec_ = null;
        if (specBuilder_ != null) {
          specBuilder_.dispose();
          specBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingAdmissionPolicyBinding>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyBinding>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyBinding parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyBinding> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyBinding> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyBindingListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> 
        getItemsList();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getItems(int index);
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList}
   */
  public static final class ValidatingAdmissionPolicyBindingList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
      ValidatingAdmissionPolicyBindingListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingAdmissionPolicyBindingList.class.getName());
    }
    // Use ValidatingAdmissionPolicyBindingList.newBuilder() to construct.
    private ValidatingAdmissionPolicyBindingList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyBindingList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> items_;
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance());
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance());
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingList>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyBindingList>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyBindingList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyBindingSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     * @return Whether the policyName field is set.
     */
    boolean hasPolicyName();
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     * @return The policyName.
     */
    java.lang.String getPolicyName();
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     * @return The bytes for policyName.
     */
    com.google.protobuf.ByteString
        getPolicyNameBytes();

    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     * @return Whether the paramRef field is set.
     */
    boolean hasParamRef();
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     * @return The paramRef.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getParamRef();
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder();

    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     * @return Whether the matchResources field is set.
     */
    boolean hasMatchResources();
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     * @return The matchResources.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchResources();
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder();

    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     *
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     *
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     *
     * The supported actions values are:
     *
     * "Deny" specifies that a validation failure results in a denied request.
     *
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     *
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     *
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     *
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     *
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     * @return A list containing the validationActions.
     */
    java.util.List<java.lang.String>
        getValidationActionsList();
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     *
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     *
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     *
     * The supported actions values are:
     *
     * "Deny" specifies that a validation failure results in a denied request.
     *
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     *
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     *
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     *
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     *
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     * @return The count of validationActions.
     */
    int getValidationActionsCount();
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     *
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     *
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     *
     * The supported actions values are:
     *
     * "Deny" specifies that a validation failure results in a denied request.
     *
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     *
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     *
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     *
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     *
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     * @param index The index of the element to return.
     * @return The validationActions at the given index.
     */
    java.lang.String getValidationActions(int index);
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     *
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     *
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     *
     * The supported actions values are:
     *
     * "Deny" specifies that a validation failure results in a denied request.
     *
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     *
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     *
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     *
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     *
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     * @param index The index of the value to return.
     * @return The bytes of the validationActions at the given index.
     */
    com.google.protobuf.ByteString
        getValidationActionsBytes(int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec}
   */
  public static final class ValidatingAdmissionPolicyBindingSpec extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
      ValidatingAdmissionPolicyBindingSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingAdmissionPolicyBindingSpec.class.getName());
    }
    // Use ValidatingAdmissionPolicyBindingSpec.newBuilder() to construct.
    private ValidatingAdmissionPolicyBindingSpec(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyBindingSpec() {
      policyName_ = "";
      validationActions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder.class);
    }

    private int bitField0_;
    public static final int POLICYNAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object policyName_ = "";
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     * @return Whether the policyName field is set.
     */
    @java.lang.Override
    public boolean hasPolicyName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     * @return The policyName.
     */
    @java.lang.Override
    public java.lang.String getPolicyName() {
      java.lang.Object ref = policyName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          policyName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     * @return The bytes for policyName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPolicyNameBytes() {
      java.lang.Object ref = policyName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        policyName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PARAMREF_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef paramRef_;
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     * @return Whether the paramRef field is set.
     */
    @java.lang.Override
    public boolean hasParamRef() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     * @return The paramRef.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getParamRef() {
      return paramRef_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
    }
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder() {
      return paramRef_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
    }

    public static final int MATCHRESOURCES_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchResources_;
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     * @return Whether the matchResources field is set.
     */
    @java.lang.Override
    public boolean hasMatchResources() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     * @return The matchResources.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchResources() {
      return matchResources_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
    }
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder() {
      return matchResources_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
    }

    public static final int VALIDATIONACTIONS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList validationActions_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     *
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     *
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     *
     * The supported actions values are:
     *
     * "Deny" specifies that a validation failure results in a denied request.
     *
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     *
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     *
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     *
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     *
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     * @return A list containing the validationActions.
     */
    public com.google.protobuf.ProtocolStringList
        getValidationActionsList() {
      return validationActions_;
    }
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     *
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     *
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     *
     * The supported actions values are:
     *
     * "Deny" specifies that a validation failure results in a denied request.
     *
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     *
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     *
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     *
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     *
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     * @return The count of validationActions.
     */
    public int getValidationActionsCount() {
      return validationActions_.size();
    }
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     *
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     *
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     *
     * The supported actions values are:
     *
     * "Deny" specifies that a validation failure results in a denied request.
     *
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     *
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     *
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     *
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     *
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     * @param index The index of the element to return.
     * @return The validationActions at the given index.
     */
    public java.lang.String getValidationActions(int index) {
      return validationActions_.get(index);
    }
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     *
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     *
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     *
     * The supported actions values are:
     *
     * "Deny" specifies that a validation failure results in a denied request.
     *
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     *
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     *
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     *
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     *
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     * @param index The index of the value to return.
     * @return The bytes of the validationActions at the given index.
     */
    public com.google.protobuf.ByteString
        getValidationActionsBytes(int index) {
      return validationActions_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, policyName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getParamRef());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getMatchResources());
      }
      for (int i = 0; i < validationActions_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, validationActions_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, policyName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getParamRef());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getMatchResources());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < validationActions_.size(); i++) {
          dataSize += computeStringSizeNoTag(validationActions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getValidationActionsList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec) obj;

      if (hasPolicyName() != other.hasPolicyName()) return false;
      if (hasPolicyName()) {
        if (!getPolicyName()
            .equals(other.getPolicyName())) return false;
      }
      if (hasParamRef() != other.hasParamRef()) return false;
      if (hasParamRef()) {
        if (!getParamRef()
            .equals(other.getParamRef())) return false;
      }
      if (hasMatchResources() != other.hasMatchResources()) return false;
      if (hasMatchResources()) {
        if (!getMatchResources()
            .equals(other.getMatchResources())) return false;
      }
      if (!getValidationActionsList()
          .equals(other.getValidationActionsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPolicyName()) {
        hash = (37 * hash) + POLICYNAME_FIELD_NUMBER;
        hash = (53 * hash) + getPolicyName().hashCode();
      }
      if (hasParamRef()) {
        hash = (37 * hash) + PARAMREF_FIELD_NUMBER;
        hash = (53 * hash) + getParamRef().hashCode();
      }
      if (hasMatchResources()) {
        hash = (37 * hash) + MATCHRESOURCES_FIELD_NUMBER;
        hash = (53 * hash) + getMatchResources().hashCode();
      }
      if (getValidationActionsCount() > 0) {
        hash = (37 * hash) + VALIDATIONACTIONS_FIELD_NUMBER;
        hash = (53 * hash) + getValidationActionsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getParamRefFieldBuilder();
          getMatchResourcesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        policyName_ = "";
        paramRef_ = null;
        if (paramRefBuilder_ != null) {
          paramRefBuilder_.dispose();
          paramRefBuilder_ = null;
        }
        matchResources_ = null;
        if (matchResourcesBuilder_ != null) {
          matchResourcesBuilder_.dispose();
          matchResourcesBuilder_ = null;
        }
        validationActions_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.policyName_ = policyName_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.paramRef_ = paramRefBuilder_ == null
              ? paramRef_
              : paramRefBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.matchResources_ = matchResourcesBuilder_ == null
              ? matchResources_
              : matchResourcesBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          validationActions_.makeImmutable();
          result.validationActions_ = validationActions_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance()) return this;
        if (other.hasPolicyName()) {
          policyName_ = other.policyName_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasParamRef()) {
          mergeParamRef(other.getParamRef());
        }
        if (other.hasMatchResources()) {
          mergeMatchResources(other.getMatchResources());
        }
        if (!other.validationActions_.isEmpty()) {
          if (validationActions_.isEmpty()) {
            validationActions_ = other.validationActions_;
            bitField0_ |= 0x00000008;
          } else {
            ensureValidationActionsIsMutable();
            validationActions_.addAll(other.validationActions_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                policyName_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getParamRefFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getMatchResourcesFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureValidationActionsIsMutable();
                validationActions_.add(bs);
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object policyName_ = "";
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       * @return Whether the policyName field is set.
       */
      public boolean hasPolicyName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       * @return The policyName.
       */
      public java.lang.String getPolicyName() {
        java.lang.Object ref = policyName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            policyName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       * @return The bytes for policyName.
       */
      public com.google.protobuf.ByteString
          getPolicyNameBytes() {
        java.lang.Object ref = policyName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          policyName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       * @param value The policyName to set.
       * @return This builder for chaining.
       */
      public Builder setPolicyName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        policyName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPolicyName() {
        policyName_ = getDefaultInstance().getPolicyName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       * @param value The bytes for policyName to set.
       * @return This builder for chaining.
       */
      public Builder setPolicyNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        policyName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef paramRef_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder> paramRefBuilder_;
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       * @return Whether the paramRef field is set.
       */
      public boolean hasParamRef() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       * @return The paramRef.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getParamRef() {
        if (paramRefBuilder_ == null) {
          return paramRef_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
        } else {
          return paramRefBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder setParamRef(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef value) {
        if (paramRefBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          paramRef_ = value;
        } else {
          paramRefBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder setParamRef(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder builderForValue) {
        if (paramRefBuilder_ == null) {
          paramRef_ = builderForValue.build();
        } else {
          paramRefBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder mergeParamRef(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef value) {
        if (paramRefBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            paramRef_ != null &&
            paramRef_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance()) {
            getParamRefBuilder().mergeFrom(value);
          } else {
            paramRef_ = value;
          }
        } else {
          paramRefBuilder_.mergeFrom(value);
        }
        if (paramRef_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder clearParamRef() {
        bitField0_ = (bitField0_ & ~0x00000002);
        paramRef_ = null;
        if (paramRefBuilder_ != null) {
          paramRefBuilder_.dispose();
          paramRefBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder getParamRefBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getParamRefFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder() {
        if (paramRefBuilder_ != null) {
          return paramRefBuilder_.getMessageOrBuilder();
        } else {
          return paramRef_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
        }
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder> 
          getParamRefFieldBuilder() {
        if (paramRefBuilder_ == null) {
          paramRefBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder>(
                  getParamRef(),
                  getParentForChildren(),
                  isClean());
          paramRef_ = null;
        }
        return paramRefBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchResources_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> matchResourcesBuilder_;
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       * @return Whether the matchResources field is set.
       */
      public boolean hasMatchResources() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       * @return The matchResources.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchResources() {
        if (matchResourcesBuilder_ == null) {
          return matchResources_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
        } else {
          return matchResourcesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder setMatchResources(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchResourcesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          matchResources_ = value;
        } else {
          matchResourcesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder setMatchResources(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder builderForValue) {
        if (matchResourcesBuilder_ == null) {
          matchResources_ = builderForValue.build();
        } else {
          matchResourcesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder mergeMatchResources(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchResourcesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            matchResources_ != null &&
            matchResources_ != io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance()) {
            getMatchResourcesBuilder().mergeFrom(value);
          } else {
            matchResources_ = value;
          }
        } else {
          matchResourcesBuilder_.mergeFrom(value);
        }
        if (matchResources_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder clearMatchResources() {
        bitField0_ = (bitField0_ & ~0x00000004);
        matchResources_ = null;
        if (matchResourcesBuilder_ != null) {
          matchResourcesBuilder_.dispose();
          matchResourcesBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder getMatchResourcesBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getMatchResourcesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder() {
        if (matchResourcesBuilder_ != null) {
          return matchResourcesBuilder_.getMessageOrBuilder();
        } else {
          return matchResources_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
        }
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> 
          getMatchResourcesFieldBuilder() {
        if (matchResourcesBuilder_ == null) {
          matchResourcesBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder>(
                  getMatchResources(),
                  getParentForChildren(),
                  isClean());
          matchResources_ = null;
        }
        return matchResourcesBuilder_;
      }

      private com.google.protobuf.LazyStringArrayList validationActions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureValidationActionsIsMutable() {
        if (!validationActions_.isModifiable()) {
          validationActions_ = new com.google.protobuf.LazyStringArrayList(validationActions_);
        }
        bitField0_ |= 0x00000008;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       *
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       *
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       *
       * The supported actions values are:
       *
       * "Deny" specifies that a validation failure results in a denied request.
       *
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       *
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       *
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       *
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       *
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       * @return A list containing the validationActions.
       */
      public com.google.protobuf.ProtocolStringList
          getValidationActionsList() {
        validationActions_.makeImmutable();
        return validationActions_;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       *
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       *
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       *
       * The supported actions values are:
       *
       * "Deny" specifies that a validation failure results in a denied request.
       *
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       *
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       *
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       *
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       *
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       * @return The count of validationActions.
       */
      public int getValidationActionsCount() {
        return validationActions_.size();
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       *
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       *
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       *
       * The supported actions values are:
       *
       * "Deny" specifies that a validation failure results in a denied request.
       *
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       *
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       *
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       *
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       *
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       * @param index The index of the element to return.
       * @return The validationActions at the given index.
       */
      public java.lang.String getValidationActions(int index) {
        return validationActions_.get(index);
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       *
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       *
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       *
       * The supported actions values are:
       *
       * "Deny" specifies that a validation failure results in a denied request.
       *
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       *
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       *
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       *
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       *
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       * @param index The index of the value to return.
       * @return The bytes of the validationActions at the given index.
       */
      public com.google.protobuf.ByteString
          getValidationActionsBytes(int index) {
        return validationActions_.getByteString(index);
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       *
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       *
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       *
       * The supported actions values are:
       *
       * "Deny" specifies that a validation failure results in a denied request.
       *
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       *
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       *
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       *
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       *
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       * @param index The index to set the value at.
       * @param value The validationActions to set.
       * @return This builder for chaining.
       */
      public Builder setValidationActions(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureValidationActionsIsMutable();
        validationActions_.set(index, value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       *
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       *
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       *
       * The supported actions values are:
       *
       * "Deny" specifies that a validation failure results in a denied request.
       *
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       *
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       *
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       *
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       *
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       * @param value The validationActions to add.
       * @return This builder for chaining.
       */
      public Builder addValidationActions(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureValidationActionsIsMutable();
        validationActions_.add(value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       *
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       *
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       *
       * The supported actions values are:
       *
       * "Deny" specifies that a validation failure results in a denied request.
       *
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       *
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       *
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       *
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       *
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       * @param values The validationActions to add.
       * @return This builder for chaining.
       */
      public Builder addAllValidationActions(
          java.lang.Iterable<java.lang.String> values) {
        ensureValidationActionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, validationActions_);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       *
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       *
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       *
       * The supported actions values are:
       *
       * "Deny" specifies that a validation failure results in a denied request.
       *
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       *
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       *
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       *
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       *
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearValidationActions() {
        validationActions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       *
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       *
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       *
       * The supported actions values are:
       *
       * "Deny" specifies that a validation failure results in a denied request.
       *
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       *
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       *
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       *
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       *
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       * @param value The bytes of the validationActions to add.
       * @return This builder for chaining.
       */
      public Builder addValidationActionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureValidationActionsIsMutable();
        validationActions_.add(value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingSpec>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyBindingSpec>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyBindingSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> 
        getItemsList();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getItems(int index);
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * +k8s:prerelease-lifecycle-gen:introduced=1.28
   * ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList}
   */
  public static final class ValidatingAdmissionPolicyList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
      ValidatingAdmissionPolicyListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingAdmissionPolicyList.class.getName());
    }
    // Use ValidatingAdmissionPolicyList.newBuilder() to construct.
    private ValidatingAdmissionPolicyList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> items_;
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * +k8s:prerelease-lifecycle-gen:introduced=1.28
     * ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingAdmissionPolicyList>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyList>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicySpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     * @return Whether the paramKind field is set.
     */
    boolean hasParamKind();
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     * @return The paramKind.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getParamKind();
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder();

    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     * @return Whether the matchConstraints field is set.
     */
    boolean hasMatchConstraints();
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     * @return The matchConstraints.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchConstraints();
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder();

    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> 
        getValidationsList();
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getValidations(int index);
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    int getValidationsCount();
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> 
        getValidationsOrBuilderList();
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder getValidationsOrBuilder(
        int index);

    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     *
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     *
     * failurePolicy does not define how validations that evaluate to false are handled.
     *
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     *
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return Whether the failurePolicy field is set.
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     *
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     *
     * failurePolicy does not define how validations that evaluate to false are handled.
     *
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     *
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The failurePolicy.
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     *
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     *
     * failurePolicy does not define how validations that evaluate to false are handled.
     *
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     *
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The bytes for failurePolicy.
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> 
        getAuditAnnotationsList();
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getAuditAnnotations(int index);
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    int getAuditAnnotationsCount();
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> 
        getAuditAnnotationsOrBuilderList();
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder getAuditAnnotationsOrBuilder(
        int index);

    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);

    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> 
        getVariablesList();
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getVariables(int index);
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    int getVariablesCount();
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
        getVariablesOrBuilderList();
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec}
   */
  public static final class ValidatingAdmissionPolicySpec extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
      ValidatingAdmissionPolicySpecOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingAdmissionPolicySpec.class.getName());
    }
    // Use ValidatingAdmissionPolicySpec.newBuilder() to construct.
    private ValidatingAdmissionPolicySpec(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicySpec() {
      validations_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      auditAnnotations_ = java.util.Collections.emptyList();
      matchConditions_ = java.util.Collections.emptyList();
      variables_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder.class);
    }

    private int bitField0_;
    public static final int PARAMKIND_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind paramKind_;
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     * @return Whether the paramKind field is set.
     */
    @java.lang.Override
    public boolean hasParamKind() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     * @return The paramKind.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getParamKind() {
      return paramKind_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
    }
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder() {
      return paramKind_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
    }

    public static final int MATCHCONSTRAINTS_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchConstraints_;
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     * @return Whether the matchConstraints field is set.
     */
    @java.lang.Override
    public boolean hasMatchConstraints() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     * @return The matchConstraints.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchConstraints() {
      return matchConstraints_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
    }
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder() {
      return matchConstraints_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
    }

    public static final int VALIDATIONS_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> validations_;
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> getValidationsList() {
      return validations_;
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> 
        getValidationsOrBuilderList() {
      return validations_;
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    @java.lang.Override
    public int getValidationsCount() {
      return validations_.size();
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getValidations(int index) {
      return validations_.get(index);
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder getValidationsOrBuilder(
        int index) {
      return validations_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object failurePolicy_ = "";
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     *
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     *
     * failurePolicy does not define how validations that evaluate to false are handled.
     *
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     *
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return Whether the failurePolicy field is set.
     */
    @java.lang.Override
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     *
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     *
     * failurePolicy does not define how validations that evaluate to false are handled.
     *
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     *
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The failurePolicy.
     */
    @java.lang.Override
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     *
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     *
     * failurePolicy does not define how validations that evaluate to false are handled.
     *
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     *
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The bytes for failurePolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AUDITANNOTATIONS_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> auditAnnotations_;
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> getAuditAnnotationsList() {
      return auditAnnotations_;
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> 
        getAuditAnnotationsOrBuilderList() {
      return auditAnnotations_;
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    @java.lang.Override
    public int getAuditAnnotationsCount() {
      return auditAnnotations_.size();
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getAuditAnnotations(int index) {
      return auditAnnotations_.get(index);
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder getAuditAnnotationsOrBuilder(
        int index) {
      return auditAnnotations_.get(index);
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    @java.lang.Override
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the policy is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    public static final int VARIABLES_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> variables_;
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> getVariablesList() {
      return variables_;
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
        getVariablesOrBuilderList() {
      return variables_;
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    @java.lang.Override
    public int getVariablesCount() {
      return variables_.size();
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getVariables(int index) {
      return variables_.get(index);
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     *
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
        int index) {
      return variables_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getParamKind());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getMatchConstraints());
      }
      for (int i = 0; i < validations_.size(); i++) {
        output.writeMessage(3, validations_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, failurePolicy_);
      }
      for (int i = 0; i < auditAnnotations_.size(); i++) {
        output.writeMessage(5, auditAnnotations_.get(i));
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(6, matchConditions_.get(i));
      }
      for (int i = 0; i < variables_.size(); i++) {
        output.writeMessage(7, variables_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getParamKind());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMatchConstraints());
      }
      for (int i = 0; i < validations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, validations_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, failurePolicy_);
      }
      for (int i = 0; i < auditAnnotations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, auditAnnotations_.get(i));
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, matchConditions_.get(i));
      }
      for (int i = 0; i < variables_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, variables_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec) obj;

      if (hasParamKind() != other.hasParamKind()) return false;
      if (hasParamKind()) {
        if (!getParamKind()
            .equals(other.getParamKind())) return false;
      }
      if (hasMatchConstraints() != other.hasMatchConstraints()) return false;
      if (hasMatchConstraints()) {
        if (!getMatchConstraints()
            .equals(other.getMatchConstraints())) return false;
      }
      if (!getValidationsList()
          .equals(other.getValidationsList())) return false;
      if (hasFailurePolicy() != other.hasFailurePolicy()) return false;
      if (hasFailurePolicy()) {
        if (!getFailurePolicy()
            .equals(other.getFailurePolicy())) return false;
      }
      if (!getAuditAnnotationsList()
          .equals(other.getAuditAnnotationsList())) return false;
      if (!getMatchConditionsList()
          .equals(other.getMatchConditionsList())) return false;
      if (!getVariablesList()
          .equals(other.getVariablesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasParamKind()) {
        hash = (37 * hash) + PARAMKIND_FIELD_NUMBER;
        hash = (53 * hash) + getParamKind().hashCode();
      }
      if (hasMatchConstraints()) {
        hash = (37 * hash) + MATCHCONSTRAINTS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConstraints().hashCode();
      }
      if (getValidationsCount() > 0) {
        hash = (37 * hash) + VALIDATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getValidationsList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (getAuditAnnotationsCount() > 0) {
        hash = (37 * hash) + AUDITANNOTATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAuditAnnotationsList().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      if (getVariablesCount() > 0) {
        hash = (37 * hash) + VARIABLES_FIELD_NUMBER;
        hash = (53 * hash) + getVariablesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getParamKindFieldBuilder();
          getMatchConstraintsFieldBuilder();
          getValidationsFieldBuilder();
          getAuditAnnotationsFieldBuilder();
          getMatchConditionsFieldBuilder();
          getVariablesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        paramKind_ = null;
        if (paramKindBuilder_ != null) {
          paramKindBuilder_.dispose();
          paramKindBuilder_ = null;
        }
        matchConstraints_ = null;
        if (matchConstraintsBuilder_ != null) {
          matchConstraintsBuilder_.dispose();
          matchConstraintsBuilder_ = null;
        }
        if (validationsBuilder_ == null) {
          validations_ = java.util.Collections.emptyList();
        } else {
          validations_ = null;
          validationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        failurePolicy_ = "";
        if (auditAnnotationsBuilder_ == null) {
          auditAnnotations_ = java.util.Collections.emptyList();
        } else {
          auditAnnotations_ = null;
          auditAnnotationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
        } else {
          matchConditions_ = null;
          matchConditionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (variablesBuilder_ == null) {
          variables_ = java.util.Collections.emptyList();
        } else {
          variables_ = null;
          variablesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec result) {
        if (validationsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            validations_ = java.util.Collections.unmodifiableList(validations_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.validations_ = validations_;
        } else {
          result.validations_ = validationsBuilder_.build();
        }
        if (auditAnnotationsBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            auditAnnotations_ = java.util.Collections.unmodifiableList(auditAnnotations_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.auditAnnotations_ = auditAnnotations_;
        } else {
          result.auditAnnotations_ = auditAnnotationsBuilder_.build();
        }
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
        if (variablesBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0)) {
            variables_ = java.util.Collections.unmodifiableList(variables_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.variables_ = variables_;
        } else {
          result.variables_ = variablesBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.paramKind_ = paramKindBuilder_ == null
              ? paramKind_
              : paramKindBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.matchConstraints_ = matchConstraintsBuilder_ == null
              ? matchConstraints_
              : matchConstraintsBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.failurePolicy_ = failurePolicy_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance()) return this;
        if (other.hasParamKind()) {
          mergeParamKind(other.getParamKind());
        }
        if (other.hasMatchConstraints()) {
          mergeMatchConstraints(other.getMatchConstraints());
        }
        if (validationsBuilder_ == null) {
          if (!other.validations_.isEmpty()) {
            if (validations_.isEmpty()) {
              validations_ = other.validations_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureValidationsIsMutable();
              validations_.addAll(other.validations_);
            }
            onChanged();
          }
        } else {
          if (!other.validations_.isEmpty()) {
            if (validationsBuilder_.isEmpty()) {
              validationsBuilder_.dispose();
              validationsBuilder_ = null;
              validations_ = other.validations_;
              bitField0_ = (bitField0_ & ~0x00000004);
              validationsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getValidationsFieldBuilder() : null;
            } else {
              validationsBuilder_.addAllMessages(other.validations_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          failurePolicy_ = other.failurePolicy_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (auditAnnotationsBuilder_ == null) {
          if (!other.auditAnnotations_.isEmpty()) {
            if (auditAnnotations_.isEmpty()) {
              auditAnnotations_ = other.auditAnnotations_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureAuditAnnotationsIsMutable();
              auditAnnotations_.addAll(other.auditAnnotations_);
            }
            onChanged();
          }
        } else {
          if (!other.auditAnnotations_.isEmpty()) {
            if (auditAnnotationsBuilder_.isEmpty()) {
              auditAnnotationsBuilder_.dispose();
              auditAnnotationsBuilder_ = null;
              auditAnnotations_ = other.auditAnnotations_;
              bitField0_ = (bitField0_ & ~0x00000010);
              auditAnnotationsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getAuditAnnotationsFieldBuilder() : null;
            } else {
              auditAnnotationsBuilder_.addAllMessages(other.auditAnnotations_);
            }
          }
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        if (variablesBuilder_ == null) {
          if (!other.variables_.isEmpty()) {
            if (variables_.isEmpty()) {
              variables_ = other.variables_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureVariablesIsMutable();
              variables_.addAll(other.variables_);
            }
            onChanged();
          }
        } else {
          if (!other.variables_.isEmpty()) {
            if (variablesBuilder_.isEmpty()) {
              variablesBuilder_.dispose();
              variablesBuilder_ = null;
              variables_ = other.variables_;
              bitField0_ = (bitField0_ & ~0x00000040);
              variablesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getVariablesFieldBuilder() : null;
            } else {
              variablesBuilder_.addAllMessages(other.variables_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getParamKindFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getMatchConstraintsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.Validation m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.parser(),
                        extensionRegistry);
                if (validationsBuilder_ == null) {
                  ensureValidationsIsMutable();
                  validations_.add(m);
                } else {
                  validationsBuilder_.addMessage(m);
                }
                break;
              } // case 26
              case 34: {
                failurePolicy_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.parser(),
                        extensionRegistry);
                if (auditAnnotationsBuilder_ == null) {
                  ensureAuditAnnotationsIsMutable();
                  auditAnnotations_.add(m);
                } else {
                  auditAnnotationsBuilder_.addMessage(m);
                }
                break;
              } // case 42
              case 50: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.parser(),
                        extensionRegistry);
                if (matchConditionsBuilder_ == null) {
                  ensureMatchConditionsIsMutable();
                  matchConditions_.add(m);
                } else {
                  matchConditionsBuilder_.addMessage(m);
                }
                break;
              } // case 50
              case 58: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.Variable m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.parser(),
                        extensionRegistry);
                if (variablesBuilder_ == null) {
                  ensureVariablesIsMutable();
                  variables_.add(m);
                } else {
                  variablesBuilder_.addMessage(m);
                }
                break;
              } // case 58
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind paramKind_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder> paramKindBuilder_;
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       * @return Whether the paramKind field is set.
       */
      public boolean hasParamKind() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       * @return The paramKind.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getParamKind() {
        if (paramKindBuilder_ == null) {
          return paramKind_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
        } else {
          return paramKindBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder setParamKind(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind value) {
        if (paramKindBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          paramKind_ = value;
        } else {
          paramKindBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder setParamKind(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder builderForValue) {
        if (paramKindBuilder_ == null) {
          paramKind_ = builderForValue.build();
        } else {
          paramKindBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder mergeParamKind(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind value) {
        if (paramKindBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            paramKind_ != null &&
            paramKind_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance()) {
            getParamKindBuilder().mergeFrom(value);
          } else {
            paramKind_ = value;
          }
        } else {
          paramKindBuilder_.mergeFrom(value);
        }
        if (paramKind_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder clearParamKind() {
        bitField0_ = (bitField0_ & ~0x00000001);
        paramKind_ = null;
        if (paramKindBuilder_ != null) {
          paramKindBuilder_.dispose();
          paramKindBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder getParamKindBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getParamKindFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder() {
        if (paramKindBuilder_ != null) {
          return paramKindBuilder_.getMessageOrBuilder();
        } else {
          return paramKind_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
        }
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder> 
          getParamKindFieldBuilder() {
        if (paramKindBuilder_ == null) {
          paramKindBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder>(
                  getParamKind(),
                  getParentForChildren(),
                  isClean());
          paramKind_ = null;
        }
        return paramKindBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchConstraints_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> matchConstraintsBuilder_;
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       * @return Whether the matchConstraints field is set.
       */
      public boolean hasMatchConstraints() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       * @return The matchConstraints.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchConstraints() {
        if (matchConstraintsBuilder_ == null) {
          return matchConstraints_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
        } else {
          return matchConstraintsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder setMatchConstraints(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchConstraintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          matchConstraints_ = value;
        } else {
          matchConstraintsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder setMatchConstraints(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder builderForValue) {
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = builderForValue.build();
        } else {
          matchConstraintsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder mergeMatchConstraints(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchConstraintsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            matchConstraints_ != null &&
            matchConstraints_ != io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance()) {
            getMatchConstraintsBuilder().mergeFrom(value);
          } else {
            matchConstraints_ = value;
          }
        } else {
          matchConstraintsBuilder_.mergeFrom(value);
        }
        if (matchConstraints_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder clearMatchConstraints() {
        bitField0_ = (bitField0_ & ~0x00000002);
        matchConstraints_ = null;
        if (matchConstraintsBuilder_ != null) {
          matchConstraintsBuilder_.dispose();
          matchConstraintsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder getMatchConstraintsBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getMatchConstraintsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder() {
        if (matchConstraintsBuilder_ != null) {
          return matchConstraintsBuilder_.getMessageOrBuilder();
        } else {
          return matchConstraints_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
        }
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> 
          getMatchConstraintsFieldBuilder() {
        if (matchConstraintsBuilder_ == null) {
          matchConstraintsBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder>(
                  getMatchConstraints(),
                  getParentForChildren(),
                  isClean());
          matchConstraints_ = null;
        }
        return matchConstraintsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> validations_ =
        java.util.Collections.emptyList();
      private void ensureValidationsIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          validations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation>(validations_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Validation, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> validationsBuilder_;

      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> getValidationsList() {
        if (validationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(validations_);
        } else {
          return validationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public int getValidationsCount() {
        if (validationsBuilder_ == null) {
          return validations_.size();
        } else {
          return validationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getValidations(int index) {
        if (validationsBuilder_ == null) {
          return validations_.get(index);
        } else {
          return validationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder setValidations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation value) {
        if (validationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValidationsIsMutable();
          validations_.set(index, value);
          onChanged();
        } else {
          validationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder setValidations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder builderForValue) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.set(index, builderForValue.build());
          onChanged();
        } else {
          validationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addValidations(io.kubernetes.client.proto.V1beta1Admissionregistration.Validation value) {
        if (validationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValidationsIsMutable();
          validations_.add(value);
          onChanged();
        } else {
          validationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addValidations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation value) {
        if (validationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValidationsIsMutable();
          validations_.add(index, value);
          onChanged();
        } else {
          validationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addValidations(
          io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder builderForValue) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.add(builderForValue.build());
          onChanged();
        } else {
          validationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addValidations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder builderForValue) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.add(index, builderForValue.build());
          onChanged();
        } else {
          validationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addAllValidations(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> values) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, validations_);
          onChanged();
        } else {
          validationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder clearValidations() {
        if (validationsBuilder_ == null) {
          validations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          validationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder removeValidations(int index) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.remove(index);
          onChanged();
        } else {
          validationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder getValidationsBuilder(
          int index) {
        return getValidationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder getValidationsOrBuilder(
          int index) {
        if (validationsBuilder_ == null) {
          return validations_.get(index);  } else {
          return validationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> 
           getValidationsOrBuilderList() {
        if (validationsBuilder_ != null) {
          return validationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(validations_);
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder addValidationsBuilder() {
        return getValidationsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.getDefaultInstance());
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder addValidationsBuilder(
          int index) {
        return getValidationsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.getDefaultInstance());
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder> 
           getValidationsBuilderList() {
        return getValidationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Validation, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> 
          getValidationsFieldBuilder() {
        if (validationsBuilder_ == null) {
          validationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.Validation, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder>(
                  validations_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          validations_ = null;
        }
        return validationsBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       *
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       *
       * failurePolicy does not define how validations that evaluate to false are handled.
       *
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       *
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return Whether the failurePolicy field is set.
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       *
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       *
       * failurePolicy does not define how validations that evaluate to false are handled.
       *
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       *
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return The failurePolicy.
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       *
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       *
       * failurePolicy does not define how validations that evaluate to false are handled.
       *
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       *
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return The bytes for failurePolicy.
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       *
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       *
       * failurePolicy does not define how validations that evaluate to false are handled.
       *
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       *
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @param value The failurePolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        failurePolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       *
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       *
       * failurePolicy does not define how validations that evaluate to false are handled.
       *
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       *
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFailurePolicy() {
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       *
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       *
       * failurePolicy does not define how validations that evaluate to false are handled.
       *
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       *
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @param value The bytes for failurePolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        failurePolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> auditAnnotations_ =
        java.util.Collections.emptyList();
      private void ensureAuditAnnotationsIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          auditAnnotations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation>(auditAnnotations_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> auditAnnotationsBuilder_;

      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> getAuditAnnotationsList() {
        if (auditAnnotationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(auditAnnotations_);
        } else {
          return auditAnnotationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public int getAuditAnnotationsCount() {
        if (auditAnnotationsBuilder_ == null) {
          return auditAnnotations_.size();
        } else {
          return auditAnnotationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getAuditAnnotations(int index) {
        if (auditAnnotationsBuilder_ == null) {
          return auditAnnotations_.get(index);
        } else {
          return auditAnnotationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder setAuditAnnotations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation value) {
        if (auditAnnotationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.set(index, value);
          onChanged();
        } else {
          auditAnnotationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder setAuditAnnotations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder builderForValue) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.set(index, builderForValue.build());
          onChanged();
        } else {
          auditAnnotationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation value) {
        if (auditAnnotationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(value);
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation value) {
        if (auditAnnotationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(index, value);
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(
          io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder builderForValue) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(builderForValue.build());
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder builderForValue) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(index, builderForValue.build());
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAllAuditAnnotations(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> values) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, auditAnnotations_);
          onChanged();
        } else {
          auditAnnotationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder clearAuditAnnotations() {
        if (auditAnnotationsBuilder_ == null) {
          auditAnnotations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          auditAnnotationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder removeAuditAnnotations(int index) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.remove(index);
          onChanged();
        } else {
          auditAnnotationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder getAuditAnnotationsBuilder(
          int index) {
        return getAuditAnnotationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder getAuditAnnotationsOrBuilder(
          int index) {
        if (auditAnnotationsBuilder_ == null) {
          return auditAnnotations_.get(index);  } else {
          return auditAnnotationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> 
           getAuditAnnotationsOrBuilderList() {
        if (auditAnnotationsBuilder_ != null) {
          return auditAnnotationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(auditAnnotations_);
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder addAuditAnnotationsBuilder() {
        return getAuditAnnotationsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.getDefaultInstance());
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder addAuditAnnotationsBuilder(
          int index) {
        return getAuditAnnotationsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.getDefaultInstance());
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder> 
           getAuditAnnotationsBuilderList() {
        return getAuditAnnotationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> 
          getAuditAnnotationsFieldBuilder() {
        if (auditAnnotationsBuilder_ == null) {
          auditAnnotationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder>(
                  auditAnnotations_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          auditAnnotations_ = null;
        }
        return auditAnnotationsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the policy is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> variables_ =
        java.util.Collections.emptyList();
      private void ensureVariablesIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          variables_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable>(variables_);
          bitField0_ |= 0x00000040;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Variable, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> variablesBuilder_;

      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> getVariablesList() {
        if (variablesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(variables_);
        } else {
          return variablesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public int getVariablesCount() {
        if (variablesBuilder_ == null) {
          return variables_.size();
        } else {
          return variablesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getVariables(int index) {
        if (variablesBuilder_ == null) {
          return variables_.get(index);
        } else {
          return variablesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder setVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.set(index, value);
          onChanged();
        } else {
          variablesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder setVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.set(index, builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addVariables(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.add(value);
          onChanged();
        } else {
          variablesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.add(index, value);
          onChanged();
        } else {
          variablesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addVariables(
          io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.add(builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.add(index, builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addAllVariables(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> values) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, variables_);
          onChanged();
        } else {
          variablesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder clearVariables() {
        if (variablesBuilder_ == null) {
          variables_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          variablesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder removeVariables(int index) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.remove(index);
          onChanged();
        } else {
          variablesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder getVariablesBuilder(
          int index) {
        return getVariablesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
          int index) {
        if (variablesBuilder_ == null) {
          return variables_.get(index);  } else {
          return variablesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
           getVariablesOrBuilderList() {
        if (variablesBuilder_ != null) {
          return variablesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(variables_);
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder addVariablesBuilder() {
        return getVariablesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance());
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder addVariablesBuilder(
          int index) {
        return getVariablesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance());
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       *
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder> 
           getVariablesBuilderList() {
        return getVariablesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Variable, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
          getVariablesFieldBuilder() {
        if (variablesBuilder_ == null) {
          variablesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.Variable, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder>(
                  variables_,
                  ((bitField0_ & 0x00000040) != 0),
                  getParentForChildren(),
                  isClean());
          variables_ = null;
        }
        return variablesBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingAdmissionPolicySpec>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicySpec>() {
      @java.lang.Override
      public ValidatingAdmissionPolicySpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicySpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicySpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return Whether the observedGeneration field is set.
     */
    boolean hasObservedGeneration();
    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return The observedGeneration.
     */
    long getObservedGeneration();

    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     * @return Whether the typeChecking field is set.
     */
    boolean hasTypeChecking();
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     * @return The typeChecking.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getTypeChecking();
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder getTypeCheckingOrBuilder();

    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.Condition> 
        getConditionsList();
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    io.kubernetes.client.proto.Meta.Condition getConditions(int index);
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    int getConditionsCount();
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
        getConditionsOrBuilderList();
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    io.kubernetes.client.proto.Meta.ConditionOrBuilder getConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyStatus represents the status of an admission validation policy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus}
   */
  public static final class ValidatingAdmissionPolicyStatus extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
      ValidatingAdmissionPolicyStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingAdmissionPolicyStatus.class.getName());
    }
    // Use ValidatingAdmissionPolicyStatus.newBuilder() to construct.
    private ValidatingAdmissionPolicyStatus(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyStatus() {
      conditions_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder.class);
    }

    private int bitField0_;
    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 1;
    private long observedGeneration_ = 0L;
    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return Whether the observedGeneration field is set.
     */
    @java.lang.Override
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     * @return The observedGeneration.
     */
    @java.lang.Override
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int TYPECHECKING_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking typeChecking_;
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     * @return Whether the typeChecking field is set.
     */
    @java.lang.Override
    public boolean hasTypeChecking() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     * @return The typeChecking.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getTypeChecking() {
      return typeChecking_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
    }
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder getTypeCheckingOrBuilder() {
      return typeChecking_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.Meta.Condition> conditions_;
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.Meta.Condition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    @java.lang.Override
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.Condition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getTypeChecking());
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(3, conditions_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getTypeChecking());
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, conditions_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus) obj;

      if (hasObservedGeneration() != other.hasObservedGeneration()) return false;
      if (hasObservedGeneration()) {
        if (getObservedGeneration()
            != other.getObservedGeneration()) return false;
      }
      if (hasTypeChecking() != other.hasTypeChecking()) return false;
      if (hasTypeChecking()) {
        if (!getTypeChecking()
            .equals(other.getTypeChecking())) return false;
      }
      if (!getConditionsList()
          .equals(other.getConditionsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getObservedGeneration());
      }
      if (hasTypeChecking()) {
        hash = (37 * hash) + TYPECHECKING_FIELD_NUMBER;
        hash = (53 * hash) + getTypeChecking().hashCode();
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyStatus represents the status of an admission validation policy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getTypeCheckingFieldBuilder();
          getConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        observedGeneration_ = 0L;
        typeChecking_ = null;
        if (typeCheckingBuilder_ != null) {
          typeCheckingBuilder_.dispose();
          typeCheckingBuilder_ = null;
        }
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
        } else {
          conditions_ = null;
          conditionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus result) {
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.observedGeneration_ = observedGeneration_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.typeChecking_ = typeCheckingBuilder_ == null
              ? typeChecking_
              : typeCheckingBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance()) return this;
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasTypeChecking()) {
          mergeTypeChecking(other.getTypeChecking());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000004);
              conditionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getConditionsFieldBuilder() : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                observedGeneration_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                input.readMessage(
                    getTypeCheckingFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                io.kubernetes.client.proto.Meta.Condition m =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.Condition.parser(),
                        extensionRegistry);
                if (conditionsBuilder_ == null) {
                  ensureConditionsIsMutable();
                  conditions_.add(m);
                } else {
                  conditionsBuilder_.addMessage(m);
                }
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long observedGeneration_ ;
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @return Whether the observedGeneration field is set.
       */
      @java.lang.Override
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @return The observedGeneration.
       */
      @java.lang.Override
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @param value The observedGeneration to set.
       * @return This builder for chaining.
       */
      public Builder setObservedGeneration(long value) {

        observedGeneration_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000001);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking typeChecking_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder> typeCheckingBuilder_;
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       * @return Whether the typeChecking field is set.
       */
      public boolean hasTypeChecking() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       * @return The typeChecking.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getTypeChecking() {
        if (typeCheckingBuilder_ == null) {
          return typeChecking_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
        } else {
          return typeCheckingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public Builder setTypeChecking(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking value) {
        if (typeCheckingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          typeChecking_ = value;
        } else {
          typeCheckingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public Builder setTypeChecking(
          io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder builderForValue) {
        if (typeCheckingBuilder_ == null) {
          typeChecking_ = builderForValue.build();
        } else {
          typeCheckingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public Builder mergeTypeChecking(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking value) {
        if (typeCheckingBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            typeChecking_ != null &&
            typeChecking_ != io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance()) {
            getTypeCheckingBuilder().mergeFrom(value);
          } else {
            typeChecking_ = value;
          }
        } else {
          typeCheckingBuilder_.mergeFrom(value);
        }
        if (typeChecking_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public Builder clearTypeChecking() {
        bitField0_ = (bitField0_ & ~0x00000002);
        typeChecking_ = null;
        if (typeCheckingBuilder_ != null) {
          typeCheckingBuilder_.dispose();
          typeCheckingBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder getTypeCheckingBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getTypeCheckingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder getTypeCheckingOrBuilder() {
        if (typeCheckingBuilder_ != null) {
          return typeCheckingBuilder_.getMessageOrBuilder();
        } else {
          return typeChecking_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
        }
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder> 
          getTypeCheckingFieldBuilder() {
        if (typeCheckingBuilder_ == null) {
          typeCheckingBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder>(
                  getTypeChecking(),
                  getParentForChildren(),
                  isClean());
          typeChecking_ = null;
        }
        return typeCheckingBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.Condition> conditions_ =
        java.util.Collections.emptyList();
      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.Condition>(conditions_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.Condition, io.kubernetes.client.proto.Meta.Condition.Builder, io.kubernetes.client.proto.Meta.ConditionOrBuilder> conditionsBuilder_;

      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.Condition> getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition getConditions(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.Meta.Condition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.Meta.Condition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(io.kubernetes.client.proto.Meta.Condition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.Meta.Condition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.Meta.Condition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.Meta.Condition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.Condition> values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition.Builder getConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.ConditionOrBuilder getConditionsOrBuilder(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);  } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
           getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition.Builder addConditionsBuilder() {
        return getConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.Condition.getDefaultInstance());
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition.Builder addConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.Condition.getDefaultInstance());
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.Condition.Builder> 
           getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.Meta.Condition, io.kubernetes.client.proto.Meta.Condition.Builder, io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.Meta.Condition, io.kubernetes.client.proto.Meta.Condition.Builder, io.kubernetes.client.proto.Meta.ConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingAdmissionPolicyStatus>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyStatus>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingWebhookOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     * @return Whether the clientConfig field is set.
     */
    boolean hasClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     * @return The clientConfig.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder();

    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> 
        getRulesList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index);
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index);

    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return Whether the failurePolicy field is set.
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The failurePolicy.
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The bytes for failurePolicy.
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return Whether the matchPolicy field is set.
     */
    boolean hasMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return The matchPolicy.
     */
    java.lang.String getMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return The bytes for matchPolicy.
     */
    com.google.protobuf.ByteString
        getMatchPolicyBytes();

    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     * @return Whether the namespaceSelector field is set.
     */
    boolean hasNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     * @return The namespaceSelector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     * @return Whether the objectSelector field is set.
     */
    boolean hasObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     * @return The objectSelector.
     */
    io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder();

    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return Whether the sideEffects field is set.
     */
    boolean hasSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return The sideEffects.
     */
    java.lang.String getSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return The bytes for sideEffects.
     */
    com.google.protobuf.ByteString
        getSideEffectsBytes();

    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     * @return Whether the timeoutSeconds field is set.
     */
    boolean hasTimeoutSeconds();
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     * @return The timeoutSeconds.
     */
    int getTimeoutSeconds();

    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @return A list containing the admissionReviewVersions.
     */
    java.util.List<java.lang.String>
        getAdmissionReviewVersionsList();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @return The count of admissionReviewVersions.
     */
    int getAdmissionReviewVersionsCount();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @param index The index of the element to return.
     * @return The admissionReviewVersions at the given index.
     */
    java.lang.String getAdmissionReviewVersions(int index);
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the admissionReviewVersions at the given index.
     */
    com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index);

    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingWebhook describes an admission webhook and the resources and operations it applies to.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook}
   */
  public static final class ValidatingWebhook extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
      ValidatingWebhookOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingWebhook.class.getName());
    }
    // Use ValidatingWebhook.newBuilder() to construct.
    private ValidatingWebhook(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingWebhook() {
      name_ = "";
      rules_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      matchPolicy_ = "";
      sideEffects_ = "";
      admissionReviewVersions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      matchConditions_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CLIENTCONFIG_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig clientConfig_;
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     * @return Whether the clientConfig field is set.
     */
    @java.lang.Override
    public boolean hasClientConfig() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     * @return The clientConfig.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }

    public static final int RULES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_;
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object failurePolicy_ = "";
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return Whether the failurePolicy field is set.
     */
    @java.lang.Override
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The failurePolicy.
     */
    @java.lang.Override
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     * @return The bytes for failurePolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHPOLICY_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private volatile java.lang.Object matchPolicy_ = "";
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return Whether the matchPolicy field is set.
     */
    @java.lang.Override
    public boolean hasMatchPolicy() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return The matchPolicy.
     */
    @java.lang.Override
    public java.lang.String getMatchPolicy() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     *
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     *
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     *
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     * @return The bytes for matchPolicy.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMatchPolicyBytes() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        matchPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     * @return Whether the namespaceSelector field is set.
     */
    @java.lang.Override
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     * @return The namespaceSelector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     *
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "runlevel",
     * "operator": "NotIn",
     * "values": [
     * "0",
     * "1"
     * ]
     * }
     * ]
     * }
     *
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     * "matchExpressions": [
     * {
     * "key": "environment",
     * "operator": "In",
     * "values": [
     * "prod",
     * "staging"
     * ]
     * }
     * ]
     * }
     *
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     *
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }

    public static final int OBJECTSELECTOR_FIELD_NUMBER = 10;
    private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     * @return Whether the objectSelector field is set.
     */
    @java.lang.Override
    public boolean hasObjectSelector() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     * @return The objectSelector.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }

    public static final int SIDEEFFECTS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object sideEffects_ = "";
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return Whether the sideEffects field is set.
     */
    @java.lang.Override
    public boolean hasSideEffects() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return The sideEffects.
     */
    @java.lang.Override
    public java.lang.String getSideEffects() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          sideEffects_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     * @return The bytes for sideEffects.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSideEffectsBytes() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sideEffects_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TIMEOUTSECONDS_FIELD_NUMBER = 7;
    private int timeoutSeconds_ = 0;
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     * @return Whether the timeoutSeconds field is set.
     */
    @java.lang.Override
    public boolean hasTimeoutSeconds() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     * @return The timeoutSeconds.
     */
    @java.lang.Override
    public int getTimeoutSeconds() {
      return timeoutSeconds_;
    }

    public static final int ADMISSIONREVIEWVERSIONS_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList admissionReviewVersions_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @return A list containing the admissionReviewVersions.
     */
    public com.google.protobuf.ProtocolStringList
        getAdmissionReviewVersionsList() {
      return admissionReviewVersions_;
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @return The count of admissionReviewVersions.
     */
    public int getAdmissionReviewVersionsCount() {
      return admissionReviewVersions_.size();
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @param index The index of the element to return.
     * @return The admissionReviewVersions at the given index.
     */
    public java.lang.String getAdmissionReviewVersions(int index) {
      return admissionReviewVersions_.get(index);
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the admissionReviewVersions at the given index.
     */
    public com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index) {
      return admissionReviewVersions_.getByteString(index);
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    @java.lang.Override
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     *
     * The exact matching logic is (in order):
     * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     * 3. If any matchCondition evaluates to an error (but none are FALSE):
     * - If failurePolicy=Fail, reject the request
     * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     *
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt32(7, timeoutSeconds_);
      }
      for (int i = 0; i < admissionReviewVersions_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, admissionReviewVersions_.getRaw(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(10, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(11, matchConditions_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, timeoutSeconds_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < admissionReviewVersions_.size(); i++) {
          dataSize += computeStringSizeNoTag(admissionReviewVersions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAdmissionReviewVersionsList().size();
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, matchConditions_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasClientConfig() != other.hasClientConfig()) return false;
      if (hasClientConfig()) {
        if (!getClientConfig()
            .equals(other.getClientConfig())) return false;
      }
      if (!getRulesList()
          .equals(other.getRulesList())) return false;
      if (hasFailurePolicy() != other.hasFailurePolicy()) return false;
      if (hasFailurePolicy()) {
        if (!getFailurePolicy()
            .equals(other.getFailurePolicy())) return false;
      }
      if (hasMatchPolicy() != other.hasMatchPolicy()) return false;
      if (hasMatchPolicy()) {
        if (!getMatchPolicy()
            .equals(other.getMatchPolicy())) return false;
      }
      if (hasNamespaceSelector() != other.hasNamespaceSelector()) return false;
      if (hasNamespaceSelector()) {
        if (!getNamespaceSelector()
            .equals(other.getNamespaceSelector())) return false;
      }
      if (hasObjectSelector() != other.hasObjectSelector()) return false;
      if (hasObjectSelector()) {
        if (!getObjectSelector()
            .equals(other.getObjectSelector())) return false;
      }
      if (hasSideEffects() != other.hasSideEffects()) return false;
      if (hasSideEffects()) {
        if (!getSideEffects()
            .equals(other.getSideEffects())) return false;
      }
      if (hasTimeoutSeconds() != other.hasTimeoutSeconds()) return false;
      if (hasTimeoutSeconds()) {
        if (getTimeoutSeconds()
            != other.getTimeoutSeconds()) return false;
      }
      if (!getAdmissionReviewVersionsList()
          .equals(other.getAdmissionReviewVersionsList())) return false;
      if (!getMatchConditionsList()
          .equals(other.getMatchConditionsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasClientConfig()) {
        hash = (37 * hash) + CLIENTCONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getClientConfig().hashCode();
      }
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (hasMatchPolicy()) {
        hash = (37 * hash) + MATCHPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getMatchPolicy().hashCode();
      }
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasObjectSelector()) {
        hash = (37 * hash) + OBJECTSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getObjectSelector().hashCode();
      }
      if (hasSideEffects()) {
        hash = (37 * hash) + SIDEEFFECTS_FIELD_NUMBER;
        hash = (53 * hash) + getSideEffects().hashCode();
      }
      if (hasTimeoutSeconds()) {
        hash = (37 * hash) + TIMEOUTSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getTimeoutSeconds();
      }
      if (getAdmissionReviewVersionsCount() > 0) {
        hash = (37 * hash) + ADMISSIONREVIEWVERSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAdmissionReviewVersionsList().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingWebhook describes an admission webhook and the resources and operations it applies to.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getClientConfigFieldBuilder();
          getRulesFieldBuilder();
          getNamespaceSelectorFieldBuilder();
          getObjectSelectorFieldBuilder();
          getMatchConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        clientConfig_ = null;
        if (clientConfigBuilder_ != null) {
          clientConfigBuilder_.dispose();
          clientConfigBuilder_ = null;
        }
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
        } else {
          rules_ = null;
          rulesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        failurePolicy_ = "";
        matchPolicy_ = "";
        namespaceSelector_ = null;
        if (namespaceSelectorBuilder_ != null) {
          namespaceSelectorBuilder_.dispose();
          namespaceSelectorBuilder_ = null;
        }
        objectSelector_ = null;
        if (objectSelectorBuilder_ != null) {
          objectSelectorBuilder_.dispose();
          objectSelectorBuilder_ = null;
        }
        sideEffects_ = "";
        timeoutSeconds_ = 0;
        admissionReviewVersions_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
        } else {
          matchConditions_ = null;
          matchConditionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook result) {
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000400);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.clientConfig_ = clientConfigBuilder_ == null
              ? clientConfig_
              : clientConfigBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.failurePolicy_ = failurePolicy_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.matchPolicy_ = matchPolicy_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.namespaceSelector_ = namespaceSelectorBuilder_ == null
              ? namespaceSelector_
              : namespaceSelectorBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.objectSelector_ = objectSelectorBuilder_ == null
              ? objectSelector_
              : objectSelectorBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.sideEffects_ = sideEffects_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.timeoutSeconds_ = timeoutSeconds_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          admissionReviewVersions_.makeImmutable();
          result.admissionReviewVersions_ = admissionReviewVersions_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasClientConfig()) {
          mergeClientConfig(other.getClientConfig());
        }
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          failurePolicy_ = other.failurePolicy_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasMatchPolicy()) {
          matchPolicy_ = other.matchPolicy_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasObjectSelector()) {
          mergeObjectSelector(other.getObjectSelector());
        }
        if (other.hasSideEffects()) {
          sideEffects_ = other.sideEffects_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (other.hasTimeoutSeconds()) {
          setTimeoutSeconds(other.getTimeoutSeconds());
        }
        if (!other.admissionReviewVersions_.isEmpty()) {
          if (admissionReviewVersions_.isEmpty()) {
            admissionReviewVersions_ = other.admissionReviewVersions_;
            bitField0_ |= 0x00000200;
          } else {
            ensureAdmissionReviewVersionsIsMutable();
            admissionReviewVersions_.addAll(other.admissionReviewVersions_);
          }
          onChanged();
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000400);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000400);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getClientConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.parser(),
                        extensionRegistry);
                if (rulesBuilder_ == null) {
                  ensureRulesIsMutable();
                  rules_.add(m);
                } else {
                  rulesBuilder_.addMessage(m);
                }
                break;
              } // case 26
              case 34: {
                failurePolicy_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getNamespaceSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 42
              case 50: {
                sideEffects_ = input.readBytes();
                bitField0_ |= 0x00000080;
                break;
              } // case 50
              case 56: {
                timeoutSeconds_ = input.readInt32();
                bitField0_ |= 0x00000100;
                break;
              } // case 56
              case 66: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureAdmissionReviewVersionsIsMutable();
                admissionReviewVersions_.add(bs);
                break;
              } // case 66
              case 74: {
                matchPolicy_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 74
              case 82: {
                input.readMessage(
                    getObjectSelectorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 82
              case 90: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.parser(),
                        extensionRegistry);
                if (matchConditionsBuilder_ == null) {
                  ensureMatchConditionsIsMutable();
                  matchConditions_.add(m);
                } else {
                  matchConditionsBuilder_.addMessage(m);
                }
                break;
              } // case 90
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig clientConfig_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder> clientConfigBuilder_;
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       * @return Whether the clientConfig field is set.
       */
      public boolean hasClientConfig() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       * @return The clientConfig.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig() {
        if (clientConfigBuilder_ == null) {
          return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        } else {
          return clientConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          clientConfig_ = value;
        } else {
          clientConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder builderForValue) {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = builderForValue.build();
        } else {
          clientConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder mergeClientConfig(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            clientConfig_ != null &&
            clientConfig_ != io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance()) {
            getClientConfigBuilder().mergeFrom(value);
          } else {
            clientConfig_ = value;
          }
        } else {
          clientConfigBuilder_.mergeFrom(value);
        }
        if (clientConfig_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder clearClientConfig() {
        bitField0_ = (bitField0_ & ~0x00000002);
        clientConfig_ = null;
        if (clientConfigBuilder_ != null) {
          clientConfigBuilder_.dispose();
          clientConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder getClientConfigBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getClientConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
        if (clientConfigBuilder_ != null) {
          return clientConfigBuilder_.getMessageOrBuilder();
        } else {
          return clientConfig_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder> 
          getClientConfigFieldBuilder() {
        if (clientConfigBuilder_ == null) {
          clientConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder>(
                  getClientConfig(),
                  getParentForChildren(),
                  isClean());
          clientConfig_ = null;
        }
        return clientConfigBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>(rules_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> rulesBuilder_;

      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder> 
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return Whether the failurePolicy field is set.
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return The failurePolicy.
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return The bytes for failurePolicy.
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @param value The failurePolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        failurePolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFailurePolicy() {
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       * @param value The bytes for failurePolicy to set.
       * @return This builder for chaining.
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        failurePolicy_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object matchPolicy_ = "";
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @return Whether the matchPolicy field is set.
       */
      public boolean hasMatchPolicy() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @return The matchPolicy.
       */
      public java.lang.String getMatchPolicy() {
        java.lang.Object ref = matchPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @return The bytes for matchPolicy.
       */
      public com.google.protobuf.ByteString
          getMatchPolicyBytes() {
        java.lang.Object ref = matchPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          matchPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @param value The matchPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setMatchPolicy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        matchPolicy_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMatchPolicy() {
        matchPolicy_ = getDefaultInstance().getMatchPolicy();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       *
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       *
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       *
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       * @param value The bytes for matchPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setMatchPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        matchPolicy_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> namespaceSelectorBuilder_;
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       * @return Whether the namespaceSelector field is set.
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       * @return The namespaceSelector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            namespaceSelector_ != null &&
            namespaceSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getNamespaceSelectorBuilder().mergeFrom(value);
          } else {
            namespaceSelector_ = value;
          }
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        if (namespaceSelector_ != null) {
          bitField0_ |= 0x00000020;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder clearNamespaceSelector() {
        bitField0_ = (bitField0_ & ~0x00000020);
        namespaceSelector_ = null;
        if (namespaceSelectorBuilder_ != null) {
          namespaceSelectorBuilder_.dispose();
          namespaceSelectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       *
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "runlevel",
       * "operator": "NotIn",
       * "values": [
       * "0",
       * "1"
       * ]
       * }
       * ]
       * }
       *
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       * "matchExpressions": [
       * {
       * "key": "environment",
       * "operator": "In",
       * "values": [
       * "prod",
       * "staging"
       * ]
       * }
       * ]
       * }
       *
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       *
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(),
                  getParentForChildren(),
                  isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> objectSelectorBuilder_;
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       * @return Whether the objectSelector field is set.
       */
      public boolean hasObjectSelector() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       * @return The objectSelector.
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        } else {
          return objectSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder setObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectSelector_ = value;
        } else {
          objectSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder setObjectSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = builderForValue.build();
        } else {
          objectSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder mergeObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            objectSelector_ != null &&
            objectSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            getObjectSelectorBuilder().mergeFrom(value);
          } else {
            objectSelector_ = value;
          }
        } else {
          objectSelectorBuilder_.mergeFrom(value);
        }
        if (objectSelector_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder clearObjectSelector() {
        bitField0_ = (bitField0_ & ~0x00000040);
        objectSelector_ = null;
        if (objectSelectorBuilder_ != null) {
          objectSelectorBuilder_.dispose();
          objectSelectorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getObjectSelectorBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getObjectSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
        if (objectSelectorBuilder_ != null) {
          return objectSelectorBuilder_.getMessageOrBuilder();
        } else {
          return objectSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getObjectSelectorFieldBuilder() {
        if (objectSelectorBuilder_ == null) {
          objectSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getObjectSelector(),
                  getParentForChildren(),
                  isClean());
          objectSelector_ = null;
        }
        return objectSelectorBuilder_;
      }

      private java.lang.Object sideEffects_ = "";
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @return Whether the sideEffects field is set.
       */
      public boolean hasSideEffects() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @return The sideEffects.
       */
      public java.lang.String getSideEffects() {
        java.lang.Object ref = sideEffects_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            sideEffects_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @return The bytes for sideEffects.
       */
      public com.google.protobuf.ByteString
          getSideEffectsBytes() {
        java.lang.Object ref = sideEffects_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sideEffects_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @param value The sideEffects to set.
       * @return This builder for chaining.
       */
      public Builder setSideEffects(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        sideEffects_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearSideEffects() {
        sideEffects_ = getDefaultInstance().getSideEffects();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       * @param value The bytes for sideEffects to set.
       * @return This builder for chaining.
       */
      public Builder setSideEffectsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        sideEffects_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private int timeoutSeconds_ ;
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       * @return Whether the timeoutSeconds field is set.
       */
      @java.lang.Override
      public boolean hasTimeoutSeconds() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       * @return The timeoutSeconds.
       */
      @java.lang.Override
      public int getTimeoutSeconds() {
        return timeoutSeconds_;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       * @param value The timeoutSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setTimeoutSeconds(int value) {

        timeoutSeconds_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeoutSeconds() {
        bitField0_ = (bitField0_ & ~0x00000100);
        timeoutSeconds_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList admissionReviewVersions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureAdmissionReviewVersionsIsMutable() {
        if (!admissionReviewVersions_.isModifiable()) {
          admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList(admissionReviewVersions_);
        }
        bitField0_ |= 0x00000200;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @return A list containing the admissionReviewVersions.
       */
      public com.google.protobuf.ProtocolStringList
          getAdmissionReviewVersionsList() {
        admissionReviewVersions_.makeImmutable();
        return admissionReviewVersions_;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @return The count of admissionReviewVersions.
       */
      public int getAdmissionReviewVersionsCount() {
        return admissionReviewVersions_.size();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param index The index of the element to return.
       * @return The admissionReviewVersions at the given index.
       */
      public java.lang.String getAdmissionReviewVersions(int index) {
        return admissionReviewVersions_.get(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param index The index of the value to return.
       * @return The bytes of the admissionReviewVersions at the given index.
       */
      public com.google.protobuf.ByteString
          getAdmissionReviewVersionsBytes(int index) {
        return admissionReviewVersions_.getByteString(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param index The index to set the value at.
       * @param value The admissionReviewVersions to set.
       * @return This builder for chaining.
       */
      public Builder setAdmissionReviewVersions(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.set(index, value);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param value The admissionReviewVersions to add.
       * @return This builder for chaining.
       */
      public Builder addAdmissionReviewVersions(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param values The admissionReviewVersions to add.
       * @return This builder for chaining.
       */
      public Builder addAllAdmissionReviewVersions(
          java.lang.Iterable<java.lang.String> values) {
        ensureAdmissionReviewVersionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, admissionReviewVersions_);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearAdmissionReviewVersions() {
        admissionReviewVersions_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       * @param value The bytes of the admissionReviewVersions to add.
       * @return This builder for chaining.
       */
      public Builder addAdmissionReviewVersionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000400) != 0)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000400;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       *
       * The exact matching logic is (in order):
       * 1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       * 2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       * 3. If any matchCondition evaluates to an error (but none are FALSE):
       * - If failurePolicy=Fail, reject the request
       * - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       *
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000400) != 0),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingWebhook>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingWebhook>() {
      @java.lang.Override
      public ValidatingWebhook parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingWebhook> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingWebhook> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingWebhookConfigurationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> 
        getWebhooksList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getWebhooks(int index);
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    int getWebhooksCount();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> 
        getWebhooksOrBuilderList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder getWebhooksOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
   * Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 ValidatingWebhookConfiguration instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration}
   */
  public static final class ValidatingWebhookConfiguration extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
      ValidatingWebhookConfigurationOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingWebhookConfiguration.class.getName());
    }
    // Use ValidatingWebhookConfiguration.newBuilder() to construct.
    private ValidatingWebhookConfiguration(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingWebhookConfiguration() {
      webhooks_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int WEBHOOKS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> webhooks_;
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> getWebhooksList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> 
        getWebhooksOrBuilderList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public int getWebhooksCount() {
      return webhooks_.size();
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getWebhooks(int index) {
      return webhooks_.get(index);
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder getWebhooksOrBuilder(
        int index) {
      return webhooks_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        output.writeMessage(2, webhooks_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, webhooks_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getWebhooksList()
          .equals(other.getWebhooksList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getWebhooksCount() > 0) {
        hash = (37 * hash) + WEBHOOKS_FIELD_NUMBER;
        hash = (53 * hash) + getWebhooksList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
     * Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 ValidatingWebhookConfiguration instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getWebhooksFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
        } else {
          webhooks_ = null;
          webhooksBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration result) {
        if (webhooksBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.webhooks_ = webhooks_;
        } else {
          result.webhooks_ = webhooksBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (webhooksBuilder_ == null) {
          if (!other.webhooks_.isEmpty()) {
            if (webhooks_.isEmpty()) {
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureWebhooksIsMutable();
              webhooks_.addAll(other.webhooks_);
            }
            onChanged();
          }
        } else {
          if (!other.webhooks_.isEmpty()) {
            if (webhooksBuilder_.isEmpty()) {
              webhooksBuilder_.dispose();
              webhooksBuilder_ = null;
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
              webhooksBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getWebhooksFieldBuilder() : null;
            } else {
              webhooksBuilder_.addAllMessages(other.webhooks_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.parser(),
                        extensionRegistry);
                if (webhooksBuilder_ == null) {
                  ensureWebhooksIsMutable();
                  webhooks_.add(m);
                } else {
                  webhooksBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> webhooks_ =
        java.util.Collections.emptyList();
      private void ensureWebhooksIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook>(webhooks_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> webhooksBuilder_;

      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> getWebhooksList() {
        if (webhooksBuilder_ == null) {
          return java.util.Collections.unmodifiableList(webhooks_);
        } else {
          return webhooksBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public int getWebhooksCount() {
        if (webhooksBuilder_ == null) {
          return webhooks_.size();
        } else {
          return webhooksBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);
        } else {
          return webhooksBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.set(index, value);
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.set(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(index, value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addAllWebhooks(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> values) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, webhooks_);
          onChanged();
        } else {
          webhooksBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder clearWebhooks() {
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder removeWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.remove(index);
          onChanged();
        } else {
          webhooksBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder getWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder getWebhooksOrBuilder(
          int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);  } else {
          return webhooksBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> 
           getWebhooksOrBuilderList() {
        if (webhooksBuilder_ != null) {
          return webhooksBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(webhooks_);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder addWebhooksBuilder() {
        return getWebhooksFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder addWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder> 
           getWebhooksBuilderList() {
        return getWebhooksFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> 
          getWebhooksFieldBuilder() {
        if (webhooksBuilder_ == null) {
          webhooksBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder>(
                  webhooks_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          webhooks_ = null;
        }
        return webhooksBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingWebhookConfiguration>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingWebhookConfiguration>() {
      @java.lang.Override
      public ValidatingWebhookConfiguration parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingWebhookConfiguration> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingWebhookConfiguration> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingWebhookConfigurationListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> 
        getItemsList();
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getItems(int index);
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList}
   */
  public static final class ValidatingWebhookConfigurationList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
      ValidatingWebhookConfigurationListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ValidatingWebhookConfigurationList.class.getName());
    }
    // Use ValidatingWebhookConfigurationList.newBuilder() to construct.
    private ValidatingWebhookConfigurationList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValidatingWebhookConfigurationList() {
      items_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return Whether the metadata field is set.
     */
    @java.lang.Override
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> items_;
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList) obj;

      if (hasMetadata() != other.hasMetadata()) return false;
      if (hasMetadata()) {
        if (!getMetadata()
            .equals(other.getMetadata())) return false;
      }
      if (!getItemsList()
          .equals(other.getItemsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
        } else {
          items_ = null;
          itemsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList result) {
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metadata_ = metadataBuilder_ == null
              ? metadata_
              : metadataBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration m =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.parser(),
                        extensionRegistry);
                if (itemsBuilder_ == null) {
                  ensureItemsIsMutable();
                  items_.add(m);
                } else {
                  itemsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return Whether the metadata field is set.
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       * @return The metadata.
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            metadata_ != null &&
            metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            getMetadataBuilder().mergeFrom(value);
          } else {
            metadata_ = value;
          }
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        if (metadata_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metadata_ = null;
        if (metadataBuilder_ != null) {
          metadataBuilder_.dispose();
          metadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidatingWebhookConfigurationList>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingWebhookConfigurationList>() {
      @java.lang.Override
      public ValidatingWebhookConfigurationList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValidatingWebhookConfigurationList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingWebhookConfigurationList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.Validation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     *
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     * For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     *
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     *
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     *
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     * non-intersecting elements in `Y` are appended, retaining their partial order.
     * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     * non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     * @return Whether the expression field is set.
     */
    boolean hasExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     *
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     * For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     *
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     *
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     *
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     * non-intersecting elements in `Y` are appended, retaining their partial order.
     * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     * non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     * @return The expression.
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     *
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     * For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     *
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     *
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     *
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     * non-intersecting elements in `Y` are appended, retaining their partial order.
     * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     * non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     * @return The bytes for expression.
     */
    com.google.protobuf.ByteString
        getExpressionBytes();

    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     * @return Whether the reason field is set.
     */
    boolean hasReason();
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     * @return The reason.
     */
    java.lang.String getReason();
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     * @return The bytes for reason.
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     * @return Whether the messageExpression field is set.
     */
    boolean hasMessageExpression();
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     * @return The messageExpression.
     */
    java.lang.String getMessageExpression();
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     * @return The bytes for messageExpression.
     */
    com.google.protobuf.ByteString
        getMessageExpressionBytes();
  }
  /**
   * <pre>
   * Validation specifies the CEL expression which is used to apply the validation.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Validation}
   */
  public static final class Validation extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.Validation)
      ValidationOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Validation.class.getName());
    }
    // Use Validation.newBuilder() to construct.
    private Validation(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Validation() {
      expression_ = "";
      message_ = "";
      reason_ = "";
      messageExpression_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder.class);
    }

    private int bitField0_;
    public static final int EXPRESSION_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object expression_ = "";
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     *
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     * For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     *
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     *
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     *
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     * non-intersecting elements in `Y` are appended, retaining their partial order.
     * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     * non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     * @return Whether the expression field is set.
     */
    @java.lang.Override
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     *
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     * For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     *
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     *
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     *
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     * non-intersecting elements in `Y` are appended, retaining their partial order.
     * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     * non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     * @return The expression.
     */
    @java.lang.Override
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     *
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     * For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     * request resource.
     *
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     *
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     *
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     * non-intersecting elements in `Y` are appended, retaining their partial order.
     * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     * non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     * @return The bytes for expression.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REASON_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object reason_ = "";
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     * @return Whether the reason field is set.
     */
    @java.lang.Override
    public boolean hasReason() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     * @return The reason.
     */
    @java.lang.Override
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     * @return The bytes for reason.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGEEXPRESSION_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object messageExpression_ = "";
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     * @return Whether the messageExpression field is set.
     */
    @java.lang.Override
    public boolean hasMessageExpression() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     * @return The messageExpression.
     */
    @java.lang.Override
    public java.lang.String getMessageExpression() {
      java.lang.Object ref = messageExpression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          messageExpression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     * @return The bytes for messageExpression.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageExpressionBytes() {
      java.lang.Object ref = messageExpression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        messageExpression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, expression_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, message_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, reason_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, messageExpression_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, expression_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, message_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, reason_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, messageExpression_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Validation)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.Validation other = (io.kubernetes.client.proto.V1beta1Admissionregistration.Validation) obj;

      if (hasExpression() != other.hasExpression()) return false;
      if (hasExpression()) {
        if (!getExpression()
            .equals(other.getExpression())) return false;
      }
      if (hasMessage() != other.hasMessage()) return false;
      if (hasMessage()) {
        if (!getMessage()
            .equals(other.getMessage())) return false;
      }
      if (hasReason() != other.hasReason()) return false;
      if (hasReason()) {
        if (!getReason()
            .equals(other.getReason())) return false;
      }
      if (hasMessageExpression() != other.hasMessageExpression()) return false;
      if (hasMessageExpression()) {
        if (!getMessageExpression()
            .equals(other.getMessageExpression())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessageExpression()) {
        hash = (37 * hash) + MESSAGEEXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getMessageExpression().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.Validation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Validation specifies the CEL expression which is used to apply the validation.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Validation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.Validation)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        expression_ = "";
        message_ = "";
        reason_ = "";
        messageExpression_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Validation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Validation result = new io.kubernetes.client.proto.V1beta1Admissionregistration.Validation(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.Validation result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.expression_ = expression_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.message_ = message_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.reason_ = reason_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.messageExpression_ = messageExpression_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Validation) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.Validation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.Validation other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.getDefaultInstance()) return this;
        if (other.hasExpression()) {
          expression_ = other.expression_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasMessage()) {
          message_ = other.message_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasReason()) {
          reason_ = other.reason_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasMessageExpression()) {
          messageExpression_ = other.messageExpression_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                expression_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                message_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                reason_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                messageExpression_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       *
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       * For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       *
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       *
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       *
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       * non-intersecting elements in `Y` are appended, retaining their partial order.
       * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       * non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       * @return Whether the expression field is set.
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       *
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       * For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       *
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       *
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       *
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       * non-intersecting elements in `Y` are appended, retaining their partial order.
       * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       * non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       * @return The expression.
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       *
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       * For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       *
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       *
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       *
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       * non-intersecting elements in `Y` are appended, retaining their partial order.
       * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       * non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       * @return The bytes for expression.
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       *
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       * For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       *
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       *
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       *
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       * non-intersecting elements in `Y` are appended, retaining their partial order.
       * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       * non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       * @param value The expression to set.
       * @return This builder for chaining.
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        expression_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       *
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       * For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       *
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       *
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       *
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       * non-intersecting elements in `Y` are appended, retaining their partial order.
       * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       * non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpression() {
        expression_ = getDefaultInstance().getExpression();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       *
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       * For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       * request resource.
       *
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       *
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       *
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       * non-intersecting elements in `Y` are appended, retaining their partial order.
       * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       * non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       * @param value The bytes for expression to set.
       * @return This builder for chaining.
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        expression_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return Whether the message field is set.
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       * @return Whether the reason field is set.
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       * @return The reason.
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       * @return The bytes for reason.
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        reason_ = getDefaultInstance().getReason();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       * @param value The bytes for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reason_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object messageExpression_ = "";
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       * @return Whether the messageExpression field is set.
       */
      public boolean hasMessageExpression() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       * @return The messageExpression.
       */
      public java.lang.String getMessageExpression() {
        java.lang.Object ref = messageExpression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            messageExpression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       * @return The bytes for messageExpression.
       */
      public com.google.protobuf.ByteString
          getMessageExpressionBytes() {
        java.lang.Object ref = messageExpression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          messageExpression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       * @param value The messageExpression to set.
       * @return This builder for chaining.
       */
      public Builder setMessageExpression(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        messageExpression_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessageExpression() {
        messageExpression_ = getDefaultInstance().getMessageExpression();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       * @param value The bytes for messageExpression to set.
       * @return This builder for chaining.
       */
      public Builder setMessageExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        messageExpression_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.Validation)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.Validation)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.Validation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.Validation();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Validation>
        PARSER = new com.google.protobuf.AbstractParser<Validation>() {
      @java.lang.Override
      public Validation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Validation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Validation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VariableOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.Variable)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     * @return Whether the expression field is set.
     */
    boolean hasExpression();
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     * @return The expression.
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     * @return The bytes for expression.
     */
    com.google.protobuf.ByteString
        getExpressionBytes();
  }
  /**
   * <pre>
   * Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Variable}
   */
  public static final class Variable extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.Variable)
      VariableOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Variable.class.getName());
    }
    // Use Variable.newBuilder() to construct.
    private Variable(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Variable() {
      name_ = "";
      expression_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EXPRESSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object expression_ = "";
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     * @return Whether the expression field is set.
     */
    @java.lang.Override
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     * @return The expression.
     */
    @java.lang.Override
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     * @return The bytes for expression.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, expression_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, expression_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Variable)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.Variable other = (io.kubernetes.client.proto.V1beta1Admissionregistration.Variable) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasExpression() != other.hasExpression()) return false;
      if (hasExpression()) {
        if (!getExpression()
            .equals(other.getExpression())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Variable}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.Variable)
        io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        expression_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Variable result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Variable result = new io.kubernetes.client.proto.V1beta1Admissionregistration.Variable(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.expression_ = expression_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Variable) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.Variable)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasExpression()) {
          expression_ = other.expression_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                expression_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       * @return Whether the expression field is set.
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       * @return The expression.
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       * @return The bytes for expression.
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       * @param value The expression to set.
       * @return This builder for chaining.
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        expression_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpression() {
        expression_ = getDefaultInstance().getExpression();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       * @param value The bytes for expression to set.
       * @return This builder for chaining.
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        expression_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.Variable)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.Variable)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.Variable DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.Variable();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Variable>
        PARSER = new com.google.protobuf.AbstractParser<Variable>() {
      @java.lang.Override
      public Variable parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Variable> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Variable> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface WebhookClientConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     *
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     *
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     *
     * The scheme must be "https"; the URL must begin with "https://".
     *
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     *
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     *
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     * @return Whether the url field is set.
     */
    boolean hasUrl();
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     *
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     *
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     *
     * The scheme must be "https"; the URL must begin with "https://".
     *
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     *
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     *
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     * @return The url.
     */
    java.lang.String getUrl();
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     *
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     *
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     *
     * The scheme must be "https"; the URL must begin with "https://".
     *
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     *
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     *
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     * @return The bytes for url.
     */
    com.google.protobuf.ByteString
        getUrlBytes();

    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     *
     * If the webhook is running within the cluster, then you should use `service`.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     * @return Whether the service field is set.
     */
    boolean hasService();
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     *
     * If the webhook is running within the cluster, then you should use `service`.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     * @return The service.
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getService();
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     *
     * If the webhook is running within the cluster, then you should use `service`.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder getServiceOrBuilder();

    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     * @return Whether the caBundle field is set.
     */
    boolean hasCaBundle();
    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     * @return The caBundle.
     */
    com.google.protobuf.ByteString getCaBundle();
  }
  /**
   * <pre>
   * WebhookClientConfig contains the information to make a TLS
   * connection with the webhook
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig}
   */
  public static final class WebhookClientConfig extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
      WebhookClientConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        WebhookClientConfig.class.getName());
    }
    // Use WebhookClientConfig.newBuilder() to construct.
    private WebhookClientConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private WebhookClientConfig() {
      url_ = "";
      caBundle_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.class, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder.class);
    }

    private int bitField0_;
    public static final int URL_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object url_ = "";
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     *
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     *
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     *
     * The scheme must be "https"; the URL must begin with "https://".
     *
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     *
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     *
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     * @return Whether the url field is set.
     */
    @java.lang.Override
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     *
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     *
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     *
     * The scheme must be "https"; the URL must begin with "https://".
     *
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     *
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     *
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     * @return The url.
     */
    @java.lang.Override
    public java.lang.String getUrl() {
      java.lang.Object ref = url_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          url_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     *
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     *
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     *
     * The scheme must be "https"; the URL must begin with "https://".
     *
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     *
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     *
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     * @return The bytes for url.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUrlBytes() {
      java.lang.Object ref = url_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        url_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVICE_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference service_;
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     *
     * If the webhook is running within the cluster, then you should use `service`.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     * @return Whether the service field is set.
     */
    @java.lang.Override
    public boolean hasService() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     *
     * If the webhook is running within the cluster, then you should use `service`.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     * @return The service.
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getService() {
      return service_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
    }
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     *
     * If the webhook is running within the cluster, then you should use `service`.
     *
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     */
    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder getServiceOrBuilder() {
      return service_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
    }

    public static final int CABUNDLE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString caBundle_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     * @return Whether the caBundle field is set.
     */
    @java.lang.Override
    public boolean hasCaBundle() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     * @return The caBundle.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCaBundle() {
      return caBundle_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(1, getService());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBytes(2, caBundle_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, url_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getService());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, caBundle_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, url_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig other = (io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig) obj;

      if (hasUrl() != other.hasUrl()) return false;
      if (hasUrl()) {
        if (!getUrl()
            .equals(other.getUrl())) return false;
      }
      if (hasService() != other.hasService()) return false;
      if (hasService()) {
        if (!getService()
            .equals(other.getService())) return false;
      }
      if (hasCaBundle() != other.hasCaBundle()) return false;
      if (hasCaBundle()) {
        if (!getCaBundle()
            .equals(other.getCaBundle())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasUrl()) {
        hash = (37 * hash) + URL_FIELD_NUMBER;
        hash = (53 * hash) + getUrl().hashCode();
      }
      if (hasService()) {
        hash = (37 * hash) + SERVICE_FIELD_NUMBER;
        hash = (53 * hash) + getService().hashCode();
      }
      if (hasCaBundle()) {
        hash = (37 * hash) + CABUNDLE_FIELD_NUMBER;
        hash = (53 * hash) + getCaBundle().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * WebhookClientConfig contains the information to make a TLS
     * connection with the webhook
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
        io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.class, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getServiceFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        url_ = "";
        service_ = null;
        if (serviceBuilder_ != null) {
          serviceBuilder_.dispose();
          serviceBuilder_ = null;
        }
        caBundle_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig result = new io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.url_ = url_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.service_ = serviceBuilder_ == null
              ? service_
              : serviceBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.caBundle_ = caBundle_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance()) return this;
        if (other.hasUrl()) {
          url_ = other.url_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasService()) {
          mergeService(other.getService());
        }
        if (other.hasCaBundle()) {
          setCaBundle(other.getCaBundle());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getServiceFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 10
              case 18: {
                caBundle_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 18
              case 26: {
                url_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object url_ = "";
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       *
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       *
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       *
       * The scheme must be "https"; the URL must begin with "https://".
       *
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       *
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       *
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       * @return Whether the url field is set.
       */
      public boolean hasUrl() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       *
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       *
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       *
       * The scheme must be "https"; the URL must begin with "https://".
       *
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       *
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       *
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       * @return The url.
       */
      public java.lang.String getUrl() {
        java.lang.Object ref = url_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            url_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       *
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       *
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       *
       * The scheme must be "https"; the URL must begin with "https://".
       *
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       *
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       *
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       * @return The bytes for url.
       */
      public com.google.protobuf.ByteString
          getUrlBytes() {
        java.lang.Object ref = url_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          url_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       *
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       *
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       *
       * The scheme must be "https"; the URL must begin with "https://".
       *
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       *
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       *
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       * @param value The url to set.
       * @return This builder for chaining.
       */
      public Builder setUrl(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        url_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       *
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       *
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       *
       * The scheme must be "https"; the URL must begin with "https://".
       *
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       *
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       *
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearUrl() {
        url_ = getDefaultInstance().getUrl();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       *
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       *
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       *
       * The scheme must be "https"; the URL must begin with "https://".
       *
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       *
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       *
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       * @param value The bytes for url to set.
       * @return This builder for chaining.
       */
      public Builder setUrlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        url_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference service_;
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder> serviceBuilder_;
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       *
       * If the webhook is running within the cluster, then you should use `service`.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       * @return Whether the service field is set.
       */
      public boolean hasService() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       *
       * If the webhook is running within the cluster, then you should use `service`.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       * @return The service.
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getService() {
        if (serviceBuilder_ == null) {
          return service_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
        } else {
          return serviceBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       *
       * If the webhook is running within the cluster, then you should use `service`.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public Builder setService(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference value) {
        if (serviceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          service_ = value;
        } else {
          serviceBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       *
       * If the webhook is running within the cluster, then you should use `service`.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public Builder setService(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder builderForValue) {
        if (serviceBuilder_ == null) {
          service_ = builderForValue.build();
        } else {
          serviceBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       *
       * If the webhook is running within the cluster, then you should use `service`.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public Builder mergeService(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference value) {
        if (serviceBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            service_ != null &&
            service_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance()) {
            getServiceBuilder().mergeFrom(value);
          } else {
            service_ = value;
          }
        } else {
          serviceBuilder_.mergeFrom(value);
        }
        if (service_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       *
       * If the webhook is running within the cluster, then you should use `service`.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public Builder clearService() {
        bitField0_ = (bitField0_ & ~0x00000002);
        service_ = null;
        if (serviceBuilder_ != null) {
          serviceBuilder_.dispose();
          serviceBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       *
       * If the webhook is running within the cluster, then you should use `service`.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder getServiceBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getServiceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       *
       * If the webhook is running within the cluster, then you should use `service`.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder getServiceOrBuilder() {
        if (serviceBuilder_ != null) {
          return serviceBuilder_.getMessageOrBuilder();
        } else {
          return service_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
        }
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       *
       * If the webhook is running within the cluster, then you should use `service`.
       *
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder> 
          getServiceFieldBuilder() {
        if (serviceBuilder_ == null) {
          serviceBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder>(
                  getService(),
                  getParentForChildren(),
                  isClean());
          service_ = null;
        }
        return serviceBuilder_;
      }

      private com.google.protobuf.ByteString caBundle_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       * @return Whether the caBundle field is set.
       */
      @java.lang.Override
      public boolean hasCaBundle() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       * @return The caBundle.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCaBundle() {
        return caBundle_;
      }
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       * @param value The caBundle to set.
       * @return This builder for chaining.
       */
      public Builder setCaBundle(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        caBundle_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearCaBundle() {
        bitField0_ = (bitField0_ & ~0x00000004);
        caBundle_ = getDefaultInstance().getCaBundle();
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<WebhookClientConfig>
        PARSER = new com.google.protobuf.AbstractParser<WebhookClientConfig>() {
      @java.lang.Override
      public WebhookClientConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<WebhookClientConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<WebhookClientConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n8k8s.io/api/admissionregistration/v1bet" +
      "a1/generated.proto\022(k8s.io.api.admission" +
      "registration.v1beta1\0323k8s.io/api/admissi" +
      "onregistration/v1/generated.proto\0324k8s.i" +
      "o/apimachinery/pkg/apis/meta/v1/generate" +
      "d.proto\032/k8s.io/apimachinery/pkg/runtime" +
      "/generated.proto\0326k8s.io/apimachinery/pk" +
      "g/runtime/schema/generated.proto\"7\n\017Audi" +
      "tAnnotation\022\013\n\003key\030\001 \001(\t\022\027\n\017valueExpress" +
      "ion\030\002 \001(\t\"6\n\021ExpressionWarning\022\020\n\010fieldR" +
      "ef\030\002 \001(\t\022\017\n\007warning\030\003 \001(\t\"2\n\016MatchCondit" +
      "ion\022\014\n\004name\030\001 \001(\t\022\022\n\nexpression\030\002 \001(\t\"\375\002" +
      "\n\016MatchResources\022N\n\021namespaceSelector\030\001 " +
      "\001(\01323.k8s.io.apimachinery.pkg.apis.meta." +
      "v1.LabelSelector\022K\n\016objectSelector\030\002 \001(\013" +
      "23.k8s.io.apimachinery.pkg.apis.meta.v1." +
      "LabelSelector\022X\n\rresourceRules\030\003 \003(\0132A.k" +
      "8s.io.api.admissionregistration.v1beta1." +
      "NamedRuleWithOperations\022_\n\024excludeResour" +
      "ceRules\030\004 \003(\0132A.k8s.io.api.admissionregi" +
      "stration.v1beta1.NamedRuleWithOperations" +
      "\022\023\n\013matchPolicy\030\007 \001(\t\"\302\004\n\017MutatingWebhoo" +
      "k\022\014\n\004name\030\001 \001(\t\022S\n\014clientConfig\030\002 \001(\0132=." +
      "k8s.io.api.admissionregistration.v1beta1" +
      ".WebhookClientConfig\022F\n\005rules\030\003 \003(\01327.k8" +
      "s.io.api.admissionregistration.v1.RuleWi" +
      "thOperations\022\025\n\rfailurePolicy\030\004 \001(\t\022\023\n\013m" +
      "atchPolicy\030\t \001(\t\022N\n\021namespaceSelector\030\005 " +
      "\001(\01323.k8s.io.apimachinery.pkg.apis.meta." +
      "v1.LabelSelector\022K\n\016objectSelector\030\013 \001(\013" +
      "23.k8s.io.apimachinery.pkg.apis.meta.v1." +
      "LabelSelector\022\023\n\013sideEffects\030\006 \001(\t\022\026\n\016ti" +
      "meoutSeconds\030\007 \001(\005\022\037\n\027admissionReviewVer" +
      "sions\030\010 \003(\t\022\032\n\022reinvocationPolicy\030\n \001(\t\022" +
      "Q\n\017matchConditions\030\014 \003(\01328.k8s.io.api.ad" +
      "missionregistration.v1beta1.MatchConditi" +
      "on\"\257\001\n\034MutatingWebhookConfiguration\022B\n\010m" +
      "etadata\030\001 \001(\01320.k8s.io.apimachinery.pkg." +
      "apis.meta.v1.ObjectMeta\022K\n\010Webhooks\030\002 \003(" +
      "\01329.k8s.io.api.admissionregistration.v1b" +
      "eta1.MutatingWebhook\"\273\001\n MutatingWebhook" +
      "ConfigurationList\022@\n\010metadata\030\001 \001(\0132..k8" +
      "s.io.apimachinery.pkg.apis.meta.v1.ListM" +
      "eta\022U\n\005items\030\002 \003(\0132F.k8s.io.api.admissio" +
      "nregistration.v1beta1.MutatingWebhookCon" +
      "figuration\"\205\001\n\027NamedRuleWithOperations\022\025" +
      "\n\rresourceNames\030\001 \003(\t\022S\n\022ruleWithOperati" +
      "ons\030\002 \001(\01327.k8s.io.api.admissionregistra" +
      "tion.v1.RuleWithOperations\"-\n\tParamKind\022" +
      "\022\n\napiVersion\030\001 \001(\t\022\014\n\004kind\030\002 \001(\t\"\223\001\n\010Pa" +
      "ramRef\022\014\n\004name\030\001 \001(\t\022\021\n\tnamespace\030\002 \001(\t\022" +
      "E\n\010selector\030\003 \001(\01323.k8s.io.apimachinery." +
      "pkg.apis.meta.v1.LabelSelector\022\037\n\027parame" +
      "terNotFoundAction\030\004 \001(\t\"O\n\020ServiceRefere" +
      "nce\022\021\n\tnamespace\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\022\014\n\004" +
      "path\030\003 \001(\t\022\014\n\004port\030\004 \001(\005\"g\n\014TypeChecking" +
      "\022W\n\022expressionWarnings\030\001 \003(\0132;.k8s.io.ap" +
      "i.admissionregistration.v1beta1.Expressi" +
      "onWarning\"\221\002\n\031ValidatingAdmissionPolicy\022" +
      "B\n\010metadata\030\001 \001(\01320.k8s.io.apimachinery." +
      "pkg.apis.meta.v1.ObjectMeta\022U\n\004spec\030\002 \001(" +
      "\0132G.k8s.io.api.admissionregistration.v1b" +
      "eta1.ValidatingAdmissionPolicySpec\022Y\n\006st" +
      "atus\030\003 \001(\0132I.k8s.io.api.admissionregistr" +
      "ation.v1beta1.ValidatingAdmissionPolicyS" +
      "tatus\"\304\001\n ValidatingAdmissionPolicyBindi" +
      "ng\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimachine" +
      "ry.pkg.apis.meta.v1.ObjectMeta\022\\\n\004spec\030\002" +
      " \001(\0132N.k8s.io.api.admissionregistration." +
      "v1beta1.ValidatingAdmissionPolicyBinding" +
      "Spec\"\303\001\n$ValidatingAdmissionPolicyBindin" +
      "gList\022@\n\010metadata\030\001 \001(\0132..k8s.io.apimach" +
      "inery.pkg.apis.meta.v1.ListMeta\022Y\n\005items" +
      "\030\002 \003(\0132J.k8s.io.api.admissionregistratio" +
      "n.v1beta1.ValidatingAdmissionPolicyBindi" +
      "ng\"\355\001\n$ValidatingAdmissionPolicyBindingS" +
      "pec\022\022\n\npolicyName\030\001 \001(\t\022D\n\010paramRef\030\002 \001(" +
      "\01322.k8s.io.api.admissionregistration.v1b" +
      "eta1.ParamRef\022P\n\016matchResources\030\003 \001(\01328." +
      "k8s.io.api.admissionregistration.v1beta1" +
      ".MatchResources\022\031\n\021validationActions\030\004 \003" +
      "(\t\"\265\001\n\035ValidatingAdmissionPolicyList\022@\n\010" +
      "metadata\030\001 \001(\0132..k8s.io.apimachinery.pkg" +
      ".apis.meta.v1.ListMeta\022R\n\005items\030\002 \003(\0132C." +
      "k8s.io.api.admissionregistration.v1beta1" +
      ".ValidatingAdmissionPolicy\"\214\004\n\035Validatin" +
      "gAdmissionPolicySpec\022F\n\tparamKind\030\001 \001(\0132" +
      "3.k8s.io.api.admissionregistration.v1bet" +
      "a1.ParamKind\022R\n\020matchConstraints\030\002 \001(\01328" +
      ".k8s.io.api.admissionregistration.v1beta" +
      "1.MatchResources\022I\n\013validations\030\003 \003(\01324." +
      "k8s.io.api.admissionregistration.v1beta1" +
      ".Validation\022\025\n\rfailurePolicy\030\004 \001(\t\022S\n\020au" +
      "ditAnnotations\030\005 \003(\01329.k8s.io.api.admiss" +
      "ionregistration.v1beta1.AuditAnnotation\022" +
      "Q\n\017matchConditions\030\006 \003(\01328.k8s.io.api.ad" +
      "missionregistration.v1beta1.MatchConditi" +
      "on\022E\n\tvariables\030\007 \003(\01322.k8s.io.api.admis" +
      "sionregistration.v1beta1.Variable\"\320\001\n\037Va" +
      "lidatingAdmissionPolicyStatus\022\032\n\022observe" +
      "dGeneration\030\001 \001(\003\022L\n\014typeChecking\030\002 \001(\0132" +
      "6.k8s.io.api.admissionregistration.v1bet" +
      "a1.TypeChecking\022C\n\nconditions\030\003 \003(\0132/.k8" +
      "s.io.apimachinery.pkg.apis.meta.v1.Condi" +
      "tion\"\250\004\n\021ValidatingWebhook\022\014\n\004name\030\001 \001(\t" +
      "\022S\n\014clientConfig\030\002 \001(\0132=.k8s.io.api.admi" +
      "ssionregistration.v1beta1.WebhookClientC" +
      "onfig\022F\n\005rules\030\003 \003(\01327.k8s.io.api.admiss" +
      "ionregistration.v1.RuleWithOperations\022\025\n" +
      "\rfailurePolicy\030\004 \001(\t\022\023\n\013matchPolicy\030\t \001(" +
      "\t\022N\n\021namespaceSelector\030\005 \001(\01323.k8s.io.ap" +
      "imachinery.pkg.apis.meta.v1.LabelSelecto" +
      "r\022K\n\016objectSelector\030\n \001(\01323.k8s.io.apima" +
      "chinery.pkg.apis.meta.v1.LabelSelector\022\023" +
      "\n\013sideEffects\030\006 \001(\t\022\026\n\016timeoutSeconds\030\007 " +
      "\001(\005\022\037\n\027admissionReviewVersions\030\010 \003(\t\022Q\n\017" +
      "matchConditions\030\013 \003(\01328.k8s.io.api.admis" +
      "sionregistration.v1beta1.MatchCondition\"" +
      "\263\001\n\036ValidatingWebhookConfiguration\022B\n\010me" +
      "tadata\030\001 \001(\01320.k8s.io.apimachinery.pkg.a" +
      "pis.meta.v1.ObjectMeta\022M\n\010Webhooks\030\002 \003(\013" +
      "2;.k8s.io.api.admissionregistration.v1be" +
      "ta1.ValidatingWebhook\"\277\001\n\"ValidatingWebh" +
      "ookConfigurationList\022@\n\010metadata\030\001 \001(\0132." +
      ".k8s.io.apimachinery.pkg.apis.meta.v1.Li" +
      "stMeta\022W\n\005items\030\002 \003(\0132H.k8s.io.api.admis" +
      "sionregistration.v1beta1.ValidatingWebho" +
      "okConfiguration\"\\\n\nValidation\022\022\n\nExpress" +
      "ion\030\001 \001(\t\022\017\n\007message\030\002 \001(\t\022\016\n\006reason\030\003 \001" +
      "(\t\022\031\n\021messageExpression\030\004 \001(\t\",\n\010Variabl" +
      "e\022\014\n\004Name\030\001 \001(\t\022\022\n\nExpression\030\002 \001(\t\"\201\001\n\023" +
      "WebhookClientConfig\022\013\n\003url\030\003 \001(\t\022K\n\007serv" +
      "ice\030\001 \001(\0132:.k8s.io.api.admissionregistra" +
      "tion.v1beta1.ServiceReference\022\020\n\010caBundl" +
      "e\030\002 \001(\014Bd\n\032io.kubernetes.client.protoB\034V" +
      "1beta1AdmissionregistrationZ(k8s.io/api/" +
      "admissionregistration/v1beta1"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.kubernetes.client.proto.V1Admissionregistration.getDescriptor(),
          io.kubernetes.client.proto.Meta.getDescriptor(),
          io.kubernetes.client.proto.Runtime.getDescriptor(),
          io.kubernetes.client.proto.RuntimeSchema.getDescriptor(),
        });
    internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor,
        new java.lang.String[] { "Key", "ValueExpression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor,
        new java.lang.String[] { "FieldRef", "Warning", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor,
        new java.lang.String[] { "Name", "Expression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor,
        new java.lang.String[] { "NamespaceSelector", "ObjectSelector", "ResourceRules", "ExcludeResourceRules", "MatchPolicy", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor,
        new java.lang.String[] { "Name", "ClientConfig", "Rules", "FailurePolicy", "MatchPolicy", "NamespaceSelector", "ObjectSelector", "SideEffects", "TimeoutSeconds", "AdmissionReviewVersions", "ReinvocationPolicy", "MatchConditions", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor,
        new java.lang.String[] { "Metadata", "Webhooks", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor,
        new java.lang.String[] { "ResourceNames", "RuleWithOperations", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor,
        new java.lang.String[] { "ApiVersion", "Kind", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor,
        new java.lang.String[] { "Name", "Namespace", "Selector", "ParameterNotFoundAction", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor,
        new java.lang.String[] { "Namespace", "Name", "Path", "Port", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor,
        new java.lang.String[] { "ExpressionWarnings", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor,
        new java.lang.String[] { "Metadata", "Spec", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor,
        new java.lang.String[] { "PolicyName", "ParamRef", "MatchResources", "ValidationActions", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor,
        new java.lang.String[] { "ParamKind", "MatchConstraints", "Validations", "FailurePolicy", "AuditAnnotations", "MatchConditions", "Variables", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor,
        new java.lang.String[] { "ObservedGeneration", "TypeChecking", "Conditions", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor,
        new java.lang.String[] { "Name", "ClientConfig", "Rules", "FailurePolicy", "MatchPolicy", "NamespaceSelector", "ObjectSelector", "SideEffects", "TimeoutSeconds", "AdmissionReviewVersions", "MatchConditions", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor,
        new java.lang.String[] { "Metadata", "Webhooks", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor,
        new java.lang.String[] { "Expression", "Message", "Reason", "MessageExpression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor,
        new java.lang.String[] { "Name", "Expression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor,
        new java.lang.String[] { "Url", "Service", "CaBundle", });
    descriptor.resolveAllFeaturesImmutable();
    io.kubernetes.client.proto.V1Admissionregistration.getDescriptor();
    io.kubernetes.client.proto.Meta.getDescriptor();
    io.kubernetes.client.proto.Runtime.getDescriptor();
    io.kubernetes.client.proto.RuntimeSchema.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
